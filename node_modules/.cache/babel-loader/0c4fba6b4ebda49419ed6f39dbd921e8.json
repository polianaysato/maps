{"ast":null,"code":"/**\r\n * Animation module.\r\n */\nimport { __extends } from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\nimport { BaseObjectEvents } from \"../Base\";\nimport { SVGDefaults } from \"../defs/SVGDefaults\";\nimport { Disposer } from \"../utils/Disposer\";\nimport { Color } from \"../utils/Color\";\nimport { Percent, percent } from \"../utils/Percent\";\nimport * as $async from \"../utils/AsyncPending\";\nimport * as $ease from \"../utils/Ease\";\nimport * as $colors from \"../utils/Colors\";\nimport * as $math from \"../utils/Math\";\nimport * as $array from \"../utils/Array\";\nimport * as $type from \"../utils/Type\";\nimport { system } from \"../System\";\nimport { options } from \"../Options\";\n/**\r\n * Calls a `callback` function for the `duration` of milliseconds.\r\n *\r\n * @todo Needed?\r\n * @deprecated Not used anywhere\r\n * @ignore Exclude from docs\r\n * @param duration  Duration (ms)\r\n * @param callback  Callback function\r\n * @return Disposer\r\n */\n\nexport function animate(duration, callback) {\n  var disposed = false; // TODO use performance.now() ?\n\n  var startTime = Date.now();\n\n  function loop(now) {\n    if (!disposed) {\n      var diff = now - startTime;\n\n      if (diff >= duration) {\n        callback(1);\n      } else {\n        $async.nextFrame(loop);\n        callback(diff / duration);\n      }\n    }\n  }\n\n  $async.nextFrame(loop);\n  return new Disposer(function () {\n    disposed = true;\n  });\n}\n/**\r\n * Returns numeric value accoring to progress between start and end values.\r\n *\r\n * @param progress  Progress (0-1)\r\n * @param from\r\n * @param to\r\n * @return Value according to progress\r\n */\n\nfunction getProgressNumber(progress, from, to) {\n  return from + (to - from) * progress;\n}\n/**\r\n * Returns [[Percent]] value accoring to progress between start and end\r\n * values.\r\n *\r\n * @param progress  Progress (0-1)\r\n * @param from\r\n * @param to\r\n * @return Value according to progress\r\n */\n\n\nfunction getProgressPercent(progress, from, to) {\n  return new Percent(getProgressNumber(progress, from.percent, to.percent));\n}\n/**\r\n * Returns color value accoring to progress between start and end values.\r\n *\r\n * @param progress  Progress (0-1)\r\n * @param from\r\n * @param to\r\n * @return Color according to progress\r\n */\n\n\nfunction getProgressColor(progress, from, to) {\n  var color = new Color($colors.interpolate(from.rgb, to.rgb, progress));\n\n  if (from.alpha != to.alpha) {\n    color.alpha = from.alpha + (to.alpha - from.alpha) * progress;\n  }\n\n  return color;\n}\n/**\r\n * [getHybridProperty description]\r\n *\r\n * @todo Description\r\n * @param property [description]\r\n * @param type [description]\r\n * @return [description]\r\n */\n\n\nfunction getHybridProperty(property, type) {\n  return type + property.charAt(0).toUpperCase() + property.substr(1);\n}\n\nvar AnimationDisposer =\n/** @class */\nfunction () {\n  function AnimationDisposer(array) {\n    this._disposer = new Disposer(function () {\n      while (array.length !== 0) {\n        array[0].dispose();\n      }\n    });\n  }\n\n  AnimationDisposer.prototype.isDisposed = function () {\n    return this._disposer.isDisposed();\n  };\n\n  AnimationDisposer.prototype.dispose = function () {\n    this._disposer.dispose();\n  };\n\n  return AnimationDisposer;\n}();\n\nexport { AnimationDisposer };\n/**\r\n * Animation can be used to transition certain properties on an object that\r\n * implements [[IAnimatable]] interface.\r\n *\r\n * @see {@link IAnimationEvents} for a list of available events\r\n */\n\nvar Animation =\n/** @class */\nfunction (_super) {\n  __extends(Animation, _super);\n  /**\r\n   * Constructor\r\n   *\r\n   * @param object            An object animation should run on\r\n   * @param animationOptions  One or several (array) of animation options\r\n   * @param duration          Duration (ms)\r\n   * @param easing            Easing function\r\n   */\n\n\n  function Animation(object, animationOptions, duration, easing) {\n    var _this = // Init\n    _super.call(this) || this;\n    /**\r\n     * Duration of the animation in milliseconds.\r\n     */\n\n\n    _this.duration = 0;\n    /**\r\n     * Easing function to use.\r\n     *\r\n     * @see {@link Ease}\r\n     */\n\n    _this.easing = $ease.linear;\n    /**\r\n     * Contains progress of the current animation: 0 (start) to 1 (end).\r\n     */\n\n    _this.progress = 0;\n    /**\r\n     * Indicated how many times animation should loop.\r\n     */\n\n    _this._loop = 0;\n    /**\r\n     * Animation is paused.\r\n     */\n\n    _this._pause = false;\n    /**\r\n     * Holds reference to timeout for delayed play.\r\n     */\n\n    _this._delayTimeout = null;\n    /**\r\n     * Elapsed time in currently playing animation.\r\n     */\n\n    _this._time = 0;\n    _this._isFinished = false;\n    _this.className = \"Animation\"; // Override duration if animations disabled system-wide\n\n    if (options.animationsEnabled === false) {\n      duration = 0;\n    } // Set parameters\n\n\n    _this.object = object;\n    _this.animationOptions = $array.toArray(animationOptions);\n    _this.duration = duration;\n\n    if (easing) {\n      _this.easing = easing;\n    } // Run check if there are already animations playing on the same properties\n    // and stop them - the last animation takes precedence\n    //this.stopSameAnimations();\n\n    /*if ($type.hasValue(callback)) {\r\n        // TODO don't use .call\r\n        this.events.on(\"animationended\", callback, object);\r\n    }*/\n    // Apply theme\n\n\n    _this.applyTheme();\n\n    return _this;\n  } // TODO verify that this is correct\n\n\n  Animation.prototype.debug = function () {};\n  /**\r\n   * Disposes this object, clears up after itself.\r\n   */\n\n\n  Animation.prototype.dispose = function () {\n    _super.prototype.dispose.call(this);\n\n    this.pause();\n  };\n  /**\r\n   * Delays animation start by X milliseconds.\r\n   *\r\n   * @param delay  Delay (ms)\r\n   * @return Animation\r\n   */\n\n\n  Animation.prototype.delay = function (delay) {\n    var _this = this; //@todo Maybe not use `bind()`\n\n\n    if (delay > 0) {\n      this.pause(); // This is so that it will get disposed if `this.object` is disposed\n      // TODO hacky, figure out a better way\n\n      $array.move(this.object.animations, this);\n      var id_1 = setTimeout(function () {\n        _this._delayTimeout = null;\n\n        _this.start();\n      }, delay);\n      this._delayTimeout = new Disposer(function () {\n        clearTimeout(id_1);\n      });\n    }\n\n    return this;\n  };\n\n  Animation.prototype._start = function () {\n    this._isFinished = false; // Clear delay timeout if there was one\n\n    if (this._delayTimeout) {\n      this.removeDispose(this._delayTimeout);\n      this._delayTimeout = null;\n    } // Run check if there are already animations playing on the same properties\n    // and stop them - the last animation takes precedence\n\n\n    this.stopSameAnimations(); // Reset counters\n\n    this._pause = false; // Register animation\n\n    $array.move(system.animations, this); // Register this animation in object's `animations` list\n\n    $array.move(this.object.animations, this);\n    system.requestFrame();\n  };\n  /**\r\n   * Starts animation.\r\n   *\r\n   * @return Animation\r\n   */\n\n\n  Animation.prototype.start = function () {\n    this._start();\n\n    this._startTime = Date.now();\n    this._time = 0;\n    this.staticOptions = []; // Process initial property values\n\n    for (var i = this.animationOptions.length - 1; i >= 0; i--) {\n      var options_1 = this.animationOptions[i];\n\n      if (!$type.hasValue(options_1.from)) {\n        if (options_1.childObject) {\n          options_1.from = options_1.childObject[options_1.property];\n        } else {\n          options_1.from = this.object[options_1.property];\n\n          if (!$type.hasValue(options_1.from)) {\n            options_1.from = SVGDefaults[options_1.property];\n          }\n        }\n        /*if (!$type.hasValue(options.from)) {\r\n            throw Error(\"Could not get initial transition value.\");\r\n        }*/\n\n      }\n\n      if (options_1.from == options_1.to) {\n        // || options.to == (<any>this.object)[options.property]){ this is not good, as dataItem.value is set to final at once, and we animate workingValue\n        $array.remove(this.animationOptions, options_1);\n      } else if (!$type.hasValue(options_1.from) || !(options_1.from instanceof Percent) && options_1.to instanceof Percent || options_1.from instanceof Percent && !(options_1.to instanceof Percent)) {\n        // Initial value is undefined, treat it as static\n        this.staticOptions.push(options_1);\n        $array.remove(this.animationOptions, options_1);\n      } else {\n        // Use different update methods for different value types\n        if ($type.isNumber(options_1.to)) {\n          // Numeric value\n          options_1.updateMethod = getProgressNumber; // Check if initial value is not Percent\n\n          if (options_1.from instanceof Percent) {\n            // It is. Let's convert it to pixel value\n            // @todo Check if we can do this in a less hacky way\n            var convertedFrom = this.object[getHybridProperty(options_1.property, \"pixel\")];\n\n            if (!isNaN(convertedFrom)) {\n              options_1.from = convertedFrom;\n            } else {\n              this.staticOptions.push(options_1);\n              $array.remove(this.animationOptions, options_1);\n            }\n          } else if (isNaN(options_1.from)) {\n            // Static value\n            this.staticOptions.push(options_1);\n            $array.remove(this.animationOptions, options_1);\n          }\n        } else {\n          // Check if maybe we have a color or percent value\n          if (options_1.to instanceof Color) {\n            // Yup - set resolved named color\n            //options.from = $colors.stringToColor(<string>options.from);\n            if (options_1.from) {\n              options_1.updateMethod = getProgressColor;\n            } else {\n              // Static value\n              this.staticOptions.push(options_1);\n              $array.remove(this.animationOptions, options_1);\n            }\n          } else if (options_1.to instanceof Percent) {\n            // Percent\n            options_1.updateMethod = getProgressPercent; // Check if the initial value is maybe in pixels\n\n            if (!isNaN(options_1.from)) {\n              // It is. Let's convert it\n              // @todo Check if we can do this in a less hacky way\n              var convertedFrom = this.object[getHybridProperty(options_1.property, \"relative\")];\n\n              if (!isNaN(convertedFrom)) {\n                options_1.from = percent(convertedFrom * 100);\n              }\n            }\n          } else {\n            // Static value\n            this.staticOptions.push(options_1);\n            $array.remove(this.animationOptions, options_1);\n          }\n        }\n      }\n    } // Apply static options (just in case they were reset by previous\n    // animation loop)\n\n\n    this.applyStaticOptions();\n\n    if (this.events.isEnabled(\"animationstarted\")) {\n      var event_1 = {\n        type: \"animationstarted\",\n        target: this,\n        progress: this.progress\n      };\n      this.events.dispatchImmediately(\"animationstarted\", event_1);\n    }\n\n    this.update(); // If duration is 0, just end animation\n\n    if (this.duration === 0) {\n      this.end();\n    }\n\n    return this;\n  };\n  /**\r\n   * Sets loop count for the animation. If parameter is not a valid number the\r\n   * animation will keep on looping indefinitely.\r\n   *\r\n   * @param count  Number of times to loop animation\r\n   * @return Animation\r\n   */\n\n\n  Animation.prototype.loop = function (count) {\n    if (!$type.isNumber(count)) {\n      count = Infinity;\n    }\n\n    this._loop = count;\n    return this;\n  };\n  /**\r\n   * Pauses animation.\r\n   *\r\n   * @return Animation\r\n   */\n\n\n  Animation.prototype.pause = function () {\n    this._pause = true;\n\n    if (this._delayTimeout) {\n      this.removeDispose(this._delayTimeout);\n      this._delayTimeout = null;\n    }\n\n    $array.remove(system.animations, this);\n    $array.remove(this.object.animations, this);\n    return this;\n  };\n  /**\r\n   * Resumes paused animation.\r\n   *\r\n   * @return Animation\r\n   */\n\n\n  Animation.prototype.resume = function () {\n    this._start();\n\n    this._startTime = Date.now() - this._time;\n    return this;\n  };\n  /**\r\n   * Jumps to animation end. If animation is set to loop, this will start\r\n   * another round of animation from start.\r\n   *\r\n   * @return Animation\r\n   */\n\n\n  Animation.prototype.end = function () {\n    // Pause and complete the progress\n    if (this._loop == 0) {\n      this.pause();\n    }\n\n    this.setProgress(1); // Apply static options\n\n    this.applyStaticOptions();\n\n    if (this.events.isEnabled(\"animationended\")) {\n      var event_2 = {\n        type: \"animationended\",\n        target: this,\n        progress: this.progress\n      };\n      this.events.dispatchImmediately(\"animationended\", event_2);\n    } // Check if we should loop\n\n\n    if (this._loop > 0) {\n      this._loop--;\n      this.start();\n    } else {\n      this.stop();\n      this._isFinished = true;\n    }\n\n    return this;\n  };\n  /**\r\n   * Stops animation immediately leaving properties in their current values.\r\n   */\n\n\n  Animation.prototype.kill = function () {\n    this.pause();\n    this._isFinished = true;\n  };\n  /**\r\n   * Returns indicator if this animation is finished or not\r\n   *\r\n   * @return Is finished?\r\n   */\n\n\n  Animation.prototype.isFinished = function () {\n    return this._isFinished;\n  };\n  /**\r\n   * Applies static options that can't be animated.\r\n   */\n\n\n  Animation.prototype.applyStaticOptions = function () {\n    var _this = this;\n\n    $array.each(this.staticOptions, function (options) {\n      if (options.childObject) {\n        options.childObject[options.property] = _this.progress == 1 ? options.to : options.from;\n      } else {\n        _this.object[options.property] = _this.progress == 1 ? options.to : options.from;\n      }\n    });\n  };\n  /**\r\n   * Stops animation.\r\n   *\r\n   * When animation is stopped, the properties of the target object will remain\r\n   * where they were at the moment when `stop()` was called.\r\n   *\r\n   * @param skipEvent  Do not trigger `animationstopped` event\r\n   * @return Animation\r\n   */\n\n\n  Animation.prototype.stop = function (skipEvent) {\n    this.pause();\n\n    if (!skipEvent) {\n      if (this.events.isEnabled(\"animationstopped\")) {\n        var event_3 = {\n          type: \"animationstopped\",\n          target: this,\n          progress: this.progress\n        };\n        this.events.dispatchImmediately(\"animationstopped\", event_3);\n      }\n    }\n\n    return this;\n  };\n  /**\r\n   * Sets current progress and updates object's numeric and color values.\r\n   *\r\n   * @param progress Progress (0-1)\r\n   */\n\n\n  Animation.prototype.setProgress = function (progress) {\n    var _this = this;\n\n    this._time = this.duration * progress; // just in case we call this from outside\n\n    $array.each(this.animationOptions, function (options) {\n      if (options.updateMethod && $type.hasValue(options.from)) {\n        var value = options.updateMethod(progress, options.from, options.to);\n\n        if (options.childObject) {\n          options.childObject[options.property] = value;\n        } else {\n          _this.object[options.property] = value;\n        }\n      }\n    });\n    this.progress = progress;\n\n    if (this.events.isEnabled(\"animationprogress\")) {\n      var event_4 = {\n        type: \"animationprogress\",\n        target: this,\n        progress: this.progress\n      };\n      this.events.dispatchImmediately(\"animationprogress\", event_4);\n    }\n\n    system.requestFrame();\n  };\n  /**\r\n   * Tracks and sets progress according to time or frames.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @return Animation\r\n   */\n\n\n  Animation.prototype.update = function () {\n    if (!this._pause) {\n      var progress = void 0;\n      this._time = $math.fitToRange(Date.now() - this._startTime, 0, this.duration);\n      var timeProgress = this._time / this.duration;\n      progress = this.easing(timeProgress);\n\n      if (this.duration == 0 || !$type.isNumber(progress) || timeProgress >= 1) {\n        progress = 1;\n      }\n\n      this.setProgress(progress);\n\n      if ($math.round(this._time / this.duration, 6) == 1) {\n        this.end();\n      }\n    }\n\n    return this;\n  };\n\n  Object.defineProperty(Animation.prototype, \"delayed\", {\n    /**\r\n     * Returns `true` if this animation is delayed.\r\n     *\r\n     * @readonly\r\n     * @return [description]\r\n     */\n    get: function () {\n      return this._delayTimeout ? true : false;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Checks other animations currently running on the same object and removes\r\n   * overlapping options from those other animations that are contained in\r\n   * this animation.\r\n   *\r\n   * This is needed to ensure that no two confurent animations step on each\r\n   * other's toes by trying to animate the same property.\r\n   */\n\n  Animation.prototype.stopSameAnimations = function () {\n    var _this = this; // stop animation of the same property\n    // TODO make this more efficient\n    // TODO don't copy the array\n\n\n    $array.each($array.copy(this.object.animations), function (animation) {\n      if (animation !== _this && !animation.delayed) {\n        var killed_1 = [];\n        $array.each(_this.animationOptions, function (newOptions) {\n          $array.each(animation.animationOptions, function (oldOptions) {\n            if (newOptions.property == oldOptions.property && newOptions.childObject == oldOptions.childObject) {\n              killed_1.push(oldOptions);\n\n              if (animation.animationOptions.length == 0) {\n                animation.kill();\n              }\n            }\n          });\n        });\n        $array.each(killed_1, function (oldOptions) {\n          $array.remove(animation.animationOptions, oldOptions);\n        });\n      }\n    });\n  };\n  /**\r\n   * Adds easing functions to \"function\" fields.\r\n   *\r\n   * @param field  Field name\r\n   * @return Assign as function?\r\n   */\n\n\n  Animation.prototype.asFunction = function (field) {\n    return field == \"easing\" || _super.prototype.asIs.call(this, field);\n  };\n\n  return Animation;\n}(BaseObjectEvents);\n\nexport { Animation };","map":{"version":3,"mappings":"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","names":["BaseObjectEvents","SVGDefaults","Disposer","Color","Percent","percent","$async","$ease","$colors","$math","$array","$type","system","options","animate","duration","callback","disposed","startTime","Date","now","loop","diff","nextFrame","getProgressNumber","progress","from","to","getProgressPercent","getProgressColor","color","interpolate","rgb","alpha","getHybridProperty","property","type","charAt","toUpperCase","substr","array","_disposer","length","dispose","AnimationDisposer","isDisposed","__extends","object","animationOptions","easing","_super","_this","linear","className","animationsEnabled","toArray","applyTheme","Animation","call","pause","delay","move","animations","id_1","setTimeout","_delayTimeout","start","clearTimeout","_isFinished","removeDispose","stopSameAnimations","_pause","requestFrame","_start","_startTime","_time","staticOptions","i","options_1","hasValue","childObject","remove","push","isNumber","updateMethod","convertedFrom","isNaN","applyStaticOptions","events","isEnabled","event_1","target","dispatchImmediately","update","end","count","Infinity","_loop","setProgress","event_2","stop","each","skipEvent","event_3","value","event_4","fitToRange","timeProgress","round","Object","copy","animation","delayed","killed_1","newOptions","oldOptions","kill","field","asIs"],"sourceRoot":"","sources":["../../../../../src/.internal/core/utils/Animation.ts"],"sourcesContent":["/**\r\n * Animation module.\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { BaseObjectEvents, IBaseObjectEvents } from \"../Base\";\r\nimport { AMEvent } from \"../utils/EventDispatcher\";\r\nimport { SVGDefaults } from \"../defs/SVGDefaults\";\r\nimport { Disposer, IDisposer } from \"../utils/Disposer\";\r\nimport { Color } from \"../utils/Color\";\r\nimport { Percent, percent } from \"../utils/Percent\";\r\nimport * as $async from \"../utils/AsyncPending\";\r\nimport * as $ease from \"../utils/Ease\";\r\nimport * as $colors from \"../utils/Colors\";\r\nimport * as $math from \"../utils/Math\";\r\nimport * as $array from \"../utils/Array\";\r\nimport * as $type from \"../utils/Type\";\r\nimport { system } from \"../System\";\r\nimport { options } from \"../Options\";\r\n\r\n\r\n/**\r\n * Defines interface for animation objects.\r\n *\r\n * Should at least contain `update()` method.\r\n */\r\nexport interface IAnimationObject {\r\n\tupdate: () => void\r\n}\r\n\r\n/**\r\n * Defines interface for objects that can be animated\r\n */\r\nexport interface IAnimatable {\r\n\tanimations: Array<Animation>;\r\n}\r\n\r\n\r\nexport type IAnimationOption = Color | Percent | number | string | boolean;\r\n\r\n/**\r\n * Defines interface for animation options.\r\n */\r\nexport interface IAnimationOptions {\r\n\r\n\t/**\r\n\t * An initial value to animate from.\r\n\t *\r\n\t * If omitted, the source value will be current value.\r\n\t */\r\n\tfrom?: IAnimationOption;\r\n\r\n\t/**\r\n\t * A target value to animate from.\r\n\t */\r\n\tto: IAnimationOption;\r\n\r\n\t/**\r\n\t * Property name to animate.\r\n\t */\r\n\tproperty?: any;\r\n\r\n\t/**\r\n\t * If current values should be taken from different object than the target\r\n\t * element of the animation, this property should be set to that object.\r\n\t */\r\n\tchildObject?: { [index: string]: any };\r\n\r\n\t/**\r\n\t * A method/function reference that will be called to for updating the\r\n\t * property value.\r\n\t */\r\n\tupdateMethod?(progress: number, from: IAnimationOption, to: IAnimationOption): IAnimationOption;\r\n\r\n\r\n\t/**\r\n\t * sometimes we need to pass some dummy data in animationOptions\r\n\t */\r\n\tdummyData?: any;\r\n\r\n}\r\n\r\n/**\r\n * An interface for an object defining [[Percent]] animation.\r\n */\r\nexport interface IPercentAnimationOptions extends IAnimationOptions {\r\n\r\n\t/**\r\n\t * Initial value.\r\n\t */\r\n\tfrom?: Percent;\r\n\r\n\t/**\r\n\t * Target value.\r\n\t */\r\n\tto: Percent;\r\n\r\n}\r\n\r\n/**\r\n * An interface for an object defining [[Color]] animation.\r\n */\r\nexport interface IColorAnimationOptions extends IAnimationOptions {\r\n\r\n\t/**\r\n\t * Initial value.\r\n\t */\r\n\tfrom?: Color;\r\n\r\n\t/**\r\n\t * Target value.\r\n\t */\r\n\tto: Color;\r\n\r\n}\r\n\r\n\r\n/**\r\n * Calls a `callback` function for the `duration` of milliseconds.\r\n *\r\n * @todo Needed?\r\n * @deprecated Not used anywhere\r\n * @ignore Exclude from docs\r\n * @param duration  Duration (ms)\r\n * @param callback  Callback function\r\n * @return Disposer\r\n */\r\nexport function animate(duration: number, callback: (time: number) => void): IDisposer {\r\n\tlet disposed = false;\r\n\r\n\t// TODO use performance.now() ?\r\n\tconst startTime = Date.now();\r\n\r\n\tfunction loop(now: number): void {\r\n\t\tif (!disposed) {\r\n\t\t\tconst diff = now - startTime;\r\n\r\n\t\t\tif (diff >= duration) {\r\n\t\t\t\tcallback(1);\r\n\r\n\t\t\t} else {\r\n\t\t\t\t$async.nextFrame(loop);\r\n\t\t\t\tcallback(diff / duration);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t$async.nextFrame(loop);\r\n\r\n\treturn new Disposer(() => {\r\n\t\tdisposed = true;\r\n\t});\r\n}\r\n\r\n\r\n/**\r\n * Defines events for [[Animation]].\r\n */\r\nexport interface IAnimationEvents extends IBaseObjectEvents {\r\n\r\n\t/**\r\n\t * Invoked when animation starts playing.\r\n\t */\r\n\tanimationstarted: {\r\n\t\tprogress: number;\r\n\t};\r\n\r\n\t/**\r\n\t * Invoked when animation finishes playing.\r\n\t */\r\n\tanimationended: {\r\n\t\tprogress: number;\r\n\t};\r\n\r\n\t/**\r\n\t * Invoked when animation makes progress.\r\n\t */\r\n\tanimationprogress: {\r\n\t\tprogress: number;\r\n\t};\r\n\r\n\t/**\r\n\t * Invoked when animation is stopped by some other process, before it had\r\n\t * a chance to finish.\r\n\t */\r\n\tanimationstopped: {\r\n\t\tprogress: number;\r\n\t};\r\n\r\n}\r\n\r\n\r\n/**\r\n * Returns numeric value accoring to progress between start and end values.\r\n *\r\n * @param progress  Progress (0-1)\r\n * @param from\r\n * @param to\r\n * @return Value according to progress\r\n */\r\nfunction getProgressNumber(progress: number, from: number, to: number): number {\r\n\treturn from + ((to - from) * progress);\r\n}\r\n\r\n/**\r\n * Returns [[Percent]] value accoring to progress between start and end\r\n * values.\r\n *\r\n * @param progress  Progress (0-1)\r\n * @param from\r\n * @param to\r\n * @return Value according to progress\r\n */\r\nfunction getProgressPercent(progress: number, from: Percent, to: Percent): Percent {\r\n\treturn new Percent(getProgressNumber(progress, from.percent, to.percent));\r\n}\r\n\r\n/**\r\n * Returns color value accoring to progress between start and end values.\r\n *\r\n * @param progress  Progress (0-1)\r\n * @param from\r\n * @param to\r\n * @return Color according to progress\r\n */\r\nfunction getProgressColor(progress: number, from: Color, to: Color): Color {\r\n\tconst color = new Color($colors.interpolate(from.rgb, to.rgb, progress));\r\n\tif (from.alpha != to.alpha) {\r\n\t\tcolor.alpha = from.alpha + (to.alpha - from.alpha) * progress;\r\n\t}\r\n\treturn color;\r\n}\r\n\r\n/**\r\n * [getHybridProperty description]\r\n *\r\n * @todo Description\r\n * @param property [description]\r\n * @param type [description]\r\n * @return [description]\r\n */\r\nfunction getHybridProperty(property: string, type: \"pixel\" | \"relative\"): string {\r\n\treturn type + property.charAt(0).toUpperCase() + property.substr(1);\r\n}\r\n\r\n\r\nexport class AnimationDisposer implements IDisposer {\r\n\tprivate _disposer: Disposer;\r\n\r\n\tconstructor(array: Array<Animation>) {\r\n\t\tthis._disposer = new Disposer(() => {\r\n\t\t\twhile (array.length !== 0) {\r\n\t\t\t\tarray[0].dispose();\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\tisDisposed(): boolean {\r\n\t\treturn this._disposer.isDisposed();\r\n\t}\r\n\r\n\tdispose(): void {\r\n\t\tthis._disposer.dispose();\r\n\t}\r\n}\r\n\r\n\r\n/**\r\n * Animation can be used to transition certain properties on an object that\r\n * implements [[IAnimatable]] interface.\r\n *\r\n * @see {@link IAnimationEvents} for a list of available events\r\n */\r\nexport class Animation extends BaseObjectEvents implements IAnimationObject {\r\n\r\n\t/**\r\n\t * Defines available events.\r\n\t */\r\n\tpublic _events!: IAnimationEvents;\r\n\r\n\t/**\r\n\t * An animation target object. [[Animation]] will update properties of\r\n\t * this object.\r\n\t */\r\n\tpublic object: IAnimatable;\r\n\r\n\t/**\r\n\t * An array of animation option objects. Each animation object represent\r\n\t * one property. Animation can animate any number of properties\r\n\t * simultaneously.\r\n\t */\r\n\tpublic animationOptions: IAnimationOptions[];\r\n\r\n\t/**\r\n\t * Duration of the animation in milliseconds.\r\n\t */\r\n\tpublic duration: number = 0;\r\n\r\n\t/**\r\n\t * Easing function to use.\r\n\t *\r\n\t * @see {@link Ease}\r\n\t */\r\n\tpublic easing: (value: number) => number = $ease.linear;\r\n\r\n\t/**\r\n\t * Contains progress of the current animation: 0 (start) to 1 (end).\r\n\t */\r\n\tpublic progress: number = 0;\r\n\r\n\t/**\r\n\t * A list of options that cannot be animated. Those will be applied when\r\n\t * Animation ends.\r\n\t */\r\n\tprotected staticOptions!: IAnimationOptions[];\r\n\r\n\t/**\r\n\t * Indicated how many times animation should loop.\r\n\t */\r\n\tprotected _loop: number = 0;\r\n\r\n\t/**\r\n\t * Animation is paused.\r\n\t */\r\n\tprotected _pause: boolean = false;\r\n\r\n\t/**\r\n\t * Holds reference to timeout for delayed play.\r\n\t */\r\n\tprotected _delayTimeout: IDisposer | null = null;\r\n\r\n\t/**\r\n\t * A timestamp of when animation started playing.\r\n\t */\r\n\tprotected _startTime: $type.Optional<number>;\r\n\r\n\t/**\r\n\t * Elapsed time in currently playing animation.\r\n\t */\r\n\tprotected _time: number = 0;\r\n\r\n\t// TODO verify that this is correct\r\n\tprotected debug(): void { }\r\n\r\n\tprotected _isFinished: boolean = false;\r\n\r\n\t/**\r\n\t * Constructor\r\n\t *\r\n\t * @param object            An object animation should run on\r\n\t * @param animationOptions  One or several (array) of animation options\r\n\t * @param duration          Duration (ms)\r\n\t * @param easing            Easing function\r\n\t */\r\n\tconstructor(object: IAnimatable, animationOptions: IAnimationOptions[] | IAnimationOptions, duration: number, easing?: (value: number) => number) {\r\n\r\n\t\t// Init\r\n\t\tsuper();\r\n\t\tthis.className = \"Animation\";\r\n\r\n\t\t// Override duration if animations disabled system-wide\r\n\t\tif (options.animationsEnabled === false) {\r\n\t\t\tduration = 0;\r\n\t\t}\r\n\r\n\t\t// Set parameters\r\n\t\tthis.object = object;\r\n\t\tthis.animationOptions = $array.toArray(animationOptions);\r\n\t\tthis.duration = duration;\r\n\t\tif (easing) {\r\n\t\t\tthis.easing = easing;\r\n\t\t}\r\n\r\n\t\t// Run check if there are already animations playing on the same properties\r\n\t\t// and stop them - the last animation takes precedence\r\n\t\t//this.stopSameAnimations();\r\n\r\n\t\t/*if ($type.hasValue(callback)) {\r\n\t\t\t// TODO don't use .call\r\n\t\t\tthis.events.on(\"animationended\", callback, object);\r\n\t\t}*/\r\n\r\n\t\t// Apply theme\r\n\t\tthis.applyTheme();\r\n\t}\r\n\r\n\t/**\r\n\t * Disposes this object, clears up after itself.\r\n\t */\r\n\tpublic dispose(): void {\r\n\t\tsuper.dispose();\r\n\t\tthis.pause();\r\n\t}\r\n\r\n\t/**\r\n\t * Delays animation start by X milliseconds.\r\n\t *\r\n\t * @param delay  Delay (ms)\r\n\t * @return Animation\r\n\t */\r\n\tpublic delay(delay: number): Animation {\r\n\t\t//@todo Maybe not use `bind()`\r\n\t\tif (delay > 0) {\r\n\t\t\tthis.pause();\r\n\r\n\t\t\t// This is so that it will get disposed if `this.object` is disposed\r\n\t\t\t// TODO hacky, figure out a better way\r\n\t\t\t$array.move(this.object.animations, this);\r\n\r\n\t\t\tlet id = setTimeout(() => {\r\n\t\t\t\tthis._delayTimeout = null;\r\n\t\t\t\tthis.start();\r\n\t\t\t}, delay);\r\n\r\n\t\t\tthis._delayTimeout = new Disposer(() => {\r\n\t\t\t\tclearTimeout(id);\r\n\t\t\t});\r\n\t\t}\r\n\t\treturn this;\r\n\t}\r\n\r\n\tprivate _start() {\r\n\t\tthis._isFinished = false;\r\n\t\t// Clear delay timeout if there was one\r\n\t\tif (this._delayTimeout) {\r\n\t\t\tthis.removeDispose(this._delayTimeout);\r\n\t\t\tthis._delayTimeout = null;\r\n\t\t}\r\n\r\n\t\t// Run check if there are already animations playing on the same properties\r\n\t\t// and stop them - the last animation takes precedence\r\n\t\tthis.stopSameAnimations();\r\n\r\n\t\t// Reset counters\r\n\t\tthis._pause = false;\r\n\r\n\t\t// Register animation\r\n\t\t$array.move(system.animations, this);\r\n\r\n\t\t// Register this animation in object's `animations` list\r\n\t\t$array.move(this.object.animations, this);\r\n\r\n\t\tsystem.requestFrame();\r\n\t}\r\n\r\n\t/**\r\n\t * Starts animation.\r\n\t *\r\n\t * @return Animation\r\n\t */\r\n\tpublic start(): Animation {\r\n\t\tthis._start();\r\n\t\tthis._startTime = Date.now();\r\n\t\tthis._time = 0;\r\n\t\tthis.staticOptions = [];\r\n\r\n\t\t// Process initial property values\r\n\t\tfor (let i: number = this.animationOptions.length - 1; i >= 0; i--) {\r\n\t\t\tlet options: IAnimationOptions = this.animationOptions[i];\r\n\t\t\tif (!$type.hasValue(options.from)) {\r\n\t\t\t\tif (options.childObject) {\r\n\t\t\t\t\toptions.from = options.childObject[options.property];\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\toptions.from = (<any>this.object)[options.property];\r\n\r\n\t\t\t\t\tif (!$type.hasValue(options.from)) {\r\n\t\t\t\t\t\toptions.from = (<any>SVGDefaults)[options.property];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t/*if (!$type.hasValue(options.from)) {\r\n\t\t\t\t\tthrow Error(\"Could not get initial transition value.\");\r\n\t\t\t\t}*/\r\n\t\t\t}\r\n\r\n\t\t\tif (options.from == options.to) { // || options.to == (<any>this.object)[options.property]){ this is not good, as dataItem.value is set to final at once, and we animate workingValue\r\n\t\t\t\t$array.remove(this.animationOptions, options);\r\n\t\t\t}\r\n\t\t\telse if (!$type.hasValue(options.from) || (!(options.from instanceof Percent) && (options.to instanceof Percent)) || ((options.from instanceof Percent) && !(options.to instanceof Percent))) {\r\n\t\t\t\t// Initial value is undefined, treat it as static\r\n\t\t\t\tthis.staticOptions.push(options);\r\n\t\t\t\t$array.remove(this.animationOptions, options);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t// Use different update methods for different value types\r\n\t\t\t\tif ($type.isNumber(<number>options.to)) {\r\n\r\n\t\t\t\t\t// Numeric value\r\n\t\t\t\t\toptions.updateMethod = getProgressNumber;\r\n\r\n\t\t\t\t\t// Check if initial value is not Percent\r\n\t\t\t\t\tif (options.from instanceof Percent) {\r\n\t\t\t\t\t\t// It is. Let's convert it to pixel value\r\n\t\t\t\t\t\t// @todo Check if we can do this in a less hacky way\r\n\t\t\t\t\t\tlet convertedFrom: number = (<any>this.object)[getHybridProperty(options.property, \"pixel\")];\r\n\t\t\t\t\t\tif (!isNaN(convertedFrom)) {\r\n\t\t\t\t\t\t\toptions.from = convertedFrom;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\tthis.staticOptions.push(options);\r\n\t\t\t\t\t\t\t$array.remove(this.animationOptions, options);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (isNaN(<number>options.from)) {\r\n\t\t\t\t\t\t// Static value\r\n\t\t\t\t\t\tthis.staticOptions.push(options);\r\n\t\t\t\t\t\t$array.remove(this.animationOptions, options);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\t// Check if maybe we have a color or percent value\r\n\t\t\t\t\tif (options.to instanceof Color) {\r\n\t\t\t\t\t\t// Yup - set resolved named color\r\n\t\t\t\t\t\t//options.from = $colors.stringToColor(<string>options.from);\r\n\t\t\t\t\t\tif (options.from) {\r\n\t\t\t\t\t\t\toptions.updateMethod = getProgressColor;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t// Static value\r\n\t\t\t\t\t\t\tthis.staticOptions.push(options);\r\n\t\t\t\t\t\t\t$array.remove(this.animationOptions, options);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (options.to instanceof Percent) {\r\n\t\t\t\t\t\t// Percent\r\n\t\t\t\t\t\toptions.updateMethod = getProgressPercent;\r\n\r\n\t\t\t\t\t\t// Check if the initial value is maybe in pixels\r\n\t\t\t\t\t\tif (!isNaN(<number>options.from)) {\r\n\t\t\t\t\t\t\t// It is. Let's convert it\r\n\t\t\t\t\t\t\t// @todo Check if we can do this in a less hacky way\r\n\t\t\t\t\t\t\tlet convertedFrom: number = (<any>this.object)[getHybridProperty(options.property, \"relative\")];\r\n\t\t\t\t\t\t\tif (!isNaN(convertedFrom)) {\r\n\t\t\t\t\t\t\t\toptions.from = percent(convertedFrom * 100);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\t// Static value\r\n\t\t\t\t\t\tthis.staticOptions.push(options);\r\n\t\t\t\t\t\t$array.remove(this.animationOptions, options);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Apply static options (just in case they were reset by previous\r\n\t\t// animation loop)\r\n\t\tthis.applyStaticOptions();\r\n\r\n\t\tif (this.events.isEnabled(\"animationstarted\")) {\r\n\t\t\tconst event: AMEvent<this, IAnimationEvents>[\"animationstarted\"] = {\r\n\t\t\t\ttype: \"animationstarted\",\r\n\t\t\t\ttarget: this,\r\n\t\t\t\tprogress: this.progress\r\n\t\t\t};\r\n\t\t\tthis.events.dispatchImmediately(\"animationstarted\", event);\r\n\t\t}\r\n\r\n\t\tthis.update();\r\n\r\n\t\t// If duration is 0, just end animation\r\n\t\tif (this.duration === 0) {\r\n\t\t\tthis.end();\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Sets loop count for the animation. If parameter is not a valid number the\r\n\t * animation will keep on looping indefinitely.\r\n\t *\r\n\t * @param count  Number of times to loop animation\r\n\t * @return Animation\r\n\t */\r\n\tpublic loop(count?: number): Animation {\r\n\t\tif (!$type.isNumber(count)) {\r\n\t\t\tcount = Infinity;\r\n\t\t}\r\n\t\tthis._loop = count;\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Pauses animation.\r\n\t *\r\n\t * @return Animation\r\n\t */\r\n\tpublic pause(): Animation {\r\n\t\tthis._pause = true;\r\n\r\n\t\tif (this._delayTimeout) {\r\n\t\t\tthis.removeDispose(this._delayTimeout);\r\n\t\t\tthis._delayTimeout = null;\r\n\t\t}\r\n\r\n\t\t$array.remove(system.animations, this);\r\n\t\t$array.remove(this.object.animations, this);\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Resumes paused animation.\r\n\t *\r\n\t * @return Animation\r\n\t */\r\n\tpublic resume(): Animation {\r\n\t\tthis._start();\r\n\t\tthis._startTime = Date.now() - this._time;\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Jumps to animation end. If animation is set to loop, this will start\r\n\t * another round of animation from start.\r\n\t *\r\n\t * @return Animation\r\n\t */\r\n\tpublic end(): Animation {\r\n\r\n\t\t// Pause and complete the progress\r\n\t\tif (this._loop == 0) {\r\n\t\t\tthis.pause();\r\n\t\t}\r\n\t\tthis.setProgress(1);\r\n\r\n\t\t// Apply static options\r\n\t\tthis.applyStaticOptions();\r\n\r\n\t\tif (this.events.isEnabled(\"animationended\")) {\r\n\t\t\tconst event: AMEvent<this, IAnimationEvents>[\"animationended\"] = {\r\n\t\t\t\ttype: \"animationended\",\r\n\t\t\t\ttarget: this,\r\n\t\t\t\tprogress: this.progress\r\n\t\t\t};\r\n\t\t\tthis.events.dispatchImmediately(\"animationended\", event);\r\n\t\t}\r\n\r\n\t\t// Check if we should loop\r\n\t\tif (this._loop > 0) {\r\n\t\t\tthis._loop--;\r\n\t\t\tthis.start();\r\n\t\t}\r\n\t\telse {\r\n\t\t\tthis.stop();\r\n\t\t\tthis._isFinished = true;\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Stops animation immediately leaving properties in their current values.\r\n\t */\r\n\tpublic kill() {\r\n\t\tthis.pause();\r\n\t\tthis._isFinished = true;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns indicator if this animation is finished or not\r\n\t *\r\n\t * @return Is finished?\r\n\t */\r\n\tpublic isFinished(): boolean {\r\n\t\treturn this._isFinished;\r\n\t}\r\n\r\n\t/**\r\n\t * Applies static options that can't be animated.\r\n\t */\r\n\tprotected applyStaticOptions(): void {\r\n\t\t$array.each(this.staticOptions, (options) => {\r\n\t\t\tif (options.childObject) {\r\n\t\t\t\toptions.childObject[options.property] = this.progress == 1 ? options.to : options.from;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t(<any>this.object)[options.property] = this.progress == 1 ? options.to : options.from;\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Stops animation.\r\n\t *\r\n\t * When animation is stopped, the properties of the target object will remain\r\n\t * where they were at the moment when `stop()` was called.\r\n\t *\r\n\t * @param skipEvent  Do not trigger `animationstopped` event\r\n\t * @return Animation\r\n\t */\r\n\tpublic stop(skipEvent?: boolean): Animation {\r\n\t\tthis.pause();\r\n\t\tif (!skipEvent) {\r\n\t\t\tif (this.events.isEnabled(\"animationstopped\")) {\r\n\t\t\t\tconst event: AMEvent<this, IAnimationEvents>[\"animationstopped\"] = {\r\n\t\t\t\t\ttype: \"animationstopped\",\r\n\t\t\t\t\ttarget: this,\r\n\t\t\t\t\tprogress: this.progress\r\n\t\t\t\t};\r\n\t\t\t\tthis.events.dispatchImmediately(\"animationstopped\", event);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Sets current progress and updates object's numeric and color values.\r\n\t *\r\n\t * @param progress Progress (0-1)\r\n\t */\r\n\tpublic setProgress(progress: number): void {\r\n\t\tthis._time = this.duration * progress; // just in case we call this from outside\r\n\t\t$array.each(this.animationOptions, (options) => {\r\n\t\t\tif (options.updateMethod && $type.hasValue(options.from)) {\r\n\t\t\t\tlet value = options.updateMethod(progress, options.from, options.to);\r\n\r\n\t\t\t\tif (options.childObject) {\r\n\t\t\t\t\toptions.childObject[options.property] = value;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\t(<any>this.object)[options.property] = value;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tthis.progress = progress;\r\n\t\tif (this.events.isEnabled(\"animationprogress\")) {\r\n\t\t\tconst event: AMEvent<this, IAnimationEvents>[\"animationprogress\"] = {\r\n\t\t\t\ttype: \"animationprogress\",\r\n\t\t\t\ttarget: this,\r\n\t\t\t\tprogress: this.progress\r\n\t\t\t};\r\n\t\t\tthis.events.dispatchImmediately(\"animationprogress\", event);\r\n\t\t}\r\n\r\n\t\tsystem.requestFrame();\r\n\t}\r\n\r\n\t/**\r\n\t * Tracks and sets progress according to time or frames.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @return Animation\r\n\t */\r\n\tpublic update(): Animation {\r\n\t\tif (!this._pause) {\r\n\r\n\t\t\tlet progress;\r\n\t\t\tthis._time = $math.fitToRange(Date.now() - this._startTime!, 0, this.duration);\r\n\t\t\tlet timeProgress = this._time / this.duration;\r\n\t\t\tprogress = this.easing(timeProgress);\r\n\t\t\tif (this.duration == 0 || !$type.isNumber(progress) || timeProgress >= 1) {\r\n\t\t\t\tprogress = 1;\r\n\t\t\t}\r\n\r\n\t\t\tthis.setProgress(progress);\r\n\r\n\t\t\tif ($math.round(this._time / this.duration, 6) == 1) {\r\n\t\t\t\tthis.end();\r\n\t\t\t}\r\n\r\n\t\t}\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns `true` if this animation is delayed.\r\n\t *\r\n\t * @readonly\r\n\t * @return [description]\r\n\t */\r\n\tpublic get delayed(): boolean {\r\n\t\treturn this._delayTimeout ? true : false;\r\n\t}\r\n\r\n\t/**\r\n\t * Checks other animations currently running on the same object and removes\r\n\t * overlapping options from those other animations that are contained in\r\n\t * this animation.\r\n\t *\r\n\t * This is needed to ensure that no two confurent animations step on each\r\n\t * other's toes by trying to animate the same property.\r\n\t */\r\n\tprivate stopSameAnimations(): void {\r\n\t\t// stop animation of the same property\r\n\t\t// TODO make this more efficient\r\n\t\t// TODO don't copy the array\r\n\t\t$array.each($array.copy(this.object.animations), (animation) => {\r\n\t\t\tif (animation !== this && !animation.delayed) {\r\n\t\t\t\tconst killed: Array<IAnimationOptions> = [];\r\n\r\n\t\t\t\t$array.each(this.animationOptions, (newOptions) => {\r\n\t\t\t\t\t$array.each(animation.animationOptions, (oldOptions) => {\r\n\t\t\t\t\t\tif (newOptions.property == oldOptions.property && newOptions.childObject == oldOptions.childObject) {\r\n\t\t\t\t\t\t\tkilled.push(oldOptions);\r\n\r\n\t\t\t\t\t\t\tif (animation.animationOptions.length == 0) {\r\n\t\t\t\t\t\t\t\tanimation.kill();\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t});\r\n\r\n\t\t\t\t$array.each(killed, (oldOptions) => {\r\n\t\t\t\t\t$array.remove(animation.animationOptions, oldOptions);\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Adds easing functions to \"function\" fields.\r\n\t *\r\n\t * @param field  Field name\r\n\t * @return Assign as function?\r\n\t */\r\n\tprotected asFunction(field: string): boolean {\r\n\t\treturn field == \"easing\" || super.asIs(field);\r\n\t}\r\n\r\n}"]},"metadata":{},"sourceType":"module"}