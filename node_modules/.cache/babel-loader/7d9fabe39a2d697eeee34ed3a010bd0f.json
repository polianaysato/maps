{"ast":null,"code":"/**\r\n * Text class deals with all text placed on chart.\r\n */\nimport { __extends } from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\nimport { Container } from \"../Container\";\nimport { registry } from \"../Registry\";\nimport { getTextFormatter } from \"../formatters/TextFormatter\";\nimport { MultiDisposer } from \"../utils/Disposer\";\nimport { InterfaceColorSet } from \"../../core/utils/InterfaceColorSet\";\nimport * as $math from \"../utils/Math\";\nimport * as $utils from \"../utils/Utils\";\nimport * as $type from \"../utils/Type\";\nimport * as $dom from \"../utils/DOM\";\nimport { defaultRules, ResponsiveBreakpoints } from \"../utils/Responsive\";\nimport { options } from \"../Options\";\n;\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * Text is used to display highly configurable, data-enabled textual elements.\r\n *\r\n * ## Data Binding\r\n *\r\n * A Text element can dynamically parse and populate its contents with values\r\n * from a [[DataItem]].\r\n *\r\n * To activate such binding, set element's `dataItem` property.\r\n *\r\n * When activated, text contents will be parsed for special tags, e.g.:\r\n *\r\n * ```TypeScript\r\n * label.dataItem = myDataItem;\r\n * label.text = \"The title is: {title}\";\r\n * ```\r\n * ```JavaScript\r\n * label.dataItem = myDataItem;\r\n * label.text = \"The title is: {title}\";\r\n * ```\r\n *\r\n * The above will automatically replace \"{title}\" in the string with the\r\n * actual data value from `myDataItem`.\r\n *\r\n * Note, that most often dataItem is set by the Component.\r\n *\r\n *\r\n * @see {@link ILabelEvents} for a list of available events\r\n * @see {@link ILabelAdapters} for a list of available Adapters\r\n * @see {@link https://www.amcharts.com/docs/v4/concepts/formatters/formatting-strings/} for info on string formatting and data binding\r\n * @todo Vertical align\r\n * @important\r\n */\n\nvar Label =\n/** @class */\nfunction (_super) {\n  __extends(Label, _super);\n  /**\r\n   * Constructor\r\n   */\n\n\n  function Label() {\n    var _this = // Execute super's constructor\n    _super.call(this) || this;\n    /**\r\n     * Indicates if the whole text does not fit into max dimenstions set for it.\r\n     */\n\n\n    _this.isOversized = false; // Set this class name\n\n    _this.className = \"Label\";\n    _this.fill = new InterfaceColorSet().getFor(\"text\"); // not good to set this, as then these will appear on each label and values set on container won't be applied.\n    //this.textDecoration = \"none\";\n    //this.fontWeight = \"normal\";\n    // Set defaults\n\n    _this.wrap = false;\n    _this.truncate = false;\n    _this.fullWords = true;\n    _this.ellipsis = \"â€¦\";\n    _this.textAlign = \"start\";\n    _this.textValign = \"top\";\n    _this.layout = \"absolute\";\n    _this.baseLineRatio = -0.27; //this.pixelPerfect = true;\n\n    _this._positionPrecision = 1; // Add events to watch for maxWidth/maxHeight changes so that we can\n    // invalidate this\n\n    _this.events.on(\"maxsizechanged\", function () {\n      if (_this.inited) {\n        _this.handleMaxSize();\n      }\n    }, _this, false); // this solves strange bug when text just added to svg is 0x0\n\n\n    _this.events.once(\"validated\", _this.handleValidate, _this, false); // Aply theme\n\n\n    _this.applyTheme();\n\n    return _this;\n  }\n  /**\r\n   * A placeholder method that is called **after** element finishes drawing\r\n   * itself.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  Label.prototype.afterDraw = function () {\n    // since we removed validatePosition from sprite, we still need it here to handle rotated text\n    _super.prototype.afterDraw.call(this);\n\n    this.validatePosition();\n  };\n  /**\r\n   * Sets [[Paper]] instance to use to draw elements.\r\n   * @ignore\r\n   * @param paper Paper\r\n   * @return true if paper was changed, false, if it's the same\r\n   */\n\n\n  Label.prototype.setPaper = function (paper) {\n    var changed = _super.prototype.setPaper.call(this, paper);\n\n    if (changed) {\n      this.hardInvalidate();\n    }\n\n    return changed;\n  };\n  /**\r\n   * @ignore\r\n   */\n\n\n  Label.prototype.handleValidate = function () {\n    if ((this.currentText || this.text) && (this.bbox.width == 0 || this.bbox.height == 0)) {\n      registry.events.once(\"exitframe\", this.hardInvalidate, this);\n    }\n  };\n  /**\r\n   * @ignore\r\n   */\n\n\n  Label.prototype.handleMaxSize = function () {\n    if (this.bbox.width > this.availableWidth || this.bbox.width < this.availableWidth && (this.isOversized || this.truncate) || this.bbox.height > this.availableHeight || this.bbox.height < this.availableHeight && this.isOversized) {\n      this.invalidate();\n    } else {//this.alignSVGText();\n    }\n  };\n  /**\r\n   * [arrange description]\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description\r\n   */\n\n\n  Label.prototype.arrange = function () {};\n  /**\r\n   * Updates current text according to data item and supported features.\r\n   * Returns `true` if current text has changed.\r\n   *\r\n   * @return Text changed?\r\n   */\n\n\n  Label.prototype.updateCurrentText = function () {\n    // Determine output format\n    var output, text;\n\n    if ($utils.isNotEmpty(this.html) && this.paper.supportsForeignObject()) {\n      // We favor HTML text if it's set and browser supports `foreignObject`\n      output = \"html\";\n      text = this.html;\n    } else {\n      output = \"svg\";\n      text = this.text;\n    } // Need to toString source?\n\n\n    if ($type.isObject(text)) {\n      text = text.toString();\n    } // Need to format text all the time\n\n\n    if ($type.hasValue(text) && text !== \"\") {\n      text = this.populateString(text, this.dataItem);\n    }\n\n    if (output == \"html\") {\n      if (this._adapterO) {\n        text = this._adapterO.apply(\"htmlOutput\", text);\n      }\n    } else {\n      if (this._adapterO) {\n        text = this._adapterO.apply(\"textOutput\", text);\n      }\n    } // Update the text\n\n\n    var changed = text != this.currentText || output != this._currentFormat;\n    this.currentText = text;\n    this._currentFormat = output;\n    return changed;\n  };\n  /**\r\n   * Hard invalidate means the text will be redrawn even if it hasn't changed.\r\n   * This is used when we change `fontSize`, `fontFamily`, or for some other\r\n   * reasons.\r\n   */\n\n\n  Label.prototype.hardInvalidate = function () {\n    this._prevStatus = \"\";\n    this.invalidate();\n  };\n  /**\r\n   * Gets line bbox, uses caching to save cpu\r\n   * @ignore\r\n   */\n\n\n  Label.prototype.getLineBBox = function (lineInfo) {\n    //let cacheKey = lineInfo.text + lineInfo.style;\n    //let lineBBox = this.getCache(cacheKey);\n    //if (!lineBBox) {\n    //lineBBox = lineInfo.element.getBBox();\n    //if (lineBBox.width != 0 && lineBBox.height != 0) {\n    //\tthis.setCache(cacheKey, lineBBox, 5000);\n    //}\n    //}\n    var element = lineInfo && lineInfo.element;\n    var node = element && element.node; // Check for the parent Node to avoid FF from throwing errors\n\n    if (node && node.parentNode) {\n      lineInfo.bbox = element.getBBox();\n    }\n  };\n  /**\r\n   * Draws the textual label.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  Label.prototype.draw = function () {\n    // Draw super\n    _super.prototype.draw.call(this);\n\n    var oldW = this.bbox.width;\n    var oldH = this.bbox.height;\n    var topParent = this.topParent;\n\n    if (topParent) {\n      if (!topParent.maxWidth || !topParent.maxHeight) {\n        topParent.events.once(\"maxsizechanged\", this.hardInvalidate, this, false);\n        return;\n      }\n    } // Calculate max width and height\n\n\n    var maxWidth = $math.max(this.availableWidth - this.pixelPaddingLeft - this.pixelPaddingRight, 0);\n    var maxHeight = $math.max(this.availableHeight - this.pixelPaddingTop - this.pixelPaddingBottom, 0); // save\n\n    var status = maxHeight + \",\" + maxWidth + this.wrap + this.truncate + this.fullWords + this.rtl + this.ellipsis; // Update text\n\n    if (!this.updateCurrentText() && this.inited && this._prevStatus == status) {\n      return;\n    }\n\n    this._measuredWidth = 0;\n    this._measuredHeight = 0; // Reset\n\n    this.isOversized = false; // Determine output format\n\n    var output = this._currentFormat;\n    var text = this.currentText; // Empty string\n\n    if (!$type.hasValue(text) || text == \"\") {\n      this.element.attr({\n        display: \"none\"\n      });\n      return;\n    } // Chop up text into lines\n    // We're still processing SVG and HTML in the same way for now\n\n\n    var lines = text.split(\"\\n\"); // Do we need to go through the trouble of measuring lines\n    //let measure: boolean = true;// (lines.length > 1) || this.wrap;\n\n    this._prevStatus = status;\n    this.textAlign = this.textAlign; // need this to measure\n\n    var display = this.group.getAttr(\"display\");\n\n    if (display == \"none\") {\n      this.group.removeAttr(\"display\");\n    }\n\n    if (this.textPathElement) {\n      this.textPathElement.removeChildren();\n    } // SVG or HTML?\n\n\n    if (output === \"svg\") {\n      /**\r\n       * SVG\r\n       */\n      this.element.removeAttr(\"display\"); // Clear the element\n\n      var group = this.element;\n      this.resetBBox(); // Init state variables\n\n      var currentHeight = 0;\n      var currentFormat = \"\"; // Process each line\n\n      for (var i = 0; i < lines.length; i++) {\n        // Get line\n        var line = lines[i]; // Check if line is empty\n\n        if (line == \"\") {\n          // It is, let's just update currentHeight and go to the next one\n          // If it's the first line, we'll have to use arbirary line height,\n          // since there's nothing to measure. For subsequent lines we can take\n          // previous line's height\n          var tempElement = this.getSVGLineElement(\"\", 0);\n          tempElement.add(this.getSvgElement(\".\", getTextFormatter().translateStyleShortcuts(currentFormat)));\n          group.add(tempElement);\n          var offset = Math.ceil(tempElement.getBBox().height);\n\n          if (offset > 0) {\n            currentHeight += offset;\n          }\n\n          group.removeElement(tempElement); // Clear cache if necessary\n\n          var lineInfo_1 = this.getLineInfo(i);\n\n          if (lineInfo_1) {\n            lineInfo_1.text = \"\";\n            lineInfo_1.element.textContent = \"\";\n          }\n\n          continue;\n        } // Chunk up the line and process each chunk\n\n\n        var chunks = getTextFormatter().chunk(line, null, this.ignoreFormatting);\n        var currentLineHeight = 0;\n        var firstChunk = true;\n        var skipTextChunks = false; // Create line element or grab it from cache\n\n        var lineInfo = this.getLineInfo(i);\n\n        if (lineInfo) {\n          // Empty line\n          lineInfo.text = \"\";\n          lineInfo.element.textContent = \"\";\n        } else {\n          // Init new line info\n          lineInfo = {\n            \"text\": \"\",\n            \"element\": this.getSVGLineElement(\"\", 0),\n            \"complex\": false\n          }; // Create the line element\n          //lineInfo.element = this.getSVGLineElement(\"\", 0);\n          //lineElement = this.getSVGLineElement(\"\", 0);\n\n          group.add(lineInfo.element);\n        }\n\n        lineInfo.element.removeAttr(\"display\");\n        lineInfo.element.removeChildren(); // memory leak without this\n\n        if (this.textPathElement) {\n          lineInfo.element.add(this.textPathElement);\n        }\n        /*// @todo not needed anymore\r\n        if (this.rtl) {\r\n            chunks.reverse();\r\n        }*/\n        // Process each chunk\n\n\n        for (var x = 0; x < chunks.length; x++) {\n          // If there's more than one chunk, means the line is \"complex\"\n          if (x) {\n            lineInfo.complex = true;\n          } // Get chunk\n\n\n          var chunk = chunks[x]; // Is this chunk format or text?\n\n          if (chunk.type === \"format\") {\n            // Log current format, so that we can apply it to multiple lines if\n            // necessary\n            currentFormat = chunk.text;\n          } else {\n            // It's text block\n            // Need to skip?\n            // We do this when truncating. We can't just simply go ahead and\n            // abandon chunk processing as they might have formatting\n            // instructions in them that are relevant for subsequent lines\n            if (skipTextChunks) {\n              continue;\n            } // Add chunk to the current element\n            //lineInfo.element.content += $utils.trim(getTextFormatter().format(currentFormat + chunk.text, output));\n\n\n            lineInfo.text = chunk.text;\n            lineInfo.style = getTextFormatter().translateStyleShortcuts(currentFormat);\n\n            if (this.textPathElement) {\n              this.getSvgElement(lineInfo.text, lineInfo.style, this.textPathElement);\n            } else {\n              this.getSvgElement(lineInfo.text, lineInfo.style, lineInfo.element);\n            }\n\n            this.getLineBBox(lineInfo);\n            lineInfo.bbox.width = Math.ceil(lineInfo.bbox.width); // Updated current line height\n\n            if (currentLineHeight < lineInfo.bbox.height) {\n              currentLineHeight = lineInfo.bbox.height;\n            } // Wrapping?\n\n\n            if ((this.wrap || this.truncate) && lineInfo.bbox.width > maxWidth) {\n              // Set oversized\n              this.isOversized = true; // Take temporary measurements\n\n              var lineText = lineInfo.element.textContent;\n              var avgCharWidth = lineInfo.bbox.width / lineText.length; // * .9;\n              // Calculate average number of symbols / width\n\n              var excessChars = $math.min(Math.ceil((lineInfo.bbox.width - maxWidth) / avgCharWidth), lineText.length); // Are we truncating or auto-wrapping text?\n\n              if (this.truncate) {\n                /**\r\n                 * Processing line truncation\r\n                 * With the addition of each text chunk we measure if current\r\n                 * line does not exceed maxWidth. If it does, we will stop\r\n                 * addition of further chunks as well as try to truncate\r\n                 * current or any number of previous chunks with an added\r\n                 * ellipsis\r\n                 */\n                // Indicator whether we need to add ellipsis to the current\n                // element, even if it fits. This is needed to indicate\n                // whether we have already removed some subsequent chunks in\n                // which case we need to add ellipsis.\n                var addEllipsis = false; // Process each child in the temporary line, until the whole\n                // line fits, preferably with an ellipsis\n                // TODO use iterator instead\n\n                var node_1 = lineInfo.element.node;\n\n                if (node_1 && node_1.childNodes) {\n                  for (var e = lineInfo.element.node.childNodes.length - 1; e >= 0; e--) {\n                    // Get current element\n                    var node_2 = lineInfo.element.node.childNodes[e]; // Add ellipsis only if previous chunk was removed in full\n                    // and this chunk already fits\n                    //if (addEllipsis && (bbox.width <= maxWidth)) {\n\n                    if (addEllipsis && lineInfo.bbox.width <= maxWidth) {\n                      // Add ellipsis\n                      node_2.textContent += \" \" + this.ellipsis; // Measure again (we need to make sure ellipsis fits)\n\n                      lineInfo.bbox = lineInfo.element.getBBox();\n                      lineInfo.bbox.width = Math.floor(lineInfo.bbox.width); // If it fits, we're done here\n                      // If it doesn't we continue rolling\n\n                      if (lineInfo.bbox.width <= maxWidth) {\n                        break;\n                      }\n                    }\n\n                    addEllipsis = false; // Get element text\n\n                    var elementText = node_2.textContent; // Calculate average number of symbols / width\n\n                    lineText = lineInfo.element.textContent;\n                    excessChars = $math.min(Math.ceil((lineInfo.bbox.width - maxWidth) / avgCharWidth), lineText.length); // Do this until we fit\n\n                    while (lineInfo.bbox.width > maxWidth && excessChars <= lineText.length && excessChars > 0) {\n                      // Calculate max available chars\n                      var maxChars = $math.max(lineText.length - excessChars - this.ellipsis.length, 1); // Is there anything left?\n\n                      if (maxChars <= 1) {\n                        // Nope, let's jump to the previous item\n                        // Set excess characters to zero so that this loop does\n                        // not repeat when it over\n                        excessChars = 0; // Add ellipsis to previous item\n                        // Subsequent iterations will check if the ellipsis fits\n\n                        if (e > 0) {\n                          // Indicating to add ellipsis to previous item\n                          addEllipsis = true; // Removing this node\n\n                          lineInfo.element.node.removeChild(node_2);\n                        }\n                      } // Truncate the text\n\n\n                      elementText = $utils.truncateWithEllipsis(elementText, maxChars, this.ellipsis, this.fullWords, this.rtl);\n\n                      if (elementText.length > maxChars && this.fullWords) {\n                        // Still too long?\n                        // Let's try truncating breaking words anyway\n                        elementText = $utils.truncateWithEllipsis(elementText, maxChars, this.ellipsis, false, this.rtl);\n                      } // Set truncated text\n\n\n                      node_2.textContent = elementText; // Measure again\n\n                      lineInfo.bbox = lineInfo.element.getBBox();\n                      lineInfo.bbox.width = Math.floor(lineInfo.bbox.width); // Increase excess characters count, just in case it still\n                      // doesn't fit and we have to go at it again\n\n                      excessChars = Math.ceil(excessChars * 1.1);\n                    } // Do not process further chunks\n\n\n                    skipTextChunks = true;\n                  }\n                }\n              } else {\n                /**\r\n                 * Processign auto-wrap\r\n                 * In this case we're going to be adding text chunks until\r\n                 * they don't fit into current line. Once that happens we will\r\n                 * inject the rest of the chunks to the next line\r\n                 */\n                // Get last node added and measure it\n                var node_3 = lineInfo.element.node;\n\n                if (node_3) {\n                  var lastNode = lineInfo.element.node.lastChild; // Init split lines\n\n                  var splitLines = void 0;\n\n                  while (lineInfo.bbox.width > maxWidth && excessChars <= lineText.length && excessChars > 0) {\n                    // Calculate max available chars\n                    var maxChars = $math.max(chunk.text.length - excessChars, 1); // Don't split the words mid-word if it's not the first chunk\n                    // in the line\n\n                    if (firstChunk) {\n                      // Split mid-word if necessary\n                      splitLines = $utils.splitTextByCharCount(chunk.text, maxChars, true, this.rtl);\n                    } else {\n                      // Don't split mid-word\n                      splitLines = $utils.splitTextByCharCount(chunk.text, maxChars, true, this.rtl, false); // Check if the first word is too long\n\n                      if (splitLines[0].length > maxChars || maxChars === 1) {\n                        // Yes - move the whole chunk to the next line\n                        // Remove the element we just added\n                        lineInfo.element.node.removeChild(lastNode); // Break out of the while on next cycle\n\n                        excessChars = 0;\n                      }\n                    } // Use the first line to update last item\n\n\n                    if (excessChars > 0) {\n                      var lineText_1 = splitLines.shift();\n\n                      if (firstChunk) {\n                        lineText_1 = $utils.trim(lineText_1);\n                      }\n\n                      lastNode.textContent = getTextFormatter().cleanUp(lineText_1);\n                    } // Measure again, just in case\n\n\n                    lineInfo.bbox = lineInfo.element.getBBox();\n                    lineInfo.bbox.width = Math.floor(lineInfo.bbox.width); // Increase excess characters count, just in case it still\n                    // doesn't fit and we have to go at it again\n                    //excessChars = Math.ceil(excessChars * 1.05);\n\n                    excessChars++;\n                  } // Construct the rest of the line\n\n\n                  if (splitLines.length > 0) {\n                    var restOfLine = \"\"; // Add leftovers from splitting the current chunk\n\n                    if ($type.hasValue(splitLines)) {\n                      if (this.rtl) {\n                        restOfLine += splitLines.join(\"\") + currentFormat;\n                      } else {\n                        restOfLine += currentFormat + splitLines.join(\"\").replace(/([\\[\\]]{1})/g, \"$1$1\");\n                      }\n                    } // Add the rest of the chunks\n\n\n                    for (var c = x + 1; c < chunks.length; c++) {\n                      if (chunks[c].type == \"value\") {\n                        // We're escaping single square brackets that were\n                        // cleaned up by chunk() back to double square brackets\n                        // so that they are not being treated as format on\n                        // next pass.\n                        restOfLine += chunks[c].text.replace(/([\\[\\]]{1})/g, \"$1$1\");\n                      } else {\n                        restOfLine += chunks[c].text;\n                      }\n                    } // Inject the rest of the lines as chunks for subsequent\n\n\n                    lines.splice(i + 1, 0, restOfLine);\n                  } // Skip processing the rest of the chunks\n\n\n                  skipTextChunks = true;\n                }\n              }\n            } // Let's update the text's bbox with the line's one\n\n\n            if (this.bbox.width < lineInfo.bbox.width) {\n              this.bbox.width = lineInfo.bbox.width;\n            } // commented to avoid bug (seen on sankey link) where text is incorrectly aligned\n            //if (this.bbox.x > lineInfo.bbox.x) {\n            //this.bbox.x = lineInfo.bbox.x;\n            //}\n\n\n            this.bbox.height = currentHeight + currentLineHeight; // Position current line\n\n            if (!this.textPathElement) {\n              lineInfo.element.attr({\n                \"x\": \"0\",\n                \"y\": currentHeight + currentLineHeight,\n                \"dy\": $math.round(this.baseLineRatio * currentLineHeight, 3).toString()\n              });\n            } else {\n              lineInfo.element.attr({\n                \"dy\": -this.paddingBottom.toString()\n              });\n            }\n\n            firstChunk = false;\n          }\n        } // Trim the last item\n\n\n        var node = lineInfo.element.node;\n\n        if (node) {\n          var lastNode = node.lastChild;\n\n          if (lastNode) {\n            lastNode.textContent = this.rtl ? $utils.ltrim(lastNode.textContent) : $utils.rtrim(lastNode.textContent);\n          }\n        } // Increment collective height\n\n\n        currentHeight += currentLineHeight; // Save line cache\n\n        this.addLineInfo(lineInfo, i);\n      } // Check if maybe we need to hide the whole label if it doesn't fit\n\n\n      this.maybeHideOversized();\n      this.measureFailed = false;\n\n      if (this.bbox.width == 0 || this.bbox.height == 0) {\n        this.measureFailed = true;\n      } // Updated measured dims\n\n\n      this._measuredWidth = $math.round($math.max(this.bbox.width, this.pixelWidth - this.pixelPaddingLeft - this.pixelPaddingRight));\n      this._measuredHeight = $math.round($math.max(this.bbox.height, this.pixelHeight - this.pixelPaddingTop - this.pixelPaddingBottom)); // Align the lines\n\n      this.alignSVGText();\n      this.bbox.width = this._measuredWidth;\n      this.bbox.height = this._measuredHeight;\n\n      if (oldH != this._measuredHeight || oldW != this._measuredWidth) {\n        this.dispatch(\"transformed\");\n      }\n\n      this.hideUnused(lines.length);\n    } else {\n      /**\r\n       * HTML\r\n       */\n      this.element.removeAttr(\"display\");\n      this.resetBBox(); // Clear the element\n\n      var group = this.element;\n      group.removeChildren(); // Create a ForeignObject to use as HTML container\n\n      var fo = this.paper.foreignObject();\n      group.add(fo); // Set widths on foreignObject so that autosizing measurements work\n      // This will bet reset to actual content width/height\n\n      if (this.maxWidth) {\n        fo.attr({\n          width: this.maxWidth - this.pixelPaddingLeft - this.pixelPaddingRight\n        });\n      }\n\n      if (this.maxHeight) {\n        fo.attr({\n          height: this.maxHeight - this.pixelPaddingTop - this.pixelPaddingBottom\n        });\n      } // Create line element\n      //let lineElement: HTMLElement = this.getHTMLLineElement(getTextFormatter().format(this.html, output));\n\n\n      var lineElement = this.getHTMLLineElement(text);\n      fo.node.appendChild(lineElement); // Temporarily set to inline-block so we can measure real width and height\n\n      lineElement.style.display = \"inline-block\";\n      var clientWidth = lineElement.clientWidth;\n      var clientHeight = lineElement.clientHeight;\n      lineElement.style.display = \"block\";\n      this._bbox = {\n        x: 0,\n        y: 0,\n        width: clientWidth,\n        height: clientHeight\n      }; // Set exact dimensions of foreignObject so it is sized exactly as\n      // the content within (add one pixel to width so it does not wrap)\n\n      fo.attr({\n        width: clientWidth + 1,\n        height: clientHeight\n      }); // Check if maybe we need to hide the whole label if it doesn't fit\n\n      this.maybeHideOversized(); // Set measurements and update bbox\n\n      this._measuredWidth = $math.max(this.bbox.width, this.pixelWidth - this.pixelPaddingLeft - this.pixelPaddingRight);\n      this._measuredHeight = $math.max(this.bbox.height, this.pixelHeight - this.pixelPaddingTop - this.pixelPaddingBottom);\n      this.bbox.width = this._measuredWidth;\n      this.bbox.height = this._measuredHeight; // Don't let labels bleed out of the alotted area\n\n      if (this.truncate) {\n        lineElement.style.overflow = \"hidden\";\n      }\n\n      if (clientWidth > maxWidth || clientHeight > maxHeight) {\n        this.isOversized = true;\n      }\n    } // Set applicable styles\n\n\n    this.setStyles();\n    this.updateCenter();\n    this.updateBackground();\n\n    if (display == \"none\") {\n      this.group.attr({\n        display: \"none\"\n      });\n    }\n\n    if (this.pathElement) {\n      this.paper.appendDef(this.pathElement);\n    }\n  };\n  /**\r\n   * Hides element if it does not fit into available space\r\n   */\n\n\n  Label.prototype.maybeHideOversized = function () {\n    if (this.hideOversized) {\n      if (this.availableWidth < this.bbox.width || this.availableHeight < this.bbox.height) {\n        this.element.attr({\n          display: \"none\"\n        });\n        this.isOversized = true;\n      } else {\n        this.element.removeAttr(\"display\");\n        this.isOversized = false;\n      }\n    }\n  };\n  /**\r\n   * Aligns the lines horizontally and vertically, based on properties.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  Label.prototype.alignSVGText = function () {\n    // Get Group\n    var group = this.element;\n    var children = group.node.children || group.node.childNodes; // Is there anything to align?\n\n    if (!children || children && children.length == 0) {\n      return;\n    }\n\n    var width = this._measuredWidth;\n    var height = this._measuredHeight; // TODO maybe these aren't needed ?\n\n    $utils.used(this.pixelPaddingLeft);\n    $utils.used(this.pixelPaddingRight);\n    $utils.used(this.pixelPaddingTop);\n    $utils.used(this.pixelPaddingBottom);\n\n    if (this.rtl) {\n      group.attr({\n        \"direction\": \"rtl\"\n      });\n    } else {\n      group.removeAttr(\"direction\");\n    } // Process each line\n    //$iter.each(group.children.backwards().iterator(), (element) => {\n\n\n    for (var i = children.length - 1; i >= 0; i--) {\n      // Align horizontally\n      // Since we are using `text-anchor` for horizontal alignment, all we need\n      // to do here is move the `x` position\n      var node = children[i];\n      node.setAttribute(\"text-anchor\", this.textAlign);\n\n      if (this.textPathElement) {\n        node.removeAttribute(\"x\");\n        node.removeAttribute(\"y\");\n      } else {\n        switch (this.textAlign) {\n          case \"middle\":\n            node.setAttribute(\"x\", (width / 2).toString() + \"px\");\n            break;\n\n          case \"end\":\n            if (this.rtl) {} else {\n              node.setAttribute(\"x\", width.toString());\n            }\n\n            break;\n\n          default:\n            if (this.rtl) {\n              node.setAttribute(\"x\", width.toString());\n            } else {\n              node.removeAttribute(\"text-anchor\");\n            }\n\n            break;\n        }\n\n        var y = $type.toNumber(node.getAttribute(\"y\"));\n\n        switch (this.textValign) {\n          case \"middle\":\n            node.setAttribute(\"y\", ((y || 0) + (height - this.bbox.height) / 2).toString());\n            break;\n\n          case \"bottom\":\n            node.setAttribute(\"y\", ((y || 0) + height - this.bbox.height).toString());\n            break;\n\n          default:\n            node.setAttribute(\"y\", (y || 0).toString());\n            break;\n        }\n      }\n    }\n  };\n  /**\r\n   * Produces an SVG line element with formatted text.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param text    Text to wrap into line\r\n   * @param y       Current line vertical position\r\n   * @return A DOM element\r\n   * @todo Implement HTML support\r\n   */\n\n\n  Label.prototype.getSVGLineElement = function (text, y) {\n    // Create a <text> node and set text\n    var element = this.paper.addGroup(\"text\");\n    element.textContent = text; // Set parameters\n\n    element.attr({\n      \"x\": \"0\" //\"alignment-baseline\": \"hanging\",\n      //\"baseline-shift\": \"-20%\",\n      //\"text-anchor\": \"center\"\n\n    }); // Set `y` position\n\n    if ($type.hasValue(y)) {\n      element.attr({\n        \"y\": y.toString()\n      });\n    } // Don't let labels blled out of the alotted area\n\n\n    if (this.truncate || this.wrap) {\n      element.attr({\n        \"overflow\": \"hidden\"\n      });\n    } // Add RTL?\n    // This has now been moved to this.alignSVGText()\n    // if (this.rtl) {\n    // \telement.attr({\n    // \t\t\"direction\": \"rtl\",\n    // \t\t//\"unicode-bidi\": \"bidi-override\"\n    // \t});\n    // }\n\n\n    return element;\n  };\n\n  Object.defineProperty(Label.prototype, \"rtl\", {\n    /**\r\n     * @return RTL?\r\n     */\n    get: function get() {\n      if ($type.hasValue(this._rtl)) {\n        return this._rtl;\n      } else if (this._topParent) {\n        return this._topParent.rtl;\n      }\n\n      return false;\n    },\n\n    /**\r\n     * An RTL (right-to-left) setting.\r\n     *\r\n     * RTL may affect alignment, text, and other visual properties.\r\n     *\r\n     * If you set this on a top-level chart object, it will be used for all\r\n     * child elements, e.g. labels, unless they have their own `rtl` setting\r\n     * set directly on them.\r\n     *\r\n     * @param value  `true` for to use RTL\r\n     */\n    set: function set(value) {\n      value = $type.toBoolean(value);\n      this._rtl = value;\n\n      if (this.element) {\n        this.alignSVGText();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Resets cached BBox.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n  Label.prototype.resetBBox = function () {\n    this._bbox = {\n      x: 0,\n      y: 0,\n      width: 0,\n      height: 0\n    };\n  };\n  /**\r\n   * Creates and returns an HTML line element (`<div>`).\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param text  Text to add\r\n   * @return `<div>` element reference\r\n   */\n\n\n  Label.prototype.getHTMLLineElement = function (text) {\n    // Create the <div> element\n    var div = document.createElement(\"div\");\n    div.innerHTML = text; // Set text alignment\n\n    switch (this.textAlign) {\n      case \"middle\":\n        div.style.textAlign = \"center\";\n        break;\n\n      case \"end\":\n        div.style.textAlign = \"right\";\n        break;\n    } // Disable or enable wrapping\n\n\n    if (this.wrap) {\n      div.style.wordWrap = \"break-word\";\n    } else {\n      div.style.whiteSpace = \"nowrap\";\n    } // Don't let labels bleed out of the alotted area\n    // Moved to `draw()` because setting \"hidden\" kills all measuring\n\n    /*if (this.truncate) {\r\n        div.style.overflow = \"hidden\";\r\n    }*/\n    // Set RTL-related styles\n\n\n    if (this.rtl) {\n      div.style.direction = \"rtl\"; //div.style.unicodeBidi = \"bidi-override\";\n    } // Translate some of the SVG styles into CSS\n\n\n    if ($type.hasValue(this.fill)) {\n      div.style.color = this.fill.toString();\n    }\n\n    return div;\n  };\n  /**\r\n   * Applies specific styles to text to make it not selectable, unless it is\r\n   * explicitly set as `selectable`.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Set styles via AMElement\r\n   */\n\n\n  Label.prototype.setStyles = function () {\n    var group = this.element;\n\n    if (!this.selectable || this.draggable || this.resizable || this.swipeable) {\n      group.addStyle({\n        \"webkitUserSelect\": \"none\",\n        \"msUserSelect\": \"none\"\n      });\n    } else if (this.selectable) {\n      group.removeStyle(\"webkitUserSelect\");\n      group.removeStyle(\"msUserSelect\");\n    }\n  };\n  /**\r\n   * Hides unused lines\r\n   */\n\n\n  Label.prototype.hideUnused = function (index) {\n    this.initLineCache();\n    var lines = this.getCache(\"lineInfo\");\n\n    if (lines.length >= index) {\n      for (var i = index; i < lines.length; i++) {\n        var line = lines[i];\n\n        if (line && line.element) {\n          line.element.attr({\n            \"display\": \"none\"\n          });\n        }\n      }\n    }\n  };\n\n  Object.defineProperty(Label.prototype, \"text\", {\n    /**\r\n     * @return SVG text\r\n     */\n    get: function get() {\n      return this.getPropertyValue(\"text\");\n    },\n\n    /**\r\n     * An SVG text.\r\n     *\r\n     * Please note that setting `html` will override this setting if browser\r\n     * supports `foreignObject` in SGV, such as most modern browsers excluding\r\n     * IEs.\r\n     *\r\n     * @param value  SVG Text\r\n     */\n    set: function set(value) {\n      //this.setPropertyValue(\"html\", undefined);\n      this.setPropertyValue(\"text\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Label.prototype, \"path\", {\n    /**\r\n     * @return Path\r\n     */\n    get: function get() {\n      return this.getPropertyValue(\"path\");\n    },\n\n    /**\r\n     * An SVG path string to position text along. If set, the text will follow\r\n     * the curvature of the path.\r\n     *\r\n     * Location along the path can be set using `locationOnPath`.\r\n     *\r\n     * IMPORTANT: Only SVG text can be put on path. If you are using HTML text\r\n     * this setting will be ignored.\r\n     *\r\n     * @since 4.1.2\r\n     * @param  value  Path\r\n     */\n    set: function set(value) {\n      if (this.setPropertyValue(\"path\", value, true)) {\n        if (this.pathElement) {\n          this.pathElement.dispose();\n        }\n\n        if (this.textPathElement) {\n          this.textPathElement.dispose();\n        }\n\n        this.pathElement = this.paper.add(\"path\");\n        this.pathElement.attr({\n          \"d\": value\n        });\n        this.pathElement.attr({\n          \"id\": \"text-path-\" + this.uid\n        });\n\n        this._disposers.push(this.pathElement);\n\n        this.textPathElement = this.paper.addGroup(\"textPath\");\n        this.textPathElement.attrNS($dom.XLINK, \"xlink:href\", \"#text-path-\" + this.uid); // TODO remove after https://bugzilla.mozilla.org/show_bug.cgi?id=455986 is fixed\n\n        this.textPathElement.attr({\n          \"path\": value\n        });\n\n        this._disposers.push(this.textPathElement);\n\n        this.hardInvalidate();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Label.prototype, \"locationOnPath\", {\n    /**\r\n     * @return Relatvie location on path\r\n     */\n    get: function get() {\n      return this.getPropertyValue(\"locationOnPath\");\n    },\n\n    /**\r\n     * Relative label location on `path`. Value range is from 0 (beginning)\r\n     * to 1 (end).\r\n     *\r\n     * Works only if you set `path` setting to an SVG path.\r\n     *\r\n     * @since 4.1.2\r\n     * @default 0\r\n     * @param  value  Relatvie location on path\r\n     */\n    set: function set(value) {\n      this.setPropertyValue(\"locationOnPath\", value);\n\n      if (this.textPathElement) {\n        this.textPathElement.attr({\n          \"startOffset\": value * 100 + \"%\"\n        });\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Label.prototype, \"baseLineRatio\", {\n    /**\r\n     * @return Base line ratio\r\n     */\n    get: function get() {\n      return this.getPropertyValue(\"baseLineRatio\");\n    },\n\n    /**\r\n     * A ratio to calculate text baseline. Ralative distance from the bottom of\r\n     * the label.\r\n     *\r\n     * @since 4.4.2\r\n     * @default -0.27\r\n     * @param  value  Base line ratio\r\n     */\n    set: function set(value) {\n      this.setPropertyValue(\"baseLineRatio\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Label.prototype, \"wrap\", {\n    /**\r\n     * @return Auto-wrap enabled or not\r\n     */\n    get: function get() {\n      return this.getPropertyValue(\"wrap\");\n    },\n\n    /**\r\n     * Enables or disables autowrapping of text.\r\n     *\r\n     * @param value  Auto-wrapping enabled\r\n     */\n    set: function set(value) {\n      this.resetBBox();\n      this.setPropertyValue(\"wrap\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Label.prototype, \"truncate\", {\n    /**\r\n     * @return Truncate text?\r\n     */\n    get: function get() {\n      return this.getPropertyValue(\"truncate\");\n    },\n\n    /**\r\n     * Indicates if text lines need to be truncated if they do not fit, using\r\n     * configurable `ellipsis` string.\r\n     *\r\n     * `truncate` overrides `wrap` if both are set to `true`.\r\n     *\r\n     * NOTE: For HTML text, this setting **won't** trigger a parser and actual\r\n     * line truncation with ellipsis. It will just hide everything that goes\r\n     * outside the label.\r\n     *\r\n     * @param value  trincate text?\r\n     */\n    set: function set(value) {\n      this.resetBBox();\n      this.setPropertyValue(\"truncate\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Label.prototype, \"fullWords\", {\n    /**\r\n     * @return Truncate on full words?\r\n     */\n    get: function get() {\n      return this.getPropertyValue(\"fullWords\");\n    },\n\n    /**\r\n     * If `truncate` is enabled, should Label try to break only on full words\r\n     * (`true`), or whenever needed, including middle of the word. (`false`)\r\n     *\r\n     * @default true\r\n     * @param value  Truncate on full words?\r\n     */\n    set: function set(value) {\n      this.setPropertyValue(\"fullWords\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Label.prototype, \"ellipsis\", {\n    /**\r\n     * @return Ellipsis string\r\n     */\n    get: function get() {\n      return this.getPropertyValue(\"ellipsis\");\n    },\n\n    /**\r\n     * Ellipsis character to use if `truncate` is enabled.\r\n     *\r\n     * @param value Ellipsis string\r\n     * @default \"...\"\r\n     */\n    set: function set(value) {\n      this.setPropertyValue(\"ellipsis\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Label.prototype, \"selectable\", {\n    /**\r\n     * @return Text selectable?\r\n     */\n    get: function get() {\n      return this.getPropertyValue(\"selectable\");\n    },\n\n    /**\r\n     * Forces the text to be selectable. This setting will be ignored if the\r\n     * object has some kind of interaction attached to it, such as it is\r\n     * `draggable`, `swipeable`, `resizable`.\r\n     *\r\n     * @param value  Text selectable?\r\n     * @default false\r\n     */\n    set: function set(value) {\n      this.setPropertyValue(\"selectable\", value, true);\n      this.setStyles();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Label.prototype, \"textAlign\", {\n    /**\r\n     * @return Alignment\r\n     */\n    get: function get() {\n      return this.getPropertyValue(\"textAlign\");\n    },\n\n    /**\r\n     * Horizontal text alignment.\r\n     *\r\n     * Available choices:\r\n     * * \"start\"\r\n     * * \"middle\"\r\n     * * \"end\"\r\n     *\r\n     * @param value  Alignment\r\n     */\n    set: function set(value) {\n      this.setPropertyValue(\"textAlign\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Label.prototype, \"textValign\", {\n    /**\r\n     * @ignore Exclude from docs (not used)\r\n     * @return Alignment\r\n     * @deprecated\r\n     */\n    get: function get() {\n      return this.getPropertyValue(\"textValign\");\n    },\n\n    /**\r\n     * Vertical text alignment.\r\n     *\r\n     * @ignore Exclude from docs (not used)\r\n     * @param value  Alignment\r\n     * @deprecated\r\n     */\n    set: function set(value) {\n      this.setPropertyValue(\"textValign\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Label.prototype, \"html\", {\n    /**\r\n     * @return HTML content\r\n     */\n    get: function get() {\n      return this.getPropertyValue(\"html\");\n    },\n\n    /**\r\n     * Raw HTML to be used as text.\r\n     *\r\n     * NOTE: HTML text is subject to browser support. It relies on browsers\r\n     * supporting SVG `foreignObject` nodes. Some browsers (read IEs) do not\r\n     * support it. On those browsers, the text will fall back to basic SVG text,\r\n     * striping out all HTML markup and styling that goes with it.\r\n     *\r\n     * For more information about `foreignObject` and its browser compatibility\r\n     * refer to [this page](https://developer.mozilla.org/en/docs/Web/SVG/Element/foreignObject#Browser_compatibility).\r\n     *\r\n     * @param value HTML text\r\n     */\n    set: function set(value) {\n      this.setPropertyValue(\"html\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Label.prototype, \"hideOversized\", {\n    /**\r\n     * @return Hide if text does not fit?\r\n     */\n    get: function get() {\n      return this.getPropertyValue(\"hideOversized\");\n    },\n\n    /**\r\n     * Indicates whether the whole text should be hidden if it does not fit into\r\n     * its allotted space.\r\n     *\r\n     * @param value  Hide if text does not fit?\r\n     */\n    set: function set(value) {\n      this.setPropertyValue(\"hideOversized\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Label.prototype, \"ignoreFormatting\", {\n    /**\r\n     * @return Ignore formatting?\r\n     */\n    get: function get() {\n      return this.getPropertyValue(\"ignoreFormatting\");\n    },\n\n    /**\r\n     * If set to `true` square-bracket formatting blocks will be treated as\r\n     * regular text.\r\n     *\r\n     * @default false\r\n     * @param value  Ignore formatting?\r\n     */\n    set: function set(value) {\n      this.setPropertyValue(\"ignoreFormatting\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Override `mesaureElement` so it does not get measure again, because\r\n   * internal `_bbox` is being updated by measuring routines in Text itself.\r\n   */\n\n  Label.prototype.measureElement = function () {};\n  /**\r\n   * Returns information about a line element.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param index  Line index\r\n   * @return Line info object\r\n   */\n\n\n  Label.prototype.getLineInfo = function (index) {\n    this.initLineCache();\n    var lines = this.getCache(\"lineInfo\");\n    return lines.length > index ? lines[index] : undefined;\n  };\n  /**\r\n   * Adds a line to line info cache.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param line     Line info object\r\n   * @param index    Insert at specified index\r\n   */\n\n\n  Label.prototype.addLineInfo = function (line, index) {\n    this.initLineCache();\n    this.getCache(\"lineInfo\")[index] = line;\n  };\n  /**\r\n   * Checks if line cache is initialized and initializes it.\r\n   */\n\n\n  Label.prototype.initLineCache = function () {\n    if (!$type.hasValue(this.getCache(\"lineInfo\"))) {\n      this.setCache(\"lineInfo\", [], 0);\n    }\n  };\n  /**\r\n   * Sets a [[DataItem]] to use for populating dynamic sections of the text.\r\n   *\r\n   * Check the description for [[Text]] class, for data binding.\r\n   *\r\n   * @param dataItem Data item\r\n   */\n\n\n  Label.prototype.setDataItem = function (dataItem) {\n    if (this._sourceDataItemEvents) {\n      this._sourceDataItemEvents.dispose();\n    }\n\n    if (dataItem) {\n      this._sourceDataItemEvents = new MultiDisposer([dataItem.events.on(\"valuechanged\", this.invalidate, this, false), dataItem.events.on(\"workingvaluechanged\", this.invalidate, this, false), dataItem.events.on(\"calculatedvaluechanged\", this.invalidate, this, false), dataItem.events.on(\"propertychanged\", this.invalidate, this, false)]);\n    }\n\n    _super.prototype.setDataItem.call(this, dataItem);\n  };\n\n  Object.defineProperty(Label.prototype, \"availableWidth\", {\n    /**\r\n     * Returns available horizontal space.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @return Available width (px)\r\n     */\n    get: function get() {\n      return $type.hasValue(this.maxWidth) ? this.maxWidth : this.pixelWidth;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Label.prototype, \"availableHeight\", {\n    /**\r\n     * Returns available vertical space.\r\n     *\r\n     * @return Available height (px)\r\n     */\n    get: function get() {\n      return $type.hasValue(this.maxHeight) ? this.maxHeight : this.pixelHeight;\n    },\n    enumerable: true,\n    configurable: true\n  }); // temp, replacing textFormatter method\n\n  Label.prototype.getSvgElement = function (text, style, parent) {\n    var element = this.paper.add(\"tspan\");\n    element.textContent = text;\n\n    if (style) {\n      if (options.nonce && parent) {\n        //element.node.setAttribute(\"nonce\", \"test123\");\n        var classid = \"amcharts_element_style_\" + btoa(style).replace(/[^\\w]*/g, \"\");\n        element.node.setAttribute(\"class\", classid);\n        var defs = document.createElementNS($dom.SVGNS, \"defs\");\n        parent.node.appendChild(defs);\n        var e = document.createElement(\"style\");\n        e.type = \"text/css\";\n        e.innerHTML = \".\" + classid + \" { \" + style + \"}\";\n        e.setAttribute(\"nonce\", options.nonce);\n        defs.appendChild(e);\n      } else {\n        element.node.setAttribute(\"style\", style);\n      }\n    }\n\n    if (parent) {\n      parent.add(element);\n    }\n\n    return element;\n  };\n  /**\r\n   * Invalidates the whole element, including layout AND all its child\r\n   * elements.\r\n   */\n\n\n  Label.prototype.deepInvalidate = function () {\n    _super.prototype.deepInvalidate.call(this);\n\n    this.hardInvalidate();\n  };\n\n  Object.defineProperty(Label.prototype, \"readerTitle\", {\n    /**\r\n     * @return Title\r\n     */\n    get: function get() {\n      var title = this.getPropertyValue(\"readerTitle\");\n\n      if (!title) {\n        title = this.populateString($utils.plainText($utils.isNotEmpty(this.html) ? this.html : this.text));\n      } else if (this.dataItem) {\n        title = this.populateString(title);\n      }\n\n      return title;\n    },\n\n    /**\r\n     * Screen reader title of the element.\r\n     *\r\n     * @param value Title\r\n     */\n    set: function set(value) {\n      value = $type.toText(value);\n\n      if (this.setPropertyValue(\"readerTitle\", value)) {\n        this.applyAccessibility();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return Label;\n}(Container);\n\nexport { Label };\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\n\nregistry.registeredClasses[\"Label\"] = Label;\n/**\r\n * Add default responsive rules\r\n */\n\n/**\r\n * Hide labels added directly to chart, like titles if chart is short.\r\n */\n\ndefaultRules.push({\n  relevant: ResponsiveBreakpoints.heightXS,\n  state: function state(target, stateId) {\n    if (target instanceof Label && target.parent && target.parent.isBaseSprite) {\n      var state = target.states.create(stateId);\n      state.properties.disabled = true;\n      return state;\n    }\n\n    return null;\n  }\n});","map":{"version":3,"mappings":"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","names":["Container","registry","getTextFormatter","MultiDisposer","InterfaceColorSet","$math","$utils","$type","$dom","defaultRules","ResponsiveBreakpoints","options","__extends","_super","_this","className","fill","getFor","wrap","truncate","fullWords","ellipsis","textAlign","textValign","layout","baseLineRatio","_positionPrecision","events","on","inited","handleMaxSize","once","handleValidate","applyTheme","Label","afterDraw","call","validatePosition","paper","changed","setPaper","hardInvalidate","currentText","text","bbox","width","height","availableWidth","isOversized","availableHeight","invalidate","output","isNotEmpty","html","supportsForeignObject","isObject","toString","hasValue","populateString","dataItem","_adapterO","apply","_currentFormat","_prevStatus","lineInfo","element","node","parentNode","getBBox","draw","oldW","oldH","topParent","maxWidth","maxHeight","max","pixelPaddingLeft","pixelPaddingRight","pixelPaddingTop","pixelPaddingBottom","status","rtl","updateCurrentText","_measuredWidth","_measuredHeight","attr","display","lines","split","group","getAttr","removeAttr","textPathElement","removeChildren","resetBBox","currentHeight","currentFormat","i","length","line","tempElement","getSVGLineElement","add","getSvgElement","translateStyleShortcuts","offset","Math","ceil","removeElement","lineInfo_1","getLineInfo","textContent","chunks","chunk","ignoreFormatting","currentLineHeight","firstChunk","skipTextChunks","x","complex","type","style","getLineBBox","lineText","avgCharWidth","excessChars","min","addEllipsis","node_1","childNodes","e","node_2","floor","elementText","maxChars","removeChild","truncateWithEllipsis","node_3","lastNode","lastChild","splitLines","splitTextByCharCount","lineText_1","shift","trim","cleanUp","restOfLine","join","replace","c","splice","round","paddingBottom","ltrim","rtrim","addLineInfo","maybeHideOversized","measureFailed","pixelWidth","pixelHeight","alignSVGText","dispatch","hideUnused","fo","foreignObject","lineElement","getHTMLLineElement","appendChild","clientWidth","clientHeight","_bbox","y","overflow","setStyles","updateCenter","updateBackground","pathElement","appendDef","hideOversized","children","used","setAttribute","removeAttribute","toNumber","getAttribute","addGroup","Object","_rtl","_topParent","value","toBoolean","div","document","createElement","innerHTML","wordWrap","whiteSpace","direction","color","selectable","draggable","resizable","swipeable","addStyle","removeStyle","index","initLineCache","getCache","getPropertyValue","setPropertyValue","dispose","uid","_disposers","push","attrNS","XLINK","undefined","setCache","_sourceDataItemEvents","setDataItem","parent","nonce","classid","btoa","defs","createElementNS","SVGNS","deepInvalidate","title","plainText","toText","applyAccessibility","registeredClasses","relevant","heightXS","state","target","stateId","isBaseSprite","states","create","properties","disabled"],"sourceRoot":"","sources":["../../../../../src/.internal/core/elements/Label.ts"],"sourcesContent":["/**\r\n * Text class deals with all text placed on chart.\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { Container, IContainerProperties, IContainerAdapters, IContainerEvents } from \"../Container\";\r\nimport { DataItem } from \"../DataItem\";\r\nimport { TextValign } from \"../defs/TextValign\";\r\nimport { TextAlign } from \"../defs/TextAlign\";\r\nimport { IRectangle } from \"../defs/IRectangle\";\r\nimport { AMElement } from \"../rendering/AMElement\";\r\nimport { Group } from \"../rendering/Group\";\r\nimport { registry } from \"../Registry\";\r\nimport { ITextChunk, getTextFormatter } from \"../formatters/TextFormatter\";\r\nimport { MultiDisposer } from \"../utils/Disposer\";\r\nimport { InterfaceColorSet } from \"../../core/utils/InterfaceColorSet\";\r\nimport * as $math from \"../utils/Math\";\r\nimport * as $utils from \"../utils/Utils\";\r\nimport * as $type from \"../utils/Type\";\r\nimport { Paper } from \"../rendering/Paper\";\r\nimport * as $dom from \"../utils/DOM\";\r\nimport { defaultRules, ResponsiveBreakpoints } from \"../utils/Responsive\";\r\nimport { options } from \"../Options\";\r\n\r\n\r\n/**\r\n * Defines properties for [[Text]].\r\n */\r\nexport interface ILabelProperties extends IContainerProperties {\r\n\r\n\t/**\r\n\t * Horizontal align of the text.\r\n\t *\r\n\t * @default \"start\"\r\n\t */\r\n\ttextAlign?: TextAlign;\r\n\r\n\t/**\r\n\t * Vertical align of the text.\r\n\t *\r\n\t * @default \"top\"\r\n\t */\r\n\ttextValign?: TextValign;\r\n\r\n\t/**\r\n\t * A plain text content.\r\n\t */\r\n\ttext?: string;\r\n\r\n\t/**\r\n\t * Should the lines wrap if they do not fit into max width?\r\n\t *\r\n\t * @default false\r\n\t */\r\n\twrap?: boolean;\r\n\r\n\t/**\r\n\t * Should the text be selectable>\r\n\t *\r\n\t * @default false\r\n\t */\r\n\tselectable?: boolean;\r\n\r\n\t/**\r\n\t * HTML content.\r\n\t */\r\n\thtml?: string;\r\n\r\n\t/**\r\n\t * Should the lines be truncated (optionally with ellipsis) if they do not\r\n\t * fit into max width?\r\n\t *\r\n\t * @default false\r\n\t */\r\n\ttruncate?: boolean;\r\n\r\n\t/**\r\n\t * If `truncate` is enabled, should Label try to break only on full words\r\n\t * (`true`), or whenever needed, including middle of the word. (`false`)\r\n\t *\r\n\t * @default true\r\n\t */\r\n\tfullWords?: boolean;\r\n\r\n\t/**\r\n\t * If lines are truncated, this ellipsis will be added at the end.\r\n\t *\r\n\t * @default \"â€¦\"\r\n\t */\r\n\tellipsis?: string;\r\n\r\n\t/**\r\n\t * Hide text of it does not fit into element's dimensions?\r\n\t *\r\n\t * @default false\r\n\t */\r\n\thideOversized?: boolean;\r\n\r\n\t/**\r\n\t * If set to `true` square-bracket formatting blocks will be treated as\r\n\t * regular text.\r\n\t *\r\n\t * @default false\r\n\t */\r\n\tignoreFormatting?: boolean;\r\n\r\n\t/**\r\n\t * Path string along which text should be arranged\r\n\t */\r\n\tpath?: string\r\n\r\n\t/**\r\n\t * Relative label location on path.\r\n\t */\r\n\tlocationOnPath?: number;\r\n\r\n\t/**\r\n\t * A ratio to calculate text baseline. Ralative distance from the bottom of\r\n\t * the label.\r\n\t *\r\n\t * @default -0.27\r\n\t */\r\n\tbaseLineRatio?: number;\r\n}\r\n\r\n/**\r\n * Text line information.\r\n *\r\n * Objects used to hold cached information about lines in a Text element.\r\n */\r\nexport interface ITextLineInfo {\r\n\r\n\t/**\r\n\t * Measurements for the bounding box of the line.\r\n\t */\r\n\t\"bbox\"?: IRectangle,\r\n\r\n\t/**\r\n\t * A reference to an SVG `<g>` element that holds line elements.\r\n\t */\r\n\t\"element\"?: Group,\r\n\r\n\t/**\r\n\t * Indicates if line contains more than one element, e.g. has multiple\r\n\t * formatted blocks.\r\n\t */\r\n\t\"complex\"?: boolean,\r\n\r\n\t\"text\"?: string,\r\n\r\n\t\"style\"?: string\r\n};\r\n\r\n/**\r\n * Defines events for [[Text]].\r\n */\r\nexport interface ILabelEvents extends IContainerEvents { }\r\n\r\n/**\r\n * Adapters for [[Text]].\r\n *\r\n * Includes both the [[Adapter]] definitions and properties.\r\n *\r\n * @see {@link Adapter}\r\n */\r\nexport interface ILabelAdapters extends IContainerAdapters, ILabelProperties {\r\n\r\n\t/**\r\n\t * Applied to the final formatted label text.\r\n\t */\r\n\ttextOutput: string;\r\n\r\n\t/**\r\n\t * Applied to the final formatted label HTML.\r\n\t */\r\n\thtmlOutput: string;\r\n\r\n}\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Text is used to display highly configurable, data-enabled textual elements.\r\n *\r\n * ## Data Binding\r\n *\r\n * A Text element can dynamically parse and populate its contents with values\r\n * from a [[DataItem]].\r\n *\r\n * To activate such binding, set element's `dataItem` property.\r\n *\r\n * When activated, text contents will be parsed for special tags, e.g.:\r\n *\r\n * ```TypeScript\r\n * label.dataItem = myDataItem;\r\n * label.text = \"The title is: {title}\";\r\n * ```\r\n * ```JavaScript\r\n * label.dataItem = myDataItem;\r\n * label.text = \"The title is: {title}\";\r\n * ```\r\n *\r\n * The above will automatically replace \"{title}\" in the string with the\r\n * actual data value from `myDataItem`.\r\n *\r\n * Note, that most often dataItem is set by the Component.\r\n *\r\n *\r\n * @see {@link ILabelEvents} for a list of available events\r\n * @see {@link ILabelAdapters} for a list of available Adapters\r\n * @see {@link https://www.amcharts.com/docs/v4/concepts/formatters/formatting-strings/} for info on string formatting and data binding\r\n * @todo Vertical align\r\n * @important\r\n */\r\nexport class Label extends Container {\r\n\t/**\r\n\t * Defines available properties.\r\n\t */\r\n\tpublic _properties!: ILabelProperties;\r\n\r\n\t/**\r\n\t * Defines Adapter type.\r\n\t */\r\n\tpublic _adapter!: ILabelAdapters;\r\n\r\n\t/**\r\n\t * Defines available events.\r\n\t */\r\n\tpublic _events!: ILabelEvents;\r\n\r\n\t/**\r\n\t * Indicates if the whole text does not fit into max dimenstions set for it.\r\n\t */\r\n\tpublic isOversized: boolean = false;\r\n\r\n\t/**\r\n\t * Currently formatted text, read only.\r\n\t */\r\n\tpublic currentText: string;\r\n\r\n\t/**\r\n\t * Current format to be used for outputing text.\r\n\t */\r\n\tprotected _currentFormat: string;\r\n\r\n\t/**\r\n\t * [_sourceDataItemEvents description]\r\n\t *\r\n\t * @todo Description\r\n\t */\r\n\tprotected _sourceDataItemEvents: MultiDisposer;\r\n\r\n\r\n\tprotected _prevStatus: string;\r\n\r\n\t/**\r\n\t * SVG path element.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic pathElement: $type.Optional<AMElement>;\r\n\r\n\t/**\r\n\t * SVG textpath element.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic textPathElement: $type.Optional<Group>;\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor() {\r\n\r\n\t\t// Execute super's constructor\r\n\t\tsuper();\r\n\r\n\t\t// Set this class name\r\n\t\tthis.className = \"Label\";\r\n\r\n\t\tthis.fill = new InterfaceColorSet().getFor(\"text\");\r\n\r\n\t\t// not good to set this, as then these will appear on each label and values set on container won't be applied.\r\n\t\t//this.textDecoration = \"none\";\r\n\t\t//this.fontWeight = \"normal\";\r\n\r\n\r\n\t\t// Set defaults\r\n\t\tthis.wrap = false;\r\n\t\tthis.truncate = false;\r\n\t\tthis.fullWords = true;\r\n\t\tthis.ellipsis = \"â€¦\";\r\n\t\tthis.textAlign = \"start\";\r\n\t\tthis.textValign = \"top\";\r\n\r\n\t\tthis.layout = \"absolute\";\r\n\t\tthis.baseLineRatio = -0.27;\r\n\t\t//this.pixelPerfect = true;\r\n\t\tthis._positionPrecision = 1;\r\n\r\n\t\t// Add events to watch for maxWidth/maxHeight changes so that we can\r\n\t\t// invalidate this\r\n\t\tthis.events.on(\"maxsizechanged\", () => {\r\n\t\t\tif (this.inited) {\r\n\t\t\t\tthis.handleMaxSize()\r\n\t\t\t}\r\n\t\t}, this, false);\r\n\r\n\t\t// this solves strange bug when text just added to svg is 0x0\r\n\t\tthis.events.once(\"validated\", this.handleValidate, this, false);\r\n\r\n\t\t// Aply theme\r\n\t\tthis.applyTheme();\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * A placeholder method that is called **after** element finishes drawing\r\n\t * itself.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tprotected afterDraw(): void {\r\n\t\t// since we removed validatePosition from sprite, we still need it here to handle rotated text\r\n\t\tsuper.afterDraw();\r\n\t\tthis.validatePosition();\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Sets [[Paper]] instance to use to draw elements.\r\n\t * @ignore\r\n\t * @param paper Paper\r\n\t * @return true if paper was changed, false, if it's the same\r\n\t */\r\n\tpublic setPaper(paper: Paper): boolean {\r\n\r\n\t\tlet changed = super.setPaper(paper);\r\n\r\n\t\tif (changed) {\r\n\t\t\tthis.hardInvalidate();\r\n\t\t}\r\n\t\treturn changed;\r\n\t}\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tprotected handleValidate() {\r\n\t\tif ((this.currentText || this.text) && (this.bbox.width == 0 || this.bbox.height == 0)) {\r\n\t\t\tregistry.events.once(\"exitframe\", this.hardInvalidate, this);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tprotected handleMaxSize() {\r\n\t\tif (\r\n\t\t\t(this.bbox.width > this.availableWidth)\r\n\t\t\t|| ((this.bbox.width < this.availableWidth) && (this.isOversized || this.truncate))\r\n\t\t\t|| (this.bbox.height > this.availableHeight)\r\n\t\t\t|| ((this.bbox.height < this.availableHeight) && this.isOversized)\r\n\t\t) {\r\n\t\t\tthis.invalidate();\r\n\t\t}\r\n\t\telse {\r\n\t\t\t//this.alignSVGText();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * [arrange description]\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description\r\n\t */\r\n\tpublic arrange(): void {\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Updates current text according to data item and supported features.\r\n\t * Returns `true` if current text has changed.\r\n\t *\r\n\t * @return Text changed?\r\n\t */\r\n\tprotected updateCurrentText(): boolean {\r\n\t\t// Determine output format\r\n\t\tlet output: string, text: string;\r\n\r\n\t\tif ($utils.isNotEmpty(this.html) && this.paper.supportsForeignObject()) {\r\n\r\n\t\t\t// We favor HTML text if it's set and browser supports `foreignObject`\r\n\t\t\toutput = \"html\";\r\n\t\t\ttext = this.html;\r\n\t\t}\r\n\t\telse {\r\n\t\t\toutput = \"svg\";\r\n\t\t\ttext = this.text;\r\n\t\t}\r\n\r\n\t\t// Need to toString source?\r\n\t\tif ($type.isObject(text as any)) {\r\n\t\t\ttext = text.toString();\r\n\t\t}\r\n\r\n\t\t// Need to format text all the time\r\n\t\tif ($type.hasValue(text) && text !== \"\") {\r\n\t\t\ttext = this.populateString(text, this.dataItem);\r\n\t\t}\r\n\r\n\t\tif (output == \"html\") {\r\n\t\t\tif (this._adapterO) {\r\n\t\t\t\ttext = this._adapterO.apply(\"htmlOutput\", text);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\tif (this._adapterO) {\r\n\t\t\t\ttext = this._adapterO.apply(\"textOutput\", text);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Update the text\r\n\t\tlet changed = text != this.currentText || output != this._currentFormat;\r\n\t\tthis.currentText = text;\r\n\t\tthis._currentFormat = output;\r\n\r\n\t\treturn changed;\r\n\t}\r\n\r\n\t/**\r\n\t * Hard invalidate means the text will be redrawn even if it hasn't changed.\r\n\t * This is used when we change `fontSize`, `fontFamily`, or for some other\r\n\t * reasons.\r\n\t */\r\n\tpublic hardInvalidate() {\r\n\t\tthis._prevStatus = \"\";\r\n\t\tthis.invalidate();\r\n\t}\r\n\r\n\t/**\r\n\t * Gets line bbox, uses caching to save cpu\r\n\t * @ignore\r\n\t */\r\n\tprotected getLineBBox(lineInfo: ITextLineInfo) {\r\n\t\t//let cacheKey = lineInfo.text + lineInfo.style;\r\n\r\n\t\t//let lineBBox = this.getCache(cacheKey);\r\n\t\t//if (!lineBBox) {\r\n\t\t//lineBBox = lineInfo.element.getBBox();\r\n\t\t//if (lineBBox.width != 0 && lineBBox.height != 0) {\r\n\t\t//\tthis.setCache(cacheKey, lineBBox, 5000);\r\n\t\t//}\r\n\t\t//}\r\n\r\n\t\tlet element = lineInfo && lineInfo.element;\r\n\t\tlet node = element && element.node;\r\n\r\n\t\t// Check for the parent Node to avoid FF from throwing errors\r\n\t\tif (node && node.parentNode) {\r\n\t\t\tlineInfo.bbox = element.getBBox();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Draws the textual label.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic draw(): void {\r\n\r\n\t\t// Draw super\r\n\t\tsuper.draw();\r\n\r\n\t\tlet oldW = this.bbox.width;\r\n\t\tlet oldH = this.bbox.height;\r\n\r\n\t\tlet topParent = this.topParent;\r\n\t\tif (topParent) {\r\n\t\t\tif (!topParent.maxWidth || !topParent.maxHeight) {\r\n\t\t\t\ttopParent.events.once(\"maxsizechanged\", this.hardInvalidate, this, false);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Calculate max width and height\r\n\t\tlet maxWidth: number = $math.max(this.availableWidth - this.pixelPaddingLeft - this.pixelPaddingRight, 0);\r\n\t\tlet maxHeight: number = $math.max(this.availableHeight - this.pixelPaddingTop - this.pixelPaddingBottom, 0);\r\n\r\n\t\t// save\r\n\t\tlet status = maxHeight + \",\" + maxWidth + this.wrap + this.truncate + this.fullWords + this.rtl + this.ellipsis;\r\n\r\n\t\t// Update text\r\n\t\tif (!this.updateCurrentText() && this.inited && this._prevStatus == status) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tthis._measuredWidth = 0;\r\n\t\tthis._measuredHeight = 0;\r\n\r\n\t\t// Reset\r\n\t\tthis.isOversized = false;\r\n\r\n\t\t// Determine output format\r\n\t\tlet output = this._currentFormat;\r\n\t\tlet text = this.currentText;\r\n\r\n\t\t// Empty string\r\n\t\tif (!$type.hasValue(text) || text == \"\") {\r\n\t\t\tthis.element.attr({ display: \"none\" });\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// Chop up text into lines\r\n\t\t// We're still processing SVG and HTML in the same way for now\r\n\t\tlet lines: string[] = text.split(\"\\n\");\r\n\r\n\t\t// Do we need to go through the trouble of measuring lines\r\n\t\t//let measure: boolean = true;// (lines.length > 1) || this.wrap;\r\n\r\n\t\tthis._prevStatus = status;\r\n\r\n\t\tthis.textAlign = this.textAlign;\r\n\r\n\t\t// need this to measure\r\n\t\tlet display = this.group.getAttr(\"display\");\r\n\t\tif (display == \"none\") {\r\n\t\t\tthis.group.removeAttr(\"display\");\r\n\t\t}\r\n\r\n\t\tif (this.textPathElement) {\r\n\t\t\tthis.textPathElement.removeChildren();\r\n\t\t}\r\n\r\n\t\t// SVG or HTML?\r\n\t\tif (output === \"svg\") {\r\n\t\t\t/**\r\n\t\t\t * SVG\r\n\t\t\t */\r\n\r\n\t\t\tthis.element.removeAttr(\"display\");\r\n\r\n\t\t\t// Clear the element\r\n\t\t\tlet group: Group = <Group>this.element;\r\n\r\n\t\t\tthis.resetBBox();\r\n\r\n\t\t\t// Init state variables\r\n\t\t\tlet currentHeight: number = 0;\r\n\t\t\tlet currentFormat: string = \"\";\r\n\r\n\t\t\t// Process each line\r\n\t\t\tfor (let i = 0; i < lines.length; i++) {\r\n\r\n\t\t\t\t// Get line\r\n\t\t\t\tlet line: string = lines[i];\r\n\r\n\t\t\t\t// Check if line is empty\r\n\t\t\t\tif (line == \"\") {\r\n\t\t\t\t\t// It is, let's just update currentHeight and go to the next one\r\n\t\t\t\t\t// If it's the first line, we'll have to use arbirary line height,\r\n\t\t\t\t\t// since there's nothing to measure. For subsequent lines we can take\r\n\t\t\t\t\t// previous line's height\r\n\t\t\t\t\tlet tempElement = this.getSVGLineElement(\"\", 0);\r\n\t\t\t\t\ttempElement.add(\r\n\t\t\t\t\t\tthis.getSvgElement(\r\n\t\t\t\t\t\t\t\".\",\r\n\t\t\t\t\t\t\tgetTextFormatter().translateStyleShortcuts(currentFormat)\r\n\t\t\t\t\t\t)\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t\tgroup.add(tempElement);\r\n\t\t\t\t\tlet offset = Math.ceil(tempElement.getBBox().height);\r\n\t\t\t\t\tif (offset > 0) {\r\n\t\t\t\t\t\tcurrentHeight += offset;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tgroup.removeElement(tempElement);\r\n\r\n\t\t\t\t\t// Clear cache if necessary\r\n\t\t\t\t\tlet lineInfo = this.getLineInfo(i);\r\n\t\t\t\t\tif (lineInfo) {\r\n\t\t\t\t\t\tlineInfo.text = \"\";\r\n\t\t\t\t\t\tlineInfo.element.textContent = \"\";\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Chunk up the line and process each chunk\r\n\t\t\t\tlet chunks: ITextChunk[] = getTextFormatter().chunk(line, null, this.ignoreFormatting);\r\n\t\t\t\tlet currentLineHeight: number = 0;\r\n\t\t\t\tlet firstChunk: boolean = true;\r\n\t\t\t\tlet skipTextChunks: boolean = false;\r\n\r\n\t\t\t\t// Create line element or grab it from cache\r\n\t\t\t\tlet lineInfo = this.getLineInfo(i);\r\n\r\n\t\t\t\tif (lineInfo) {\r\n\t\t\t\t\t// Empty line\r\n\t\t\t\t\tlineInfo.text = \"\";\r\n\t\t\t\t\tlineInfo.element.textContent = \"\";\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\t// Init new line info\r\n\t\t\t\t\tlineInfo = {\r\n\t\t\t\t\t\t\"text\": \"\",\r\n\t\t\t\t\t\t\"element\": this.getSVGLineElement(\"\", 0),\r\n\t\t\t\t\t\t\"complex\": false\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\t// Create the line element\r\n\t\t\t\t\t//lineInfo.element = this.getSVGLineElement(\"\", 0);\r\n\t\t\t\t\t//lineElement = this.getSVGLineElement(\"\", 0);\r\n\t\t\t\t\tgroup.add(lineInfo.element);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlineInfo.element.removeAttr(\"display\");\r\n\t\t\t\tlineInfo.element.removeChildren(); // memory leak without this\r\n\r\n\t\t\t\tif (this.textPathElement) {\r\n\t\t\t\t\tlineInfo.element.add(this.textPathElement);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t/*// @todo not needed anymore\r\n\t\t\t\tif (this.rtl) {\r\n\t\t\t\t\tchunks.reverse();\r\n\t\t\t\t}*/\r\n\r\n\t\t\t\t// Process each chunk\r\n\t\t\t\tfor (let x: number = 0; x < chunks.length; x++) {\r\n\r\n\t\t\t\t\t// If there's more than one chunk, means the line is \"complex\"\r\n\t\t\t\t\tif (x) {\r\n\t\t\t\t\t\tlineInfo.complex = true;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Get chunk\r\n\t\t\t\t\tlet chunk = chunks[x];\r\n\r\n\t\t\t\t\t// Is this chunk format or text?\r\n\t\t\t\t\tif (chunk.type === \"format\") {\r\n\r\n\t\t\t\t\t\t// Log current format, so that we can apply it to multiple lines if\r\n\t\t\t\t\t\t// necessary\r\n\t\t\t\t\t\tcurrentFormat = chunk.text;\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\r\n\t\t\t\t\t\t// It's text block\r\n\r\n\t\t\t\t\t\t// Need to skip?\r\n\t\t\t\t\t\t// We do this when truncating. We can't just simply go ahead and\r\n\t\t\t\t\t\t// abandon chunk processing as they might have formatting\r\n\t\t\t\t\t\t// instructions in them that are relevant for subsequent lines\r\n\t\t\t\t\t\tif (skipTextChunks) {\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// Add chunk to the current element\r\n\t\t\t\t\t\t//lineInfo.element.content += $utils.trim(getTextFormatter().format(currentFormat + chunk.text, output));\r\n\r\n\t\t\t\t\t\tlineInfo.text = chunk.text;\r\n\t\t\t\t\t\tlineInfo.style = getTextFormatter().translateStyleShortcuts(currentFormat);\r\n\r\n\r\n\t\t\t\t\t\tif (this.textPathElement) {\r\n\t\t\t\t\t\t\tthis.getSvgElement(lineInfo.text, lineInfo.style, this.textPathElement);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\tthis.getSvgElement(lineInfo.text, lineInfo.style, lineInfo.element);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tthis.getLineBBox(lineInfo);\r\n\t\t\t\t\t\tlineInfo.bbox.width = Math.ceil(lineInfo.bbox.width);\r\n\r\n\t\t\t\t\t\t// Updated current line height\r\n\t\t\t\t\t\tif (currentLineHeight < lineInfo.bbox.height) {\r\n\t\t\t\t\t\t\tcurrentLineHeight = lineInfo.bbox.height;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// Wrapping?\r\n\t\t\t\t\t\tif ((this.wrap || this.truncate) && (lineInfo.bbox.width > maxWidth)) {\r\n\r\n\t\t\t\t\t\t\t// Set oversized\r\n\t\t\t\t\t\t\tthis.isOversized = true;\r\n\r\n\t\t\t\t\t\t\t// Take temporary measurements\r\n\t\t\t\t\t\t\tlet lineText: string = lineInfo.element.textContent;\r\n\t\t\t\t\t\t\tlet avgCharWidth: number = (lineInfo.bbox.width / lineText.length); // * .9;\r\n\r\n\t\t\t\t\t\t\t// Calculate average number of symbols / width\r\n\t\t\t\t\t\t\tlet excessChars: number = $math.min(Math.ceil((lineInfo.bbox.width - maxWidth) / avgCharWidth), lineText.length);\r\n\r\n\t\t\t\t\t\t\t// Are we truncating or auto-wrapping text?\r\n\t\t\t\t\t\t\tif (this.truncate) {\r\n\r\n\t\t\t\t\t\t\t\t/**\r\n\t\t\t\t\t\t\t\t * Processing line truncation\r\n\t\t\t\t\t\t\t\t * With the addition of each text chunk we measure if current\r\n\t\t\t\t\t\t\t\t * line does not exceed maxWidth. If it does, we will stop\r\n\t\t\t\t\t\t\t\t * addition of further chunks as well as try to truncate\r\n\t\t\t\t\t\t\t\t * current or any number of previous chunks with an added\r\n\t\t\t\t\t\t\t\t * ellipsis\r\n\t\t\t\t\t\t\t\t */\r\n\r\n\t\t\t\t\t\t\t\t// Indicator whether we need to add ellipsis to the current\r\n\t\t\t\t\t\t\t\t// element, even if it fits. This is needed to indicate\r\n\t\t\t\t\t\t\t\t// whether we have already removed some subsequent chunks in\r\n\t\t\t\t\t\t\t\t// which case we need to add ellipsis.\r\n\t\t\t\t\t\t\t\tlet addEllipsis: boolean = false;\r\n\r\n\t\t\t\t\t\t\t\t// Process each child in the temporary line, until the whole\r\n\t\t\t\t\t\t\t\t// line fits, preferably with an ellipsis\r\n\t\t\t\t\t\t\t\t// TODO use iterator instead\r\n\t\t\t\t\t\t\t\tlet node = lineInfo.element.node;\r\n\t\t\t\t\t\t\t\tif (node && node.childNodes) {\r\n\t\t\t\t\t\t\t\t\tfor (let e = lineInfo.element.node.childNodes.length - 1; e >= 0; e--) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t// Get current element\r\n\t\t\t\t\t\t\t\t\t\tlet node = lineInfo.element.node.childNodes[e];\r\n\r\n\r\n\t\t\t\t\t\t\t\t\t\t// Add ellipsis only if previous chunk was removed in full\r\n\t\t\t\t\t\t\t\t\t\t// and this chunk already fits\r\n\t\t\t\t\t\t\t\t\t\t//if (addEllipsis && (bbox.width <= maxWidth)) {\r\n\t\t\t\t\t\t\t\t\t\tif (addEllipsis && (lineInfo.bbox.width <= maxWidth)) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t// Add ellipsis\r\n\t\t\t\t\t\t\t\t\t\t\tnode.textContent += \" \" + this.ellipsis;\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t// Measure again (we need to make sure ellipsis fits)\r\n\t\t\t\t\t\t\t\t\t\t\tlineInfo.bbox = lineInfo.element.getBBox();\r\n\t\t\t\t\t\t\t\t\t\t\tlineInfo.bbox.width = Math.floor(lineInfo.bbox.width);\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t// If it fits, we're done here\r\n\t\t\t\t\t\t\t\t\t\t\t// If it doesn't we continue rolling\r\n\t\t\t\t\t\t\t\t\t\t\tif (lineInfo.bbox.width <= maxWidth) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\taddEllipsis = false;\r\n\r\n\t\t\t\t\t\t\t\t\t\t// Get element text\r\n\t\t\t\t\t\t\t\t\t\tlet elementText = node.textContent;\r\n\r\n\t\t\t\t\t\t\t\t\t\t// Calculate average number of symbols / width\r\n\t\t\t\t\t\t\t\t\t\tlineText = lineInfo.element.textContent;\r\n\t\t\t\t\t\t\t\t\t\texcessChars = $math.min(Math.ceil((lineInfo.bbox.width - maxWidth) / avgCharWidth), lineText.length);\r\n\r\n\t\t\t\t\t\t\t\t\t\t// Do this until we fit\r\n\t\t\t\t\t\t\t\t\t\twhile ((lineInfo.bbox.width > maxWidth) && (excessChars <= lineText.length) && (excessChars > 0)) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t// Calculate max available chars\r\n\t\t\t\t\t\t\t\t\t\t\tlet maxChars: number = $math.max(lineText.length - excessChars - this.ellipsis.length, 1);\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t// Is there anything left?\r\n\t\t\t\t\t\t\t\t\t\t\tif (maxChars <= 1) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\t// Nope, let's jump to the previous item\r\n\t\t\t\t\t\t\t\t\t\t\t\t// Set excess characters to zero so that this loop does\r\n\t\t\t\t\t\t\t\t\t\t\t\t// not repeat when it over\r\n\t\t\t\t\t\t\t\t\t\t\t\texcessChars = 0;\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\t// Add ellipsis to previous item\r\n\t\t\t\t\t\t\t\t\t\t\t\t// Subsequent iterations will check if the ellipsis fits\r\n\t\t\t\t\t\t\t\t\t\t\t\tif (e > 0) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t// Indicating to add ellipsis to previous item\r\n\t\t\t\t\t\t\t\t\t\t\t\t\taddEllipsis = true;\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t// Removing this node\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tlineInfo.element.node.removeChild(node);\r\n\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t// Truncate the text\r\n\t\t\t\t\t\t\t\t\t\t\telementText = $utils.truncateWithEllipsis(elementText, maxChars, this.ellipsis, this.fullWords, this.rtl);\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tif ((elementText.length > maxChars) && this.fullWords) {\r\n\t\t\t\t\t\t\t\t\t\t\t\t// Still too long?\r\n\t\t\t\t\t\t\t\t\t\t\t\t// Let's try truncating breaking words anyway\r\n\t\t\t\t\t\t\t\t\t\t\t\telementText = $utils.truncateWithEllipsis(elementText, maxChars, this.ellipsis, false, this.rtl);\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t// Set truncated text\r\n\t\t\t\t\t\t\t\t\t\t\tnode.textContent = elementText;\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t// Measure again\r\n\t\t\t\t\t\t\t\t\t\t\tlineInfo.bbox = lineInfo.element.getBBox();\r\n\t\t\t\t\t\t\t\t\t\t\tlineInfo.bbox.width = Math.floor(lineInfo.bbox.width);\r\n\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t// Increase excess characters count, just in case it still\r\n\t\t\t\t\t\t\t\t\t\t\t// doesn't fit and we have to go at it again\r\n\t\t\t\t\t\t\t\t\t\t\texcessChars = Math.ceil(excessChars * 1.1);\r\n\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t// Do not process further chunks\r\n\t\t\t\t\t\t\t\t\t\tskipTextChunks = true;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse {\r\n\r\n\t\t\t\t\t\t\t\t/**\r\n\t\t\t\t\t\t\t\t * Processign auto-wrap\r\n\t\t\t\t\t\t\t\t * In this case we're going to be adding text chunks until\r\n\t\t\t\t\t\t\t\t * they don't fit into current line. Once that happens we will\r\n\t\t\t\t\t\t\t\t * inject the rest of the chunks to the next line\r\n\t\t\t\t\t\t\t\t */\r\n\t\t\t\t\t\t\t\t// Get last node added and measure it\r\n\t\t\t\t\t\t\t\tlet node = lineInfo.element.node;\r\n\t\t\t\t\t\t\t\tif (node) {\r\n\t\t\t\t\t\t\t\t\tlet lastNode = lineInfo.element.node.lastChild;\r\n\r\n\t\t\t\t\t\t\t\t\t// Init split lines\r\n\t\t\t\t\t\t\t\t\tlet splitLines: string[];\r\n\t\t\t\t\t\t\t\t\twhile ((lineInfo.bbox.width > maxWidth) && (excessChars <= lineText.length) && (excessChars > 0)) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t// Calculate max available chars\r\n\t\t\t\t\t\t\t\t\t\tlet maxChars: number = $math.max(chunk.text.length - excessChars, 1);\r\n\r\n\t\t\t\t\t\t\t\t\t\t// Don't split the words mid-word if it's not the first chunk\r\n\t\t\t\t\t\t\t\t\t\t// in the line\r\n\t\t\t\t\t\t\t\t\t\tif (firstChunk) {\r\n\t\t\t\t\t\t\t\t\t\t\t// Split mid-word if necessary\r\n\t\t\t\t\t\t\t\t\t\t\tsplitLines = $utils.splitTextByCharCount(chunk.text, maxChars, true, this.rtl);\r\n\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\telse {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t// Don't split mid-word\r\n\t\t\t\t\t\t\t\t\t\t\tsplitLines = $utils.splitTextByCharCount(chunk.text, maxChars, true, this.rtl, false);\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t// Check if the first word is too long\r\n\t\t\t\t\t\t\t\t\t\t\tif ((splitLines[0].length > maxChars) || maxChars === 1) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\t// Yes - move the whole chunk to the next line\r\n\t\t\t\t\t\t\t\t\t\t\t\t// Remove the element we just added\r\n\t\t\t\t\t\t\t\t\t\t\t\tlineInfo.element.node.removeChild(lastNode)\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\t// Break out of the while on next cycle\r\n\t\t\t\t\t\t\t\t\t\t\t\texcessChars = 0;\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t// Use the first line to update last item\r\n\t\t\t\t\t\t\t\t\t\tif (excessChars > 0) {\r\n\t\t\t\t\t\t\t\t\t\t\tlet lineText = splitLines.shift();\r\n\t\t\t\t\t\t\t\t\t\t\tif (firstChunk) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tlineText = $utils.trim(lineText);\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\tlastNode.textContent = getTextFormatter().cleanUp(lineText);\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t// Measure again, just in case\r\n\t\t\t\t\t\t\t\t\t\tlineInfo.bbox = lineInfo.element.getBBox();\r\n\t\t\t\t\t\t\t\t\t\tlineInfo.bbox.width = Math.floor(lineInfo.bbox.width);\r\n\r\n\t\t\t\t\t\t\t\t\t\t// Increase excess characters count, just in case it still\r\n\t\t\t\t\t\t\t\t\t\t// doesn't fit and we have to go at it again\r\n\t\t\t\t\t\t\t\t\t\t//excessChars = Math.ceil(excessChars * 1.05);\r\n\t\t\t\t\t\t\t\t\t\texcessChars++;\r\n\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\r\n\t\t\t\t\t\t\t\t\t// Construct the rest of the line\r\n\t\t\t\t\t\t\t\t\tif (splitLines.length > 0) {\r\n\r\n\t\t\t\t\t\t\t\t\t\tlet restOfLine: string = \"\";\r\n\t\t\t\t\t\t\t\t\t\t// Add leftovers from splitting the current chunk\r\n\t\t\t\t\t\t\t\t\t\tif ($type.hasValue(splitLines)) {\r\n\t\t\t\t\t\t\t\t\t\t\tif (this.rtl) {\r\n\t\t\t\t\t\t\t\t\t\t\t\trestOfLine += splitLines.join(\"\") + currentFormat;\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\t\t\t\t\trestOfLine += currentFormat + splitLines.join(\"\").replace(/([\\[\\]]{1})/g, \"$1$1\");\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t// Add the rest of the chunks\r\n\t\t\t\t\t\t\t\t\t\tfor (let c: number = x + 1; c < chunks.length; c++) {\r\n\t\t\t\t\t\t\t\t\t\t\tif (chunks[c].type == \"value\") {\r\n\t\t\t\t\t\t\t\t\t\t\t\t// We're escaping single square brackets that were\r\n\t\t\t\t\t\t\t\t\t\t\t\t// cleaned up by chunk() back to double square brackets\r\n\t\t\t\t\t\t\t\t\t\t\t\t// so that they are not being treated as format on\r\n\t\t\t\t\t\t\t\t\t\t\t\t// next pass.\r\n\t\t\t\t\t\t\t\t\t\t\t\trestOfLine += chunks[c].text.replace(/([\\[\\]]{1})/g, \"$1$1\");\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\t\t\t\t\trestOfLine += chunks[c].text;\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t// Inject the rest of the lines as chunks for subsequent\r\n\r\n\t\t\t\t\t\t\t\t\t\tlines.splice(i + 1, 0, restOfLine);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t// Skip processing the rest of the chunks\r\n\t\t\t\t\t\t\t\t\tskipTextChunks = true;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t// Let's update the text's bbox with the line's one\r\n\t\t\t\t\t\tif (this.bbox.width < lineInfo.bbox.width) {\r\n\t\t\t\t\t\t\tthis.bbox.width = lineInfo.bbox.width;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// commented to avoid bug (seen on sankey link) where text is incorrectly aligned\r\n\t\t\t\t\t\t//if (this.bbox.x > lineInfo.bbox.x) {\r\n\t\t\t\t\t\t//this.bbox.x = lineInfo.bbox.x;\r\n\t\t\t\t\t\t//}\r\n\r\n\t\t\t\t\t\tthis.bbox.height = currentHeight + currentLineHeight;\r\n\r\n\t\t\t\t\t\t// Position current line\r\n\t\t\t\t\t\tif (!this.textPathElement) {\r\n\t\t\t\t\t\t\tlineInfo.element.attr({\r\n\t\t\t\t\t\t\t\t\"x\": \"0\",\r\n\t\t\t\t\t\t\t\t\"y\": currentHeight + currentLineHeight,\r\n\t\t\t\t\t\t\t\t\"dy\": $math.round((this.baseLineRatio * currentLineHeight), 3).toString()\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\tlineInfo.element.attr({\r\n\t\t\t\t\t\t\t\t\"dy\": -this.paddingBottom.toString()\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tfirstChunk = false;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Trim the last item\r\n\t\t\t\tlet node = lineInfo.element.node;\r\n\t\t\t\tif (node) {\r\n\t\t\t\t\tlet lastNode = node.lastChild;\r\n\t\t\t\t\tif (lastNode) {\r\n\t\t\t\t\t\tlastNode.textContent = this.rtl ?\r\n\t\t\t\t\t\t\t$utils.ltrim(lastNode.textContent) :\r\n\t\t\t\t\t\t\t$utils.rtrim(lastNode.textContent);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Increment collective height\r\n\t\t\t\tcurrentHeight += currentLineHeight;\r\n\r\n\t\t\t\t// Save line cache\r\n\t\t\t\tthis.addLineInfo(lineInfo, i);\r\n\t\t\t}\r\n\r\n\t\t\t// Check if maybe we need to hide the whole label if it doesn't fit\r\n\t\t\tthis.maybeHideOversized();\r\n\r\n\t\t\tthis.measureFailed = false;\r\n\t\t\tif (this.bbox.width == 0 || this.bbox.height == 0) {\r\n\t\t\t\tthis.measureFailed = true;\r\n\t\t\t}\r\n\r\n\t\t\t// Updated measured dims\r\n\t\t\tthis._measuredWidth = $math.round($math.max(this.bbox.width, this.pixelWidth - this.pixelPaddingLeft - this.pixelPaddingRight));\r\n\t\t\tthis._measuredHeight = $math.round($math.max(this.bbox.height, this.pixelHeight - this.pixelPaddingTop - this.pixelPaddingBottom));\r\n\r\n\t\t\t// Align the lines\r\n\t\t\tthis.alignSVGText();\r\n\r\n\t\t\tthis.bbox.width = this._measuredWidth;\r\n\t\t\tthis.bbox.height = this._measuredHeight;\r\n\r\n\t\t\tif (oldH != this._measuredHeight || oldW != this._measuredWidth) {\r\n\t\t\t\tthis.dispatch(\"transformed\");\r\n\t\t\t}\r\n\r\n\t\t\tthis.hideUnused(lines.length);\r\n\t\t}\r\n\t\telse {\r\n\r\n\t\t\t/**\r\n\t\t\t * HTML\r\n\t\t\t */\r\n\r\n\t\t\tthis.element.removeAttr(\"display\");\r\n\t\t\tthis.resetBBox();\r\n\r\n\t\t\t// Clear the element\r\n\t\t\tlet group: Group = <Group>this.element;\r\n\t\t\tgroup.removeChildren();\r\n\r\n\t\t\t// Create a ForeignObject to use as HTML container\r\n\t\t\tlet fo = this.paper.foreignObject();\r\n\t\t\tgroup.add(fo);\r\n\r\n\t\t\t// Set widths on foreignObject so that autosizing measurements work\r\n\t\t\t// This will bet reset to actual content width/height\r\n\t\t\tif (this.maxWidth) {\r\n\t\t\t\tfo.attr({\r\n\t\t\t\t\twidth: this.maxWidth - this.pixelPaddingLeft - this.pixelPaddingRight\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t\tif (this.maxHeight) {\r\n\t\t\t\tfo.attr({\r\n\t\t\t\t\theight: this.maxHeight - this.pixelPaddingTop - this.pixelPaddingBottom\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\t// Create line element\r\n\t\t\t//let lineElement: HTMLElement = this.getHTMLLineElement(getTextFormatter().format(this.html, output));\r\n\t\t\tlet lineElement: HTMLElement = this.getHTMLLineElement(text);\r\n\t\t\tfo.node.appendChild(lineElement);\r\n\r\n\t\t\t// Temporarily set to inline-block so we can measure real width and height\r\n\t\t\tlineElement.style.display = \"inline-block\";\r\n\t\t\tconst clientWidth = lineElement.clientWidth;\r\n\t\t\tconst clientHeight = lineElement.clientHeight;\r\n\r\n\t\t\tlineElement.style.display = \"block\";\r\n\t\t\tthis._bbox = {\r\n\t\t\t\tx: 0,\r\n\t\t\t\ty: 0,\r\n\t\t\t\twidth: clientWidth,\r\n\t\t\t\theight: clientHeight\r\n\t\t\t};\r\n\r\n\t\t\t// Set exact dimensions of foreignObject so it is sized exactly as\r\n\t\t\t// the content within (add one pixel to width so it does not wrap)\r\n\t\t\tfo.attr({\r\n\t\t\t\twidth: clientWidth + 1,\r\n\t\t\t\theight: clientHeight\r\n\t\t\t});\r\n\r\n\t\t\t// Check if maybe we need to hide the whole label if it doesn't fit\r\n\t\t\tthis.maybeHideOversized();\r\n\r\n\t\t\t// Set measurements and update bbox\r\n\t\t\tthis._measuredWidth = $math.max(this.bbox.width, this.pixelWidth - this.pixelPaddingLeft - this.pixelPaddingRight);\r\n\t\t\tthis._measuredHeight = $math.max(this.bbox.height, this.pixelHeight - this.pixelPaddingTop - this.pixelPaddingBottom);\r\n\r\n\t\t\tthis.bbox.width = this._measuredWidth;\r\n\t\t\tthis.bbox.height = this._measuredHeight;\r\n\r\n\t\t\t// Don't let labels bleed out of the alotted area\r\n\t\t\tif (this.truncate) {\r\n\t\t\t\tlineElement.style.overflow = \"hidden\";\r\n\t\t\t}\r\n\r\n\t\t\tif ((clientWidth > maxWidth) || (clientHeight > maxHeight)) {\r\n\t\t\t\tthis.isOversized = true;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\r\n\t\t// Set applicable styles\r\n\t\tthis.setStyles();\r\n\t\tthis.updateCenter();\r\n\t\tthis.updateBackground();\r\n\r\n\t\tif (display == \"none\") {\r\n\t\t\tthis.group.attr({ display: \"none\" });\r\n\t\t}\r\n\r\n\t\tif (this.pathElement) {\r\n\t\t\tthis.paper.appendDef(this.pathElement);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Hides element if it does not fit into available space\r\n\t */\r\n\tprivate maybeHideOversized(): void {\r\n\t\tif (this.hideOversized) {\r\n\t\t\tif ((this.availableWidth < this.bbox.width) || (this.availableHeight < this.bbox.height)) {\r\n\t\t\t\tthis.element.attr({ display: \"none\" });\r\n\t\t\t\tthis.isOversized = true;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tthis.element.removeAttr(\"display\");\r\n\t\t\t\tthis.isOversized = false;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Aligns the lines horizontally and vertically, based on properties.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic alignSVGText(): void {\r\n\t\t// Get Group\r\n\t\tlet group: Group = <Group>this.element;\r\n\t\tlet children = group.node.children || group.node.childNodes;\r\n\r\n\t\t// Is there anything to align?\r\n\t\tif (!children || (children && children.length == 0)) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tlet width = this._measuredWidth;\r\n\t\tlet height = this._measuredHeight;\r\n\r\n\t\t// TODO maybe these aren't needed ?\r\n\t\t$utils.used(this.pixelPaddingLeft);\r\n\t\t$utils.used(this.pixelPaddingRight);\r\n\t\t$utils.used(this.pixelPaddingTop);\r\n\t\t$utils.used(this.pixelPaddingBottom);\r\n\r\n\t\tif (this.rtl) {\r\n\t\t\tgroup.attr({\r\n\t\t\t\t\"direction\": \"rtl\"\r\n\t\t\t});\r\n\t\t}\r\n\t\telse {\r\n\t\t\tgroup.removeAttr(\"direction\");\r\n\t\t}\r\n\r\n\t\t// Process each line\r\n\t\t//$iter.each(group.children.backwards().iterator(), (element) => {\r\n\t\tfor (let i = children.length - 1; i >= 0; i--) {\r\n\t\t\t// Align horizontally\r\n\t\t\t// Since we are using `text-anchor` for horizontal alignment, all we need\r\n\t\t\t// to do here is move the `x` position\r\n\t\t\tlet node = <SVGElement>children[i];\r\n\r\n\t\t\tnode.setAttribute(\"text-anchor\", this.textAlign);\r\n\r\n\t\t\tif (this.textPathElement) {\r\n\t\t\t\tnode.removeAttribute(\"x\");\r\n\t\t\t\tnode.removeAttribute(\"y\");\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tswitch (this.textAlign) {\r\n\t\t\t\t\tcase \"middle\":\r\n\t\t\t\t\t\tnode.setAttribute(\"x\", (width / 2).toString() + \"px\");\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase \"end\":\r\n\t\t\t\t\t\tif (this.rtl) {\r\n\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\tnode.setAttribute(\"x\", width.toString());\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\tif (this.rtl) {\r\n\t\t\t\t\t\t\tnode.setAttribute(\"x\", width.toString());\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\tnode.removeAttribute(\"text-anchor\");\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet y = $type.toNumber(node.getAttribute(\"y\"));\r\n\r\n\t\t\t\tswitch (this.textValign) {\r\n\t\t\t\t\tcase \"middle\":\r\n\t\t\t\t\t\tnode.setAttribute(\"y\", ((y || 0) + (height - this.bbox.height) / 2).toString());\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase \"bottom\":\r\n\t\t\t\t\t\tnode.setAttribute(\"y\", ((y || 0) + height - this.bbox.height).toString());\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\tnode.setAttribute(\"y\", (y || 0).toString());\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Produces an SVG line element with formatted text.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param text    Text to wrap into line\r\n\t * @param y       Current line vertical position\r\n\t * @return A DOM element\r\n\t * @todo Implement HTML support\r\n\t */\r\n\tpublic getSVGLineElement(text: string, y?: number): Group {\r\n\r\n\t\t// Create a <text> node and set text\r\n\t\tlet element: Group = this.paper.addGroup(\"text\");\r\n\t\telement.textContent = text;\r\n\r\n\t\t// Set parameters\r\n\t\telement.attr({\r\n\t\t\t\"x\": \"0\"\r\n\t\t\t//\"alignment-baseline\": \"hanging\",\r\n\t\t\t//\"baseline-shift\": \"-20%\",\r\n\t\t\t//\"text-anchor\": \"center\"\r\n\t\t});\r\n\r\n\t\t// Set `y` position\r\n\t\tif ($type.hasValue(y)) {\r\n\t\t\telement.attr({\r\n\t\t\t\t\"y\": y.toString()\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\t// Don't let labels blled out of the alotted area\r\n\t\tif (this.truncate || this.wrap) {\r\n\t\t\telement.attr({ \"overflow\": \"hidden\" });\r\n\t\t}\r\n\r\n\t\t// Add RTL?\r\n\t\t// This has now been moved to this.alignSVGText()\r\n\t\t// if (this.rtl) {\r\n\t\t// \telement.attr({\r\n\t\t// \t\t\"direction\": \"rtl\",\r\n\t\t// \t\t//\"unicode-bidi\": \"bidi-override\"\r\n\t\t// \t});\r\n\t\t// }\r\n\r\n\t\treturn element;\r\n\t}\r\n\r\n\t/**\r\n\t * An RTL (right-to-left) setting.\r\n\t *\r\n\t * RTL may affect alignment, text, and other visual properties.\r\n\t *\r\n\t * If you set this on a top-level chart object, it will be used for all\r\n\t * child elements, e.g. labels, unless they have their own `rtl` setting\r\n\t * set directly on them.\r\n\t *\r\n\t * @param value  `true` for to use RTL\r\n\t */\r\n\tpublic set rtl(value: boolean) {\r\n\t\tvalue = $type.toBoolean(value);\r\n\t\tthis._rtl = value;\r\n\t\tif (this.element) {\r\n\t\t\tthis.alignSVGText();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @return RTL?\r\n\t */\r\n\tpublic get rtl(): boolean {\r\n\t\tif ($type.hasValue(this._rtl)) {\r\n\t\t\treturn this._rtl;\r\n\t\t}\r\n\t\telse if (this._topParent) {\r\n\t\t\treturn this._topParent.rtl;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/**\r\n\t * Resets cached BBox.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic resetBBox(): void {\r\n\t\tthis._bbox = { x: 0, y: 0, width: 0, height: 0 };\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Creates and returns an HTML line element (`<div>`).\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param text  Text to add\r\n\t * @return `<div>` element reference\r\n\t */\r\n\tpublic getHTMLLineElement(text: string): HTMLElement {\r\n\r\n\t\t// Create the <div> element\r\n\t\tlet div: HTMLElement = document.createElement(\"div\");\r\n\t\tdiv.innerHTML = text;\r\n\r\n\t\t// Set text alignment\r\n\t\tswitch (this.textAlign) {\r\n\t\t\tcase \"middle\":\r\n\t\t\t\tdiv.style.textAlign = \"center\";\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"end\":\r\n\t\t\t\tdiv.style.textAlign = \"right\";\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\t// Disable or enable wrapping\r\n\t\tif (this.wrap) {\r\n\t\t\tdiv.style.wordWrap = \"break-word\";\r\n\t\t}\r\n\t\telse {\r\n\t\t\tdiv.style.whiteSpace = \"nowrap\";\r\n\t\t}\r\n\r\n\t\t// Don't let labels bleed out of the alotted area\r\n\t\t// Moved to `draw()` because setting \"hidden\" kills all measuring\r\n\t\t/*if (this.truncate) {\r\n\t\t\tdiv.style.overflow = \"hidden\";\r\n\t\t}*/\r\n\r\n\t\t// Set RTL-related styles\r\n\t\tif (this.rtl) {\r\n\t\t\tdiv.style.direction = \"rtl\";\r\n\t\t\t//div.style.unicodeBidi = \"bidi-override\";\r\n\t\t}\r\n\r\n\t\t// Translate some of the SVG styles into CSS\r\n\t\tif ($type.hasValue(this.fill)) {\r\n\t\t\tdiv.style.color = this.fill.toString();\r\n\t\t}\r\n\r\n\t\treturn div;\r\n\t}\r\n\r\n\t/**\r\n\t * Applies specific styles to text to make it not selectable, unless it is\r\n\t * explicitly set as `selectable`.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Set styles via AMElement\r\n\t */\r\n\tpublic setStyles(): void {\r\n\t\tlet group: Group = <Group>this.element;\r\n\t\tif (!this.selectable || this.draggable || this.resizable || this.swipeable) {\r\n\t\t\tgroup.addStyle({\r\n\t\t\t\t\"webkitUserSelect\": \"none\",\r\n\t\t\t\t\"msUserSelect\": \"none\"\r\n\t\t\t});\r\n\t\t}\r\n\t\telse if (this.selectable) {\r\n\t\t\tgroup.removeStyle(\"webkitUserSelect\");\r\n\t\t\tgroup.removeStyle(\"msUserSelect\");\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Hides unused lines\r\n\t */\r\n\tprotected hideUnused(index: number) {\r\n\t\tthis.initLineCache();\r\n\t\tlet lines: ITextLineInfo[] = this.getCache(\"lineInfo\");\r\n\t\tif (lines.length >= index) {\r\n\t\t\tfor (let i = index; i < lines.length; i++) {\r\n\t\t\t\tlet line = lines[i];\r\n\t\t\t\tif (line && line.element) {\r\n\t\t\t\t\tline.element.attr({ \"display\": \"none\" });\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * An SVG text.\r\n\t *\r\n\t * Please note that setting `html` will override this setting if browser\r\n\t * supports `foreignObject` in SGV, such as most modern browsers excluding\r\n\t * IEs.\r\n\t *\r\n\t * @param value  SVG Text\r\n\t */\r\n\tpublic set text(value: string) {\r\n\t\t//this.setPropertyValue(\"html\", undefined);\r\n\t\tthis.setPropertyValue(\"text\", value, true);\r\n\t}\r\n\r\n\t/**\r\n\t * @return SVG text\r\n\t */\r\n\tpublic get text(): string {\r\n\t\treturn this.getPropertyValue(\"text\");\r\n\t}\r\n\r\n\t/**\r\n\t * An SVG path string to position text along. If set, the text will follow\r\n\t * the curvature of the path.\r\n\t *\r\n\t * Location along the path can be set using `locationOnPath`.\r\n\t *\r\n\t * IMPORTANT: Only SVG text can be put on path. If you are using HTML text\r\n\t * this setting will be ignored.\r\n\t *\r\n\t * @since 4.1.2\r\n\t * @param  value  Path\r\n\t */\r\n\tpublic set path(value: string) {\r\n\t\tif (this.setPropertyValue(\"path\", value, true)) {\r\n\t\t\tif (this.pathElement) {\r\n\t\t\t\tthis.pathElement.dispose();\r\n\t\t\t}\r\n\r\n\t\t\tif (this.textPathElement) {\r\n\t\t\t\tthis.textPathElement.dispose();\r\n\t\t\t}\r\n\r\n\t\t\tthis.pathElement = this.paper.add(\"path\");\r\n\t\t\tthis.pathElement.attr({ \"d\": value });\r\n\t\t\tthis.pathElement.attr({ \"id\": \"text-path-\" + this.uid });\r\n\t\t\tthis._disposers.push(this.pathElement);\r\n\r\n\t\t\tthis.textPathElement = this.paper.addGroup(\"textPath\");\r\n\t\t\tthis.textPathElement.attrNS($dom.XLINK, \"xlink:href\", \"#text-path-\" + this.uid);\r\n\t\t\t// TODO remove after https://bugzilla.mozilla.org/show_bug.cgi?id=455986 is fixed\r\n\t\t\tthis.textPathElement.attr({ \"path\": value });\r\n\t\t\tthis._disposers.push(this.textPathElement);\r\n\t\t\tthis.hardInvalidate();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @return Path\r\n\t */\r\n\tpublic get path(): string {\r\n\t\treturn this.getPropertyValue(\"path\");\r\n\t}\r\n\r\n\t/**\r\n\t * Relative label location on `path`. Value range is from 0 (beginning)\r\n\t * to 1 (end).\r\n\t *\r\n\t * Works only if you set `path` setting to an SVG path.\r\n\t *\r\n\t * @since 4.1.2\r\n\t * @default 0\r\n\t * @param  value  Relatvie location on path\r\n\t */\r\n\tpublic set locationOnPath(value: number) {\r\n\t\tthis.setPropertyValue(\"locationOnPath\", value);\r\n\t\tif (this.textPathElement) {\r\n\t\t\tthis.textPathElement.attr({ \"startOffset\": (value * 100) + \"%\" })\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @return Relatvie location on path\r\n\t */\r\n\tpublic get locationOnPath(): number {\r\n\t\treturn this.getPropertyValue(\"locationOnPath\");\r\n\t}\r\n\r\n\t/**\r\n\t * A ratio to calculate text baseline. Ralative distance from the bottom of\r\n\t * the label.\r\n\t *\r\n\t * @since 4.4.2\r\n\t * @default -0.27\r\n\t * @param  value  Base line ratio\r\n\t */\r\n\tpublic set baseLineRatio(value: number) {\r\n\t\tthis.setPropertyValue(\"baseLineRatio\", value);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Base line ratio\r\n\t */\r\n\tpublic get baseLineRatio(): number {\r\n\t\treturn this.getPropertyValue(\"baseLineRatio\");\r\n\t}\r\n\r\n\t/**\r\n\t * Enables or disables autowrapping of text.\r\n\t *\r\n\t * @param value  Auto-wrapping enabled\r\n\t */\r\n\tpublic set wrap(value: boolean) {\r\n\t\tthis.resetBBox();\r\n\t\tthis.setPropertyValue(\"wrap\", value, true);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Auto-wrap enabled or not\r\n\t */\r\n\tpublic get wrap(): boolean {\r\n\t\treturn this.getPropertyValue(\"wrap\");\r\n\t}\r\n\r\n\t/**\r\n\t * Indicates if text lines need to be truncated if they do not fit, using\r\n\t * configurable `ellipsis` string.\r\n\t *\r\n\t * `truncate` overrides `wrap` if both are set to `true`.\r\n\t *\r\n\t * NOTE: For HTML text, this setting **won't** trigger a parser and actual\r\n\t * line truncation with ellipsis. It will just hide everything that goes\r\n\t * outside the label.\r\n\t *\r\n\t * @param value  trincate text?\r\n\t */\r\n\tpublic set truncate(value: boolean) {\r\n\t\tthis.resetBBox();\r\n\t\tthis.setPropertyValue(\"truncate\", value, true);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Truncate text?\r\n\t */\r\n\tpublic get truncate(): boolean {\r\n\t\treturn this.getPropertyValue(\"truncate\");\r\n\t}\r\n\r\n\t/**\r\n\t * If `truncate` is enabled, should Label try to break only on full words\r\n\t * (`true`), or whenever needed, including middle of the word. (`false`)\r\n\t *\r\n\t * @default true\r\n\t * @param value  Truncate on full words?\r\n\t */\r\n\tpublic set fullWords(value: boolean) {\r\n\t\tthis.setPropertyValue(\"fullWords\", value, true);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Truncate on full words?\r\n\t */\r\n\tpublic get fullWords(): boolean {\r\n\t\treturn this.getPropertyValue(\"fullWords\");\r\n\t}\r\n\r\n\t/**\r\n\t * Ellipsis character to use if `truncate` is enabled.\r\n\t *\r\n\t * @param value Ellipsis string\r\n\t * @default \"...\"\r\n\t */\r\n\tpublic set ellipsis(value: string) {\r\n\t\tthis.setPropertyValue(\"ellipsis\", value, true);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Ellipsis string\r\n\t */\r\n\tpublic get ellipsis(): string {\r\n\t\treturn this.getPropertyValue(\"ellipsis\");\r\n\t}\r\n\r\n\t/**\r\n\t * Forces the text to be selectable. This setting will be ignored if the\r\n\t * object has some kind of interaction attached to it, such as it is\r\n\t * `draggable`, `swipeable`, `resizable`.\r\n\t *\r\n\t * @param value  Text selectable?\r\n\t * @default false\r\n\t */\r\n\tpublic set selectable(value: boolean) {\r\n\t\tthis.setPropertyValue(\"selectable\", value, true);\r\n\t\tthis.setStyles();\r\n\t}\r\n\r\n\t/**\r\n\t * @return Text selectable?\r\n\t */\r\n\tpublic get selectable(): boolean {\r\n\t\treturn this.getPropertyValue(\"selectable\");\r\n\t}\r\n\r\n\t/**\r\n\t * Horizontal text alignment.\r\n\t *\r\n\t * Available choices:\r\n\t * * \"start\"\r\n\t * * \"middle\"\r\n\t * * \"end\"\r\n\t *\r\n\t * @param value  Alignment\r\n\t */\r\n\tpublic set textAlign(value: TextAlign) {\r\n\t\tthis.setPropertyValue(\"textAlign\", value, true);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Alignment\r\n\t */\r\n\tpublic get textAlign(): TextAlign {\r\n\t\treturn this.getPropertyValue(\"textAlign\");\r\n\t}\r\n\r\n\t/**\r\n\t * Vertical text alignment.\r\n\t *\r\n\t * @ignore Exclude from docs (not used)\r\n\t * @param value  Alignment\r\n\t * @deprecated\r\n\t */\r\n\tpublic set textValign(value: TextValign) {\r\n\t\tthis.setPropertyValue(\"textValign\", value, true);\r\n\t}\r\n\r\n\t/**\r\n\t * @ignore Exclude from docs (not used)\r\n\t * @return Alignment\r\n\t * @deprecated\r\n\t */\r\n\tpublic get textValign(): TextValign {\r\n\t\treturn this.getPropertyValue(\"textValign\");\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Raw HTML to be used as text.\r\n\t *\r\n\t * NOTE: HTML text is subject to browser support. It relies on browsers\r\n\t * supporting SVG `foreignObject` nodes. Some browsers (read IEs) do not\r\n\t * support it. On those browsers, the text will fall back to basic SVG text,\r\n\t * striping out all HTML markup and styling that goes with it.\r\n\t *\r\n\t * For more information about `foreignObject` and its browser compatibility\r\n\t * refer to [this page](https://developer.mozilla.org/en/docs/Web/SVG/Element/foreignObject#Browser_compatibility).\r\n\t *\r\n\t * @param value HTML text\r\n\t */\r\n\tpublic set html(value: string) {\r\n\t\tthis.setPropertyValue(\"html\", value, true);\r\n\t}\r\n\r\n\t/**\r\n\t * @return HTML content\r\n\t */\r\n\tpublic get html(): string {\r\n\t\treturn this.getPropertyValue(\"html\");\r\n\t}\r\n\r\n\t/**\r\n\t * Indicates whether the whole text should be hidden if it does not fit into\r\n\t * its allotted space.\r\n\t *\r\n\t * @param value  Hide if text does not fit?\r\n\t */\r\n\tpublic set hideOversized(value: boolean) {\r\n\t\tthis.setPropertyValue(\"hideOversized\", value, true);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Hide if text does not fit?\r\n\t */\r\n\tpublic get hideOversized(): boolean {\r\n\t\treturn this.getPropertyValue(\"hideOversized\");\r\n\t}\r\n\r\n\t/**\r\n\t * If set to `true` square-bracket formatting blocks will be treated as\r\n\t * regular text.\r\n\t *\r\n\t * @default false\r\n\t * @param value  Ignore formatting?\r\n\t */\r\n\tpublic set ignoreFormatting(value: boolean) {\r\n\t\tthis.setPropertyValue(\"ignoreFormatting\", value, true);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Ignore formatting?\r\n\t */\r\n\tpublic get ignoreFormatting(): boolean {\r\n\t\treturn this.getPropertyValue(\"ignoreFormatting\");\r\n\t}\r\n\r\n\t/**\r\n\t * Override `mesaureElement` so it does not get measure again, because\r\n\t * internal `_bbox` is being updated by measuring routines in Text itself.\r\n\t */\r\n\tpublic measureElement(): void { }\r\n\r\n\t/**\r\n\t * Returns information about a line element.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param index  Line index\r\n\t * @return Line info object\r\n\t */\r\n\tpublic getLineInfo(index: number): ITextLineInfo {\r\n\t\tthis.initLineCache();\r\n\t\tlet lines = this.getCache(\"lineInfo\");\r\n\t\treturn lines.length > index ? lines[index] : undefined;\r\n\t}\r\n\r\n\t/**\r\n\t * Adds a line to line info cache.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param line     Line info object\r\n\t * @param index    Insert at specified index\r\n\t */\r\n\tpublic addLineInfo(line: ITextLineInfo, index: number): void {\r\n\t\tthis.initLineCache();\r\n\t\tthis.getCache(\"lineInfo\")[index] = line;\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if line cache is initialized and initializes it.\r\n\t */\r\n\tprivate initLineCache(): void {\r\n\t\tif (!$type.hasValue(this.getCache(\"lineInfo\"))) {\r\n\t\t\tthis.setCache(\"lineInfo\", [], 0);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Sets a [[DataItem]] to use for populating dynamic sections of the text.\r\n\t *\r\n\t * Check the description for [[Text]] class, for data binding.\r\n\t *\r\n\t * @param dataItem Data item\r\n\t */\r\n\tpublic setDataItem(dataItem: DataItem): void {\r\n\t\tif (this._sourceDataItemEvents) {\r\n\t\t\tthis._sourceDataItemEvents.dispose();\r\n\t\t}\r\n\t\tif (dataItem) {\r\n\t\t\tthis._sourceDataItemEvents = new MultiDisposer([\r\n\t\t\t\tdataItem.events.on(\"valuechanged\", this.invalidate, this, false),\r\n\t\t\t\tdataItem.events.on(\"workingvaluechanged\", this.invalidate, this, false),\r\n\t\t\t\tdataItem.events.on(\"calculatedvaluechanged\", this.invalidate, this, false),\r\n\t\t\t\tdataItem.events.on(\"propertychanged\", this.invalidate, this, false)\r\n\t\t\t]);\r\n\t\t}\r\n\t\tsuper.setDataItem(dataItem);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns available horizontal space.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @return Available width (px)\r\n\t */\r\n\tpublic get availableWidth(): number {\r\n\t\treturn $type.hasValue(this.maxWidth) ? this.maxWidth : this.pixelWidth;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns available vertical space.\r\n\t *\r\n\t * @return Available height (px)\r\n\t */\r\n\tpublic get availableHeight(): number {\r\n\t\treturn $type.hasValue(this.maxHeight) ? this.maxHeight : this.pixelHeight;\r\n\t}\r\n\r\n\t// temp, replacing textFormatter method\r\n\tpublic getSvgElement(text: string, style?: string, parent?: Group): AMElement {\r\n\t\tlet element = this.paper.add(\"tspan\");\r\n\t\telement.textContent = text;\r\n\t\tif (style) {\r\n\r\n\t\t\tif (options.nonce && parent) {\r\n\t\t\t\t//element.node.setAttribute(\"nonce\", \"test123\");\r\n\t\t\t\tconst classid = \"amcharts_element_style_\" + btoa(style).replace(/[^\\w]*/g, \"\");\r\n\t\t\t\telement.node.setAttribute(\"class\", classid);\r\n\r\n\t\t\t\tconst defs = <SVGDefsElement>document.createElementNS($dom.SVGNS, \"defs\");\r\n\t\t\t\tparent.node.appendChild(defs);\r\n\r\n\t\t\t\tconst e = document.createElement(\"style\");\r\n\t\t\t\te.type = \"text/css\";\r\n\t\t\t\te.innerHTML = \".\" + classid + \" { \" + style + \"}\";\r\n\t\t\t\te.setAttribute(\"nonce\", options.nonce)\r\n\t\t\t\tdefs.appendChild(e);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\telement.node.setAttribute(\"style\", style);\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif (parent) {\r\n\t\t\tparent.add(element);\r\n\t\t}\r\n\r\n\t\treturn element;\r\n\t}\r\n\r\n\t/**\r\n\t * Invalidates the whole element, including layout AND all its child\r\n\t * elements.\r\n\t */\r\n\tpublic deepInvalidate() {\r\n\t\tsuper.deepInvalidate();\r\n\t\tthis.hardInvalidate();\r\n\t}\r\n\r\n\t/**\r\n\t * Screen reader title of the element.\r\n\t *\r\n\t * @param value Title\r\n\t */\r\n\tpublic set readerTitle(value: string) {\r\n\t\tvalue = $type.toText(value);\r\n\t\tif (this.setPropertyValue(\"readerTitle\", value)) {\r\n\t\t\tthis.applyAccessibility();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @return Title\r\n\t */\r\n\tpublic get readerTitle(): string {\r\n\t\tlet title = this.getPropertyValue(\"readerTitle\");\r\n\t\tif (!title) {\r\n\t\t\ttitle = this.populateString(\r\n\t\t\t\t$utils.plainText(\r\n\t\t\t\t\t$utils.isNotEmpty(this.html)\r\n\t\t\t\t\t\t? this.html\r\n\t\t\t\t\t\t: this.text\r\n\t\t\t\t)\r\n\t\t\t);\r\n\t\t}\r\n\t\telse if (this.dataItem) {\r\n\t\t\ttitle = this.populateString(title);\r\n\t\t}\r\n\t\treturn title;\r\n\t}\r\n}\r\n\r\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\r\nregistry.registeredClasses[\"Label\"] = Label;\r\n\r\n/**\r\n * Add default responsive rules\r\n */\r\n\r\n/**\r\n * Hide labels added directly to chart, like titles if chart is short.\r\n */\r\ndefaultRules.push({\r\n\trelevant: ResponsiveBreakpoints.heightXS,\r\n\tstate: function(target, stateId) {\r\n\t\tif (target instanceof Label && target.parent && target.parent.isBaseSprite) {\r\n\t\t\tlet state = target.states.create(stateId);\r\n\t\t\tstate.properties.disabled = true;\r\n\t\t\treturn state;\r\n\t\t}\r\n\r\n\t\treturn null;\r\n\t}\r\n});\r\n"]},"metadata":{},"sourceType":"module"}