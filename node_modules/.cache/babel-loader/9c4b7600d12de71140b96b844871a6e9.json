{"ast":null,"code":"/**\r\n * ChordNode module\r\n */\nimport { __extends } from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\nimport { FlowDiagramNode } from \"./FlowDiagramNode\";\nimport { AxisLabelCircular } from \"../axes/AxisLabelCircular\";\nimport { registry } from \"../../core/Registry\";\nimport { Slice } from \"../../core/elements/Slice\";\nimport { InterfaceColorSet } from \"../../core/utils/InterfaceColorSet\";\nimport * as $iter from \"../../core/utils/Iterator\";\nimport * as $math from \"../../core/utils/Math\";\nimport * as $type from \"../../core/utils/Type\";\nimport { Bullet } from \"../elements/Bullet\";\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * Creates a node in a Chord Diagram.\r\n *\r\n * A Chord node is a block with a value, which represents its size on the\r\n * diagram.\r\n *\r\n * Nodes are connected via [[ChordLink]] elements.\r\n *\r\n * @see {@link IChordNodeEvents} for a list of available events\r\n * @see {@link IChordNodeAdapters} for a list of available Adapters\r\n * @important\r\n */\n\nvar ChordNode =\n/** @class */\nfunction (_super) {\n  __extends(ChordNode, _super);\n  /**\r\n   * Constructor\r\n   */\n\n\n  function ChordNode() {\n    var _this = _super.call(this) || this;\n\n    _this.className = \"ChordNode\";\n\n    var label = _this.createChild(AxisLabelCircular);\n\n    label.location = 0.5;\n    label.radius = 5;\n    label.text = \"{name}\";\n    label.zIndex = 1;\n    label.shouldClone = false;\n    _this.label = label;\n    _this.layout = \"none\";\n\n    _this.events.on(\"positionchanged\", _this.updateRotation, _this, false);\n\n    _this.isMeasured = false;\n    _this.slice = _this.createChild(Slice);\n    _this.slice.isMeasured = false;\n    var hiddenState = _this.hiddenState;\n    hiddenState.properties.fill = new InterfaceColorSet().getFor(\"disabledBackground\");\n    hiddenState.properties.opacity = 0.5;\n    hiddenState.properties.visible = true;\n    _this.setStateOnChildren = false;\n    _this.slice.hiddenState.properties.visible = true;\n\n    _this.adapter.add(\"tooltipX\", function (tooltipX, target) {\n      return target.slice.ix * (target.slice.radius - (target.slice.radius - target.slice.pixelInnerRadius) / 2);\n    });\n\n    _this.adapter.add(\"tooltipY\", function (tooltipY, target) {\n      return target.slice.iy * (target.slice.radius - (target.slice.radius - target.slice.pixelInnerRadius) / 2);\n    });\n\n    return _this;\n  }\n  /**\r\n   * Invalidates all links, attached to this node.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  ChordNode.prototype.invalidateLinks = function () {\n    var _this = this;\n\n    _super.prototype.invalidateLinks.call(this);\n\n    var label = this.label;\n    var slice = this.slice;\n    var chart = this.chart;\n\n    if (chart && slice) {\n      var sum = this.total;\n      var arc_1 = slice.arc;\n      var sliceStartAngle_1 = slice.startAngle;\n      this.children.each(function (child) {\n        if (child instanceof Bullet) {\n          var locationX = child.locationX;\n\n          if (!$type.isNumber(locationX)) {\n            locationX = 0.5;\n          }\n\n          var locationY = child.locationY;\n\n          if (!$type.isNumber(locationY)) {\n            locationY = 1;\n          }\n\n          var childAngle = sliceStartAngle_1 + arc_1 * locationX;\n          var childRadius = locationY * slice.radius;\n          child.x = childRadius * $math.cos(childAngle);\n          child.y = childRadius * $math.sin(childAngle);\n        }\n      });\n      var labelAngle = sliceStartAngle_1 + arc_1 * label.location;\n      var startAngle = sliceStartAngle_1 + (1 - sum / this.adjustedTotal) * arc_1 * 0.5; // if value of a node is > then sum of the links, add to center link\n\n      if ($type.isNaN(startAngle)) {\n        startAngle = sliceStartAngle_1;\n      }\n\n      label.fixPosition(labelAngle, slice.radius);\n      this.nextAngle = startAngle;\n\n      if (this._outgoingSorted) {\n        $iter.each(this._outgoingSorted, function (dataItem) {\n          var link = dataItem.link;\n          link.parent = _this.chart.linksContainer;\n          var value = dataItem.getWorkingValue(\"value\");\n\n          if ($type.isNumber(value)) {\n            if (chart.nonRibbon) {\n              var percentWidth = link.percentWidth;\n\n              if (!$type.isNumber(percentWidth)) {\n                percentWidth = 5;\n              }\n\n              percentWidth = percentWidth / 100;\n              link.startAngle = sliceStartAngle_1 + arc_1 / 2 - arc_1 / 2 * percentWidth;\n              link.arc = arc_1 * percentWidth;\n            } else {\n              link.arc = value * chart.valueAngle;\n              link.startAngle = _this.nextAngle;\n              _this.nextAngle += link.arc;\n            }\n\n            if (!dataItem.toNode) {\n              link.endAngle = link.startAngle;\n            }\n\n            link.radius = slice.pixelInnerRadius;\n          } //link.validate();\n\n        });\n      }\n\n      if (this._incomingSorted) {\n        $iter.each(this._incomingSorted, function (dataItem) {\n          var link = dataItem.link;\n          link.radius = slice.pixelInnerRadius;\n\n          if (chart.nonRibbon) {\n            var percentWidth = link.percentWidth;\n\n            if (!$type.isNumber(percentWidth)) {\n              percentWidth = 5;\n            }\n\n            percentWidth = percentWidth / 100;\n            link.endAngle = sliceStartAngle_1 + arc_1 / 2 - arc_1 / 2 * percentWidth;\n            link.arc = arc_1 * percentWidth;\n          } else {\n            link.endAngle = _this.nextAngle;\n            var value = dataItem.getWorkingValue(\"value\");\n\n            if ($type.isNumber(value)) {\n              link.arc = value * chart.valueAngle; // yes, this is needed\n\n              _this.nextAngle += link.arc;\n            }\n          }\n\n          if (!dataItem.fromNode) {\n            link.startAngle = link.endAngle;\n          } //link.validate();\n\n        });\n      }\n    }\n  };\n  /**\r\n   * @ignore\r\n   * updates slice start angle so that when we drag a node it would face the center\r\n   */\n\n\n  ChordNode.prototype.updateRotation = function () {\n    var slice = this.slice;\n    var mAngle = this.trueStartAngle + slice.arc / 2;\n    var radius = slice.radius;\n    var tx = radius * $math.cos(mAngle);\n    var ty = radius * $math.sin(mAngle);\n    var angle = $math.getAngle({\n      x: tx + this.pixelX,\n      y: ty + this.pixelY\n    });\n    slice.startAngle = this.trueStartAngle + (angle - mAngle);\n    this.dx = -this.pixelX;\n    this.dy = -this.pixelY;\n  };\n  /**\r\n   * Copies properties and labels from another [[ChordNode]].\r\n   *\r\n   * @param source  Source node\r\n   */\n\n\n  ChordNode.prototype.copyFrom = function (source) {\n    _super.prototype.copyFrom.call(this, source);\n\n    this.label.copyFrom(source.label);\n    this.slice.copyFrom(source.slice);\n  };\n\n  return ChordNode;\n}(FlowDiagramNode);\n\nexport { ChordNode };\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\n\nregistry.registeredClasses[\"ChordNode\"] = ChordNode;","map":{"version":3,"mappings":"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","names":["FlowDiagramNode","AxisLabelCircular","registry","Slice","InterfaceColorSet","$iter","$math","$type","Bullet","__extends","_super","_this","className","label","createChild","location","radius","text","zIndex","shouldClone","layout","events","on","updateRotation","isMeasured","slice","hiddenState","properties","fill","getFor","opacity","visible","setStateOnChildren","adapter","add","tooltipX","target","ix","pixelInnerRadius","tooltipY","iy","ChordNode","invalidateLinks","call","chart","sum","total","arc_1","arc","sliceStartAngle_1","startAngle","children","each","child","locationX","isNumber","locationY","childAngle","childRadius","x","cos","y","sin","labelAngle","adjustedTotal","isNaN","fixPosition","nextAngle","_outgoingSorted","dataItem","link","parent","linksContainer","value","getWorkingValue","nonRibbon","percentWidth","valueAngle","toNode","endAngle","_incomingSorted","fromNode","mAngle","trueStartAngle","tx","ty","angle","getAngle","pixelX","pixelY","dx","dy","source","copyFrom","registeredClasses"],"sourceRoot":"","sources":["../../../../../src/.internal/charts/elements/ChordNode.ts"],"sourcesContent":["/**\r\n * ChordNode module\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { FlowDiagramNode, IFlowDiagramNodeAdapters, IFlowDiagramNodeEvents, IFlowDiagramNodeProperties } from \"./FlowDiagramNode\";\r\nimport { ChordDiagram, ChordDiagramDataItem } from \"../types/ChordDiagram\";\r\nimport { List } from \"../../core/utils/List\";\r\nimport { AxisLabelCircular } from \"../axes/AxisLabelCircular\";\r\nimport { registry } from \"../../core/Registry\";\r\nimport { Slice } from \"../../core/elements/Slice\";\r\nimport { InterfaceColorSet } from \"../../core/utils/InterfaceColorSet\";\r\nimport * as $iter from \"../../core/utils/Iterator\";\r\nimport * as $math from \"../../core/utils/Math\";\r\nimport * as $type from \"../../core/utils/Type\";\r\nimport { Bullet } from \"../elements/Bullet\";\r\n\r\n/**\r\n * ============================================================================\r\n * REQUISITES\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Defines properties for [[ChordNode]].\r\n */\r\nexport interface IChordNodeProperties extends IFlowDiagramNodeProperties { }\r\n\r\n/**\r\n * Defines events for [[ChordNode]].\r\n */\r\nexport interface IChordNodeEvents extends IFlowDiagramNodeEvents { }\r\n\r\n/**\r\n * Defines adapters for [[ChordNode]].\r\n *\r\n * @see {@link Adapter}\r\n */\r\nexport interface IChordNodeAdapters extends IFlowDiagramNodeAdapters, IChordNodeProperties { }\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Creates a node in a Chord Diagram.\r\n *\r\n * A Chord node is a block with a value, which represents its size on the\r\n * diagram.\r\n *\r\n * Nodes are connected via [[ChordLink]] elements.\r\n *\r\n * @see {@link IChordNodeEvents} for a list of available events\r\n * @see {@link IChordNodeAdapters} for a list of available Adapters\r\n * @important\r\n */\r\nexport class ChordNode extends FlowDiagramNode {\r\n\r\n\t/**\r\n\t * Defines available properties.\r\n\t */\r\n\tpublic _properties!: IChordNodeProperties;\r\n\r\n\t/**\r\n\t * Defines available adapters.\r\n\t */\r\n\tpublic _adapter!: IChordNodeAdapters;\r\n\r\n\t/**\r\n\t * Defines available events.\r\n\t */\r\n\tpublic _events!: IChordNodeEvents;\r\n\r\n\t/**\r\n\t * A list of data items of the items coming in from another node, one level\r\n\t * up.\r\n\t *\r\n\t * These are what ingoing links are build out of.\r\n\t */\r\n\tprotected _incomingDataItems: List<ChordDiagramDataItem>;\r\n\r\n\t/**\r\n\t * A list of data items of the items going out of the node.\r\n\t *\r\n\t * These are what outgoing links are build out of.\r\n\t */\r\n\tprotected _outgoingDataItems: List<ChordDiagramDataItem>;\r\n\r\n\t/**\r\n\t * Sorted list of incoming items.\r\n\t */\r\n\tprotected _incomingSorted: $iter.Iterator<ChordDiagramDataItem>;\r\n\r\n\t/**\r\n\t * Sorted list of outgoing items.\r\n\t */\r\n\tprotected _outgoingSorted: $iter.Iterator<ChordDiagramDataItem>;\r\n\r\n\t/**\r\n\t * A chart instance this node is added to.\r\n\t */\r\n\tpublic chart: ChordDiagram;\r\n\r\n\r\n\t/**\r\n\t * Defines the type of the [[ChordDiagramDataItem]] used in the class.\r\n\t */\r\n\tpublic _dataItem: ChordDiagramDataItem;\r\n\r\n\r\n\t/**\r\n\t * Slice sprite of a node\r\n\t */\r\n\tpublic slice: Slice;\r\n\r\n\t/**\r\n\t * A label element which shows node's name.\r\n\t */\r\n\tpublic label: AxisLabelCircular;\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tpublic nextAngle: number;\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tpublic trueStartAngle: number;\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor() {\r\n\t\tsuper();\r\n\t\tthis.className = \"ChordNode\";\r\n\r\n\t\tlet label = this.createChild(AxisLabelCircular);\r\n\t\tlabel.location = 0.5;\r\n\t\tlabel.radius = 5;\r\n\t\tlabel.text = \"{name}\";\r\n\t\tlabel.zIndex = 1;\r\n\t\tlabel.shouldClone = false;\r\n\t\tthis.label = label;\r\n\r\n\t\tthis.layout = \"none\";\r\n\r\n\t\tthis.events.on(\"positionchanged\", this.updateRotation, this, false);\r\n\r\n\t\tthis.isMeasured = false;\r\n\t\tthis.slice = this.createChild(Slice);\r\n\t\tthis.slice.isMeasured = false;\r\n\r\n\t\tlet hiddenState = this.hiddenState;\r\n\t\thiddenState.properties.fill = new InterfaceColorSet().getFor(\"disabledBackground\");\r\n\t\thiddenState.properties.opacity = 0.5;\r\n\t\thiddenState.properties.visible = true;\r\n\r\n\t\tthis.setStateOnChildren = false;\r\n\r\n\t\tthis.slice.hiddenState.properties.visible = true;\r\n\r\n\t\tthis.adapter.add(\"tooltipX\", (tooltipX, target)=>{\r\n\t\t    return target.slice.ix * (target.slice.radius - (target.slice.radius - target.slice.pixelInnerRadius) / 2);\r\n\t\t})\r\n\r\n\t\tthis.adapter.add(\"tooltipY\", (tooltipY, target)=>{\r\n\t\t    return target.slice.iy * (target.slice.radius - (target.slice.radius - target.slice.pixelInnerRadius) / 2);\r\n\t\t})\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Invalidates all links, attached to this node.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic invalidateLinks(): void {\r\n\t\tsuper.invalidateLinks();\r\n\r\n\t\tlet label = this.label;\r\n\t\tlet slice = this.slice;\r\n\t\tlet chart = this.chart;\r\n\t\tif (chart && slice) {\r\n\r\n\t\t\tlet sum = this.total;\r\n\t\t\tlet arc = slice.arc;\r\n\t\t\tlet sliceStartAngle = slice.startAngle;\r\n\r\n\t\t\tthis.children.each((child) => {\r\n\t\t\t\tif (child instanceof Bullet) {\r\n\t\t\t\t\tlet locationX = child.locationX;\r\n\t\t\t\t\tif (!$type.isNumber(locationX)) {\r\n\t\t\t\t\t\tlocationX = 0.5;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tlet locationY = child.locationY;\r\n\t\t\t\t\tif (!$type.isNumber(locationY)) {\r\n\t\t\t\t\t\tlocationY = 1;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tlet childAngle = sliceStartAngle + arc * locationX;\r\n\t\t\t\t\tlet childRadius = locationY * slice.radius;\r\n\r\n\t\t\t\t\tchild.x = childRadius * $math.cos(childAngle);\r\n\t\t\t\t\tchild.y = childRadius * $math.sin(childAngle);\r\n\t\t\t\t}\r\n\t\t\t})\r\n\r\n\r\n\t\t\tlet labelAngle = sliceStartAngle + arc * label.location;\r\n\t\t\tlet startAngle = sliceStartAngle + (1 - sum / this.adjustedTotal) * arc * 0.5; // if value of a node is > then sum of the links, add to center link\r\n\r\n\t\t\tif ($type.isNaN(startAngle)) {\r\n\t\t\t\tstartAngle = sliceStartAngle;\r\n\t\t\t}\r\n\r\n\t\t\tlabel.fixPosition(labelAngle, slice.radius);\r\n\r\n\t\t\tthis.nextAngle = startAngle;\r\n\r\n\t\t\tif (this._outgoingSorted) {\r\n\r\n\t\t\t\t$iter.each(this._outgoingSorted, (dataItem) => {\r\n\t\t\t\t\tlet link = dataItem.link;\r\n\t\t\t\t\tlink.parent = this.chart.linksContainer;\r\n\t\t\t\t\tlet value = dataItem.getWorkingValue(\"value\");\r\n\r\n\t\t\t\t\tif ($type.isNumber(value)) {\r\n\r\n\t\t\t\t\t\tif (chart.nonRibbon) {\r\n\t\t\t\t\t\t\tlet percentWidth = link.percentWidth;\r\n\t\t\t\t\t\t\tif (!$type.isNumber(percentWidth)) {\r\n\t\t\t\t\t\t\t\tpercentWidth = 5;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tpercentWidth = percentWidth / 100;\r\n\r\n\t\t\t\t\t\t\tlink.startAngle = sliceStartAngle + arc / 2 - arc / 2 * percentWidth;\r\n\t\t\t\t\t\t\tlink.arc = arc * percentWidth;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\tlink.arc = value * chart.valueAngle;\r\n\t\t\t\t\t\t\tlink.startAngle = this.nextAngle;\r\n\t\t\t\t\t\t\tthis.nextAngle += link.arc;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif (!dataItem.toNode) {\r\n\t\t\t\t\t\t\tlink.endAngle = link.startAngle;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tlink.radius = slice.pixelInnerRadius;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t//link.validate();\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\tif (this._incomingSorted) {\r\n\t\t\t\t$iter.each(this._incomingSorted, (dataItem) => {\r\n\t\t\t\t\tlet link = dataItem.link;\r\n\r\n\t\t\t\t\tlink.radius = slice.pixelInnerRadius;\r\n\r\n\t\t\t\t\tif (chart.nonRibbon) {\r\n\t\t\t\t\t\tlet percentWidth = link.percentWidth;\r\n\t\t\t\t\t\tif (!$type.isNumber(percentWidth)) {\r\n\t\t\t\t\t\t\tpercentWidth = 5;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tpercentWidth = percentWidth / 100;\r\n\r\n\t\t\t\t\t\tlink.endAngle = sliceStartAngle + arc / 2 - arc / 2 * percentWidth;\r\n\t\t\t\t\t\tlink.arc = arc * percentWidth;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tlink.endAngle = this.nextAngle;\r\n\t\t\t\t\t\tlet value = dataItem.getWorkingValue(\"value\");\r\n\t\t\t\t\t\tif ($type.isNumber(value)) {\r\n\t\t\t\t\t\t\tlink.arc = value * chart.valueAngle; // yes, this is needed\r\n\t\t\t\t\t\t\tthis.nextAngle += link.arc;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (!dataItem.fromNode) {\r\n\t\t\t\t\t\tlink.startAngle = link.endAngle;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t//link.validate();\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @ignore\r\n\t * updates slice start angle so that when we drag a node it would face the center\r\n\t */\r\n\tprotected updateRotation() {\r\n\t\tlet slice = this.slice;\r\n\t\tlet mAngle = this.trueStartAngle + slice.arc / 2;\r\n\t\tlet radius = slice.radius;\r\n\r\n\t\tlet tx = radius * $math.cos(mAngle);\r\n\t\tlet ty = radius * $math.sin(mAngle);\r\n\r\n\t\tlet angle = $math.getAngle({ x: tx + this.pixelX, y: ty + this.pixelY });\r\n\r\n\t\tslice.startAngle = this.trueStartAngle + (angle - mAngle);\r\n\r\n\t\tthis.dx = - this.pixelX;\r\n\t\tthis.dy = - this.pixelY;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Copies properties and labels from another [[ChordNode]].\r\n\t *\r\n\t * @param source  Source node\r\n\t */\r\n\tpublic copyFrom(source: this): void {\r\n\t\tsuper.copyFrom(source);\r\n\t\tthis.label.copyFrom(source.label);\r\n\t\tthis.slice.copyFrom(source.slice);\r\n\t}\r\n}\r\n\r\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\r\nregistry.registeredClasses[\"ChordNode\"] = ChordNode;\r\n"]},"metadata":{},"sourceType":"module"}