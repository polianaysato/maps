{"ast":null,"code":"/**\r\n * Contains code and logic for generating linear gradients.\r\n */\nimport { __extends } from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\nimport { BaseObject } from \"../../Base\";\nimport { List } from \"../../utils/List\";\nimport { getGhostPaper } from \"../Paper\";\nimport { registry } from \"../../Registry\";\nimport * as $iter from \"../../utils/Iterator\";\nimport * as $math from \"../../utils/Math\";\nimport * as $type from \"../../utils/Type\";\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * Linear gradient class.\r\n */\n\nvar LinearGradient =\n/** @class */\nfunction (_super) {\n  __extends(LinearGradient, _super);\n  /**\r\n   * Constructor.\r\n   */\n\n\n  function LinearGradient() {\n    var _this = // Init\n    _super.call(this) || this;\n    /**\r\n     * List of colors switch definitions in a gradient.\r\n     */\n\n\n    _this._stops = new List();\n    /**\r\n     * Gradient direction.\r\n     */\n\n    _this._rotation = 0;\n    _this.className = \"LinearGradient\";\n\n    _this._stops.events.on(\"setIndex\", _this.validate, _this);\n\n    _this._stops.events.on(\"inserted\", _this.validate, _this); // Create element\n\n\n    _this.element = _this.paper.addGroup(\"linearGradient\");\n    _this.id = \"gradient-\" + registry.getUniqueId();\n\n    _this.element.attr({\n      \"id\": _this.id\n    });\n\n    _this._disposers.push(_this.element); // Apply theme\n\n\n    _this.applyTheme();\n\n    return _this;\n  }\n  /**\r\n   * Draws gradient.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  LinearGradient.prototype.validate = function () {\n    var _this = this;\n\n    var rotation = (this._rotation + 90) * $math.RADIANS;\n    var x1 = Math.round(50 + Math.sin(rotation + Math.PI) * 50) + '%';\n    var y1 = Math.round(50 + Math.cos(rotation) * 50) + '%';\n    var x2 = Math.round(50 + Math.sin(rotation) * 50) + '%';\n    var y2 = Math.round(50 + Math.cos(rotation + Math.PI) * 50) + '%';\n    var gradientElement = this.element;\n    gradientElement.removeChildNodes();\n    gradientElement.attr({\n      \"x1\": x1,\n      \"x2\": x2,\n      \"y1\": y1,\n      \"y2\": y2\n    });\n    $iter.each($iter.indexed(this._stops.iterator()), function (a) {\n      var i = a[0];\n      var stop = a[1];\n      var offset = stop.offset;\n\n      if (!$type.isNumber(offset)) {\n        offset = i / (_this._stops.length - 1);\n      }\n\n      var gradientStop = _this.paper.add(\"stop\");\n\n      if ($type.hasValue(stop.color)) {\n        gradientStop.attr({\n          \"stop-color\": stop.color.toString()\n        });\n      }\n\n      if ($type.isNumber(stop.opacity)) {\n        gradientStop.attr({\n          \"stop-opacity\": stop.opacity\n        });\n      }\n\n      if ($type.isNumber(offset)) {\n        gradientStop.attr({\n          \"offset\": offset\n        });\n      }\n\n      gradientElement.add(gradientStop);\n    });\n  };\n  /**\r\n   * Clears the gradient.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  LinearGradient.prototype.clear = function () {\n    this._stops.clear();\n  };\n  /**\r\n   * Adds a color step to the gradient.\r\n   *\r\n   * @param color    Color (hex code or named color)\r\n   * @param opacity  Opacity (value from 0 to 1; 0 completely transaprent, 1 fully opaque)\r\n   * @param offset   Position of color in the gradient (value 0 to 1; 0 meaning start of the gradient and 1 end)\r\n   */\n\n\n  LinearGradient.prototype.addColor = function (color, opacity, offset) {\n    this._stops.push({\n      color: color,\n      opacity: opacity,\n      offset: offset\n    });\n  };\n\n  Object.defineProperty(LinearGradient.prototype, \"stops\", {\n    /**\r\n     * A list of color stops in the gradient.\r\n     *\r\n     * @return Stops\r\n     */\n    get: function get() {\n      return this._stops;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(LinearGradient.prototype, \"paper\", {\n    /**\r\n     * @ignore Exclude from docs\r\n     * @return Paper\r\n     */\n    get: function get() {\n      if (this._paper) {\n        return this._paper;\n      }\n\n      return getGhostPaper();\n    },\n\n    /**\r\n     * [[Paper]] instace to use for the gradient.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param paper  Paper\r\n     */\n    set: function set(paper) {\n      if (this._paper != paper) {\n        this._paper = paper;\n        this.validate();\n        paper.appendDef(this.element);\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(LinearGradient.prototype, \"rotation\", {\n    /**\r\n     * @return Rotation\r\n     */\n    get: function get() {\n      return this._rotation;\n    },\n\n    /**\r\n     * Rotation (direction) of the gradient in degrees.\r\n     *\r\n     * @param value  Rotation\r\n     */\n    set: function set(value) {\n      //this.element.attr({ \"gradientTransform\": \"rotate(\" + value + \" 10 100)\" });\n      this._rotation = value;\n      this.validate();\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  LinearGradient.prototype.copyFrom = function (source) {\n    _super.prototype.copyFrom.call(this, source);\n\n    this.stops.copyFrom(source.stops);\n    this._rotation = source.rotation;\n  };\n\n  Object.defineProperty(LinearGradient.prototype, \"gradientUnits\", {\n    /**\r\n     * Which units are used when drawing gradient filter.\r\n     *\r\n     * Use `\"userSpaceOnUse\"` when applying gradient on a perfectly straight line.\r\n     *\r\n     * @since 4.9.17\r\n     * @default objectBoundingBox\r\n     * @param value Filter units\r\n     */\n    set: function set(value) {\n      this.element.attr({\n        gradientUnits: value\n      });\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return LinearGradient;\n}(BaseObject);\n\nexport { LinearGradient };\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\n\nregistry.registeredClasses[\"LinearGradient\"] = LinearGradient;","map":{"version":3,"mappings":"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","names":["BaseObject","List","getGhostPaper","registry","$iter","$math","$type","__extends","_super","_this","className","_stops","events","on","validate","element","paper","addGroup","id","getUniqueId","attr","_disposers","push","applyTheme","LinearGradient","rotation","_rotation","RADIANS","x1","Math","round","sin","PI","y1","cos","x2","y2","gradientElement","removeChildNodes","each","indexed","iterator","a","i","stop","offset","isNumber","length","gradientStop","add","hasValue","color","toString","opacity","clear","Object","_paper","appendDef","value","source","copyFrom","call","stops","gradientUnits","registeredClasses"],"sourceRoot":"","sources":["../../../../../../src/.internal/core/rendering/fills/LinearGradient.ts"],"sourcesContent":["/**\r\n * Contains code and logic for generating linear gradients.\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { BaseObject } from \"../../Base\";\r\nimport { List } from \"../../utils/List\";\r\nimport { Group } from \"../Group\";\r\nimport { AMElement } from \"../AMElement\";\r\nimport { Paper, getGhostPaper } from \"../Paper\";\r\nimport { Color } from \"../../utils/Color\";\r\nimport { registry } from \"../../Registry\";\r\nimport * as $iter from \"../../utils/Iterator\";\r\nimport * as $math from \"../../utils/Math\";\r\nimport * as $type from \"../../utils/Type\";\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * REQUISITES\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Represents an object describing color switching point in a gradiend.\r\n */\r\nexport interface IGradientStop {\r\n\r\n\t/**\r\n\t * Color.\r\n\t */\r\n\tcolor: Color;\r\n\r\n\t/**\r\n\t * Offset defines where in the gradient the color should kick in. Values\r\n\t * from 0 to 1 are possible with 0 meaning start, 0.5 half-way through the\r\n\t * gradient, etc.\r\n\t */\r\n\toffset?: number;\r\n\r\n\t/**\r\n\t * Transparency of the color. 0 - completely transparent, 1 - fully opaque.\r\n\t */\r\n\topacity?: number;\r\n}\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Linear gradient class.\r\n */\r\nexport class LinearGradient extends BaseObject {\r\n\r\n\t/**\r\n\t * List of colors switch definitions in a gradient.\r\n\t */\r\n\tprotected _stops: List<IGradientStop> = new List<IGradientStop>();\r\n\r\n\t/**\r\n\t * An SVG `<group>` element used to draw gradient.\r\n\t */\r\n\tpublic element: Group;\r\n\r\n\t/**\r\n\t * Reference to Paper to add element to.\r\n\t */\r\n\tprotected _paper: $type.Optional<Paper>;\r\n\r\n\t/**\r\n\t * Gradient direction.\r\n\t */\r\n\tprotected _rotation: number = 0;\r\n\r\n\t/**\r\n\t * Constructor.\r\n\t */\r\n\tconstructor() {\r\n\r\n\t\t// Init\r\n\t\tsuper();\r\n\t\tthis.className = \"LinearGradient\";\r\n\r\n\t\tthis._stops.events.on(\"setIndex\", this.validate, this);\r\n\t\tthis._stops.events.on(\"inserted\", this.validate, this);\r\n\t\t// Create element\r\n\t\tthis.element = this.paper.addGroup(\"linearGradient\");\r\n\t\tthis.id = \"gradient-\" + registry.getUniqueId();\r\n\t\tthis.element.attr({ \"id\": this.id });\r\n\t\tthis._disposers.push(this.element);\r\n\r\n\t\t// Apply theme\r\n\t\tthis.applyTheme();\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Draws gradient.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic validate(): void {\r\n\r\n\t\tlet rotation = (this._rotation + 90) * $math.RADIANS;\r\n\r\n\t\tlet x1: string = Math.round(50 + Math.sin(rotation + Math.PI) * 50) + '%';\r\n\t\tlet y1: string = Math.round(50 + Math.cos(rotation) * 50) + '%';\r\n\r\n\t\tlet x2: string = Math.round(50 + Math.sin(rotation) * 50) + '%';\r\n\t\tlet y2: string = Math.round(50 + Math.cos(rotation + Math.PI) * 50) + '%';\r\n\r\n\r\n\t\tlet gradientElement: Group = this.element;\r\n\t\tgradientElement.removeChildNodes();\r\n\t\tgradientElement.attr({\"x1\": x1, \"x2\":x2, \"y1\": y1, \"y2\":y2});\r\n\r\n\t\t$iter.each($iter.indexed(this._stops.iterator()), (a) => {\r\n\t\t\tlet i = a[0];\r\n\t\t\tlet stop = a[1];\r\n\t\t\tlet offset: $type.Optional<number> = stop.offset;\r\n\r\n\t\t\tif (!$type.isNumber(offset)) {\r\n\t\t\t\toffset = i / (this._stops.length - 1)\r\n\t\t\t}\r\n\r\n\t\t\tlet gradientStop: AMElement = this.paper.add(\"stop\");\r\n\t\t\tif ($type.hasValue(stop.color)) {\r\n\t\t\t\tgradientStop.attr({ \"stop-color\": stop.color.toString() });\r\n\t\t\t}\r\n\t\t\tif ($type.isNumber(stop.opacity)) {\r\n\t\t\t\tgradientStop.attr({ \"stop-opacity\": stop.opacity });\r\n\t\t\t}\r\n\r\n\t\t\tif ($type.isNumber(offset)) {\r\n\t\t\t\tgradientStop.attr({ \"offset\": offset });\r\n\t\t\t}\r\n\r\n\t\t\tgradientElement.add(gradientStop);\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Clears the gradient.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic clear(): void {\r\n\t\tthis._stops.clear();\r\n\t}\r\n\r\n\t/**\r\n\t * Adds a color step to the gradient.\r\n\t *\r\n\t * @param color    Color (hex code or named color)\r\n\t * @param opacity  Opacity (value from 0 to 1; 0 completely transaprent, 1 fully opaque)\r\n\t * @param offset   Position of color in the gradient (value 0 to 1; 0 meaning start of the gradient and 1 end)\r\n\t */\r\n\tpublic addColor(color: Color, opacity?: number, offset?: number): void {\r\n\t\tthis._stops.push({ color: color, opacity: opacity, offset: offset });\r\n\t}\r\n\r\n\t/**\r\n\t * A list of color stops in the gradient.\r\n\t *\r\n\t * @return Stops\r\n\t */\r\n\tpublic get stops(): List<IGradientStop> {\r\n\t\treturn this._stops;\r\n\t}\r\n\r\n\t/**\r\n\t * [[Paper]] instace to use for the gradient.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param paper  Paper\r\n\t */\r\n\tpublic set paper(paper: Paper) {\r\n\t\tif (this._paper != paper) {\r\n\t\t\tthis._paper = paper;\r\n\t\t\tthis.validate();\r\n\t\t\tpaper.appendDef(this.element);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @ignore Exclude from docs\r\n\t * @return Paper\r\n\t */\r\n\tpublic get paper(): Paper {\r\n\t\tif (this._paper) {\r\n\t\t\treturn this._paper;\r\n\t\t}\r\n\t\treturn getGhostPaper();\r\n\t}\r\n\r\n\t/**\r\n\t * Rotation (direction) of the gradient in degrees.\r\n\t *\r\n\t * @param value  Rotation\r\n\t */\r\n\tpublic set rotation(value: number) {\r\n\t\t//this.element.attr({ \"gradientTransform\": \"rotate(\" + value + \" 10 100)\" });\r\n\t\tthis._rotation = value;\r\n\t\tthis.validate();\r\n\t}\r\n\r\n\t/**\r\n\t * @return Rotation\r\n\t */\r\n\tpublic get rotation(): number {\r\n\t\treturn this._rotation;\r\n\t}\r\n\r\n\r\n\tpublic copyFrom(source:this){\r\n\t\tsuper.copyFrom(source);\r\n\r\n\t\tthis.stops.copyFrom(source.stops);\r\n\r\n\t\tthis._rotation = source.rotation;\r\n\t}\r\n\r\n\t/**\r\n\t * Which units are used when drawing gradient filter.\r\n\t *\r\n\t * Use `\"userSpaceOnUse\"` when applying gradient on a perfectly straight line.\r\n\t *\r\n\t * @since 4.9.17\r\n\t * @default objectBoundingBox\r\n\t * @param value Filter units\r\n\t */\r\n\tpublic set gradientUnits(value: \"objectBoundingBox\" | \"userSpaceOnUse\") {\r\n\t\tthis.element.attr({gradientUnits:value});\r\n\t}\r\n}\r\n\r\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\r\nregistry.registeredClasses[\"LinearGradient\"] = LinearGradient;\r\n"]},"metadata":{},"sourceType":"module"}