{"ast":null,"code":"/**\r\n * Morpher module contains functionality that allows morphing one polygon to\r\n * another.\r\n */\nimport { __extends } from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\nimport { BaseObject } from \"../Base\";\nimport { Animation, AnimationDisposer } from \"../utils/Animation\";\nimport * as $math from \"../utils/Math\";\nimport * as $ease from \"../utils/Ease\";\nimport * as $type from \"../utils/Type\";\n/**\r\n * Morpher can be used to morph one polygon to some other polygon.\r\n */\n\nvar Morpher =\n/** @class */\nfunction (_super) {\n  __extends(Morpher, _super);\n  /**\r\n   * Constructor.\r\n   *\r\n   * @param morphable An object to morph\r\n   */\n\n\n  function Morpher(morphable) {\n    var _this = _super.call(this) || this;\n    /**\r\n     * A storage for measurements.\r\n     */\n\n\n    _this._bboxes = [];\n    /**\r\n     * Duration of the morphing animation in milliseconds.\r\n     */\n\n    _this.morphDuration = 800;\n    /**\r\n     * An easing function to use for morphing animation.\r\n     *\r\n     * @see {@link Ease}\r\n     */\n\n    _this.morphEasing = $ease.cubicOut;\n    /**\r\n     * If set to `true`, all separate parts of the multi-part polygon will\r\n     * morph into a single circle or polygon when using built-in methods\r\n     * `morphToCircle()` or `morphToPolygon()`.\r\n     *\r\n     * Otherwise each separate part of polygon will morph to individual target\r\n     * circle or polgyon.\r\n     */\n\n    _this.morphToSingle = true;\n    /**\r\n     * A ratio to scale morphed object in relation to the source object.\r\n     */\n\n    _this.scaleRatio = 1;\n    _this.className = \"Morpher\";\n    _this.morphable = morphable;\n\n    _this.applyTheme();\n\n    return _this;\n  }\n  /**\r\n   * Morphs a polygon to another polygon.\r\n   *\r\n   * @param toPoints  Corner points of the target shape\r\n   * @param duration  Duration in milliseconds\r\n   * @param easing    Easing function\r\n   * @return Animation\r\n   */\n\n\n  Morpher.prototype.morphToPolygon = function (toPoints, duration, easing) {\n    var points = this.morphable.currentPoints;\n\n    if (points && toPoints) {\n      this.sortPoints(points);\n      this.sortPoints(toPoints);\n      this._morphFromPointsReal = [];\n      this._morphToPointsReal = [];\n\n      if (!$type.hasValue(duration)) {\n        duration = this.morphDuration;\n      }\n\n      if (!$type.hasValue(easing)) {\n        easing = this.morphEasing;\n      }\n\n      this._morphFromPointsReal = this.normalizePoints(toPoints, points);\n      this._morphToPointsReal = this.normalizePoints(points, toPoints);\n      this.morphable.currentPoints = this._morphFromPointsReal;\n      var animation = new Animation(this, {\n        property: \"morphProgress\",\n        from: 0,\n        to: 1\n      }, duration, easing);\n\n      this._disposers.push(animation);\n\n      animation.start();\n      return animation;\n    }\n  };\n  /**\r\n   * [normalizePoints description]\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description\r\n   * @param pointsA  Point A\r\n   * @param pointsB  Point B\r\n   * @return Normalized points\r\n   */\n\n\n  Morpher.prototype.normalizePoints = function (pointsA, pointsB) {\n    for (var i = 0, len = pointsA.length; i < len; i++) {\n      var surfaceA = pointsA[i][0];\n      var holeA = pointsA[i][1];\n      var bboxA = $type.getValue($math.getBBox(surfaceA));\n      var middleX = bboxA.x + bboxA.width;\n      var middleY = bboxA.y + bboxA.height; // check if we have the same in PointsB\n\n      if (!pointsB[i]) {\n        pointsB[i] = [];\n      } // check if we have surface in pointsB\n\n\n      if (surfaceA && !pointsB[i][0]) {\n        pointsB[i][0] = [{\n          x: middleX,\n          y: middleY\n        }, {\n          x: middleX,\n          y: middleY\n        }];\n      }\n\n      if (pointsB[i][0]) {\n        pointsB[i][0] = this.addPoints(pointsB[i][0], surfaceA.length);\n        var distance = Infinity;\n        var splitAt = 0;\n\n        for (var a = 0; a < pointsB[i][0].length; a++) {\n          var newDistance = $math.getDistance(pointsB[i][0][a], surfaceA[0]);\n\n          if (newDistance < distance) {\n            splitAt = a;\n            distance = newDistance;\n          }\n        }\n\n        var partA = pointsB[i][0].slice(0, splitAt);\n        var partB = pointsB[i][0].slice(splitAt);\n        pointsB[i][0] = partB.concat(partA);\n      }\n\n      if (holeA) {\n        if (!pointsB[i][1]) {\n          pointsB[i][1] = [{\n            x: middleX,\n            y: middleY\n          }, {\n            x: middleX,\n            y: middleY\n          }];\n        }\n\n        pointsB[i][1] = this.addPoints(pointsB[i][1], holeA.length);\n      }\n    }\n\n    return pointsB;\n  };\n  /**\r\n   * [sortPoints description]\r\n   *\r\n   * @ignore Exclude from doc\r\n   * @todo Description\r\n   * @param points  [description]\r\n   * @return                        common bbox of points\r\n   */\n\n\n  Morpher.prototype.sortPoints = function (points) {\n    points.sort(function (a, b) {\n      var bbox1 = $type.getValue($math.getBBox(a[0]));\n      var bbox2 = $type.getValue($math.getBBox(b[0]));\n\n      if (bbox1.width * bbox1.height > bbox2.width * bbox2.height) {\n        return -1;\n      } else {\n        return 1;\n      }\n    });\n    var bboxes = [];\n\n    for (var i = 0, len = points.length; i < len; i++) {\n      var surface = points[i][0];\n\n      if (surface) {\n        bboxes.push($type.getValue($math.getBBox(surface)));\n      }\n    }\n\n    return $math.getCommonRectangle(bboxes);\n  };\n  /**\r\n   * Morphs polygon to a circle (it is actually a polygon which makes a circle).\r\n   *\r\n   * @param radius    Target circle radius (px)\r\n   * @param duration  Duration (ms)\r\n   * @param easing    Easing function\r\n   * @return Animation\r\n   */\n\n\n  Morpher.prototype.morphToCircle = function (radius, duration, easing) {\n    var points = this.morphable.points;\n    var commonBBox = this.sortPoints(points);\n    this._morphFromPointsReal = [];\n    this._morphToPointsReal = [];\n\n    if (!$type.hasValue(duration)) {\n      duration = this.morphDuration;\n    }\n\n    if (!$type.hasValue(easing)) {\n      easing = this.morphEasing;\n    } // surface\n\n\n    for (var i = 0, len = points.length; i < len; i++) {\n      var surface = points[i][0];\n      var hole = points[i][1];\n      this._morphFromPointsReal[i] = [];\n      this._morphToPointsReal[i] = [];\n\n      if (surface) {\n        var toPoints = surface;\n        var fromPoints = surface;\n        var bbox = $type.getValue($math.getBBox(fromPoints)); // this._bboxes[i];\n\n        if (this.morphToSingle) {\n          bbox = $type.getValue(commonBBox);\n        }\n\n        var middleX = bbox.x + bbox.width / 2;\n        var middleY = bbox.y + bbox.height / 2;\n        var realRadius = radius;\n\n        if (!$type.isNumber(realRadius)) {\n          realRadius = Math.min(bbox.width / 2, bbox.height / 2);\n        }\n\n        toPoints = []; // find angle for the first point\n\n        var startAngle = $math.getAngle({\n          x: middleX,\n          y: middleY\n        }, surface[0]);\n        var count = 100;\n\n        if (surface.length > count) {\n          count = surface.length;\n        }\n\n        fromPoints = this.addPoints(surface, count);\n        count = fromPoints.length; // add Points might increase number a bit\n\n        var angle = 360 / (count - 1);\n\n        for (var a = 0; a < count; a++) {\n          var realAngle = angle * a + startAngle;\n          var pointOnCircle = {\n            x: middleX + realRadius * $math.cos(realAngle),\n            y: middleY + realRadius * $math.sin(realAngle)\n          };\n          toPoints[a] = pointOnCircle;\n        }\n\n        if (hole && hole.length > 0) {\n          for (var i_1 = 0, hlen = hole.length; i_1 < hlen; i_1++) {\n            toPoints.push({\n              x: middleX,\n              y: middleY\n            });\n          }\n        }\n\n        this._morphFromPointsReal[i][0] = fromPoints;\n        this._morphToPointsReal[i][0] = toPoints;\n      }\n    }\n\n    this.morphable.currentPoints = this._morphFromPointsReal;\n    var animation = new Animation(this, {\n      property: \"morphProgress\",\n      from: 0,\n      to: 1\n    }, duration, easing);\n\n    this._disposers.push(animation);\n\n    animation.start();\n    return animation;\n  };\n  /**\r\n   * [addPoints description]\r\n   *\r\n   * @ignore Exclude from doc\r\n   * @todo Description\r\n   * @param points         [description]\r\n   * @param mustHaveCount  [description]\r\n   * @return [description]\r\n   */\n\n\n  Morpher.prototype.addPoints = function (points, mustHaveCount) {\n    var addToSegmentCount = Math.round(mustHaveCount / points.length);\n    var newPoints = [];\n\n    for (var i = 0, len = points.length; i < len; i++) {\n      var point0 = points[i];\n      var point1 = void 0;\n\n      if (i == points.length - 1) {\n        point1 = points[0];\n      } else {\n        point1 = points[i + 1];\n      }\n\n      newPoints.push(point0);\n\n      for (var p = 1; p < addToSegmentCount; p++) {\n        var percent = p / addToSegmentCount;\n        var extraPoint = {\n          x: point0.x + (point1.x - point0.x) * percent,\n          y: point0.y + (point1.y - point0.y) * percent\n        };\n        newPoints.push(extraPoint);\n      } // stop adding in case we already added more than left in original\n\n\n      if (newPoints.length + points.length - i == mustHaveCount) {\n        addToSegmentCount = 0;\n      }\n    }\n\n    if (newPoints.length < mustHaveCount && points.length > 0) {\n      var lastPoint = points[points.length - 1];\n\n      for (var p = newPoints.length; p < mustHaveCount; p++) {\n        // add same as last\n        newPoints.push({\n          x: lastPoint.x,\n          y: lastPoint.y\n        });\n      }\n    }\n\n    return newPoints;\n  };\n  /**\r\n   * Morphs polygon into a rectangular polygon.\r\n   *\r\n   * @param width     Width of the target rectangle (px)\r\n   * @param height    Height of the target rectangle (px)\r\n   * @param duration  Duration (ms)\r\n   * @param easing    Easing function\r\n   * @return Animation\r\n   */\n\n\n  Morpher.prototype.morphToRectangle = function (width, height, duration, easing) {\n    var points = this.morphable.points;\n    this.sortPoints(points);\n    this._morphFromPointsReal = [];\n    this._morphToPointsReal = [];\n\n    if (!$type.hasValue(duration)) {\n      duration = this.morphDuration;\n    }\n\n    if (!$type.hasValue(easing)) {\n      easing = this.morphEasing;\n    } //\t\tlet biggestBBox: IRectangle = this._bboxes[this._biggestIndex];\n    // surface\n\n\n    for (var i = 0, len = points.length; i < len; i++) {\n      var surface = points[i][0];\n      var hole = points[i][1];\n      this._morphFromPointsReal[i] = [];\n      this._morphToPointsReal[i] = [];\n\n      if (surface) {\n        var toPoints = surface;\n        var fromPoints = surface;\n        var bbox = this._bboxes[i]; // we only work with first area. TODO: maybe we should find the biggest one?\n\n        if (this.morphToSingle) {//if (i != this._biggestIndex) {\n          //\tbbox = { x: biggestBBox.x + biggestBBox.width / 2, y: biggestBBox.y + biggestBBox.height / 2, width: 0, height: 0 };\n          //}\n        }\n\n        var x = bbox.x;\n        var y = bbox.y;\n        var realWidth = width;\n        var realHeight = height;\n\n        if (!$type.isNumber(realWidth)) {\n          realWidth = bbox.width;\n        }\n\n        if (!$type.isNumber(realHeight)) {\n          realHeight = bbox.height;\n        }\n\n        toPoints = [{\n          x: x,\n          y: y\n        }, {\n          x: x + realWidth,\n          y: y\n        }, {\n          x: x + realWidth,\n          y: y + realHeight\n        }, {\n          x: x,\n          y: y + realHeight\n        }];\n        toPoints = this.addPoints(toPoints, surface.length); // if polygon has less points then count, add\n\n        if (surface.length < 4) {\n          for (var i_2 = surface.length; i_2 < 4; i_2++) {\n            toPoints.push({\n              x: surface[i_2].x,\n              y: surface[i_2].y\n            });\n          }\n        }\n\n        if (hole && hole.length > 0) {\n          var middleX = bbox.x + bbox.width / 2;\n          var middleY = bbox.y + bbox.height / 2;\n\n          for (var i_3 = 0, hlen = hole.length; i_3 < hlen; i_3++) {\n            toPoints.push({\n              x: middleX,\n              y: middleY\n            });\n          }\n        }\n\n        this._morphFromPointsReal[i][0] = fromPoints;\n        this._morphToPointsReal[i][0] = toPoints;\n      }\n    }\n\n    this.morphable.currentPoints = this._morphFromPointsReal;\n    var animation = new Animation(this, {\n      property: \"morphProgress\",\n      from: 0,\n      to: 1\n    }, duration, easing);\n\n    this._disposers.push(animation);\n\n    animation.start();\n    return animation;\n  };\n\n  Object.defineProperty(Morpher.prototype, \"morphProgress\", {\n    /**\r\n     * Returns the progress of morph transition.\r\n     *\r\n     * @return Progress (0-1)\r\n     */\n    get: function get() {\n      return this._morphProgress;\n    },\n\n    /**\r\n     * Progress of the morph transition.\r\n     *\r\n     * Setting this will also trigger actual transformation.\r\n     *\r\n     * @param value  Progress (0-1)\r\n     */\n    set: function set(value) {\n      this._morphProgress = value;\n      var currentPoints = [];\n\n      if (value != null) {\n        var fromPoints = this._morphFromPointsReal;\n        var toPoints = this._morphToPointsReal;\n\n        if (fromPoints != null && toPoints != null) {\n          for (var i = 0, len = fromPoints.length; i < len; i++) {\n            var currentArea = [];\n            currentPoints.push(currentArea);\n            var surfaceFrom = fromPoints[i][0];\n            var holeFrom = fromPoints[i][1];\n            var surfaceTo = toPoints[i][0];\n            var holeTo = toPoints[i][1];\n\n            if (surfaceFrom && surfaceFrom.length > 0 && surfaceTo && surfaceTo.length > 0) {\n              var currentSurface = [];\n\n              for (var i_4 = 0, slen = surfaceFrom.length; i_4 < slen; i_4++) {\n                var point0 = surfaceFrom[i_4];\n                var point1 = surfaceTo[i_4];\n                var currentPoint = {\n                  x: point0.x + (point1.x * this.scaleRatio - point0.x) * value,\n                  y: point0.y + (point1.y * this.scaleRatio - point0.y) * value\n                };\n                currentSurface.push(currentPoint);\n              }\n\n              currentArea[0] = currentSurface;\n            }\n\n            if (holeFrom && holeFrom.length > 0 && holeTo && holeTo.length > 0) {\n              var currentHole = [];\n\n              for (var i_5 = 0, hlen = holeFrom.length; i_5 < hlen; i_5++) {\n                var point0 = holeFrom[i_5];\n                var point1 = holeTo[i_5];\n                var currentPoint = {\n                  x: point0.x + (point1.x * this.scaleRatio - point0.x) * value,\n                  y: point0.y + (point1.y * this.scaleRatio - point0.y) * value\n                };\n                currentHole.push(currentPoint);\n              }\n\n              currentArea[1] = currentHole;\n            }\n          }\n        }\n      }\n\n      this.morphable.currentPoints = currentPoints;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Restores the polygon to its original appearance.\r\n   *\r\n   * @param duration  Duration (ms)\r\n   * @param easing    Easing function\r\n   * @return Animation\r\n   */\n\n  Morpher.prototype.morphBack = function (duration, easing) {\n    this._morphToPointsReal = this._morphFromPointsReal;\n    this._morphFromPointsReal = this.morphable.currentPoints;\n\n    if (!$type.hasValue(duration)) {\n      duration = this.morphDuration;\n    }\n\n    if (!$type.hasValue(easing)) {\n      easing = this.morphEasing;\n    }\n\n    var animation = new Animation(this, {\n      property: \"morphProgress\",\n      from: 0,\n      to: 1\n    }, duration, easing);\n\n    this._disposers.push(animation);\n\n    animation.start();\n    return animation;\n  };\n\n  Object.defineProperty(Morpher.prototype, \"animations\", {\n    /**\r\n     * Returns a list of morph animations currently being played.\r\n     *\r\n     * @return List of animations\r\n     */\n    get: function get() {\n      if (!this._animations) {\n        this._animations = [];\n\n        this._disposers.push(new AnimationDisposer(this._animations));\n      }\n\n      return this._animations;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return Morpher;\n}(BaseObject);\n\nexport { Morpher };","map":{"version":3,"mappings":"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","names":["BaseObject","Animation","AnimationDisposer","$math","$ease","$type","__extends","morphable","_super","_this","cubicOut","className","applyTheme","Morpher","toPoints","duration","easing","points","currentPoints","sortPoints","_morphFromPointsReal","_morphToPointsReal","hasValue","morphDuration","morphEasing","normalizePoints","animation","property","from","to","_disposers","push","start","pointsA","pointsB","i","len","length","surfaceA","holeA","bboxA","getValue","getBBox","middleX","x","width","middleY","y","height","addPoints","distance","Infinity","splitAt","a","newDistance","getDistance","partA","slice","partB","concat","sort","b","bbox1","bbox2","bboxes","surface","getCommonRectangle","radius","commonBBox","hole","fromPoints","bbox","morphToSingle","realRadius","isNumber","Math","min","startAngle","getAngle","count","angle","realAngle","pointOnCircle","cos","sin","i_1","hlen","mustHaveCount","addToSegmentCount","round","newPoints","point0","point1","p","percent","extraPoint","lastPoint","_bboxes","realWidth","realHeight","i_2","i_3","Object","_morphProgress","value","currentArea","surfaceFrom","holeFrom","surfaceTo","holeTo","currentSurface","i_4","slen","currentPoint","scaleRatio","currentHole","i_5","_animations"],"sourceRoot":"","sources":["../../../../../src/.internal/core/utils/Morpher.ts"],"sourcesContent":["/**\r\n * Morpher module contains functionality that allows morphing one polygon to\r\n * another.\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { BaseObject } from \"../Base\";\r\nimport { IPoint } from \"../defs/IPoint\";\r\nimport { IRectangle } from \"../defs/IRectangle\";\r\nimport { IMorphable } from \"../defs/IMorphable\";\r\nimport { IAnimatable, Animation, AnimationDisposer } from \"../utils/Animation\";\r\nimport * as $math from \"../utils/Math\";\r\nimport * as $ease from \"../utils/Ease\";\r\nimport * as $type from \"../utils/Type\";\r\n\r\n\r\n/**\r\n * Morpher can be used to morph one polygon to some other polygon.\r\n */\r\nexport class Morpher extends BaseObject implements IAnimatable {\r\n\r\n\t/**\r\n\t * An element that will be a subject for morphing.\r\n\t */\r\n\tpublic morphable: IMorphable;\r\n\r\n\t/**\r\n\t * [_morphFromPointsReal description]\r\n\t *\r\n\t * @todo Description\r\n\t */\r\n\tprotected _morphFromPointsReal: $type.Optional<Array<Array<Array<IPoint>>>>;\r\n\r\n\t/**\r\n\t * [_morphToPointsReal description]\r\n\t *\r\n\t * @todo Description\r\n\t */\r\n\tprotected _morphToPointsReal: $type.Optional<Array<Array<Array<IPoint>>>>;\r\n\r\n\t/**\r\n\t * [_morphToPoints description]\r\n\t *\r\n\t * @todo Description\r\n\t */\r\n\tprotected _morphToPoints: $type.Optional<Array<Array<Array<IPoint>>>>;\r\n\r\n\t/**\r\n\t * Morph progress (0-1)\r\n\t */\r\n\tprotected _morphProgress: $type.Optional<number>;\r\n\r\n\t/**\r\n\t * List of animations currently running.\r\n\t */\r\n\tprotected _animations: $type.Optional<Array<Animation>>;\r\n\r\n\t/**\r\n\t * A storage for measurements.\r\n\t */\r\n\tprotected _bboxes: IRectangle[] = [];\r\n\r\n\t/**\r\n\t * Duration of the morphing animation in milliseconds.\r\n\t */\r\n\tpublic morphDuration: number = 800;\r\n\r\n\t/**\r\n\t * An easing function to use for morphing animation.\r\n\t *\r\n\t * @see {@link Ease}\r\n\t */\r\n\tpublic morphEasing: (value: number) => number = $ease.cubicOut;\r\n\r\n\t/**\r\n\t * If set to `true`, all separate parts of the multi-part polygon will\r\n\t * morph into a single circle or polygon when using built-in methods\r\n\t * `morphToCircle()` or `morphToPolygon()`.\r\n\t *\r\n\t * Otherwise each separate part of polygon will morph to individual target\r\n\t * circle or polgyon.\r\n\t */\r\n\tpublic morphToSingle: boolean = true;\r\n\r\n\t/**\r\n\t * A ratio to scale morphed object in relation to the source object.\r\n\t */\r\n\tpublic scaleRatio: number = 1;\r\n\r\n\t/**\r\n\t * Constructor.\r\n\t *\r\n\t * @param morphable An object to morph\r\n\t */\r\n\tconstructor(morphable: IMorphable) {\r\n\t\tsuper();\r\n\t\tthis.className = \"Morpher\";\r\n\t\tthis.morphable = morphable;\r\n\t\tthis.applyTheme();\r\n\t}\r\n\r\n\t/**\r\n\t * Morphs a polygon to another polygon.\r\n\t *\r\n\t * @param toPoints  Corner points of the target shape\r\n\t * @param duration  Duration in milliseconds\r\n\t * @param easing    Easing function\r\n\t * @return Animation\r\n\t */\r\n\tpublic morphToPolygon(toPoints: Array<Array<Array<IPoint>>>, duration?: number, easing?: (value: number) => number): Animation {\r\n\t\tlet points: Array<Array<Array<IPoint>>> = this.morphable.currentPoints;\r\n\t\tif(points && toPoints){\r\n\t\t\tthis.sortPoints(points);\r\n\t\t\tthis.sortPoints(toPoints);\r\n\r\n\t\t\tthis._morphFromPointsReal = [];\r\n\t\t\tthis._morphToPointsReal = [];\r\n\r\n\t\t\tif (!$type.hasValue(duration)) {\r\n\t\t\t\tduration = this.morphDuration;\r\n\t\t\t}\r\n\r\n\t\t\tif (!$type.hasValue(easing)) {\r\n\t\t\t\teasing = this.morphEasing;\r\n\t\t\t}\r\n\r\n\t\t\tthis._morphFromPointsReal = this.normalizePoints(toPoints, points);\r\n\t\t\tthis._morphToPointsReal = this.normalizePoints(points, toPoints);\r\n\r\n\t\t\tthis.morphable.currentPoints = this._morphFromPointsReal;\r\n\r\n\t\t\tlet animation = new Animation(this, { property: \"morphProgress\", from: 0, to: 1 }, duration, easing);\r\n\t\t\tthis._disposers.push(animation);\r\n\t\t\tanimation.start()\r\n\t\t\treturn animation;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * [normalizePoints description]\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description\r\n\t * @param pointsA  Point A\r\n\t * @param pointsB  Point B\r\n\t * @return Normalized points\r\n\t */\r\n\tpublic normalizePoints(pointsA: Array<Array<Array<IPoint>>>, pointsB: Array<Array<Array<IPoint>>>): Array<Array<Array<IPoint>>> {\r\n\t\tfor (let i = 0, len = pointsA.length; i < len; i++) {\r\n\t\t\tlet surfaceA: Array<IPoint> = pointsA[i][0];\r\n\r\n\t\t\tlet holeA: Array<IPoint> = pointsA[i][1];\r\n\t\t\tlet bboxA: IRectangle = $type.getValue($math.getBBox(surfaceA));\r\n\r\n\t\t\tlet middleX = bboxA.x + bboxA.width;\r\n\t\t\tlet middleY = bboxA.y + bboxA.height;\r\n\r\n\t\t\t// check if we have the same in PointsB\r\n\t\t\tif (!pointsB[i]) {\r\n\t\t\t\tpointsB[i] = [];\r\n\t\t\t}\r\n\r\n\t\t\t// check if we have surface in pointsB\r\n\t\t\tif (surfaceA && !pointsB[i][0]) {\r\n\t\t\t\tpointsB[i][0] = [{ x: middleX, y: middleY }, { x: middleX, y: middleY }];\r\n\t\t\t}\r\n\r\n\t\t\tif (pointsB[i][0]) {\r\n\t\t\t\tpointsB[i][0] = this.addPoints(pointsB[i][0], surfaceA.length);\r\n\r\n\t\t\t\tlet distance = Infinity;\r\n\t\t\t\tlet splitAt = 0;\r\n\r\n\t\t\t\tfor (let a = 0; a < pointsB[i][0].length; a++) {\r\n\t\t\t\t\tlet newDistance = $math.getDistance(pointsB[i][0][a], surfaceA[0]);\r\n\t\t\t\t\tif (newDistance < distance) {\r\n\t\t\t\t\t\tsplitAt = a;\r\n\t\t\t\t\t\tdistance = newDistance;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet partA = pointsB[i][0].slice(0, splitAt);\r\n\t\t\t\tlet partB = pointsB[i][0].slice(splitAt);\r\n\t\t\t\tpointsB[i][0] = partB.concat(partA);\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif (holeA) {\r\n\t\t\t\tif (!pointsB[i][1]) {\r\n\t\t\t\t\tpointsB[i][1] = [{ x: middleX, y: middleY }, { x: middleX, y: middleY }];\r\n\t\t\t\t}\r\n\t\t\t\tpointsB[i][1] = this.addPoints(pointsB[i][1], holeA.length);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn pointsB;\r\n\t}\r\n\r\n\t/**\r\n\t * [sortPoints description]\r\n\t *\r\n\t * @ignore Exclude from doc\r\n\t * @todo Description\r\n\t * @param points  [description]\r\n\t * @return                        common bbox of points\r\n\t */\r\n\tpublic sortPoints(points: Array<Array<Array<IPoint>>>): $type.Optional<IRectangle> {\r\n\t\tpoints.sort(function(a, b) {\r\n\t\t\tlet bbox1: IRectangle = $type.getValue($math.getBBox(a[0]));\r\n\t\t\tlet bbox2: IRectangle = $type.getValue($math.getBBox(b[0]));\r\n\r\n\t\t\tif (bbox1.width * bbox1.height > bbox2.width * bbox2.height) {\r\n\t\t\t\treturn -1;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\treturn 1;\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tlet bboxes: IRectangle[] = [];\r\n\t\tfor (let i = 0, len = points.length; i < len; i++) {\r\n\t\t\tlet surface: IPoint[] = points[i][0];\r\n\t\t\tif (surface) {\r\n\t\t\t\tbboxes.push($type.getValue($math.getBBox(surface)));\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn $math.getCommonRectangle(bboxes);\r\n\t}\r\n\r\n\t/**\r\n\t * Morphs polygon to a circle (it is actually a polygon which makes a circle).\r\n\t *\r\n\t * @param radius    Target circle radius (px)\r\n\t * @param duration  Duration (ms)\r\n\t * @param easing    Easing function\r\n\t * @return Animation\r\n\t */\r\n\tpublic morphToCircle(radius?: number, duration?: number, easing?: (value: number) => number): Animation {\r\n\t\tlet points: Array<Array<Array<IPoint>>> = this.morphable.points;\r\n\r\n\t\tlet commonBBox = this.sortPoints(points);\r\n\r\n\t\tthis._morphFromPointsReal = [];\r\n\t\tthis._morphToPointsReal = [];\r\n\r\n\t\tif (!$type.hasValue(duration)) {\r\n\t\t\tduration = this.morphDuration;\r\n\t\t}\r\n\r\n\t\tif (!$type.hasValue(easing)) {\r\n\t\t\teasing = this.morphEasing;\r\n\t\t}\r\n\r\n\t\t// surface\r\n\t\tfor (let i = 0, len = points.length; i < len; i++) {\r\n\t\t\tlet surface: IPoint[] = points[i][0];\r\n\t\t\tlet hole: IPoint[] = points[i][1];\r\n\r\n\t\t\tthis._morphFromPointsReal[i] = [];\r\n\t\t\tthis._morphToPointsReal[i] = [];\r\n\r\n\t\t\tif (surface) {\r\n\r\n\t\t\t\tlet toPoints: IPoint[] = surface;\r\n\t\t\t\tlet fromPoints: IPoint[] = surface;\r\n\t\t\t\tlet bbox: IRectangle = $type.getValue($math.getBBox(fromPoints)) // this._bboxes[i];\r\n\r\n\t\t\t\tif (this.morphToSingle) {\r\n\t\t\t\t\tbbox = $type.getValue(commonBBox);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet middleX: number = bbox.x + bbox.width / 2;\r\n\t\t\t\tlet middleY: number = bbox.y + bbox.height / 2;\r\n\t\t\t\tlet realRadius: $type.Optional<number> = radius;\r\n\t\t\t\tif (!$type.isNumber(realRadius)) {\r\n\t\t\t\t\trealRadius = Math.min(bbox.width / 2, bbox.height / 2);\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttoPoints = [];\r\n\r\n\t\t\t\t// find angle for the first point\r\n\t\t\t\tlet startAngle: number = $math.getAngle({ x: middleX, y: middleY }, surface[0]);\r\n\t\t\t\tlet count: number = 100;\r\n\r\n\t\t\t\tif (surface.length > count) {\r\n\t\t\t\t\tcount = surface.length;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfromPoints = this.addPoints(surface, count);\r\n\t\t\t\tcount = fromPoints.length; // add Points might increase number a bit\r\n\r\n\t\t\t\tlet angle: number = 360 / (count - 1);\r\n\r\n\t\t\t\tfor (let a: number = 0; a < count; a++) {\r\n\t\t\t\t\tlet realAngle: number = angle * a + startAngle;\r\n\t\t\t\t\tlet pointOnCircle: IPoint = { x: middleX + realRadius * $math.cos(realAngle), y: middleY + realRadius * $math.sin(realAngle) };\r\n\t\t\t\t\ttoPoints[a] = pointOnCircle;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (hole && hole.length > 0) {\r\n\t\t\t\t\tfor (let i = 0, hlen = hole.length; i < hlen; i++) {\r\n\t\t\t\t\t\ttoPoints.push({ x: middleX, y: middleY });\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis._morphFromPointsReal[i][0] = fromPoints;\r\n\t\t\t\tthis._morphToPointsReal[i][0] = toPoints;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis.morphable.currentPoints = this._morphFromPointsReal;\r\n\r\n\t\tlet animation = new Animation(this, { property: \"morphProgress\", from: 0, to: 1 }, duration, easing);\r\n\t\tthis._disposers.push(animation);\r\n\t\tanimation.start()\r\n\t\treturn animation;\r\n\t}\r\n\r\n\t/**\r\n\t * [addPoints description]\r\n\t *\r\n\t * @ignore Exclude from doc\r\n\t * @todo Description\r\n\t * @param points         [description]\r\n\t * @param mustHaveCount  [description]\r\n\t * @return [description]\r\n\t */\r\n\tpublic addPoints(points: IPoint[], mustHaveCount: number): IPoint[] {\r\n\t\tlet addToSegmentCount: number = Math.round(mustHaveCount / points.length);\r\n\t\tlet newPoints: IPoint[] = [];\r\n\t\tfor (let i = 0, len = points.length; i < len; i++) {\r\n\t\t\tlet point0: IPoint = points[i];\r\n\t\t\tlet point1: IPoint;\r\n\t\t\tif (i == points.length - 1) {\r\n\t\t\t\tpoint1 = points[0];\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tpoint1 = points[i + 1];\r\n\t\t\t}\r\n\r\n\t\t\tnewPoints.push(point0);\r\n\r\n\t\t\tfor (let p: number = 1; p < addToSegmentCount; p++) {\r\n\t\t\t\tlet percent: number = p / addToSegmentCount;\r\n\t\t\t\tlet extraPoint: IPoint = { x: point0.x + (point1.x - point0.x) * percent, y: point0.y + (point1.y - point0.y) * percent }\r\n\t\t\t\tnewPoints.push(extraPoint);\r\n\t\t\t}\r\n\r\n\t\t\t// stop adding in case we already added more than left in original\r\n\t\t\tif (newPoints.length + points.length - i == mustHaveCount) {\r\n\t\t\t\taddToSegmentCount = 0;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (newPoints.length < mustHaveCount && points.length > 0) {\r\n\t\t\tlet lastPoint: IPoint = points[points.length - 1];\r\n\t\t\tfor (let p: number = newPoints.length; p < mustHaveCount; p++) {\r\n\t\t\t\t// add same as last\r\n\t\t\t\tnewPoints.push({ x: lastPoint.x, y: lastPoint.y });\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn newPoints;\r\n\t}\r\n\r\n\t/**\r\n\t * Morphs polygon into a rectangular polygon.\r\n\t *\r\n\t * @param width     Width of the target rectangle (px)\r\n\t * @param height    Height of the target rectangle (px)\r\n\t * @param duration  Duration (ms)\r\n\t * @param easing    Easing function\r\n\t * @return Animation\r\n\t */\r\n\tpublic morphToRectangle(width?: number, height?: number, duration?: number, easing?: (value: number) => number): Animation {\r\n\t\tlet points: Array<Array<Array<IPoint>>> = this.morphable.points;\r\n\r\n\t\tthis.sortPoints(points);\r\n\r\n\t\tthis._morphFromPointsReal = [];\r\n\t\tthis._morphToPointsReal = [];\r\n\r\n\t\tif (!$type.hasValue(duration)) {\r\n\t\t\tduration = this.morphDuration;\r\n\t\t}\r\n\r\n\t\tif (!$type.hasValue(easing)) {\r\n\t\t\teasing = this.morphEasing;\r\n\t\t}\r\n\r\n\t\t//\t\tlet biggestBBox: IRectangle = this._bboxes[this._biggestIndex];\r\n\r\n\t\t// surface\r\n\t\tfor (let i = 0, len = points.length; i < len; i++) {\r\n\t\t\tlet surface: IPoint[] = points[i][0];\r\n\t\t\tlet hole: IPoint[] = points[i][1];\r\n\r\n\t\t\tthis._morphFromPointsReal[i] = [];\r\n\t\t\tthis._morphToPointsReal[i] = [];\r\n\r\n\t\t\tif (surface) {\r\n\r\n\t\t\t\tlet toPoints: IPoint[] = surface;\r\n\t\t\t\tlet fromPoints: IPoint[] = surface;\r\n\t\t\t\tlet bbox: IRectangle = this._bboxes[i];\r\n\r\n\r\n\t\t\t\t// we only work with first area. TODO: maybe we should find the biggest one?\r\n\t\t\t\tif (this.morphToSingle) {\r\n\t\t\t\t\t//if (i != this._biggestIndex) {\r\n\t\t\t\t\t//\tbbox = { x: biggestBBox.x + biggestBBox.width / 2, y: biggestBBox.y + biggestBBox.height / 2, width: 0, height: 0 };\r\n\t\t\t\t\t//}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet x: number = bbox.x;\r\n\t\t\t\tlet y: number = bbox.y;\r\n\r\n\t\t\t\tlet realWidth: $type.Optional<number> = width;\r\n\t\t\t\tlet realHeight: $type.Optional<number> = height;\r\n\r\n\t\t\t\tif (!$type.isNumber(realWidth)) {\r\n\t\t\t\t\trealWidth = bbox.width;\r\n\t\t\t\t}\r\n\t\t\t\tif (!$type.isNumber(realHeight)) {\r\n\t\t\t\t\trealHeight = bbox.height;\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttoPoints = [{ x: x, y: y }, { x: x + realWidth, y: y }, { x: x + realWidth, y: y + realHeight }, { x: x, y: y + realHeight }];\r\n\t\t\t\ttoPoints = this.addPoints(toPoints, surface.length);\r\n\r\n\t\t\t\t// if polygon has less points then count, add\r\n\t\t\t\tif (surface.length < 4) {\r\n\t\t\t\t\tfor (let i = surface.length; i < 4; i++) {\r\n\t\t\t\t\t\ttoPoints.push({ x: surface[i].x, y: surface[i].y });\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (hole && hole.length > 0) {\r\n\t\t\t\t\tlet middleX: number = bbox.x + bbox.width / 2;\r\n\t\t\t\t\tlet middleY: number = bbox.y + bbox.height / 2;\r\n\r\n\t\t\t\t\tfor (let i = 0, hlen = hole.length; i < hlen; i++) {\r\n\t\t\t\t\t\ttoPoints.push({ x: middleX, y: middleY });\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis._morphFromPointsReal[i][0] = fromPoints;\r\n\t\t\t\tthis._morphToPointsReal[i][0] = toPoints;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis.morphable.currentPoints = this._morphFromPointsReal;\r\n\r\n\t\tlet animation = new Animation(this, { property: \"morphProgress\", from: 0, to: 1 }, duration, easing);\r\n\t\tthis._disposers.push(animation);\r\n\t\tanimation.start()\r\n\t\treturn animation;\r\n\t}\r\n\r\n\t/**\r\n\t * Progress of the morph transition.\r\n\t *\r\n\t * Setting this will also trigger actual transformation.\r\n\t *\r\n\t * @param value  Progress (0-1)\r\n\t */\r\n\tpublic set morphProgress(value: $type.Optional<number>) {\r\n\t\tthis._morphProgress = value;\r\n\r\n\t\tlet currentPoints: Array<Array<Array<IPoint>>> = [];\r\n\r\n\t\tif (value != null) {\r\n\t\t\tlet fromPoints: $type.Optional<Array<Array<Array<IPoint>>>> = this._morphFromPointsReal;\r\n\t\t\tlet toPoints: $type.Optional<Array<Array<Array<IPoint>>>> = this._morphToPointsReal;\r\n\r\n\t\t\tif (fromPoints != null && toPoints != null) {\r\n\r\n\t\t\t\tfor (let i = 0, len = fromPoints.length; i < len; i++) {\r\n\r\n\t\t\t\t\tlet currentArea: Array<Array<IPoint>> = [];\r\n\t\t\t\t\tcurrentPoints.push(currentArea);\r\n\r\n\t\t\t\t\tlet surfaceFrom: IPoint[] = fromPoints[i][0];\r\n\t\t\t\t\tlet holeFrom: IPoint[] = fromPoints[i][1];\r\n\r\n\t\t\t\t\tlet surfaceTo: IPoint[] = toPoints[i][0];\r\n\t\t\t\t\tlet holeTo: IPoint[] = toPoints[i][1];\r\n\r\n\t\t\t\t\tif (surfaceFrom && surfaceFrom.length > 0 && surfaceTo && surfaceTo.length > 0) {\r\n\r\n\t\t\t\t\t\tlet currentSurface: IPoint[] = [];\r\n\r\n\t\t\t\t\t\tfor (let i = 0, slen = surfaceFrom.length; i < slen; i++) {\r\n\t\t\t\t\t\t\tlet point0: IPoint = surfaceFrom[i];\r\n\t\t\t\t\t\t\tlet point1: IPoint = surfaceTo[i];\r\n\r\n\t\t\t\t\t\t\tlet currentPoint: IPoint = { x: point0.x + (point1.x * this.scaleRatio - point0.x) * value, y: point0.y + (point1.y * this.scaleRatio - point0.y) * value }\r\n\r\n\t\t\t\t\t\t\tcurrentSurface.push(currentPoint);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tcurrentArea[0] = currentSurface;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (holeFrom && holeFrom.length > 0 && holeTo && holeTo.length > 0) {\r\n\t\t\t\t\t\tlet currentHole: IPoint[] = [];\r\n\t\t\t\t\t\tfor (let i = 0, hlen = holeFrom.length; i < hlen; i++) {\r\n\t\t\t\t\t\t\tlet point0: IPoint = holeFrom[i];\r\n\t\t\t\t\t\t\tlet point1: IPoint = holeTo[i];\r\n\r\n\t\t\t\t\t\t\tlet currentPoint: IPoint = { x: point0.x + (point1.x * this.scaleRatio - point0.x) * value, y: point0.y + (point1.y * this.scaleRatio - point0.y) * value }\r\n\r\n\t\t\t\t\t\t\tcurrentHole.push(currentPoint);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tcurrentArea[1] = currentHole;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis.morphable.currentPoints = currentPoints;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the progress of morph transition.\r\n\t *\r\n\t * @return Progress (0-1)\r\n\t */\r\n\tpublic get morphProgress(): $type.Optional<number> {\r\n\t\treturn this._morphProgress;\r\n\t}\r\n\r\n\t/**\r\n\t * Restores the polygon to its original appearance.\r\n\t *\r\n\t * @param duration  Duration (ms)\r\n\t * @param easing    Easing function\r\n\t * @return Animation\r\n\t */\r\n\tpublic morphBack(duration?: number, easing?: (value: number) => number): Animation {\r\n\t\tthis._morphToPointsReal = this._morphFromPointsReal;\r\n\t\tthis._morphFromPointsReal = this.morphable.currentPoints;\r\n\r\n\t\tif (!$type.hasValue(duration)) {\r\n\t\t\tduration = this.morphDuration;\r\n\t\t}\r\n\r\n\t\tif (!$type.hasValue(easing)) {\r\n\t\t\teasing = this.morphEasing;\r\n\t\t}\r\n\r\n\t\tlet animation = new Animation(this, { property: \"morphProgress\", from: 0, to: 1 }, duration, easing);\r\n\t\tthis._disposers.push(animation);\r\n\t\tanimation.start()\r\n\t\treturn animation;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a list of morph animations currently being played.\r\n\t *\r\n\t * @return List of animations\r\n\t */\r\n\tpublic get animations(): Array<Animation> {\r\n\t\tif (!this._animations) {\r\n\t\t\tthis._animations = [];\r\n\t\t\tthis._disposers.push(new AnimationDisposer(this._animations));\r\n\t\t}\r\n\t\treturn this._animations;\r\n\t}\r\n\r\n}\r\n"]},"metadata":{},"sourceType":"module"}