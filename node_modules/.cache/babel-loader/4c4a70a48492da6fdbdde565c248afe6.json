{"ast":null,"code":"/**\r\n * HeatLegend module\r\n */\nimport { __extends } from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\nimport { Container } from \"../../core/Container\";\nimport { LinearGradient } from \"../../core/rendering/fills/LinearGradient\";\nimport { registry } from \"../../core/Registry\";\nimport { toColor, Color } from \"../../core/utils/Color\";\nimport { ListTemplate, ListDisposer } from \"../../core/utils/List\";\nimport { percent } from \"../../core/utils/Percent\";\nimport { ValueAxis } from \"../../charts/axes/ValueAxis\";\nimport { AxisRendererX } from \"../../charts/axes/AxisRendererX\";\nimport { AxisRendererY } from \"../../charts/axes/AxisRendererY\";\nimport * as $iter from \"../../core/utils/Iterator\";\nimport * as $type from \"../../core/utils/Type\";\nimport * as $colors from \"../../core/utils/Colors\";\nimport { RoundedRectangle } from \"../../core/elements/RoundedRectangle\";\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * This class creates a link (waved color-filled line) between two nodes in a\r\n * Sankey Diagram.\r\n *\r\n * @see {@link IHeatLegendEvents} for a list of available events\r\n * @see {@link IHeatLegendAdapters} for a list of available Adapters\r\n * @important\r\n */\n\nvar HeatLegend =\n/** @class */\nfunction (_super) {\n  __extends(HeatLegend, _super);\n  /**\r\n   * Constructor\r\n   */\n\n\n  function HeatLegend() {\n    var _this = _super.call(this) || this;\n\n    _this.className = \"HeatLegend\";\n    _this.markerContainer = _this.createChild(Container);\n    _this.markerContainer.shouldClone = false;\n    _this.markerCount = 1; // Create a template container and list for the a marker\n\n    var marker = new RoundedRectangle();\n    marker.minHeight = 20;\n    marker.minWidth = 20;\n    marker.interactionsEnabled = false;\n    marker.fillOpacity = 1;\n    marker.cornerRadius(0, 0, 0, 0);\n    _this.markerContainer.minHeight = 20;\n    _this.markerContainer.minWidth = 20;\n    _this.orientation = \"horizontal\";\n    _this.markers = new ListTemplate(marker);\n\n    _this._disposers.push(new ListDisposer(_this.markers));\n\n    _this._disposers.push(_this.markers.template);\n\n    _this.applyTheme();\n\n    return _this;\n  }\n\n  HeatLegend.prototype.getMinFromRules = function (property) {\n    var series = this.series;\n\n    if (series) {\n      var minValue_1;\n      $iter.eachContinue(series.heatRules.iterator(), function (heatRule) {\n        if (heatRule.property == property) {\n          minValue_1 = heatRule.min;\n          return false;\n        }\n\n        return true;\n      });\n      return minValue_1;\n    }\n  };\n\n  HeatLegend.prototype.getMaxFromRules = function (property) {\n    var series = this.series;\n\n    if (series) {\n      var maxValue_1;\n      $iter.each(series.heatRules.iterator(), function (heatRule) {\n        if (heatRule.property == property) {\n          maxValue_1 = heatRule.max;\n          return false;\n        }\n\n        return true;\n      });\n      return maxValue_1;\n    }\n  };\n  /**\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  HeatLegend.prototype.validate = function () {\n    _super.prototype.validate.call(this);\n\n    this.valueAxis.renderer.inversed = this.reverseOrder;\n    var series = this.series;\n    var minColor = this.minColor;\n    var maxColor = this.maxColor;\n\n    if (!$type.hasValue(minColor)) {\n      minColor = toColor(this.getMinFromRules(\"fill\"));\n    }\n\n    if (!$type.hasValue(maxColor)) {\n      maxColor = toColor(this.getMaxFromRules(\"fill\"));\n    }\n\n    if (series) {\n      var seriesFill = series.fill;\n\n      if (!$type.hasValue(minColor) && seriesFill instanceof Color) {\n        minColor = seriesFill;\n      }\n\n      if (!$type.hasValue(maxColor) && seriesFill instanceof Color) {\n        maxColor = seriesFill;\n      }\n    }\n\n    if (!$type.hasValue(maxColor)) {\n      maxColor = toColor(this.getMaxFromRules(\"fill\"));\n    }\n\n    var minOpacity = $type.toNumber(this.getMinFromRules(\"fillOpacity\"));\n\n    if (!$type.isNumber(minOpacity)) {\n      minOpacity = 1;\n    }\n\n    var maxOpacity = $type.toNumber(this.getMaxFromRules(\"fillOpacity\"));\n\n    if (!$type.isNumber(maxOpacity)) {\n      maxOpacity = 1;\n    }\n\n    var minStrokeOpacity = $type.toNumber(this.getMinFromRules(\"strokeOpacity\"));\n\n    if (!$type.isNumber(minStrokeOpacity)) {\n      minStrokeOpacity = 1;\n    }\n\n    var maxStrokeOpacity = $type.toNumber(this.getMaxFromRules(\"strokeOpacity\"));\n\n    if (!$type.isNumber(maxStrokeOpacity)) {\n      maxStrokeOpacity = 1;\n    }\n\n    var minStroke = toColor(this.getMinFromRules(\"stroke\"));\n    var maxStroke = toColor(this.getMaxFromRules(\"stroke\")); //if (series) {\n\n    for (var i = 0; i < this.markerCount; i++) {\n      var marker = this.markers.getIndex(i);\n\n      if (!marker) {\n        marker = this.markers.create();\n        marker.parent = this.markerContainer;\n        marker.height = percent(100);\n        marker.width = percent(100);\n      }\n\n      if (this.markerCount == 1) {\n        var gradient = new LinearGradient();\n\n        if (this.reverseOrder) {\n          gradient.addColor(maxColor, maxOpacity);\n          gradient.addColor(minColor, minOpacity);\n        } else {\n          gradient.addColor(minColor, minOpacity);\n          gradient.addColor(maxColor, maxOpacity);\n        }\n\n        if (this.orientation == \"vertical\") {\n          gradient.rotation = -90;\n        }\n\n        marker.fill = gradient;\n\n        if ($type.hasValue(minStroke) && $type.hasValue(maxStroke)) {\n          var strokeGradient = new LinearGradient();\n\n          if (this.reverseOrder) {\n            strokeGradient.addColor(maxStroke, maxStrokeOpacity);\n            strokeGradient.addColor(minStroke, minStrokeOpacity);\n          } else {\n            strokeGradient.addColor(minStroke, minStrokeOpacity);\n            strokeGradient.addColor(maxStroke, maxStrokeOpacity);\n          }\n\n          if (this.orientation == \"vertical\") {\n            strokeGradient.rotation = -90;\n          }\n\n          marker.stroke = strokeGradient;\n        }\n      } else {\n        var c = i;\n\n        if (this.reverseOrder) {\n          c = this.markerCount - i - 1;\n        }\n\n        var color = new Color($colors.interpolate(minColor.rgb, maxColor.rgb, c / this.markerCount));\n        marker.fill = color;\n        var opacity = minOpacity + (maxOpacity - minOpacity) * c / this.markerCount;\n        marker.fillOpacity = opacity;\n\n        if ($type.hasValue(minStroke) && $type.hasValue(maxStroke)) {\n          var color_1 = new Color($colors.interpolate(minStroke.rgb, maxStroke.rgb, c / this.markerCount));\n          marker.stroke = color_1;\n          var opacity_1 = minStrokeOpacity + (maxStrokeOpacity - minStrokeOpacity) * c / this.markerCount;\n          marker.strokeOpacity = opacity_1;\n        }\n      }\n    }\n\n    var renderer = this.valueAxis.renderer;\n\n    if (this.markerCount > 1) {\n      if (this.orientation == \"horizontal\") {\n        renderer.minGridDistance = this.measuredWidth / this.markerCount;\n      } else {\n        renderer.minGridDistance = this.measuredHeight / this.markerCount;\n      }\n    }\n\n    this.valueAxis.invalidate();\n\n    for (var i = this.markerCount, len = this.markers.length; i < len; i++) {\n      this.markers.getIndex(i).parent = undefined;\n    }\n  };\n\n  Object.defineProperty(HeatLegend.prototype, \"minColor\", {\n    /**\r\n     * Returns minColor value\r\n     * @return {Color}\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"minColor\");\n    },\n\n    /**\r\n     * Min color of a heat legend. If a series is set for the legend, minColor is taken from series.\r\n     *\r\n     * @param {Color}\r\n     */\n    set: function (value) {\n      if (!(value instanceof Color)) {\n        value = toColor(value);\n      }\n\n      this.setColorProperty(\"minColor\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(HeatLegend.prototype, \"maxColor\", {\n    /**\r\n     * Returns maxColor value\r\n     * @return {Color}\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"maxColor\");\n    },\n\n    /**\r\n     * Max color of a heat legend. If a series is set for the legend, maxColor is taken from series.\r\n     *\r\n     * @param {Color}\r\n     */\n    set: function (value) {\n      if (!(value instanceof Color)) {\n        value = toColor(value);\n      }\n\n      this.setColorProperty(\"maxColor\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(HeatLegend.prototype, \"markerCount\", {\n    /**\r\n     * Returns number of color squares (markers).\r\n     * @return {number}\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"markerCount\");\n    },\n\n    /**\r\n     * Number of color squares (markers) in the heat legend. If only 1 marker is used, it will be filled with gradient.\r\n     *\r\n     * @param {number}\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"markerCount\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(HeatLegend.prototype, \"minValue\", {\n    /**\r\n     * Returns minimum value of heat legend.\r\n     * @return {number}\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"minValue\");\n    },\n\n    /**\r\n     * Minimum value of heat legend's value axis. If a series is set for the legend, min is taken from series.\r\n     *\r\n     * @param {number}\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"minValue\", value);\n      this.valueAxis.min = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(HeatLegend.prototype, \"maxValue\", {\n    /**\r\n     * Returns maximum value of heat legend.\r\n     * @return {number}\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"maxValue\");\n    },\n\n    /**\r\n     * Maximum value of heat legend's value axis. If a series is set for the legend, max is taken from series.\r\n     *\r\n     * @param {number}\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"maxValue\", value);\n      this.valueAxis.max = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(HeatLegend.prototype, \"orientation\", {\n    /**\r\n     * Returns orientation value.\r\n     *\r\n     * @return {\"horizontal\" | \"vertical\"}\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"orientation\");\n    },\n\n    /**\r\n    * Heat legend orientation. Note, if you change orientation of a heat legend, you must set value axis renderer properties after that, as with orientation renderer changes.\r\n    *\r\n    * @param {\"horizontal\" | \"vertical\"}\r\n    */\n    set: function (value) {\n      this.setPropertyValue(\"orientation\", value, true);\n      var markerContainer = this.markerContainer;\n      var valueAxis = this.valueAxis; // HORIZONTAL\n\n      if (value == \"horizontal\") {\n        if (!$type.hasValue(this.width)) {\n          this.width = 200;\n        }\n\n        this.height = undefined;\n        valueAxis.width = percent(100);\n        valueAxis.height = undefined;\n        valueAxis.tooltip.pointerOrientation = \"vertical\";\n        this.layout = \"vertical\";\n        markerContainer.width = percent(100);\n        markerContainer.height = undefined;\n\n        if (!(valueAxis.renderer instanceof AxisRendererX)) {\n          valueAxis.renderer = new AxisRendererX();\n        }\n      } // VERTICAL\n      else {\n        if (!$type.hasValue(this.height)) {\n          this.height = 200;\n        }\n\n        this.width = undefined;\n        this.layout = \"horizontal\";\n        markerContainer.width = undefined;\n        markerContainer.height = percent(100);\n        valueAxis.height = percent(100);\n        valueAxis.width = undefined;\n        valueAxis.tooltip.pointerOrientation = \"horizontal\";\n\n        if (!(valueAxis.renderer instanceof AxisRendererY)) {\n          valueAxis.renderer = new AxisRendererY();\n        }\n\n        valueAxis.renderer.inside = true;\n        valueAxis.renderer.labels.template.inside = true;\n        this.markerContainer.reverseOrder = true;\n      }\n\n      var renderer = valueAxis.renderer;\n      renderer.grid.template.disabled = true;\n      renderer.axisFills.template.disabled = true;\n      renderer.baseGrid.disabled = true;\n      renderer.labels.template.padding(2, 3, 2, 3);\n      renderer.minHeight = undefined;\n      renderer.minWidth = undefined;\n      this.markerContainer.layout = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(HeatLegend.prototype, \"valueAxis\", {\n    /**\r\n     * Returns valueAxis value.\r\n     * @return {ValueAxis}\r\n     */\n    get: function () {\n      if (!this._valueAxis) {\n        this.valueAxis = this.createChild(ValueAxis);\n        this.valueAxis.shouldClone = false;\n      }\n\n      return this._valueAxis;\n    },\n\n    /**\r\n     * Sets a value axis of heat legend. Value axis for heat legend is created automatically.\r\n     * @param {ValueAxis}\r\n     */\n    set: function (valueAxis) {\n      this._valueAxis = valueAxis;\n      valueAxis.parent = this;\n      valueAxis.strictMinMax = true;\n      this.orientation = this.orientation;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(HeatLegend.prototype, \"series\", {\n    /**\r\n     * Returns series value.\r\n     * @return {Series}\r\n     */\n    get: function () {\n      return this._series;\n    },\n\n    /**\r\n     * You can set series for heat legend. It will take min, max, minColor and maxColor values from this series.\r\n     * @param series\r\n     */\n    set: function (series) {\n      var _this = this;\n\n      this._series = series;\n      var dataField = \"value\";\n\n      try {\n        var dataFieldDefined = series.heatRules.getIndex(0).dataField;\n\n        if (dataFieldDefined) {\n          dataField = dataFieldDefined;\n        }\n      } catch (err) {}\n\n      this.updateMinMax(series.dataItem.values[dataField].low, series.dataItem.values[dataField].high);\n      series.dataItem.events.on(\"calculatedvaluechanged\", function (event) {\n        _this.updateMinMax(series.dataItem.values[dataField].low, series.dataItem.values[dataField].high);\n      }, undefined, false);\n      series.heatRules.events.on(\"inserted\", this.invalidate, this, false);\n      series.heatRules.events.on(\"removed\", this.invalidate, this, false);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Updates min/max of value axis.\r\n   * @ignore\r\n   */\n\n  HeatLegend.prototype.updateMinMax = function (min, max) {\n    var valueAxis = this.valueAxis;\n\n    if (!$type.isNumber(this.minValue)) {\n      valueAxis.min = min;\n      valueAxis.invalidate();\n    }\n\n    if (!$type.isNumber(this.maxValue)) {\n      valueAxis.max = max;\n      valueAxis.invalidate();\n    }\n  };\n  /**\r\n   * Processes JSON-based config before it is applied to the object.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param config  Config\r\n   */\n\n\n  HeatLegend.prototype.processConfig = function (config) {\n    if (config) {\n      // Set up series\n      if ($type.hasValue(config.series) && $type.isString(config.series)) {\n        if ($type.isString(config.series)) {\n          if (this.map.hasKey(config.series)) {\n            config.series = this.map.getKey(config.series);\n          } else {\n            var seriesId_1 = config.series;\n            var disposer_1 = this.map.events.on(\"insertKey\", function (ev) {\n              if (ev.key == seriesId_1) {\n                this.series = ev.newValue;\n                disposer_1.dispose();\n              }\n            }, this);\n\n            this._disposers.push(disposer_1);\n\n            delete config.series;\n          }\n        }\n      }\n    }\n\n    _super.prototype.processConfig.call(this, config);\n  };\n\n  return HeatLegend;\n}(Container);\n\nexport { HeatLegend };\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\n\nregistry.registeredClasses[\"HeatLegend\"] = HeatLegend;","map":{"version":3,"mappings":"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","names":["Container","LinearGradient","registry","toColor","Color","ListTemplate","ListDisposer","percent","ValueAxis","AxisRendererX","AxisRendererY","$iter","$type","$colors","RoundedRectangle","__extends","_super","_this","className","markerContainer","createChild","shouldClone","markerCount","marker","minHeight","minWidth","interactionsEnabled","fillOpacity","cornerRadius","orientation","markers","_disposers","push","template","applyTheme","HeatLegend","property","series","minValue_1","eachContinue","heatRules","iterator","heatRule","min","maxValue_1","each","max","validate","call","valueAxis","renderer","inversed","reverseOrder","minColor","maxColor","hasValue","getMinFromRules","getMaxFromRules","seriesFill","fill","minOpacity","toNumber","isNumber","maxOpacity","minStrokeOpacity","maxStrokeOpacity","minStroke","maxStroke","i","getIndex","create","parent","height","width","gradient","addColor","rotation","strokeGradient","stroke","c","color","interpolate","rgb","opacity","color_1","opacity_1","strokeOpacity","minGridDistance","measuredWidth","measuredHeight","invalidate","len","length","undefined","Object","getPropertyValue","value","setColorProperty","setPropertyValue","tooltip","pointerOrientation","layout","inside","labels","grid","disabled","axisFills","baseGrid","padding","_valueAxis","strictMinMax","_series","dataField","dataFieldDefined","err","updateMinMax","dataItem","values","low","high","events","on","event","minValue","maxValue","config","isString","map","hasKey","getKey","seriesId_1","disposer_1","ev","key","newValue","dispose","processConfig","registeredClasses"],"sourceRoot":"","sources":["../../../../../src/.internal/charts/elements/HeatLegend.ts"],"sourcesContent":["/**\r\n * HeatLegend module\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { Container, IContainerProperties, IContainerEvents, IContainerAdapters } from \"../../core/Container\";\r\nimport { Series } from \"../series/Series\";\r\nimport { LinearGradient } from \"../../core/rendering/fills/LinearGradient\";\r\nimport { registry } from \"../../core/Registry\";\r\nimport { toColor, Color } from \"../../core/utils/Color\";\r\nimport { ListTemplate, ListDisposer } from \"../../core/utils/List\";\r\nimport { percent } from \"../../core/utils/Percent\";\r\nimport { ValueAxis } from \"../../charts/axes/ValueAxis\";\r\nimport { AxisRendererX } from \"../../charts/axes/AxisRendererX\";\r\nimport { AxisRendererY } from \"../../charts/axes/AxisRendererY\";\r\nimport * as $iter from \"../../core/utils/Iterator\";\r\nimport * as $type from \"../../core/utils/Type\";\r\nimport * as $colors from \"../../core/utils/Colors\";\r\nimport { RoundedRectangle } from \"../../core/elements/RoundedRectangle\";\r\n\r\n/**\r\n * ============================================================================\r\n * REQUISITES\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Defines properties for [[HeatLegend]].\r\n */\r\nexport interface IHeatLegendProperties extends IContainerProperties {\r\n\r\n\t/**\r\n\t * Minimum color\r\n\t *\r\n\t * @todo Description\r\n\t */\r\n\tminColor?: Color;\r\n\r\n\t/**\r\n\t * Minimum value\r\n\t *\r\n\t * @todo Description\r\n\t */\r\n\tminValue?: number;\r\n\r\n\t/**\r\n\t * Maximum value\r\n\t *\r\n\t * @todo Description\r\n\t */\r\n\tmaxValue?: number;\r\n\r\n\r\n\t/**\r\n\t * Maximum color\r\n\t *\r\n\t * @todo Description\r\n\t */\r\n\tmaxColor?: Color;\r\n\r\n\t/**\r\n\t * Number of markers (steps)\r\n\t *\r\n\t * @todo Description\r\n\t */\r\n\tmarkerCount?: number;\r\n\r\n\r\n\t/**\r\n\t * Orientation\r\n\t *\r\n\t * @todo Description\r\n\t */\r\n\torientation?: \"horizontal\" | \"vertical\";\r\n\r\n}\r\n\r\n/**\r\n * Defines events for [[HeatLegend]].\r\n */\r\nexport interface IHeatLegendEvents extends IContainerEvents { }\r\n\r\n/**\r\n * Defines adapters for [[HeatLegend]].\r\n *\r\n * @see {@link Adapter}\r\n */\r\nexport interface IHeatLegendAdapters extends IContainerAdapters, IHeatLegendProperties { }\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * This class creates a link (waved color-filled line) between two nodes in a\r\n * Sankey Diagram.\r\n *\r\n * @see {@link IHeatLegendEvents} for a list of available events\r\n * @see {@link IHeatLegendAdapters} for a list of available Adapters\r\n * @important\r\n */\r\nexport class HeatLegend extends Container {\r\n\r\n\t/**\r\n\t * Defines available properties.\r\n\t */\r\n\tpublic _properties!: IHeatLegendProperties;\r\n\r\n\t/**\r\n\t * Defines available adapters.\r\n\t */\r\n\tpublic _adapter!: IHeatLegendAdapters;\r\n\r\n\t/**\r\n\t * Defines available events.\r\n\t */\r\n\tpublic _events!: IHeatLegendEvents;\r\n\r\n\t/**\r\n\t * List of heat legend markers (color step rectangles).\r\n\t */\r\n\tpublic markers: ListTemplate<RoundedRectangle>;\r\n\r\n\t/**\r\n\t * Container which holds markers\r\n\t */\r\n\tpublic markerContainer: Container;\r\n\r\n\t/**\r\n\t * Value axis of a heat legend\r\n\t * @ignore\r\n\t */\r\n\tprotected _valueAxis: ValueAxis;\r\n\r\n\t/**\r\n\t * Series of a heat legend\r\n\t * @ignore\r\n\t */\r\n\tprotected _series: Series;\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor() {\r\n\t\tsuper();\r\n\t\tthis.className = \"HeatLegend\";\r\n\r\n\t\tthis.markerContainer = this.createChild(Container);\r\n\t\tthis.markerContainer.shouldClone = false;\r\n\r\n\t\tthis.markerCount = 1;\r\n\r\n\t\t// Create a template container and list for the a marker\r\n\t\tlet marker: RoundedRectangle = new RoundedRectangle();\r\n\t\tmarker.minHeight = 20;\r\n\t\tmarker.minWidth = 20;\r\n\t\tmarker.interactionsEnabled = false;\r\n\t\tmarker.fillOpacity = 1;\r\n\t\tmarker.cornerRadius(0, 0, 0, 0);\r\n\r\n\t\tthis.markerContainer.minHeight = 20;\r\n\t\tthis.markerContainer.minWidth = 20;\r\n\r\n\t\tthis.orientation = \"horizontal\";\r\n\r\n\t\tthis.markers = new ListTemplate<RoundedRectangle>(marker);\r\n\t\tthis._disposers.push(new ListDisposer(this.markers));\r\n\t\tthis._disposers.push(this.markers.template);\r\n\r\n\t\tthis.applyTheme();\r\n\t}\r\n\r\n\r\n\tprotected getMinFromRules(property: string, ) {\r\n\t\tlet series = this.series;\r\n\t\tif (series) {\r\n\t\t\tlet minValue;\r\n\t\t\t$iter.eachContinue(series.heatRules.iterator(), (heatRule) => {\r\n\t\t\t\tif (heatRule.property == property) {\r\n\t\t\t\t\tminValue = heatRule.min;\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t\treturn true;\r\n\t\t\t})\r\n\t\t\treturn minValue;\r\n\t\t}\r\n\t}\r\n\r\n\tprotected getMaxFromRules(property: string, ) {\r\n\t\tlet series = this.series;\r\n\t\tif (series) {\r\n\t\t\tlet maxValue;\r\n\t\t\t$iter.each(series.heatRules.iterator(), (heatRule) => {\r\n\t\t\t\tif (heatRule.property == property) {\r\n\t\t\t\t\tmaxValue = heatRule.max;\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t\treturn true;\r\n\t\t\t});\r\n\t\t\treturn maxValue;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic validate() {\r\n\t\tsuper.validate();\r\n\r\n\t\tthis.valueAxis.renderer.inversed = this.reverseOrder;\r\n\r\n\t\tlet series = this.series;\r\n\r\n\t\tlet minColor = this.minColor;\r\n\t\tlet maxColor = this.maxColor;\r\n\r\n\t\tif (!$type.hasValue(minColor)) {\r\n\t\t\tminColor = toColor(this.getMinFromRules(\"fill\"));\r\n\t\t}\r\n\r\n\t\tif (!$type.hasValue(maxColor)) {\r\n\t\t\tmaxColor = toColor(this.getMaxFromRules(\"fill\"));\r\n\t\t}\r\n\r\n\t\tif (series) {\r\n\t\t\tlet seriesFill = series.fill;\r\n\t\t\tif (!$type.hasValue(minColor) && seriesFill instanceof Color) {\r\n\t\t\t\tminColor = seriesFill;\r\n\t\t\t}\r\n\t\t\tif (!$type.hasValue(maxColor) && seriesFill instanceof Color) {\r\n\t\t\t\tmaxColor = seriesFill;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (!$type.hasValue(maxColor)) {\r\n\t\t\tmaxColor = toColor(this.getMaxFromRules(\"fill\"));\r\n\t\t}\r\n\r\n\t\tlet minOpacity = $type.toNumber(this.getMinFromRules(\"fillOpacity\"));\r\n\t\tif (!$type.isNumber(minOpacity)) {\r\n\t\t\tminOpacity = 1;\r\n\t\t}\r\n\t\tlet maxOpacity = $type.toNumber(this.getMaxFromRules(\"fillOpacity\"));\r\n\t\tif (!$type.isNumber(maxOpacity)) {\r\n\t\t\tmaxOpacity = 1;\r\n\t\t}\r\n\r\n\r\n\t\tlet minStrokeOpacity = $type.toNumber(this.getMinFromRules(\"strokeOpacity\"));\r\n\t\tif (!$type.isNumber(minStrokeOpacity)) {\r\n\t\t\tminStrokeOpacity = 1;\r\n\t\t}\r\n\t\tlet maxStrokeOpacity = $type.toNumber(this.getMaxFromRules(\"strokeOpacity\"));\r\n\t\tif (!$type.isNumber(maxStrokeOpacity)) {\r\n\t\t\tmaxStrokeOpacity = 1;\r\n\t\t}\r\n\r\n\t\tlet minStroke = toColor(this.getMinFromRules(\"stroke\"));\r\n\t\tlet maxStroke = toColor(this.getMaxFromRules(\"stroke\"));\r\n\r\n\r\n\t\t//if (series) {\r\n\t\tfor (let i = 0; i < this.markerCount; i++) {\r\n\t\t\tlet marker = this.markers.getIndex(i);\r\n\r\n\t\t\tif (!marker) {\r\n\t\t\t\tmarker = this.markers.create();\r\n\t\t\t\tmarker.parent = this.markerContainer;\r\n\t\t\t\tmarker.height = percent(100);\r\n\t\t\t\tmarker.width = percent(100);\r\n\t\t\t}\r\n\r\n\r\n\t\t\tif (this.markerCount == 1) {\r\n\t\t\t\tlet gradient = new LinearGradient();\r\n\t\t\t\tif (this.reverseOrder) {\r\n\t\t\t\t\tgradient.addColor(maxColor, maxOpacity);\r\n\t\t\t\t\tgradient.addColor(minColor, minOpacity);\r\n\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tgradient.addColor(minColor, minOpacity);\r\n\t\t\t\t\tgradient.addColor(maxColor, maxOpacity);\r\n\t\t\t\t}\r\n\r\n\r\n\t\t\t\tif (this.orientation == \"vertical\") {\r\n\t\t\t\t\tgradient.rotation = -90;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tmarker.fill = gradient;\r\n\t\t\t\tif ($type.hasValue(minStroke) && $type.hasValue(maxStroke)) {\r\n\t\t\t\t\tlet strokeGradient = new LinearGradient();\r\n\t\t\t\t\tif (this.reverseOrder) {\r\n\t\t\t\t\t\tstrokeGradient.addColor(maxStroke, maxStrokeOpacity);\r\n\t\t\t\t\t\tstrokeGradient.addColor(minStroke, minStrokeOpacity);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tstrokeGradient.addColor(minStroke, minStrokeOpacity);\r\n\t\t\t\t\t\tstrokeGradient.addColor(maxStroke, maxStrokeOpacity);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (this.orientation == \"vertical\") {\r\n\t\t\t\t\t\tstrokeGradient.rotation = -90;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tmarker.stroke = strokeGradient;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tlet c = i;\r\n\t\t\t\tif (this.reverseOrder) {\r\n\t\t\t\t\tc = this.markerCount - i - 1;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet color = new Color($colors.interpolate(minColor.rgb, maxColor.rgb, c / this.markerCount));\r\n\t\t\t\tmarker.fill = color;\r\n\r\n\t\t\t\tlet opacity = minOpacity + (maxOpacity - minOpacity) * c / this.markerCount;\r\n\t\t\t\tmarker.fillOpacity = opacity;\r\n\r\n\t\t\t\tif ($type.hasValue(minStroke) && $type.hasValue(maxStroke)) {\r\n\t\t\t\t\tlet color = new Color($colors.interpolate(minStroke.rgb, maxStroke.rgb, c / this.markerCount));\r\n\t\t\t\t\tmarker.stroke = color;\r\n\r\n\t\t\t\t\tlet opacity = minStrokeOpacity + (maxStrokeOpacity - minStrokeOpacity) * c / this.markerCount;\r\n\t\t\t\t\tmarker.strokeOpacity = opacity;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tlet renderer = this.valueAxis.renderer;\r\n\t\tif (this.markerCount > 1) {\r\n\t\t\tif (this.orientation == \"horizontal\") {\r\n\t\t\t\trenderer.minGridDistance = this.measuredWidth / this.markerCount;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\trenderer.minGridDistance = this.measuredHeight / this.markerCount;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis.valueAxis.invalidate();\r\n\r\n\t\tfor (let i = this.markerCount, len = this.markers.length; i < len; i++) {\r\n\t\t\tthis.markers.getIndex(i).parent = undefined;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Min color of a heat legend. If a series is set for the legend, minColor is taken from series.\r\n\t *\r\n\t * @param {Color}\r\n\t */\r\n\tpublic set minColor(value: Color) {\r\n\r\n\t\tif (!(value instanceof Color)) {\r\n\t\t\tvalue = toColor(value);\r\n\t\t}\r\n\r\n\t\tthis.setColorProperty(\"minColor\", value, true);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns minColor value\r\n\t * @return {Color}\r\n\t */\r\n\tpublic get minColor(): Color {\r\n\t\treturn this.getPropertyValue(\"minColor\");\r\n\t}\r\n\r\n\t/**\r\n\t * Max color of a heat legend. If a series is set for the legend, maxColor is taken from series.\r\n\t *\r\n\t * @param {Color}\r\n\t */\r\n\tpublic set maxColor(value: Color) {\r\n\r\n\t\tif (!(value instanceof Color)) {\r\n\t\t\tvalue = toColor(value);\r\n\t\t}\r\n\r\n\t\tthis.setColorProperty(\"maxColor\", value, true);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns maxColor value\r\n\t * @return {Color}\r\n\t */\r\n\tpublic get maxColor(): Color {\r\n\t\treturn this.getPropertyValue(\"maxColor\");\r\n\t}\r\n\r\n\t/**\r\n\t * Number of color squares (markers) in the heat legend. If only 1 marker is used, it will be filled with gradient.\r\n\t *\r\n\t * @param {number}\r\n\t */\r\n\tpublic set markerCount(value: number) {\r\n\t\tthis.setPropertyValue(\"markerCount\", value, true);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns number of color squares (markers).\r\n\t * @return {number}\r\n\t */\r\n\tpublic get markerCount(): number {\r\n\t\treturn this.getPropertyValue(\"markerCount\");\r\n\t}\r\n\r\n\t/**\r\n\t * Minimum value of heat legend's value axis. If a series is set for the legend, min is taken from series.\r\n\t *\r\n\t * @param {number}\r\n\t */\r\n\tpublic set minValue(value: number) {\r\n\t\tthis.setPropertyValue(\"minValue\", value);\r\n\t\tthis.valueAxis.min = value;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns minimum value of heat legend.\r\n\t * @return {number}\r\n\t */\r\n\tpublic get minValue(): number {\r\n\t\treturn this.getPropertyValue(\"minValue\");\r\n\t}\r\n\r\n\t/**\r\n\t * Maximum value of heat legend's value axis. If a series is set for the legend, max is taken from series.\r\n\t *\r\n\t * @param {number}\r\n\t */\r\n\tpublic set maxValue(value: number) {\r\n\t\tthis.setPropertyValue(\"maxValue\", value);\r\n\t\tthis.valueAxis.max = value;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns maximum value of heat legend.\r\n\t * @return {number}\r\n\t */\r\n\tpublic get maxValue(): number {\r\n\t\treturn this.getPropertyValue(\"maxValue\");\r\n\t}\r\n\r\n\t/**\r\n\t* Heat legend orientation. Note, if you change orientation of a heat legend, you must set value axis renderer properties after that, as with orientation renderer changes.\r\n\t*\r\n\t* @param {\"horizontal\" | \"vertical\"}\r\n\t*/\r\n\tpublic set orientation(value: \"horizontal\" | \"vertical\") {\r\n\t\tthis.setPropertyValue(\"orientation\", value, true);\r\n\t\tlet markerContainer = this.markerContainer;\r\n\t\tlet valueAxis = this.valueAxis;\r\n\r\n\t\t// HORIZONTAL\r\n\t\tif (value == \"horizontal\") {\r\n\t\t\tif (!$type.hasValue(this.width)) {\r\n\t\t\t\tthis.width = 200;\r\n\t\t\t}\r\n\t\t\tthis.height = undefined;\r\n\r\n\t\t\tvalueAxis.width = percent(100);\r\n\t\t\tvalueAxis.height = undefined;\r\n\t\t\tvalueAxis.tooltip.pointerOrientation = \"vertical\";\r\n\r\n\t\t\tthis.layout = \"vertical\";\r\n\t\t\tmarkerContainer.width = percent(100);\r\n\t\t\tmarkerContainer.height = undefined;\r\n\t\t\tif (!(valueAxis.renderer instanceof AxisRendererX)) {\r\n\t\t\t\tvalueAxis.renderer = new AxisRendererX();\r\n\t\t\t}\r\n\t\t}\r\n\t\t// VERTICAL\r\n\t\telse {\r\n\t\t\tif (!$type.hasValue(this.height)) {\r\n\t\t\t\tthis.height = 200;\r\n\t\t\t}\r\n\t\t\tthis.width = undefined;\r\n\t\t\tthis.layout = \"horizontal\";\r\n\t\t\tmarkerContainer.width = undefined;\r\n\t\t\tmarkerContainer.height = percent(100);\r\n\t\t\tvalueAxis.height = percent(100);\r\n\t\t\tvalueAxis.width = undefined;\r\n\t\t\tvalueAxis.tooltip.pointerOrientation = \"horizontal\";\r\n\r\n\t\t\tif (!(valueAxis.renderer instanceof AxisRendererY)) {\r\n\t\t\t\tvalueAxis.renderer = new AxisRendererY();\r\n\t\t\t}\r\n\t\t\tvalueAxis.renderer.inside = true;\r\n\t\t\tvalueAxis.renderer.labels.template.inside = true;\r\n\r\n\t\t\tthis.markerContainer.reverseOrder = true;\r\n\t\t}\r\n\r\n\t\tlet renderer = valueAxis.renderer;\r\n\t\trenderer.grid.template.disabled = true;\r\n\t\trenderer.axisFills.template.disabled = true;\r\n\t\trenderer.baseGrid.disabled = true;\r\n\t\trenderer.labels.template.padding(2, 3, 2, 3);\r\n\r\n\t\trenderer.minHeight = undefined;\r\n\t\trenderer.minWidth = undefined;\r\n\r\n\t\tthis.markerContainer.layout = value;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns orientation value.\r\n\t *\r\n\t * @return {\"horizontal\" | \"vertical\"}\r\n\t */\r\n\tpublic get orientation(): \"horizontal\" | \"vertical\" {\r\n\t\treturn this.getPropertyValue(\"orientation\");\r\n\t}\r\n\r\n\t/**\r\n\t * Sets a value axis of heat legend. Value axis for heat legend is created automatically.\r\n\t * @param {ValueAxis}\r\n\t */\r\n\tpublic set valueAxis(valueAxis: ValueAxis) {\r\n\r\n\t\tthis._valueAxis = valueAxis;\r\n\r\n\t\tvalueAxis.parent = this;\r\n\t\tvalueAxis.strictMinMax = true;\r\n\t\tthis.orientation = this.orientation;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns valueAxis value.\r\n\t * @return {ValueAxis}\r\n\t */\r\n\tpublic get valueAxis(): ValueAxis {\r\n\t\tif (!this._valueAxis) {\r\n\t\t\tthis.valueAxis = this.createChild(ValueAxis);\r\n\t\t\tthis.valueAxis.shouldClone = false;\r\n\t\t}\r\n\t\treturn this._valueAxis;\r\n\t}\r\n\r\n\t/**\r\n\t * You can set series for heat legend. It will take min, max, minColor and maxColor values from this series.\r\n\t * @param series\r\n\t */\r\n\tset series(series: Series) {\r\n\t\tthis._series = series;\r\n\r\n\t\tlet dataField = \"value\";\r\n\r\n\t\ttry {\r\n\t\t\tlet dataFieldDefined = series.heatRules.getIndex(0).dataField;\r\n\t\t\tif (dataFieldDefined) {\r\n\t\t\t\tdataField = dataFieldDefined;\r\n\t\t\t}\r\n\t\t}\r\n\t\tcatch (err) {\r\n\r\n\t\t}\r\n\r\n\t\tthis.updateMinMax(series.dataItem.values[dataField].low, series.dataItem.values[dataField].high);\r\n\r\n\t\tseries.dataItem.events.on(\"calculatedvaluechanged\", (event) => {\r\n\t\t\tthis.updateMinMax(series.dataItem.values[dataField].low, series.dataItem.values[dataField].high);\r\n\t\t}, undefined, false);\r\n\r\n\t\tseries.heatRules.events.on(\"inserted\", this.invalidate, this, false);\r\n\t\tseries.heatRules.events.on(\"removed\", this.invalidate, this, false);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns series value.\r\n\t * @return {Series}\r\n\t */\r\n\tget series(): Series {\r\n\t\treturn this._series;\r\n\t}\r\n\r\n\t/**\r\n\t * Updates min/max of value axis.\r\n\t * @ignore\r\n\t */\r\n\tprotected updateMinMax(min: number, max: number) {\r\n\t\tlet valueAxis = this.valueAxis;\r\n\t\tif (!$type.isNumber(this.minValue)) {\r\n\t\t\tvalueAxis.min = min;\r\n\t\t\tvalueAxis.invalidate();\r\n\t\t}\r\n\t\tif (!$type.isNumber(this.maxValue)) {\r\n\t\t\tvalueAxis.max = max;\r\n\t\t\tvalueAxis.invalidate();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Processes JSON-based config before it is applied to the object.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param config  Config\r\n\t */\r\n\tpublic processConfig(config?: { [index: string]: any }): void {\r\n\r\n\t\tif (config) {\r\n\r\n\t\t\t// Set up series\r\n\t\t\tif ($type.hasValue(config.series) && $type.isString(config.series)) {\r\n\t\t\t\tif ($type.isString(config.series)) {\r\n\t\t\t\t\tif (this.map.hasKey(config.series)) {\r\n\t\t\t\t\t\tconfig.series = this.map.getKey(config.series);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tlet seriesId = config.series;\r\n\t\t\t\t\t\tconst disposer = this.map.events.on(\"insertKey\", function(ev) {\r\n\t\t\t\t\t\t\tif (ev.key == seriesId) {\r\n\t\t\t\t\t\t\t\tthis.series = ev.newValue;\r\n\t\t\t\t\t\t\t\tdisposer.dispose();\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}, this);\r\n\t\t\t\t\t\tthis._disposers.push(disposer);\r\n\t\t\t\t\t\tdelete config.series;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tsuper.processConfig(config);\r\n\r\n\t}\r\n}\r\n\r\n\r\n\r\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\r\nregistry.registeredClasses[\"HeatLegend\"] = HeatLegend;\r\n"]},"metadata":{},"sourceType":"module"}