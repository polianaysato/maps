{"ast":null,"code":"/**\r\n * This module contains PatternSet object definition\r\n */\nimport { __extends } from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\nimport { BaseObject } from \"../Base\";\nimport { Color } from \"./Color\";\nimport { InterfaceColorSet } from \"./InterfaceColorSet\";\nimport { LinePattern } from \"../rendering/fills/LinePattern\";\nimport { RectPattern } from \"../rendering/fills/RectPattern\";\nimport { CirclePattern } from \"../rendering/fills/CirclePattern\";\nimport { registry } from \"../Registry\";\n/**\r\n * ============================================================================\r\n * REQUISITES\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * Defines an interable list of distinctive patterns that can be used in\r\n * conjunction to colors to generate various fill patterns.\r\n *\r\n * @important\r\n * @since 4.7.5\r\n * @see {@link https://www.amcharts.com/docs/v4/concepts/colors/} for color-related info\r\n */\n\nvar PatternSet =\n/** @class */\nfunction (_super) {\n  __extends(PatternSet, _super);\n  /**\r\n   * Constructor\r\n   */\n\n\n  function PatternSet() {\n    var _this = _super.call(this) || this;\n    /**\r\n     * Holds the list of the colors in this set. (preset or auto-generated)\r\n     */\n\n\n    _this._list = [];\n    /**\r\n     * Current step.\r\n     */\n\n    _this._currentStep = 0;\n    /**\r\n     * If set to non-zero value, the PatternSet will start iterating patterns from\r\n     * that particular index, not the first pattern in the list.\r\n     */\n\n    _this._startIndex = 0;\n    /**\r\n     * Current pass in cycle. Once all patterns in the list are iterated,\r\n     * iteration restarts from beginning and currentPass is incremented.\r\n     */\n\n    _this._currentPass = 0;\n    /**\r\n     * A base color. If there are no colors pre-set in the color list, ColorSet\r\n     * will use this color as a base when generating new ones, applying\r\n     * `stepOptions` and `passOptions` to this base color.\r\n     */\n\n    _this.baseColor = new Color({\n      r: 103,\n      g: 183,\n      b: 220\n    });\n    _this.className = \"PatternSet\"; // Set base color to be used for pattern elements\n\n    var interfaceColors = new InterfaceColorSet(); // Set default patterns\n\n    _this.list = [_this.getLinePattern(1000, 45, 1, 6), _this.getRectPattern(10, 0, 4), _this.getLinePattern(1000, -45, 1, 6), _this.getCirclePattern(11, 2, true), _this.getLinePattern(6, 90, 1), _this.getRectPattern(12, 45, 6, true), _this.getLinePattern(6, 0, 1), _this.getRectPattern(7, 0, 4), _this.getLinePattern(1000, 45, 2, 3, \"4,2\"), _this.getCirclePattern(9, 3, false), _this.getLinePattern(1000, -45, 2, 3, \"4,2\"), _this.getRectPattern(10, 45, Math.sqrt(50)), _this.getLinePattern(1000, -45, 2, 1), _this.getRectPattern(10, 0, 9), _this.getLinePattern(1000, 45, 2, 1), _this.getLinePattern(1000, 0, 3, 1), _this.getRectPattern(10, 45, 10), _this.getLinePattern(1000, 90, 3, 1)];\n    _this.baseColor = interfaceColors.getFor(\"stroke\");\n\n    _this.applyTheme();\n\n    return _this;\n  }\n\n  PatternSet.prototype.getLinePattern = function (size, rotation, thickness, gap, strokeDashArray) {\n    var pattern = new LinePattern();\n    pattern.width = size;\n    pattern.height = size;\n    pattern.stroke = this.baseColor;\n    pattern.gap = gap;\n    pattern.strokeDasharray = strokeDashArray;\n    pattern.strokeWidth = thickness;\n    pattern.rotation = rotation;\n    return pattern;\n  };\n\n  PatternSet.prototype.getRectPattern = function (size, rotation, thickness, outline) {\n    var pattern = new RectPattern();\n    pattern.width = size;\n    pattern.height = size;\n    pattern.rectWidth = thickness;\n    pattern.rectHeight = thickness;\n\n    if (outline) {\n      pattern.stroke = this.baseColor;\n      pattern.strokeWidth = 1;\n      pattern.fillOpacity = 0;\n    } else {\n      pattern.fill = this.baseColor;\n      pattern.strokeWidth = 0;\n    }\n\n    if (rotation != 0) {\n      pattern.shapeRendering = \"auto\";\n    }\n\n    pattern.rotation = rotation;\n    return pattern;\n  };\n\n  PatternSet.prototype.getCirclePattern = function (size, radius, outline) {\n    var pattern = new CirclePattern();\n    pattern.width = size;\n    pattern.height = size;\n    pattern.shapeRendering = \"auto\";\n    pattern.radius = radius;\n\n    if (outline) {\n      pattern.stroke = this.baseColor;\n      pattern.strokeWidth = 1;\n      pattern.fillOpacity = 0;\n    } else {\n      pattern.fill = this.baseColor;\n      pattern.strokeWidth = 0;\n    }\n\n    return pattern;\n  };\n\n  Object.defineProperty(PatternSet.prototype, \"list\", {\n    /**\r\n     * @return Pattern list\r\n     */\n    get: function () {\n      return this._list;\n    },\n\n    /**\r\n     * List of pre-defined patterns to be used in set.\r\n     *\r\n     * @param value Pattern list\r\n     */\n    set: function (value) {\n      this._list = value;\n      this.reset();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Returns the next pattern in list.\r\n   *\r\n   * @return Pattern\r\n   */\n\n  PatternSet.prototype.next = function () {\n    var pattern = this.getIndex(this.currentStep);\n    this._currentStep++;\n    return pattern;\n  };\n  /**\r\n   * Returns a color at specific index in the list.\r\n   *\r\n   * @param  i  Index\r\n   * @return Pattern\r\n   */\n\n\n  PatternSet.prototype.getIndex = function (i) {\n    var pattern;\n\n    while (this.list.length <= i) {\n      this.generatePatterns();\n    }\n\n    pattern = this.list[i];\n    return pattern.clone();\n  };\n  /**\r\n   * Generates a new set of patterns.\r\n   */\n\n\n  PatternSet.prototype.generatePatterns = function () {\n    var count = this.list.length / (this._currentPass + 1);\n    this._currentPass++;\n\n    for (var i = 0; i < count; i++) {\n      this.list.push(this.list[i].clone());\n    }\n  };\n  /**\r\n   * Resets internal iterator.\r\n   *\r\n   * Calling `next()` after this will return the very first color in the color\r\n   * list, even if it was already returned before.\r\n   */\n\n\n  PatternSet.prototype.reset = function () {\n    this._currentStep = this._startIndex;\n  };\n\n  Object.defineProperty(PatternSet.prototype, \"currentStep\", {\n    /**\r\n     * @return Step\r\n     */\n    get: function () {\n      return this._currentStep;\n    },\n\n    /**\r\n     * Sets current color iteration. You can use this property to skip some\r\n     * colors from iteration. E.g. setting it to `10` will skip first ten\r\n     * colors.\r\n     *\r\n     * Please note that the number is zero-based.\r\n     *\r\n     * @param value  Step\r\n     */\n    set: function (value) {\n      this._currentStep = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(PatternSet.prototype, \"startIndex\", {\n    /**\r\n     * @return Index\r\n     */\n    get: function () {\n      return this._startIndex;\n    },\n\n    /**\r\n     * If set to non-zero value, the ColorSet will start iterating colors from\r\n     * that particular index, not the first color in the list.\r\n     *\r\n     * @default 0\r\n     * @param  value  Index\r\n     */\n    set: function (value) {\n      this._startIndex = value;\n      this.reset();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Processes JSON-based config before it is applied to the object.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param config  Config\r\n   */\n\n  PatternSet.prototype.processConfig = function (config) {\n    // if (config) {\n    // \t// Set up axis ranges\n    // \tif ($type.hasValue(config.list) && $type.isArray(config.list)) {\n    // \t\tfor (let i = 0, len = config.list.length; i < len; i++) {\n    // \t\t\tif (!(config.list[i] instanceof Color)) {\n    // \t\t\t\tconfig.list[i] = color(config.list[i]);\n    // \t\t\t}\n    // \t\t}\n    // \t}\n    // }\n    _super.prototype.processConfig.call(this, config);\n  };\n\n  return PatternSet;\n}(BaseObject);\n\nexport { PatternSet };\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\n\nregistry.registeredClasses[\"PatternSet\"] = PatternSet;","map":{"version":3,"mappings":"AAAA;;;;AAIA;;;;;;;AAMA,SAASA,UAAT,QAA2B,SAA3B;AACA,SAASC,KAAT,QAAsB,SAAtB;AACA,SAASC,iBAAT,QAAkC,qBAAlC;AAEA,SAASC,WAAT,QAA4B,gCAA5B;AACA,SAASC,WAAT,QAA4B,gCAA5B;AACA,SAASC,aAAT,QAA8B,kCAA9B;AACA,SAASC,QAAT,QAAyB,aAAzB;AAGA;;;;;;;AAQA;;;;;;;AAOA;;;;;;;;;AAQA;AAAA;AAAA;AAAgCC;AAmC/B;;;;;AAGA;AAAA,gBACCC,qBAAO,IADR;AApCA;;;;;AAGUC,kBAAmB,EAAnB;AAEV;;;;AAGUA,yBAAuB,CAAvB;AAEV;;;;;AAIUA,wBAAsB,CAAtB;AAEV;;;;;AAIUA,yBAAuB,CAAvB;AAEV;;;;;;AAKOA,sBAAmB,IAAIR,KAAJ,CAAU;AACnCS,OAAC,EAAE,GADgC;AAEnCC,OAAC,EAAE,GAFgC;AAGnCC,OAAC,EAAE;AAHgC,KAAV,CAAnB;AAWNH,SAAI,CAACI,SAAL,GAAiB,YAAjB,CAFD,CAIC;;AACA,QAAMC,eAAe,GAAG,IAAIZ,iBAAJ,EAAxB,CALD,CAOC;;AACAO,SAAI,CAACM,IAAL,GAAY,CACXN,KAAI,CAACO,cAAL,CAAoB,IAApB,EAA0B,EAA1B,EAA8B,CAA9B,EAAiC,CAAjC,CADW,EAEXP,KAAI,CAACQ,cAAL,CAAoB,EAApB,EAAwB,CAAxB,EAA2B,CAA3B,CAFW,EAGXR,KAAI,CAACO,cAAL,CAAoB,IAApB,EAA0B,CAAC,EAA3B,EAA+B,CAA/B,EAAkC,CAAlC,CAHW,EAIXP,KAAI,CAACS,gBAAL,CAAsB,EAAtB,EAA0B,CAA1B,EAA6B,IAA7B,CAJW,EAKXT,KAAI,CAACO,cAAL,CAAoB,CAApB,EAAuB,EAAvB,EAA2B,CAA3B,CALW,EAMXP,KAAI,CAACQ,cAAL,CAAoB,EAApB,EAAwB,EAAxB,EAA4B,CAA5B,EAA+B,IAA/B,CANW,EAOXR,KAAI,CAACO,cAAL,CAAoB,CAApB,EAAuB,CAAvB,EAA0B,CAA1B,CAPW,EAQXP,KAAI,CAACQ,cAAL,CAAoB,CAApB,EAAuB,CAAvB,EAA0B,CAA1B,CARW,EASXR,KAAI,CAACO,cAAL,CAAoB,IAApB,EAA0B,EAA1B,EAA8B,CAA9B,EAAiC,CAAjC,EAAoC,KAApC,CATW,EAUXP,KAAI,CAACS,gBAAL,CAAsB,CAAtB,EAAyB,CAAzB,EAA4B,KAA5B,CAVW,EAWXT,KAAI,CAACO,cAAL,CAAoB,IAApB,EAA0B,CAAC,EAA3B,EAA+B,CAA/B,EAAkC,CAAlC,EAAqC,KAArC,CAXW,EAYXP,KAAI,CAACQ,cAAL,CAAoB,EAApB,EAAwB,EAAxB,EAA4BE,IAAI,CAACC,IAAL,CAAU,EAAV,CAA5B,CAZW,EAaXX,KAAI,CAACO,cAAL,CAAoB,IAApB,EAA0B,CAAC,EAA3B,EAA+B,CAA/B,EAAkC,CAAlC,CAbW,EAcXP,KAAI,CAACQ,cAAL,CAAoB,EAApB,EAAwB,CAAxB,EAA2B,CAA3B,CAdW,EAeXR,KAAI,CAACO,cAAL,CAAoB,IAApB,EAA0B,EAA1B,EAA8B,CAA9B,EAAiC,CAAjC,CAfW,EAgBXP,KAAI,CAACO,cAAL,CAAoB,IAApB,EAA0B,CAA1B,EAA6B,CAA7B,EAAgC,CAAhC,CAhBW,EAiBXP,KAAI,CAACQ,cAAL,CAAoB,EAApB,EAAwB,EAAxB,EAA4B,EAA5B,CAjBW,EAkBXR,KAAI,CAACO,cAAL,CAAoB,IAApB,EAA0B,EAA1B,EAA8B,CAA9B,EAAiC,CAAjC,CAlBW,CAAZ;AAqBAP,SAAI,CAACY,SAAL,GAAiBP,eAAe,CAACQ,MAAhB,CAAuB,QAAvB,CAAjB;;AACAb,SAAI,CAACc,UAAL;;;AACA;;AAEMC,wCAAP,UAAsBC,IAAtB,EAAoCC,QAApC,EAAsDC,SAAtD,EAAyEC,GAAzE,EAAuFC,eAAvF,EAA+G;AAC9G,QAAIC,OAAO,GAAG,IAAI3B,WAAJ,EAAd;AACA2B,WAAO,CAACC,KAAR,GAAgBN,IAAhB;AACAK,WAAO,CAACE,MAAR,GAAiBP,IAAjB;AACAK,WAAO,CAACG,MAAR,GAAiB,KAAKZ,SAAtB;AACAS,WAAO,CAACF,GAAR,GAAcA,GAAd;AACAE,WAAO,CAACI,eAAR,GAA0BL,eAA1B;AACAC,WAAO,CAACK,WAAR,GAAsBR,SAAtB;AACAG,WAAO,CAACJ,QAAR,GAAmBA,QAAnB;AACA,WAAOI,OAAP;AACA,GAVM;;AAYAN,wCAAP,UAAsBC,IAAtB,EAAoCC,QAApC,EAAsDC,SAAtD,EAAyES,OAAzE,EAAyF;AACxF,QAAIN,OAAO,GAAG,IAAI1B,WAAJ,EAAd;AACA0B,WAAO,CAACC,KAAR,GAAgBN,IAAhB;AACAK,WAAO,CAACE,MAAR,GAAiBP,IAAjB;AACAK,WAAO,CAACO,SAAR,GAAoBV,SAApB;AACAG,WAAO,CAACQ,UAAR,GAAqBX,SAArB;;AAEA,QAAGS,OAAH,EAAW;AACVN,aAAO,CAACG,MAAR,GAAiB,KAAKZ,SAAtB;AACAS,aAAO,CAACK,WAAR,GAAsB,CAAtB;AACAL,aAAO,CAACS,WAAR,GAAsB,CAAtB;AACA,KAJD,MAKI;AACHT,aAAO,CAACU,IAAR,GAAe,KAAKnB,SAApB;AACAS,aAAO,CAACK,WAAR,GAAsB,CAAtB;AACA;;AAED,QAAGT,QAAQ,IAAI,CAAf,EAAiB;AAChBI,aAAO,CAACW,cAAR,GAAyB,MAAzB;AACA;;AAEDX,WAAO,CAACJ,QAAR,GAAmBA,QAAnB;AACA,WAAOI,OAAP;AACA,GAvBM;;AAyBAN,0CAAP,UAAwBC,IAAxB,EAAsCiB,MAAtC,EAAsDN,OAAtD,EAAqE;AACpE,QAAIN,OAAO,GAAG,IAAIzB,aAAJ,EAAd;AACAyB,WAAO,CAACC,KAAR,GAAgBN,IAAhB;AACAK,WAAO,CAACE,MAAR,GAAiBP,IAAjB;AACAK,WAAO,CAACW,cAAR,GAAyB,MAAzB;AACAX,WAAO,CAACY,MAAR,GAAiBA,MAAjB;;AACA,QAAGN,OAAH,EAAW;AACVN,aAAO,CAACG,MAAR,GAAiB,KAAKZ,SAAtB;AACAS,aAAO,CAACK,WAAR,GAAsB,CAAtB;AACAL,aAAO,CAACS,WAAR,GAAsB,CAAtB;AACA,KAJD,MAKI;AACHT,aAAO,CAACU,IAAR,GAAe,KAAKnB,SAApB;AACAS,aAAO,CAACK,WAAR,GAAsB,CAAtB;AACA;;AACD,WAAOL,OAAP;AACA,GAhBM;;AAuBPa,wBAAWnB,oBAAX,EAAW,MAAX,EAAe;AAKf;;;SAGA;AACC,aAAO,KAAKoB,KAAZ;AACA,KAVc;;AALf;;;;;SAKA,UAAgBC,KAAhB,EAAgC;AAC/B,WAAKD,KAAL,GAAaC,KAAb;AACA,WAAKC,KAAL;AACA,KAHc;oBAAA;;AAAA,GAAf;AAYA;;;;;;AAKOtB,8BAAP;AACC,QAAMM,OAAO,GAAG,KAAKiB,QAAL,CAAc,KAAKC,WAAnB,CAAhB;AACA,SAAKC,YAAL;AACA,WAAOnB,OAAP;AACA,GAJM;AAMP;;;;;;;;AAMON,kCAAP,UAAgB0B,CAAhB,EAAyB;AACxB,QAAIpB,OAAJ;;AACA,WAAO,KAAKf,IAAL,CAAUoC,MAAV,IAAoBD,CAA3B,EAA8B;AAC7B,WAAKE,gBAAL;AACA;;AACDtB,WAAO,GAAG,KAAKf,IAAL,CAAUmC,CAAV,CAAV;AACA,WAAOpB,OAAO,CAACuB,KAAR,EAAP;AACA,GAPM;AASP;;;;;AAGQ7B,0CAAR;AACC,QAAM8B,KAAK,GAAG,KAAKvC,IAAL,CAAUoC,MAAV,IAAoB,KAAKI,YAAL,GAAoB,CAAxC,CAAd;AACA,SAAKA,YAAL;;AACA,SAAK,IAAIL,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGI,KAApB,EAA2BJ,CAAC,EAA5B,EAAgC;AAC/B,WAAKnC,IAAL,CAAUyC,IAAV,CAAe,KAAKzC,IAAL,CAAUmC,CAAV,EAAaG,KAAb,EAAf;AACA;AACD,GANO;AAQR;;;;;;;;AAMO7B,+BAAP;AACC,SAAKyB,YAAL,GAAoB,KAAKQ,WAAzB;AACA,GAFM;;AAaPd,wBAAWnB,oBAAX,EAAW,aAAX,EAAsB;AAItB;;;SAGA;AACC,aAAO,KAAKyB,YAAZ;AACA,KATqB;;AATtB;;;;;;;;;SASA,UAAuBJ,KAAvB,EAAoC;AACnC,WAAKI,YAAL,GAAoBJ,KAApB;AACA,KAFqB;oBAAA;;AAAA,GAAtB;AAkBAF,wBAAWnB,oBAAX,EAAW,YAAX,EAAqB;AAKrB;;;SAGA;AACC,aAAO,KAAKiC,WAAZ;AACA,KAVoB;;AAPrB;;;;;;;SAOA,UAAsBZ,KAAtB,EAAmC;AAClC,WAAKY,WAAL,GAAmBZ,KAAnB;AACA,WAAKC,KAAL;AACA,KAHoB;oBAAA;;AAAA,GAArB;AAYA;;;;;;;AAMOtB,uCAAP,UAAqBkC,MAArB,EAAsD;AAErD;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAlD,qBAAMmD,aAAN,CAAmBC,IAAnB,CAAmB,IAAnB,EAAoBF,MAApB;AACA,GAdM;;AAgBR;AA3PA,EAAgC1D,UAAhC;;;AA6PA;;;;;;;AAMAM,QAAQ,CAACuD,iBAAT,CAA2B,YAA3B,IAA2CrC,UAA3C","names":["BaseObject","Color","InterfaceColorSet","LinePattern","RectPattern","CirclePattern","registry","__extends","_super","_this","r","g","b","className","interfaceColors","list","getLinePattern","getRectPattern","getCirclePattern","Math","sqrt","baseColor","getFor","applyTheme","PatternSet","size","rotation","thickness","gap","strokeDashArray","pattern","width","height","stroke","strokeDasharray","strokeWidth","outline","rectWidth","rectHeight","fillOpacity","fill","shapeRendering","radius","Object","_list","value","reset","getIndex","currentStep","_currentStep","i","length","generatePatterns","clone","count","_currentPass","push","_startIndex","config","processConfig","call","registeredClasses"],"sourceRoot":"","sources":["../../../../../src/.internal/core/utils/PatternSet.ts"],"sourcesContent":["/**\r\n * This module contains PatternSet object definition\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { BaseObject } from \"../Base\";\r\nimport { Color } from \"./Color\";\r\nimport { InterfaceColorSet } from \"./InterfaceColorSet\";\r\nimport { Pattern } from \"../rendering/fills/Pattern\";\r\nimport { LinePattern } from \"../rendering/fills/LinePattern\";\r\nimport { RectPattern } from \"../rendering/fills/RectPattern\";\r\nimport { CirclePattern } from \"../rendering/fills/CirclePattern\";\r\nimport { registry } from \"../Registry\";\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * REQUISITES\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Defines an interable list of distinctive patterns that can be used in\r\n * conjunction to colors to generate various fill patterns.\r\n *\r\n * @important\r\n * @since 4.7.5\r\n * @see {@link https://www.amcharts.com/docs/v4/concepts/colors/} for color-related info\r\n */\r\nexport class PatternSet extends BaseObject {\r\n\r\n\t/**\r\n\t * Holds the list of the colors in this set. (preset or auto-generated)\r\n\t */\r\n\tprotected _list: Pattern[] = [];\r\n\r\n\t/**\r\n\t * Current step.\r\n\t */\r\n\tprotected _currentStep: number = 0;\r\n\r\n\t/**\r\n\t * If set to non-zero value, the PatternSet will start iterating patterns from\r\n\t * that particular index, not the first pattern in the list.\r\n\t */\r\n\tprotected _startIndex: number = 0;\r\n\r\n\t/**\r\n\t * Current pass in cycle. Once all patterns in the list are iterated,\r\n\t * iteration restarts from beginning and currentPass is incremented.\r\n\t */\r\n\tprotected _currentPass: number = 0;\r\n\r\n\t/**\r\n\t * A base color. If there are no colors pre-set in the color list, ColorSet\r\n\t * will use this color as a base when generating new ones, applying\r\n\t * `stepOptions` and `passOptions` to this base color.\r\n\t */\r\n\tpublic baseColor: Color = new Color({\r\n\t\tr: 103,\r\n\t\tg: 183,\r\n\t\tb: 220\r\n\t});\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor() {\r\n\t\tsuper();\r\n\t\tthis.className = \"PatternSet\";\r\n\r\n\t\t// Set base color to be used for pattern elements\r\n\t\tconst interfaceColors = new InterfaceColorSet();\r\n\r\n\t\t// Set default patterns\r\n\t\tthis.list = [\r\n\t\t\tthis.getLinePattern(1000, 45, 1, 6),\r\n\t\t\tthis.getRectPattern(10, 0, 4),\r\n\t\t\tthis.getLinePattern(1000, -45, 1, 6),\r\n\t\t\tthis.getCirclePattern(11, 2, true),\r\n\t\t\tthis.getLinePattern(6, 90, 1),\r\n\t\t\tthis.getRectPattern(12, 45, 6, true),\r\n\t\t\tthis.getLinePattern(6, 0, 1),\r\n\t\t\tthis.getRectPattern(7, 0, 4),\r\n\t\t\tthis.getLinePattern(1000, 45, 2, 3, \"4,2\"),\r\n\t\t\tthis.getCirclePattern(9, 3, false),\r\n\t\t\tthis.getLinePattern(1000, -45, 2, 3, \"4,2\"),\r\n\t\t\tthis.getRectPattern(10, 45, Math.sqrt(50)),\r\n\t\t\tthis.getLinePattern(1000, -45, 2, 1),\r\n\t\t\tthis.getRectPattern(10, 0, 9),\r\n\t\t\tthis.getLinePattern(1000, 45, 2, 1),\r\n\t\t\tthis.getLinePattern(1000, 0, 3, 1),\r\n\t\t\tthis.getRectPattern(10, 45, 10),\r\n\t\t\tthis.getLinePattern(1000, 90, 3, 1)\r\n\t\t];\r\n\r\n\t\tthis.baseColor = interfaceColors.getFor(\"stroke\");\r\n\t\tthis.applyTheme();\r\n\t}\r\n\r\n\tpublic getLinePattern(size: number, rotation: number, thickness: number, gap?: number, strokeDashArray?: string): LinePattern {\r\n\t\tlet pattern = new LinePattern();\r\n\t\tpattern.width = size;\r\n\t\tpattern.height = size;\r\n\t\tpattern.stroke = this.baseColor;\r\n\t\tpattern.gap = gap;\r\n\t\tpattern.strokeDasharray = strokeDashArray;\r\n\t\tpattern.strokeWidth = thickness;\r\n\t\tpattern.rotation = rotation;\r\n\t\treturn pattern;\r\n\t}\r\n\r\n\tpublic getRectPattern(size: number, rotation: number, thickness: number, outline?:boolean): RectPattern {\r\n\t\tlet pattern = new RectPattern();\r\n\t\tpattern.width = size;\r\n\t\tpattern.height = size;\r\n\t\tpattern.rectWidth = thickness;\r\n\t\tpattern.rectHeight = thickness;\r\n\r\n\t\tif(outline){\r\n\t\t\tpattern.stroke = this.baseColor;\r\n\t\t\tpattern.strokeWidth = 1;\r\n\t\t\tpattern.fillOpacity = 0;\r\n\t\t}\r\n\t\telse{\r\n\t\t\tpattern.fill = this.baseColor;\r\n\t\t\tpattern.strokeWidth = 0;\r\n\t\t}\r\n\r\n\t\tif(rotation != 0){\r\n\t\t\tpattern.shapeRendering = \"auto\";\r\n\t\t}\r\n\r\n\t\tpattern.rotation = rotation;\r\n\t\treturn pattern;\r\n\t}\r\n\r\n\tpublic getCirclePattern(size: number, radius: number, outline:boolean): CirclePattern {\r\n\t\tlet pattern = new CirclePattern();\r\n\t\tpattern.width = size;\r\n\t\tpattern.height = size;\r\n\t\tpattern.shapeRendering = \"auto\";\r\n\t\tpattern.radius = radius;\r\n\t\tif(outline){\r\n\t\t\tpattern.stroke = this.baseColor;\r\n\t\t\tpattern.strokeWidth = 1;\r\n\t\t\tpattern.fillOpacity = 0;\r\n\t\t}\r\n\t\telse{\r\n\t\t\tpattern.fill = this.baseColor;\r\n\t\t\tpattern.strokeWidth = 0;\r\n\t\t}\r\n\t\treturn pattern;\r\n\t}\r\n\r\n\t/**\r\n\t * List of pre-defined patterns to be used in set.\r\n\t *\r\n\t * @param value Pattern list\r\n\t */\r\n\tpublic set list(value: Pattern[]) {\r\n\t\tthis._list = value;\r\n\t\tthis.reset();\r\n\t}\r\n\r\n\t/**\r\n\t * @return Pattern list\r\n\t */\r\n\tpublic get list(): Pattern[] {\r\n\t\treturn this._list;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the next pattern in list.\r\n\t *\r\n\t * @return Pattern\r\n\t */\r\n\tpublic next(): Pattern {\r\n\t\tconst pattern = this.getIndex(this.currentStep);\r\n\t\tthis._currentStep++;\r\n\t\treturn pattern;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a color at specific index in the list.\r\n\t *\r\n\t * @param  i  Index\r\n\t * @return Pattern\r\n\t */\r\n\tpublic getIndex(i: number): Pattern {\r\n\t\tlet pattern;\r\n\t\twhile (this.list.length <= i) {\r\n\t\t\tthis.generatePatterns();\r\n\t\t}\r\n\t\tpattern = this.list[i];\r\n\t\treturn pattern.clone();\r\n\t}\r\n\r\n\t/**\r\n\t * Generates a new set of patterns.\r\n\t */\r\n\tprivate generatePatterns(): void {\r\n\t\tconst count = this.list.length / (this._currentPass + 1);\r\n\t\tthis._currentPass++;\r\n\t\tfor (let i = 0; i < count; i++) {\r\n\t\t\tthis.list.push(this.list[i].clone());\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Resets internal iterator.\r\n\t *\r\n\t * Calling `next()` after this will return the very first color in the color\r\n\t * list, even if it was already returned before.\r\n\t */\r\n\tpublic reset(): void {\r\n\t\tthis._currentStep = this._startIndex;\r\n\t}\r\n\r\n\t/**\r\n\t * Sets current color iteration. You can use this property to skip some\r\n\t * colors from iteration. E.g. setting it to `10` will skip first ten\r\n\t * colors.\r\n\t *\r\n\t * Please note that the number is zero-based.\r\n\t *\r\n\t * @param value  Step\r\n\t */\r\n\tpublic set currentStep(value: number) {\r\n\t\tthis._currentStep = value;\r\n\t}\r\n\r\n\t/**\r\n\t * @return Step\r\n\t */\r\n\tpublic get currentStep(): number {\r\n\t\treturn this._currentStep;\r\n\t}\r\n\r\n\t/**\r\n\t * If set to non-zero value, the ColorSet will start iterating colors from\r\n\t * that particular index, not the first color in the list.\r\n\t *\r\n\t * @default 0\r\n\t * @param  value  Index\r\n\t */\r\n\tpublic set startIndex(value: number) {\r\n\t\tthis._startIndex = value;\r\n\t\tthis.reset();\r\n\t}\r\n\r\n\t/**\r\n\t * @return Index\r\n\t */\r\n\tpublic get startIndex(): number {\r\n\t\treturn this._startIndex;\r\n\t}\r\n\r\n\t/**\r\n\t * Processes JSON-based config before it is applied to the object.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param config  Config\r\n\t */\r\n\tpublic processConfig(config?: { [index: string]: any }): void {\r\n\r\n\t\t// if (config) {\r\n\r\n\t\t// \t// Set up axis ranges\r\n\t\t// \tif ($type.hasValue(config.list) && $type.isArray(config.list)) {\r\n\t\t// \t\tfor (let i = 0, len = config.list.length; i < len; i++) {\r\n\t\t// \t\t\tif (!(config.list[i] instanceof Color)) {\r\n\t\t// \t\t\t\tconfig.list[i] = color(config.list[i]);\r\n\t\t// \t\t\t}\r\n\t\t// \t\t}\r\n\t\t// \t}\r\n\t\t// }\r\n\t\tsuper.processConfig(config);\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\r\nregistry.registeredClasses[\"PatternSet\"] = PatternSet;"]},"metadata":{},"sourceType":"module"}