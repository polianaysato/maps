{"ast":null,"code":"/**\r\n * Category axis module\r\n */\nimport { __extends } from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\nimport { Axis, AxisDataItem } from \"./Axis\";\nimport { AxisRendererX } from \"./AxisRendererX\";\nimport { AxisRendererY } from \"./AxisRendererY\";\nimport { registry } from \"../../core/Registry\";\nimport { Dictionary } from \"../../core/utils/Dictionary\";\nimport { CategoryAxisBreak } from \"./CategoryAxisBreak\";\nimport * as $math from \"../../core/utils/Math\";\nimport * as $type from \"../../core/utils/Type\";\nimport * as $iter from \"../../core/utils/Iterator\";\n/**\r\n * ============================================================================\r\n * DATA ITEM\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * Defines a [[DataItem]] for [[CategoryAxis]].\r\n *\r\n * @see {@link DataItem}\r\n */\n\nvar CategoryAxisDataItem =\n/** @class */\nfunction (_super) {\n  __extends(CategoryAxisDataItem, _super);\n  /**\r\n   * Constructor\r\n   */\n\n\n  function CategoryAxisDataItem() {\n    var _this = _super.call(this) || this;\n\n    _this.seriesDataItems = {};\n    _this.className = \"CategoryAxisDataItem\";\n    _this.text = \"{category}\";\n    _this.locations.category = 0;\n    _this.locations.endCategory = 1;\n    _this.deltaPosition = 0;\n\n    _this.applyTheme();\n\n    return _this;\n  }\n\n  Object.defineProperty(CategoryAxisDataItem.prototype, \"category\", {\n    /**\r\n     * @return Category\r\n     */\n    get: function () {\n      if (this._adapterO) {\n        if (this._adapterO.isEnabled(\"category\")) {\n          return this._adapterO.apply(\"category\", this.properties.category);\n        }\n      }\n\n      return this.properties.category;\n    },\n\n    /**\r\n     * Category.\r\n     *\r\n     * @param value  Category\r\n     */\n    set: function (value) {\n      var oldCategory = this.properties.category;\n      this.setProperty(\"category\", value);\n\n      if ($type.hasValue(oldCategory) && oldCategory != value) {\n        if (this.component) {\n          this.component.validateDataElement(this);\n        }\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(CategoryAxisDataItem.prototype, \"endCategory\", {\n    /**\r\n     * @return End category\r\n     */\n    get: function () {\n      return this.properties.endCategory;\n    },\n\n    /**\r\n     * End category.\r\n     *\r\n     * Used for items that span several categories, like [[CategoryAxisBreak]].\r\n     *\r\n     * @param value  End category\r\n     */\n    set: function (value) {\n      this.setProperty(\"endCategory\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(CategoryAxisDataItem.prototype, \"deltaPosition\", {\n    get: function () {\n      return this.properties.deltaCoordinate;\n    },\n    set: function (value) {\n      if (value != this.properties.deltaCoordinate) {\n        this.setProperty(\"deltaCoordinate\", value);\n\n        if (this.component) {\n          this.component.invalidateDataItems();\n          this.component.invalidateSeries();\n        }\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return CategoryAxisDataItem;\n}(AxisDataItem);\n\nexport { CategoryAxisDataItem };\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * Used to create a category-based axis for the chart.\r\n *\r\n * ```TypeScript\r\n * // Create the axis\r\n * let xAxis = chart.xAxes.push(new am4charts.CategoryAxis());\r\n *\r\n * // Set settings\r\n * xAxis.title.text = \"Clients\";\r\n * ```\r\n * ```JavaScript\r\n * // Create the axis\r\n * var valueAxis = chart.xAxes.push(new am4charts.CategoryAxis());\r\n *\r\n * // Set settings\r\n * valueAxis.title.text = \"Clients\";\r\n * ```\r\n * ```JSON\r\n * \"xAxes\": [{\r\n *   \"type\": \"CategoryAxis\",\r\n *   \"title\": {\r\n *     \"text\": \"Clients\"\r\n *   }\r\n * }]\r\n * ```\r\n *\r\n * @see {@link ICategoryAxisEvents} for a list of available Events\r\n * @see {@link ICategoryAxisAdapters} for a list of available Adapters\r\n * @important\r\n */\n\nvar CategoryAxis =\n/** @class */\nfunction (_super) {\n  __extends(CategoryAxis, _super);\n  /**\r\n   * Constructor\r\n   */\n\n\n  function CategoryAxis() {\n    var _this = // Init\n    _super.call(this) || this;\n    /**\r\n     * A collection that holds Axis' data items sorted by each category.\r\n     */\n\n\n    _this.dataItemsByCategory = new Dictionary();\n    _this.className = \"CategoryAxis\"; // Set field name\n\n    _this.axisFieldName = \"category\";\n    _this._lastDataItem = _this.createDataItem();\n    _this._lastDataItem.component = _this;\n\n    _this._disposers.push(_this._lastDataItem); // Apply theme\n\n\n    _this.applyTheme();\n\n    var dataItemsByCategory = _this.dataItemsByCategory;\n\n    _this.addDisposer(_this.mainDataSet.events.on(\"removed\", function (event) {\n      dataItemsByCategory.removeKey(event.oldValue.category);\n    }));\n\n    return _this;\n  }\n  /**\r\n   * Returns a new/empty [[DataItem]] of the type appropriate for this object.\r\n   *\r\n   * @see {@link DataItem}\r\n   * @return Data Item\r\n   */\n\n\n  CategoryAxis.prototype.createDataItem = function () {\n    return new CategoryAxisDataItem();\n  };\n  /**\r\n   * Returns a new/empty [[AxisBreak]] of the appropriate type.\r\n   *\r\n   * @return Axis break\r\n   */\n\n\n  CategoryAxis.prototype.createAxisBreak = function () {\n    return new CategoryAxisBreak();\n  };\n  /**\r\n   * Processes a related series' data item.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description\r\n   * @param dataItem  Data item\r\n   */\n\n\n  CategoryAxis.prototype.processSeriesDataItem = function (dataItem, axisLetter) {\n    _super.prototype.processSeriesDataItem.call(this, dataItem, axisLetter);\n\n    var category = dataItem[\"category\" + this.axisLetter];\n\n    if ($type.hasValue(category)) {\n      var categoryAxisDataItem = this.dataItemsByCategory.getKey(category);\n\n      if (categoryAxisDataItem) {\n        var seriesId = dataItem.component.uid;\n        var seriesDataItems = categoryAxisDataItem.seriesDataItems[seriesId];\n\n        if (!seriesDataItems) {\n          seriesDataItems = [];\n          categoryAxisDataItem.seriesDataItems[seriesId] = seriesDataItems;\n        }\n\n        seriesDataItems.push(dataItem);\n      }\n    } else {\n      dataItem.component.dataItems.remove(dataItem);\n    }\n  };\n  /**\r\n   * Validates the data range.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description (review)\r\n   */\n\n\n  CategoryAxis.prototype.validateDataRange = function () {\n    var _this = this;\n\n    _super.prototype.validateDataRange.call(this);\n\n    $iter.each(this._series.iterator(), function (series) {\n      if (series.xAxis instanceof CategoryAxis && series.yAxis instanceof CategoryAxis) {\n        series.invalidateDataRange();\n      } else {\n        var startIndex = _this.positionToIndex(_this.start);\n\n        var endIndex = _this.positionToIndex(_this.end);\n\n        if (endIndex >= _this.dataItems.length) {\n          endIndex--;\n        }\n\n        var seriesId = series.uid;\n        var minIndex = void 0;\n        var maxIndex = void 0;\n\n        for (var i = startIndex; i <= endIndex; i++) {\n          var axisDataItem = _this.dataItems.getIndex(i);\n\n          if (axisDataItem) {\n            var seriesDataItems = axisDataItem.seriesDataItems[seriesId];\n\n            if (seriesDataItems) {\n              for (var i_1 = 0; i_1 < seriesDataItems.length; i_1++) {\n                var seriesDataItem = seriesDataItems[i_1];\n\n                if (seriesDataItem) {\n                  var index = seriesDataItem.index;\n\n                  if (!$type.isNumber(minIndex) || index < minIndex) {\n                    minIndex = index;\n                  }\n\n                  if (!$type.isNumber(maxIndex) || index > maxIndex) {\n                    maxIndex = index;\n                  }\n                }\n              }\n            }\n          }\n        }\n\n        if ($type.isNumber(minIndex)) {\n          series.startIndex = minIndex;\n        } else {\n          series.start = _this.start;\n        }\n\n        if ($type.isNumber(maxIndex)) {\n          series.endIndex = maxIndex + 1;\n        } else {\n          series.end = _this.end;\n        } // range might not change, but axis breaks might.\n\n\n        if (_this._axisBreaks && _this._axisBreaks.length > 0) {\n          series.invalidateDataRange();\n        }\n      }\n    });\n  };\n  /**\r\n   * Validates the whole axis. Causes it to redraw.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description (review)\r\n   */\n\n\n  CategoryAxis.prototype.validate = function () {\n    var _this = this;\n\n    _super.prototype.validate.call(this);\n\n    var dataCount = this.dataItems.length;\n    var startIndex = $math.fitToRange(Math.floor(this.start * dataCount - 1), 0, dataCount);\n    var endIndex = $math.fitToRange(Math.ceil(this.end * dataCount), 0, dataCount);\n\n    if (this.renderer.invalid) {\n      this.renderer.validate();\n    } // find frequency at which we'll show items\n\n\n    var maxCount = this.renderer.axisLength / Math.max(this.renderer.minGridDistance, 1 / Number.MAX_SAFE_INTEGER);\n    var frequency = Math.min(this.dataItems.length, Math.ceil((endIndex - startIndex) / maxCount));\n    this._startIndex = Math.floor(startIndex / frequency) * frequency;\n    this._endIndex = Math.ceil(this.end * dataCount);\n    this.fixAxisBreaks();\n\n    if (this._startIndex == this._endIndex) {\n      this._endIndex++;\n    }\n\n    this._frequency = frequency;\n\n    if (this.axisLength <= 0) {\n      return;\n    }\n\n    this.maxZoomFactor = this.dataItems.length;\n\n    if (this.dataItems.length <= 0) {\n      this.maxZoomFactor = 1;\n    }\n\n    this.resetIterators(); // it's important to use protected variables here, as getters will return 0 - length\n    // TODO use iterator instead\n    // @ todo: not solved cat axis item fading\n\n    startIndex = $math.max(0, this._startIndex - this._frequency);\n    endIndex = $math.min(this.dataItems.length, this._endIndex + this._frequency);\n    var itemIndex = 0;\n\n    for (var i = 0; i < startIndex; i++) {\n      var dataItem = this.dataItems.getIndex(i);\n      dataItem.__disabled = true;\n    }\n\n    for (var i = endIndex, len = this.dataItems.length; i < len; i++) {\n      var dataItem = this.dataItems.getIndex(i);\n      dataItem.__disabled = true;\n    }\n\n    for (var i = startIndex; i < endIndex; i++) {\n      if (i < this.dataItems.length) {\n        var dataItem = this.dataItems.getIndex(i);\n\n        if (i / this._frequency == Math.round(i / this._frequency)) {\n          var axisBreak = this.isInBreak(i);\n\n          if (!axisBreak) {\n            this.appendDataItem(dataItem);\n            this.validateDataElement(dataItem, itemIndex);\n          }\n\n          itemIndex++;\n        } else {\n          //previously we disabled all before, but this is better for cpu\n          //this.validateDataElement(dataItem, itemIndex); // helps to solve shrinking // not good - creates all items\n          dataItem.__disabled = true;\n        }\n      }\n    }\n\n    this.appendDataItem(this._lastDataItem);\n    this.validateDataElement(this._lastDataItem, itemIndex + 1, this.dataItems.length);\n\n    if (this._axisBreaks) {\n      var axisBreaks = this._axisBreaks;\n      axisBreaks.each(function (axisBreak) {\n        var adjustedStartValue = axisBreak.adjustedStartValue;\n        var adjustedEndValue = axisBreak.adjustedEndValue;\n\n        if ($math.intersect({\n          start: adjustedStartValue,\n          end: adjustedEndValue\n        }, {\n          start: _this._startIndex,\n          end: _this._endIndex\n        })) {\n          for (var b = adjustedStartValue; b <= adjustedEndValue; b++) {\n            var dataItem = _this.dataItems.getIndex(b);\n\n            dataItem.__disabled = true;\n          }\n\n          var frequency_1 = $math.fitToRange(Math.ceil(_this._frequency / axisBreak.breakSize), 1, adjustedEndValue - adjustedStartValue);\n          var itemIndex_1 = 0;\n\n          if (axisBreak.breakSize > 0) {\n            // TODO use iterator instead\n            for (var b = adjustedStartValue; b <= adjustedEndValue; b = b + frequency_1) {\n              var dataItem = _this.dataItems.getIndex(b);\n\n              dataItem.__disabled = false;\n\n              _this.appendDataItem(dataItem);\n\n              _this.validateDataElement(dataItem, itemIndex_1);\n\n              itemIndex_1++;\n            }\n          }\n        }\n      });\n    }\n\n    this.validateBreaks();\n    this.validateAxisRanges();\n    this.ghostLabel.invalidate(); // solves font issue\n\n    this.renderer.invalidateLayout();\n  };\n  /**\r\n   * [validateDataElement description]\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description\r\n   * @param dataItem   [description]\r\n   * @param itemIndex  [description]\r\n   */\n\n\n  CategoryAxis.prototype.validateDataElement = function (dataItem, itemIndex, index) {\n    _super.prototype.validateDataElement.call(this, dataItem);\n\n    dataItem.itemIndex = this._axisItemCount;\n    this._axisItemCount++; //dataItem.__disabled = false;\n\n    var renderer = this.renderer;\n\n    if (!$type.isNumber(index)) {\n      index = this.categoryToIndex(dataItem.category);\n    }\n\n    var endIndex = this.categoryToIndex(dataItem.endCategory);\n\n    if (!$type.isNumber(endIndex)) {\n      endIndex = index;\n    }\n\n    var position = this.indexToPosition(index, dataItem.locations.category);\n    var endPosition = this.indexToPosition(endIndex, dataItem.locations.endCategory);\n    dataItem.position = position;\n    var fillEndIndex;\n    var fillPosition;\n    var fillEndPosition;\n\n    if (dataItem.isRange) {\n      fillEndIndex = endIndex;\n      fillPosition = this.indexToPosition(index, dataItem.locations.category);\n      fillEndPosition = this.indexToPosition(fillEndIndex, dataItem.locations.endCategory);\n    }\n\n    dataItem.point = renderer.positionToPoint(position);\n    var tick = dataItem.tick;\n\n    if (tick && !tick.disabled) {\n      renderer.updateTickElement(tick, position, endPosition);\n    }\n\n    var grid = dataItem.grid;\n\n    if (grid && !grid.disabled) {\n      renderer.updateGridElement(grid, position, endPosition);\n    }\n\n    var label = dataItem.label;\n\n    if (label && !label.disabled) {\n      // theorethically this might result problems if category text changes, the range text won't change. But otherwise range.label.text = \"custom text\" won't work, which is not intuitive.\n      if (!dataItem.isRange || label.text == undefined) {\n        dataItem.text = dataItem.text;\n      }\n\n      renderer.updateLabelElement(label, position, endPosition);\n\n      if (renderer instanceof AxisRendererY && dataItem.label.measuredWidth > this.ghostLabel.measuredWidth || renderer instanceof AxisRendererX && dataItem.label.measuredHeight > this.ghostLabel.measuredHeight) {\n        if (dataItem.label.html) {\n          this.ghostLabel.html = dataItem.label.currentText;\n        } else {\n          this.ghostLabel.text = dataItem.label.currentText;\n        }\n      }\n    }\n\n    var fill = dataItem.axisFill;\n\n    if (fill && !fill.disabled) {\n      if (!dataItem.isRange) {\n        fillEndIndex = index + this._frequency;\n        fillPosition = this.indexToPosition(index, fill.location);\n        fillEndPosition = this.indexToPosition(fillEndIndex, fill.location);\n      }\n\n      renderer.updateFillElement(fill, fillPosition, fillEndPosition);\n\n      if (!dataItem.isRange) {\n        this.fillRule(dataItem, itemIndex);\n      }\n    }\n\n    if (dataItem.bullet) {\n      renderer.updateBullet(dataItem.bullet, position, endPosition);\n    }\n\n    var mask = dataItem.mask;\n\n    if (mask) {\n      renderer.updateFillElement(mask, fillPosition, fillEndPosition);\n    }\n  };\n  /**\r\n   * @ignore\r\n   */\n\n\n  CategoryAxis.prototype.disposeData = function () {\n    this.dataItemsByCategory.clear();\n\n    _super.prototype.disposeData.call(this);\n  };\n  /**\r\n   * Processes the axis data item.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param dataItem     Data item\r\n   * @param dataContext  The raw data that corresponds to this data item\r\n   */\n\n\n  CategoryAxis.prototype.processDataItem = function (dataItem, dataContext) {\n    if (dataItem) {\n      // creat a collection for fast access\n      _super.prototype.processDataItem.call(this, dataItem, dataContext); // check if such category already exists\n      //let existingDataItem: CategoryAxisDataItem = this.dataItemsByCategory.getKey(dataItem.category);\n      //if (existingDataItem && existingDataItem != dataItem) {\n      //\tthis.dataItems.remove(existingDataItem);\n      //}\n\n\n      if ($type.hasValue(dataItem.category)) {\n        this.dataItemsByCategory.setKey(dataItem.category, dataItem);\n      }\n    }\n  };\n\n  CategoryAxis.prototype.getDataItem = function (dataContext) {\n    var category = dataContext[this.dataFields.category];\n\n    if ($type.hasValue(category)) {\n      var dataItem = this.dataItemsByCategory.getKey(category);\n\n      if (dataItem) {\n        return dataItem;\n      } else {\n        return this.dataItems.create();\n      }\n    }\n  };\n  /**\r\n   * Converts a category index to an actual screen coordinate on the axis.\r\n   *\r\n   * `location` identifies relative location within category. 0 - beginning,\r\n   * 0.5 - middle, 1 - end, and anything inbetween.\r\n   *\r\n   * @param index     Index\r\n   * @param location  Location (0-1)\r\n   * @return Position (px)\r\n   */\n\n\n  CategoryAxis.prototype.indexToPosition = function (index, location) {\n    if (!$type.isNumber(location)) {\n      location = 0.5;\n    }\n\n    var startIndex = this.startIndex;\n    var endIndex = this.endIndex;\n    var difference = this.adjustDifference(startIndex, endIndex);\n    var startLocation = this.startLocation;\n    var endLocation = this.endLocation;\n    difference -= startLocation;\n    difference -= 1 - endLocation;\n\n    if (this._axisBreaks) {\n      var axisBreaks = this._axisBreaks;\n      $iter.eachContinue(axisBreaks.iterator(), function (axisBreak) {\n        var breakStartIndex = axisBreak.adjustedStartValue;\n        var breakEndIndex = axisBreak.adjustedEndValue;\n\n        if (index < startIndex || !$type.isNumber(breakStartIndex) || !$type.isNumber(breakEndIndex)) {\n          return false;\n        }\n\n        if ($math.intersect({\n          start: breakStartIndex,\n          end: breakEndIndex\n        }, {\n          start: startIndex,\n          end: endIndex\n        })) {\n          breakStartIndex = Math.max(startIndex, breakStartIndex);\n          breakEndIndex = Math.min(endIndex, breakEndIndex);\n          var breakSize = axisBreak.breakSize; // value to the right of break end\n\n          if (index > breakEndIndex) {\n            startIndex += (breakEndIndex - breakStartIndex) * (1 - breakSize);\n          } // value to the left of break start\n          else if (index < breakStartIndex) {} // value within break\n          else {\n            index = breakStartIndex + (index - breakStartIndex) * breakSize;\n          }\n        }\n\n        return true;\n      });\n    }\n\n    var deltaPosition = 0;\n    var dataItem = this.dataItems.getIndex(index);\n\n    if (dataItem) {\n      deltaPosition = dataItem.deltaPosition;\n    }\n\n    return $math.round(deltaPosition + (index + location - startLocation - startIndex) / difference, 5);\n  };\n  /**\r\n   * Converts a string category name to relative position on axis.\r\n   *\r\n   * `location` identifies relative location within category. 0 - beginning,\r\n   * 0.5 - middle, 1 - end, and anything inbetween.\r\n   *\r\n   * @param category  Category name\r\n   * @param location  Location (0-1)\r\n   * @return Position\r\n   */\n\n\n  CategoryAxis.prototype.categoryToPosition = function (category, location) {\n    var index = this.categoryToIndex(category);\n    return this.indexToPosition(index, location);\n  };\n  /**\r\n   * Converts a string category name to a orientation point (x, y, angle) on axis\r\n   *\r\n   * `location` identifies relative location within category. 0 - beginning,\r\n   * 0.5 - middle, 1 - end, and anything inbetween.\r\n   * @param category  Category name\r\n   * @param location  Location (0-1)\r\n   * @return Orientation point\r\n   */\n\n\n  CategoryAxis.prototype.categoryToPoint = function (category, location) {\n    var position = this.categoryToPosition(category, location);\n    var point = this.renderer.positionToPoint(position);\n    var angle = this.renderer.positionToAngle(position);\n    return {\n      x: point.x,\n      y: point.y,\n      angle: angle\n    };\n  };\n  /**\r\n   * Converts a string category name to a orientation point (x, y, angle) on axis\r\n   *\r\n   * `location` identifies relative location within category. 0 - beginning,\r\n   * 0.5 - middle, 1 - end, and anything inbetween.\r\n   * @param category  Category name\r\n   * @param location  Location (0-1)\r\n   * @return Orientation point\r\n   */\n\n\n  CategoryAxis.prototype.anyToPoint = function (category, location) {\n    return this.categoryToPoint(category, location);\n  };\n  /**\r\n   * Converts a string category name to relative position on axis.\r\n   *\r\n   * An alias to `categoryToPosition()`.\r\n   *\r\n   * @param category  Category name\r\n   * @param location  Location (0-1)\r\n   * @return Relative position\r\n   */\n\n\n  CategoryAxis.prototype.anyToPosition = function (category, location) {\n    return this.categoryToPosition(category, location);\n  };\n  /**\r\n   * Converts named category to an index of data item it corresponds to.\r\n   *\r\n   * @param category  Category\r\n   * @return Data item index\r\n   */\n\n\n  CategoryAxis.prototype.categoryToIndex = function (category) {\n    if ($type.hasValue(category)) {\n      var dataItem = this.dataItemsByCategory.getKey(category);\n\n      if (dataItem) {\n        return dataItem.index;\n      }\n    }\n  };\n  /**\r\n   * Zooms the axis to specific named ctaegories.\r\n   *\r\n   * @param startCategory  Start category\r\n   * @param endCategory    End category\r\n   */\n\n\n  CategoryAxis.prototype.zoomToCategories = function (startCategory, endCategory) {\n    this.zoomToIndexes(this.categoryToIndex(startCategory), this.categoryToIndex(endCategory) + 1);\n  };\n  /**\r\n   * [getAnyRangePath description]\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description\r\n   * @param start         [description]\r\n   * @param end           [description]\r\n   * @param startLocation [description]\r\n   * @param endLocation   [description]\r\n   * @return [description]\r\n   */\n\n\n  CategoryAxis.prototype.getAnyRangePath = function (start, end, startLocation, endLocation) {\n    var startPos = this.categoryToPosition(start, startLocation);\n    var endPos = this.categoryToPosition(end, endLocation);\n    return this.getPositionRangePath(startPos, endPos); // Base class (Axis) gets range shape from AxisRenderer\n  };\n  /**\r\n   * Takes an absolute position (px) within axis and adjust it to a specific\r\n   * `location` within category it corresponds to.\r\n   *\r\n   * @param position  Source position (px)\r\n   * @param location  Location within category (0-1)\r\n   * @return Adjusted position (px)\r\n   */\n\n\n  CategoryAxis.prototype.roundPosition = function (position, location) {\n    var index = this.positionToIndex(position);\n    return this.indexToPosition(index, location);\n  };\n  /**\r\n   * Finds and returns first series data item with specific category\r\n   * @param series    Target series\r\n   * @param category  Category\r\n   * @return XYSeriesDataItem data item\r\n   */\n\n\n  CategoryAxis.prototype.getFirstSeriesDataItem = function (series, category) {\n    for (var i = 0; i < series.dataItems.length; i++) {\n      var dataItem = series.dataItems.getIndex(i);\n\n      if (series.xAxis == this) {\n        if (dataItem.categoryX == category) {\n          return dataItem;\n        }\n      }\n\n      if (series.yAxis == this) {\n        if (dataItem.categoryY == category) {\n          return dataItem;\n        }\n      }\n    }\n  };\n  /**\r\n   * Finds and returns last series data item with specific category.\r\n   * @param series    Target series\r\n   * @param category  Category\r\n   * @return XYSeriesDataItem data item\r\n   */\n\n\n  CategoryAxis.prototype.getLastSeriesDataItem = function (series, category) {\n    for (var i = series.dataItems.length - 1; i >= 0; i--) {\n      var dataItem = series.dataItems.getIndex(i);\n\n      if (series.xAxis == this) {\n        if (dataItem.categoryX == category) {\n          return dataItem;\n        }\n      }\n\n      if (series.yAxis == this) {\n        if (dataItem.categoryY == category) {\n          return dataItem;\n        }\n      }\n    }\n  }; // todo: optimize\n\n\n  CategoryAxis.prototype.getSeriesDataItemByCategory = function (category, series) {\n    var _this = this;\n\n    var seriesDataItem;\n    series.dataItems.each(function (dataItem) {\n      if (series.xAxis == _this) {\n        if (dataItem.categoryX == category) {\n          seriesDataItem = dataItem;\n        }\n      } else if (series.yAxis == _this) {\n        if (dataItem.categoryY == category) {\n          seriesDataItem = dataItem;\n        }\n      }\n    });\n    return seriesDataItem;\n  };\n  /**\r\n   * Returns a data item from Series that corresponds to a specific absolute\r\n   * position on the Axis.\r\n   *\r\n   * @param series    Target series\r\n   * @param position  Position (px)\r\n   * @return XYSeriesDataItem data item\r\n   */\n\n\n  CategoryAxis.prototype.getSeriesDataItem = function (series, position, findNearest) {\n    var _this = this;\n\n    if ($type.isNumber(position)) {\n      var index_1 = this.positionToIndex(position);\n\n      if (index_1 >= this.dataItems.length) {\n        index_1--;\n      }\n\n      var dataItem = this.dataItems.getIndex(index_1);\n\n      if (dataItem) {\n        var category_1 = dataItem.category;\n        var sdi_1;\n        var seriesDataItem = series.dataItems.getIndex(index_1);\n\n        if (seriesDataItem) {\n          if (series.xAxis == this) {\n            if (seriesDataItem.categoryX == category_1) {\n              return seriesDataItem;\n            }\n          }\n\n          if (series.yAxis == this) {\n            if (seriesDataItem.categoryY == category_1) {\n              return seriesDataItem;\n            }\n          }\n        }\n\n        series.dataItems.each(function (dataItem) {\n          if (series.xAxis == _this) {\n            if (dataItem.categoryX == category_1) {\n              if (!sdi_1) {\n                sdi_1 = dataItem;\n              }\n\n              if (Math.abs(index_1 - sdi_1.index) > Math.abs(index_1 - dataItem.index)) {\n                sdi_1 = dataItem;\n              }\n            }\n          }\n\n          if (series.yAxis == _this) {\n            if (dataItem.categoryY == category_1) {\n              if (!sdi_1) {\n                sdi_1 = dataItem;\n              }\n\n              if (Math.abs(index_1 - sdi_1.index) > Math.abs(index_1 - dataItem.index)) {\n                sdi_1 = dataItem;\n              }\n            }\n          }\n        }); //@todo\n\n        if (findNearest) {}\n\n        return sdi_1;\n      }\n    }\n  };\n  /**\r\n   * Returns the X coordinate for series' data item.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description (review)\r\n   * @param dataItem  Data item\r\n   * @param key       Category\r\n   * @param location  Location (0-1)\r\n   * @return X coordinate (px)\r\n   */\n\n\n  CategoryAxis.prototype.getX = function (dataItem, key, location, stackKey, range) {\n    var position = this.getPositionX(dataItem, key, location, stackKey, range);\n\n    if ($type.isNaN(position)) {\n      return this.basePoint.x;\n    } else {\n      return this.renderer.positionToPoint(position).x;\n    }\n  };\n  /**\r\n   * Returns relative position on axis for series' data item.\r\n   *\r\n   * @since 4.5.14\r\n   * @param  dataItem  Data item\r\n   * @param  key       Category\r\n   * @param  location  Location (0-1)\r\n   * @return           Relative position\r\n   */\n\n\n  CategoryAxis.prototype.getPositionX = function (dataItem, key, location, stackKey, range) {\n    var position;\n\n    if ($type.hasValue(key)) {\n      position = this.categoryToPosition(dataItem.categories[key], location);\n    }\n\n    if (range) {\n      position = $math.fitToRange(position, range.start, range.end);\n    }\n\n    return position;\n  };\n  /**\r\n   * Returns the Y coordinate for series' data item.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description (review)\r\n   * @param dataItem  Data item\r\n   * @param key       Category\r\n   * @param location  Location (0-1)\r\n   * @return Y coordinate (px)\r\n   */\n\n\n  CategoryAxis.prototype.getY = function (dataItem, key, location, stackKey, range) {\n    var position = this.getPositionY(dataItem, key, location, stackKey, range);\n\n    if ($type.isNaN(position)) {\n      return this.basePoint.y;\n    } else {\n      return this.renderer.positionToPoint(position).y;\n    }\n  };\n  /**\r\n   * Returns relative position on axis for series' data item.\r\n   *\r\n   * @since 4.5.14\r\n   * @param  dataItem  Data item\r\n   * @param  key       Category\r\n   * @param  location  Location (0-1)\r\n   * @return           Relative position\r\n   */\n\n\n  CategoryAxis.prototype.getPositionY = function (dataItem, key, location, stackKey, range) {\n    var position;\n\n    if ($type.hasValue(key)) {\n      position = this.categoryToPosition(dataItem.categories[key], location);\n    }\n\n    if (range) {\n      position = $math.fitToRange(position, range.start, range.end);\n    }\n\n    return position;\n  };\n  /**\r\n   * Returns an angle for series data item.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description (review)\r\n   * @param dataItem  Data item\r\n   * @param key       Category\r\n   * @param location  Location (0-1)\r\n   * @param stackKey  Stack key (?)\r\n   * @param range Range to fit in\r\n   * @return Angle\r\n   */\n\n\n  CategoryAxis.prototype.getAngle = function (dataItem, key, location, stackKey, range) {\n    var position = this.categoryToPosition(dataItem.categories[key], location);\n\n    if (range) {\n      position = $math.fitToRange(position, range.start, range.end);\n    }\n\n    return this.positionToAngle(position);\n  };\n  /**\r\n   * Returns an absolute pixel coordinate of the start of the cell (category),\r\n   * that specific position value falls into.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description (review)\r\n   * @param position  Position (px)\r\n   * @return Cell start position (px)\r\n   */\n\n\n  CategoryAxis.prototype.getCellStartPosition = function (position) {\n    return this.roundPosition(position, 0);\n  };\n  /**\r\n   * Returns an absolute pixel coordinate of the end of the cell (category),\r\n   * that specific position value falls into.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description (review)\r\n   * @param position  Position (px)\r\n   * @return Cell end position (px)\r\n   */\n\n\n  CategoryAxis.prototype.getCellEndPosition = function (position) {\n    return this.roundPosition(position, 1);\n  };\n  /**\r\n   * Returns text to show in a category tooltip, based on specific position\r\n   * within axis.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param position  Position (px)\r\n   * @return Label (category)\r\n   */\n\n\n  CategoryAxis.prototype.getTooltipText = function (position) {\n    var dataItem = this.dataItems.getIndex(this.positionToIndex(position));\n\n    if (dataItem) {\n      this.tooltipDataItem = dataItem;\n      this.tooltip.dataItem = dataItem;\n\n      if (this.tooltipText) {\n        return this.tooltipText;\n      }\n\n      if (!this._adapterO) {\n        return dataItem.category;\n      } else {\n        return this._adapterO.apply(\"getTooltipText\", dataItem.category);\n      }\n    }\n  };\n  /**\r\n   * Returns an index of the category that corresponds to specific pixel\r\n   * position within axis.\r\n   *\r\n   * @param position  Position (px)\r\n   * @return Category index\r\n   */\n\n\n  CategoryAxis.prototype.positionToIndex = function (position) {\n    position = $math.round(position, 10);\n\n    if (position < 0) {\n      position = 0;\n    }\n\n    if (position > 1) {\n      position = 1;\n    }\n\n    var startIndex = this.startIndex;\n    var endIndex = this.endIndex;\n    var difference = endIndex - startIndex - this.startLocation - (1 - this.endLocation);\n    position += 1 / difference * this.startLocation;\n    var index = null;\n\n    if (this._axisBreaks) {\n      var axisBreaks = this._axisBreaks; // in case we have some axis breaks\n\n      $iter.eachContinue(axisBreaks.iterator(), function (axisBreak) {\n        var breakStartPosition = axisBreak.startPosition;\n        var breakEndPosition = axisBreak.endPosition;\n        var breakStartIndex = axisBreak.adjustedStartValue;\n        var breakEndIndex = axisBreak.adjustedEndValue;\n        breakStartIndex = $math.max(breakStartIndex, startIndex);\n        breakEndIndex = $math.min(breakEndIndex, endIndex);\n        var breakSize = axisBreak.breakSize;\n        difference -= (breakEndIndex - breakStartIndex) * (1 - breakSize); // position to the right of break end\n\n        if (position > breakEndPosition) {\n          startIndex += (breakEndIndex - breakStartIndex) * (1 - breakSize);\n        } // position to the left of break start\n        else if (position < breakStartPosition) {} // value within break\n        else {\n          var breakPosition = (position - breakStartPosition) / (breakEndPosition - breakStartPosition);\n          index = breakStartIndex + Math.round(breakPosition * (breakEndIndex - breakStartIndex));\n          return false;\n        }\n\n        return true;\n      });\n    }\n\n    if (!$type.isNumber(index)) {\n      index = Math.floor(position * difference + startIndex);\n    }\n\n    if (index >= this.dataItems.length) {\n      index = this.dataItems.length - 1;\n    } // not good, when panning out of bounds, each time one less item gets selected\n    //if (index >= endIndex) {\n    //\tindex--;\n    //}\n\n\n    return index;\n  };\n  /**\r\n   * Returns category based on position.\r\n   *\r\n   * Please note that `position` represents position within axis which may be\r\n   * zoomed and not correspond to Cursor's `position`.\r\n   *\r\n   * To convert Cursor's `position` to Axis' `position` use `toAxisPosition()` method.\r\n   *\r\n   * This is a synonim of `getPositionLabel()` implemented here for consistentcy.\r\n   *\r\n   * @since 4.3.8\r\n   * @see {@link https://www.amcharts.com/docs/v4/tutorials/tracking-cursors-position-via-api/#Tracking_Cursor_s_position} For more information about cursor tracking.\r\n   * @param position  Relative position on axis (0-1)\r\n   * @return Position label\r\n   */\n\n\n  CategoryAxis.prototype.positionToCategory = function (position) {\n    return this.getPositionLabel(position);\n  };\n  /**\r\n   * Returns category based on position.\r\n   *\r\n   * Please note that `position` represents position within axis which may be\r\n   * zoomed and not correspond to Cursor's `position`.\r\n   *\r\n   * To convert Cursor's `position` to Axis' `position` use `toAxisPosition()` method.\r\n   *\r\n   * @see {@link https://www.amcharts.com/docs/v4/tutorials/tracking-cursors-position-via-api/#Tracking_Cursor_s_position} For more information about cursor tracking.\r\n   * @param position  Relative position on axis (0-1)\r\n   * @return Position label\r\n   */\n\n\n  CategoryAxis.prototype.getPositionLabel = function (position) {\n    var dataItem = this.dataItems.getIndex(this.positionToIndex(position));\n\n    if (dataItem) {\n      return dataItem.category;\n    }\n  };\n\n  Object.defineProperty(CategoryAxis.prototype, \"basePoint\", {\n    /**\r\n     * Coordinates of the actual axis start.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @return Base point\r\n     */\n    get: function () {\n      // This makes base grid to be drawn at the end of the axis and adds extra\n      // grid which we need to nicely close the chart.\n      return this.renderer.positionToPoint(1);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Initializes Axis' renderer.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n  CategoryAxis.prototype.initRenderer = function () {\n    _super.prototype.initRenderer.call(this);\n\n    var renderer = this.renderer;\n    renderer.baseGrid.disabled = true;\n  };\n\n  Object.defineProperty(CategoryAxis.prototype, \"frequency\", {\n    /**\r\n     * Current frequency of labels of the axis.\r\n     *\r\n     * Normally it would be 1, but when labels start to be hidden due\r\n     * to `minGridDistance` this read-only property will increase.\r\n     *\r\n     * @readonly\r\n     * @since 4.2.0\r\n     * @return Label frequency\r\n     */\n    get: function () {\n      return this._frequency;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(CategoryAxis.prototype, \"sortBySeries\", {\n    /**\r\n     * @return Sort categories?\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"sortBySeries\");\n    },\n\n    /**\r\n     * If set to a reference of [[ColumnSeries]] the categories will be sorted\r\n     * by actual values.\r\n     *\r\n     * The categories are ordered in descending order (from highest values to\r\n     * lowest). To reverse the order, use axis renderer's `inversed` setting.\r\n     * E.g.:\r\n     *\r\n     * ```TypeScript\r\n     * categoryAxis.sortBySeries = series;\r\n     * categoryAxis.renderer.inversed = true;\r\n     * ```\r\n     * ```JavaScript\r\n     * categoryAxis.sortBySeries = series;\r\n     * categoryAxis.renderer.inversed = true;\r\n     * ```\r\n     * ```JSON\r\n     * {\r\n     *   // ...\r\n     *   \"xAxes\": [{\r\n     *     // ...\r\n     *     \"sortBySeries\": \"s1\",\r\n     *     \"renderer\": {\r\n     *       // ...\r\n     *       \"inversed\": true\r\n     *     }\r\n     *   }]\r\n     * }\r\n     * ```\r\n     *\r\n     * @since 4.8.7\r\n     * @param  value  Sort categories?\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"sortBySeries\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Processes JSON-based config before it is applied to the object.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param config  Config\r\n   */\n\n  CategoryAxis.prototype.processConfig = function (config) {\n    if (config) {\n      if ($type.hasValue(config.sortBySeries) && $type.isString(config.sortBySeries)) {\n        if (this.map.hasKey(config.sortBySeries)) {\n          config.sortBySeries = this.map.getKey(config.sortBySeries);\n        } else {\n          this.addDelayedMap(\"sortBySeries\", config.sortBySeries);\n          delete config.sortBySeries;\n        }\n      }\n    }\n\n    _super.prototype.processConfig.call(this, config);\n  };\n\n  return CategoryAxis;\n}(Axis);\n\nexport { CategoryAxis };\n/**\r\n * Register class, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\n\nregistry.registeredClasses[\"CategoryAxis\"] = CategoryAxis;\nregistry.registeredClasses[\"CategoryAxisDataItem\"] = CategoryAxisDataItem;","map":{"version":3,"mappings":"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","names":["Axis","AxisDataItem","AxisRendererX","AxisRendererY","registry","Dictionary","CategoryAxisBreak","$math","$type","$iter","__extends","_super","_this","className","text","locations","category","endCategory","deltaPosition","applyTheme","Object","CategoryAxisDataItem","_adapterO","isEnabled","apply","properties","value","oldCategory","setProperty","hasValue","component","validateDataElement","deltaCoordinate","invalidateDataItems","invalidateSeries","axisFieldName","_lastDataItem","createDataItem","_disposers","push","dataItemsByCategory","addDisposer","mainDataSet","events","on","event","removeKey","oldValue","CategoryAxis","dataItem","axisLetter","processSeriesDataItem","call","categoryAxisDataItem","getKey","seriesId","uid","seriesDataItems","dataItems","remove","validateDataRange","each","_series","iterator","series","xAxis","yAxis","invalidateDataRange","startIndex","positionToIndex","start","endIndex","end","length","minIndex","maxIndex","i","axisDataItem","getIndex","i_1","seriesDataItem","index","isNumber","_axisBreaks","validate","dataCount","fitToRange","Math","floor","ceil","renderer","invalid","maxCount","axisLength","max","minGridDistance","Number","MAX_SAFE_INTEGER","frequency","min","_startIndex","_endIndex","fixAxisBreaks","_frequency","maxZoomFactor","resetIterators","itemIndex","__disabled","len","round","axisBreak","isInBreak","appendDataItem","axisBreaks","adjustedStartValue","adjustedEndValue","intersect","b","frequency_1","breakSize","itemIndex_1","validateBreaks","validateAxisRanges","ghostLabel","invalidate","invalidateLayout","_axisItemCount","categoryToIndex","position","indexToPosition","endPosition","fillEndIndex","fillPosition","fillEndPosition","isRange","point","positionToPoint","tick","disabled","updateTickElement","grid","updateGridElement","label","undefined","updateLabelElement","measuredWidth","measuredHeight","html","currentText","fill","axisFill","location","updateFillElement","fillRule","bullet","updateBullet","mask","clear","disposeData","dataContext","processDataItem","setKey","dataFields","create","difference","adjustDifference","startLocation","endLocation","eachContinue","breakStartIndex","breakEndIndex","categoryToPosition","angle","positionToAngle","x","y","categoryToPoint","startCategory","zoomToIndexes","startPos","endPos","getPositionRangePath","categoryX","categoryY","findNearest","index_1","category_1","sdi_1","abs","key","stackKey","range","getPositionX","isNaN","basePoint","categories","getPositionY","roundPosition","tooltipDataItem","tooltip","tooltipText","breakStartPosition","startPosition","breakEndPosition","breakPosition","getPositionLabel","initRenderer","baseGrid","getPropertyValue","setPropertyValue","config","sortBySeries","isString","map","hasKey","addDelayedMap","processConfig","registeredClasses"],"sourceRoot":"","sources":["../../../../../src/.internal/charts/axes/CategoryAxis.ts"],"sourcesContent":["/**\r\n * Category axis module\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { Axis, AxisItemLocation, AxisDataItem, IAxisProperties, IAxisDataFields, IAxisAdapters, IAxisEvents, IAxisDataItemAdapters } from \"./Axis\";\r\nimport { IPoint, IOrientationPoint } from \"../../core/defs/IPoint\";\r\nimport { Animation } from \"../../core/utils/Animation\";\r\nimport { AxisFill } from \"./AxisFill\";\r\nimport { AxisRenderer } from \"./AxisRenderer\";\r\nimport { AxisRendererX } from \"./AxisRendererX\";\r\nimport { AxisRendererY } from \"./AxisRendererY\";\r\nimport { SerialChart } from \"../types/SerialChart\";\r\nimport { AxisTick } from \"./AxisTick\";\r\nimport { Grid } from \"./Grid\";\r\nimport { AxisLabel } from \"./AxisLabel\";\r\nimport { registry } from \"../../core/Registry\";\r\nimport { Dictionary } from \"../../core/utils/Dictionary\";\r\nimport { XYSeries, XYSeriesDataItem } from \"../series/XYSeries\";\r\nimport { ColumnSeries } from \"../series/ColumnSeries\";\r\nimport { CategoryAxisBreak } from \"./CategoryAxisBreak\";\r\nimport * as $math from \"../../core/utils/Math\";\r\nimport * as $type from \"../../core/utils/Type\";\r\nimport * as $iter from \"../../core/utils/Iterator\";\r\nimport { IRange } from \"../../core/defs/IRange\";\r\n\r\n/**\r\n * ============================================================================\r\n * DATA ITEM\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Defines a [[DataItem]] for [[CategoryAxis]].\r\n *\r\n * @see {@link DataItem}\r\n */\r\nexport class CategoryAxisDataItem extends AxisDataItem {\r\n\r\n\t/**\r\n\t * Defines a type of [[Component]] this data item is used for.\r\n\t */\r\n\tpublic _component!: CategoryAxis;\r\n\r\n\tpublic seriesDataItems: { [index: string]: XYSeriesDataItem[] } = {};\r\n\r\n\tpublic deltaAnimation: Animation;\r\n\r\n\t/**\r\n\t * Defines available adapters.\r\n\t */\r\n\tpublic _adapter!: ICategoryAxisDataItemAdapters;\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor() {\r\n\t\tsuper();\r\n\t\tthis.className = \"CategoryAxisDataItem\";\r\n\t\tthis.text = \"{category}\";\r\n\r\n\t\tthis.locations.category = 0;\r\n\t\tthis.locations.endCategory = 1;\r\n\r\n\t\tthis.deltaPosition = 0;\r\n\r\n\t\tthis.applyTheme();\r\n\t}\r\n\r\n\t/**\r\n\t * Category.\r\n\t *\r\n\t * @param value  Category\r\n\t */\r\n\tpublic set category(value: string) {\r\n\t\tlet oldCategory = this.properties.category;\r\n\t\tthis.setProperty(\"category\", value);\r\n\t\tif ($type.hasValue(oldCategory) && oldCategory != value) {\r\n\t\t\tif (this.component) {\r\n\t\t\t\tthis.component.validateDataElement(this);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @return Category\r\n\t */\r\n\tpublic get category(): string {\r\n\t\tif (this._adapterO) {\r\n\t\t\tif (this._adapterO.isEnabled(\"category\")) {\r\n\t\t\t\treturn this._adapterO.apply(\"category\", this.properties.category);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn this.properties.category;\r\n\t}\r\n\r\n\t/**\r\n\t * End category.\r\n\t *\r\n\t * Used for items that span several categories, like [[CategoryAxisBreak]].\r\n\t *\r\n\t * @param value  End category\r\n\t */\r\n\tpublic set endCategory(value: string) {\r\n\t\tthis.setProperty(\"endCategory\", value);\r\n\t}\r\n\r\n\t/**\r\n\t * @return End category\r\n\t */\r\n\tpublic get endCategory(): string {\r\n\t\treturn this.properties.endCategory;\r\n\t}\r\n\r\n\tpublic set deltaPosition(value: number) {\r\n\t\tif (value != this.properties.deltaCoordinate) {\r\n\t\t\tthis.setProperty(\"deltaCoordinate\", value);\r\n\t\t\tif (this.component) {\r\n\t\t\t\tthis.component.invalidateDataItems();\r\n\t\t\t\tthis.component.invalidateSeries();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tpublic get deltaPosition(): number {\r\n\t\treturn this.properties.deltaCoordinate;\r\n\t}\r\n}\r\n\r\n/**\r\n * Defines adapters for [[DataItem]]\r\n * Includes both the [[Adapter]] definitions and properties\r\n * @see {@link Adapter}\r\n */\r\nexport interface ICategoryAxisDataItemAdapters extends IAxisDataItemAdapters {\r\n\tcategory: string;\r\n}\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * REQUISITES\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Defines data fields for [[CategoryAxis]].\r\n */\r\nexport interface ICategoryAxisDataFields extends IAxisDataFields {\r\n\r\n\t/**\r\n\t * A field that holds category information.\r\n\t */\r\n\tcategory?: string;\r\n\r\n}\r\n\r\n/**\r\n * Defines properties for [[CategoryAxis]].\r\n */\r\nexport interface ICategoryAxisProperties extends IAxisProperties {\r\n\tsortBySeries?: ColumnSeries;\r\n}\r\n\r\n/**\r\n * Defines events for [[CategoryAxis]].\r\n */\r\nexport interface ICategoryAxisEvents extends IAxisEvents { }\r\n\r\n/**\r\n * Defines adapter for [[CategoryAxis]].\r\n *\r\n * @see {@link Adapter}\r\n */\r\nexport interface ICategoryAxisAdapters extends IAxisAdapters, ICategoryAxisProperties { }\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Used to create a category-based axis for the chart.\r\n *\r\n * ```TypeScript\r\n * // Create the axis\r\n * let xAxis = chart.xAxes.push(new am4charts.CategoryAxis());\r\n *\r\n * // Set settings\r\n * xAxis.title.text = \"Clients\";\r\n * ```\r\n * ```JavaScript\r\n * // Create the axis\r\n * var valueAxis = chart.xAxes.push(new am4charts.CategoryAxis());\r\n *\r\n * // Set settings\r\n * valueAxis.title.text = \"Clients\";\r\n * ```\r\n * ```JSON\r\n * \"xAxes\": [{\r\n *   \"type\": \"CategoryAxis\",\r\n *   \"title\": {\r\n *     \"text\": \"Clients\"\r\n *   }\r\n * }]\r\n * ```\r\n *\r\n * @see {@link ICategoryAxisEvents} for a list of available Events\r\n * @see {@link ICategoryAxisAdapters} for a list of available Adapters\r\n * @important\r\n */\r\nexport class CategoryAxis<T extends AxisRenderer = AxisRenderer> extends Axis<T> {\r\n\r\n\t/**\r\n\t * Defines data fields.\r\n\t */\r\n\tpublic _dataFields: ICategoryAxisDataFields;\r\n\r\n\t/**\r\n\t * Defines available properties.\r\n\t */\r\n\tpublic _properties!: ICategoryAxisProperties;\r\n\r\n\t/**\r\n\t * Defines available adapters.\r\n\t */\r\n\tpublic _adapter!: ICategoryAxisAdapters;\r\n\r\n\t/**\r\n\t * Defines available events.\r\n\t */\r\n\tpublic _events!: ICategoryAxisEvents;\r\n\r\n\t/**\r\n\t * Defines the type of the Date Items.\r\n\t */\r\n\tpublic _dataItem: CategoryAxisDataItem;\r\n\r\n\t/**\r\n\t * Defines the type of the axis breaks.\r\n\t */\r\n\tpublic _axisBreak: CategoryAxisBreak;\r\n\r\n\t/**\r\n\t * A reference to chart the axis is for.\r\n\t */\r\n\tpublic chart: SerialChart;\r\n\r\n\t/**\r\n\t * Frequency of the labels on axis.\r\n\t */\r\n\tprotected _frequency: number;\r\n\r\n\t/**\r\n\t * A collection that holds Axis' data items sorted by each category.\r\n\t */\r\n\tpublic dataItemsByCategory: Dictionary<string, this[\"_dataItem\"]> = new Dictionary<string, this[\"_dataItem\"]>();\r\n\r\n\t/**\r\n\t * last data item is used for the closing grid\r\n\t */\r\n\tprotected _lastDataItem: CategoryAxisDataItem;\r\n\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor() {\r\n\r\n\t\t// Init\r\n\t\tsuper();\r\n\t\tthis.className = \"CategoryAxis\";\r\n\r\n\t\t// Set field name\r\n\t\tthis.axisFieldName = \"category\";\r\n\r\n\t\tthis._lastDataItem = this.createDataItem();\r\n\t\tthis._lastDataItem.component = this;\r\n\t\tthis._disposers.push(this._lastDataItem);\r\n\r\n\r\n\t\t// Apply theme\r\n\t\tthis.applyTheme();\r\n\r\n\t\tlet dataItemsByCategory = this.dataItemsByCategory;\r\n\t\tthis.addDisposer(this.mainDataSet.events.on(\"removed\", function(event) {\r\n\t\t\tdataItemsByCategory.removeKey(event.oldValue.category);\r\n\t\t}))\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a new/empty [[DataItem]] of the type appropriate for this object.\r\n\t *\r\n\t * @see {@link DataItem}\r\n\t * @return Data Item\r\n\t */\r\n\tprotected createDataItem(): this[\"_dataItem\"] {\r\n\t\treturn new CategoryAxisDataItem();\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a new/empty [[AxisBreak]] of the appropriate type.\r\n\t *\r\n\t * @return Axis break\r\n\t */\r\n\tprotected createAxisBreak(): this[\"_axisBreak\"] {\r\n\t\treturn new CategoryAxisBreak();\r\n\t}\r\n\r\n\t/**\r\n\t * Processes a related series' data item.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description\r\n\t * @param dataItem  Data item\r\n\t */\r\n\tpublic processSeriesDataItem(dataItem: XYSeriesDataItem, axisLetter?: string): void {\r\n\t\tsuper.processSeriesDataItem(dataItem, axisLetter);\r\n\t\tlet category: string = (<any>dataItem)[\"category\" + this.axisLetter];\r\n\t\tif ($type.hasValue(category)) {\r\n\t\t\tlet categoryAxisDataItem: this[\"_dataItem\"] = this.dataItemsByCategory.getKey(category);\r\n\t\t\tif (categoryAxisDataItem) {\r\n\t\t\t\tlet seriesId = dataItem.component.uid;\r\n\t\t\t\tlet seriesDataItems = categoryAxisDataItem.seriesDataItems[seriesId];\r\n\t\t\t\tif (!seriesDataItems) {\r\n\t\t\t\t\tseriesDataItems = [];\r\n\t\t\t\t\tcategoryAxisDataItem.seriesDataItems[seriesId] = seriesDataItems;\r\n\t\t\t\t}\r\n\t\t\t\tseriesDataItems.push(dataItem);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\tdataItem.component.dataItems.remove(dataItem);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Validates the data range.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description (review)\r\n\t */\r\n\tpublic validateDataRange(): void {\r\n\r\n\t\tsuper.validateDataRange();\r\n\r\n\t\t$iter.each(this._series.iterator(), (series) => {\r\n\t\t\tif ((series.xAxis instanceof CategoryAxis) && (series.yAxis instanceof CategoryAxis)) {\r\n\t\t\t\tseries.invalidateDataRange();\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tlet startIndex = this.positionToIndex(this.start);\r\n\t\t\t\tlet endIndex = this.positionToIndex(this.end);\r\n\r\n\t\t\t\tif (endIndex >= this.dataItems.length) {\r\n\t\t\t\t\tendIndex--;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet seriesId = series.uid;\r\n\t\t\t\tlet minIndex: number;\r\n\t\t\t\tlet maxIndex: number;\r\n\r\n\t\t\t\tfor (let i = startIndex; i <= endIndex; i++) {\r\n\t\t\t\t\tlet axisDataItem = this.dataItems.getIndex(i);\r\n\t\t\t\t\tif (axisDataItem) {\r\n\t\t\t\t\t\tlet seriesDataItems = axisDataItem.seriesDataItems[seriesId];\r\n\r\n\t\t\t\t\t\tif (seriesDataItems) {\r\n\t\t\t\t\t\t\tfor (let i = 0; i < seriesDataItems.length; i++) {\r\n\t\t\t\t\t\t\t\tlet seriesDataItem = seriesDataItems[i];\r\n\t\t\t\t\t\t\t\tif (seriesDataItem) {\r\n\t\t\t\t\t\t\t\t\tlet index = seriesDataItem.index;\r\n\t\t\t\t\t\t\t\t\tif (!$type.isNumber(minIndex) || index < minIndex) {\r\n\t\t\t\t\t\t\t\t\t\tminIndex = index;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\tif (!$type.isNumber(maxIndex) || index > maxIndex) {\r\n\t\t\t\t\t\t\t\t\t\tmaxIndex = index;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ($type.isNumber(minIndex)) {\r\n\t\t\t\t\tseries.startIndex = minIndex;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tseries.start = this.start;\r\n\t\t\t\t}\r\n\t\t\t\tif ($type.isNumber(maxIndex)) {\r\n\t\t\t\t\tseries.endIndex = maxIndex + 1;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tseries.end = this.end;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// range might not change, but axis breaks might.\r\n\t\t\t\tif (this._axisBreaks && this._axisBreaks.length > 0) {\r\n\t\t\t\t\tseries.invalidateDataRange();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Validates the whole axis. Causes it to redraw.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description (review)\r\n\t */\r\n\tpublic validate(): void {\r\n\r\n\t\tsuper.validate();\r\n\r\n\t\tlet dataCount: number = this.dataItems.length;\r\n\r\n\t\tlet startIndex = $math.fitToRange(Math.floor(this.start * dataCount - 1), 0, dataCount);\r\n\t\tlet endIndex = $math.fitToRange(Math.ceil(this.end * dataCount), 0, dataCount);\r\n\r\n\t\tif (this.renderer.invalid) {\r\n\t\t\tthis.renderer.validate();\r\n\t\t}\r\n\r\n\t\t// find frequency at which we'll show items\r\n\t\tlet maxCount: number = this.renderer.axisLength / Math.max(this.renderer.minGridDistance, 1 / Number.MAX_SAFE_INTEGER);\r\n\t\tlet frequency: number = Math.min(this.dataItems.length, Math.ceil((endIndex - startIndex) / maxCount));\r\n\r\n\t\tthis._startIndex = Math.floor(startIndex / frequency) * frequency;\r\n\t\tthis._endIndex = Math.ceil(this.end * dataCount);\r\n\r\n\t\tthis.fixAxisBreaks();\r\n\r\n\t\tif (this._startIndex == this._endIndex) {\r\n\t\t\tthis._endIndex++;\r\n\t\t}\r\n\r\n\t\tthis._frequency = frequency;\r\n\r\n\t\tif (this.axisLength <= 0) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tthis.maxZoomFactor = this.dataItems.length;\r\n\t\tif (this.dataItems.length <= 0) {\r\n\t\t\tthis.maxZoomFactor = 1;\r\n\t\t}\r\n\r\n\t\tthis.resetIterators();\r\n\r\n\t\t// it's important to use protected variables here, as getters will return 0 - length\r\n\t\t// TODO use iterator instead\r\n\t\t// @ todo: not solved cat axis item fading\r\n\t\tstartIndex = $math.max(0, this._startIndex - this._frequency);\r\n\t\tendIndex = $math.min(this.dataItems.length, this._endIndex + this._frequency);\r\n\r\n\t\tlet itemIndex = 0;\r\n\r\n\t\tfor (let i = 0; i < startIndex; i++) {\r\n\t\t\tlet dataItem = this.dataItems.getIndex(i);\r\n\t\t\tdataItem.__disabled = true;\r\n\t\t}\r\n\r\n\t\tfor (let i = endIndex, len = this.dataItems.length; i < len; i++) {\r\n\t\t\tlet dataItem = this.dataItems.getIndex(i);\r\n\t\t\tdataItem.__disabled = true;\r\n\t\t}\r\n\r\n\t\tfor (let i = startIndex; i < endIndex; i++) {\r\n\t\t\tif (i < this.dataItems.length) {\r\n\t\t\t\tlet dataItem: this[\"_dataItem\"] = this.dataItems.getIndex(i);\r\n\t\t\t\tif (i / this._frequency == Math.round(i / this._frequency)) {\r\n\t\t\t\t\tlet axisBreak: CategoryAxisBreak = this.isInBreak(i);\r\n\t\t\t\t\tif (!axisBreak) {\r\n\t\t\t\t\t\tthis.appendDataItem(dataItem);\r\n\t\t\t\t\t\tthis.validateDataElement(dataItem, itemIndex);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\titemIndex++;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\t//previously we disabled all before, but this is better for cpu\r\n\t\t\t\t\t//this.validateDataElement(dataItem, itemIndex); // helps to solve shrinking // not good - creates all items\r\n\t\t\t\t\tdataItem.__disabled = true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis.appendDataItem(this._lastDataItem);\r\n\t\tthis.validateDataElement(this._lastDataItem, itemIndex + 1, this.dataItems.length);\r\n\r\n\t\tif (this._axisBreaks) {\r\n\t\t\tlet axisBreaks = this._axisBreaks;\r\n\r\n\t\t\taxisBreaks.each((axisBreak) => {\r\n\t\t\t\tlet adjustedStartValue: number = axisBreak.adjustedStartValue;\r\n\t\t\t\tlet adjustedEndValue: number = axisBreak.adjustedEndValue;\r\n\r\n\t\t\t\tif ($math.intersect({ start: adjustedStartValue, end: adjustedEndValue }, { start: this._startIndex, end: this._endIndex })) {\r\n\r\n\t\t\t\t\tfor (let b = adjustedStartValue; b <= adjustedEndValue; b++) {\r\n\t\t\t\t\t\tlet dataItem = this.dataItems.getIndex(b);\r\n\t\t\t\t\t\tdataItem.__disabled = true;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tlet frequency: number = $math.fitToRange(Math.ceil(this._frequency / axisBreak.breakSize), 1, adjustedEndValue - adjustedStartValue);\r\n\t\t\t\t\tlet itemIndex = 0;\r\n\t\t\t\t\tif (axisBreak.breakSize > 0) {\r\n\t\t\t\t\t\t// TODO use iterator instead\r\n\t\t\t\t\t\tfor (let b = adjustedStartValue; b <= adjustedEndValue; b = b + frequency) {\r\n\t\t\t\t\t\t\tlet dataItem: this[\"_dataItem\"] = this.dataItems.getIndex(b);\r\n\t\t\t\t\t\t\tdataItem.__disabled = false;\r\n\t\t\t\t\t\t\tthis.appendDataItem(dataItem);\r\n\t\t\t\t\t\t\tthis.validateDataElement(dataItem, itemIndex);\r\n\t\t\t\t\t\t\titemIndex++;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tthis.validateBreaks();\r\n\t\tthis.validateAxisRanges();\r\n\r\n\t\tthis.ghostLabel.invalidate(); // solves font issue\r\n\t\tthis.renderer.invalidateLayout();\r\n\t}\r\n\r\n\t/**\r\n\t * [validateDataElement description]\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description\r\n\t * @param dataItem   [description]\r\n\t * @param itemIndex  [description]\r\n\t */\r\n\tpublic validateDataElement(dataItem: this[\"_dataItem\"], itemIndex?: number, index?: number): void {\r\n\t\tsuper.validateDataElement(dataItem);\r\n\r\n\t\tdataItem.itemIndex = this._axisItemCount;\r\n\t\tthis._axisItemCount++;\r\n\r\n\t\t//dataItem.__disabled = false;\r\n\r\n\t\tlet renderer: AxisRenderer = this.renderer;\r\n\t\tif (!$type.isNumber(index)) {\r\n\t\t\tindex = this.categoryToIndex(dataItem.category);\r\n\t\t}\r\n\r\n\t\tlet endIndex = this.categoryToIndex(dataItem.endCategory);\r\n\r\n\t\tif (!$type.isNumber(endIndex)) {\r\n\t\t\tendIndex = index;\r\n\t\t}\r\n\r\n\t\tlet position: number = this.indexToPosition(index, dataItem.locations.category);\r\n\t\tlet endPosition: number = this.indexToPosition(endIndex, dataItem.locations.endCategory);\r\n\r\n\t\tdataItem.position = position;\r\n\r\n\t\tlet fillEndIndex: number;\r\n\t\tlet fillPosition: number;\r\n\t\tlet fillEndPosition: number;\r\n\r\n\t\tif (dataItem.isRange) {\r\n\t\t\tfillEndIndex = endIndex;\r\n\t\t\tfillPosition = this.indexToPosition(index, dataItem.locations.category);\r\n\t\t\tfillEndPosition = this.indexToPosition(fillEndIndex, dataItem.locations.endCategory);\r\n\t\t}\r\n\r\n\t\tdataItem.point = renderer.positionToPoint(position);\r\n\r\n\t\tlet tick: AxisTick = dataItem.tick;\r\n\t\tif (tick && !tick.disabled) {\r\n\t\t\trenderer.updateTickElement(tick, position, endPosition);\r\n\t\t}\r\n\r\n\t\tlet grid: Grid = dataItem.grid;\r\n\t\tif (grid && !grid.disabled) {\r\n\t\t\trenderer.updateGridElement(grid, position, endPosition);\r\n\t\t}\r\n\r\n\r\n\t\tlet label: AxisLabel = dataItem.label;\r\n\t\tif (label && !label.disabled) {\r\n\t\t\t// theorethically this might result problems if category text changes, the range text won't change. But otherwise range.label.text = \"custom text\" won't work, which is not intuitive.\r\n\t\t\tif (!dataItem.isRange || label.text == undefined) {\r\n\t\t\t\tdataItem.text = dataItem.text;\r\n\t\t\t}\r\n\r\n\t\t\trenderer.updateLabelElement(label, position, endPosition);\r\n\r\n\t\t\tif ((renderer instanceof AxisRendererY && dataItem.label.measuredWidth > this.ghostLabel.measuredWidth) || (renderer instanceof AxisRendererX && dataItem.label.measuredHeight > this.ghostLabel.measuredHeight)) {\r\n\t\t\t\tif (dataItem.label.html) {\r\n\t\t\t\t\tthis.ghostLabel.html = dataItem.label.currentText;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tthis.ghostLabel.text = dataItem.label.currentText;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tlet fill: AxisFill = dataItem.axisFill;\r\n\t\tif (fill && !fill.disabled) {\r\n\r\n\t\t\tif (!dataItem.isRange) {\r\n\t\t\t\tfillEndIndex = index + this._frequency;\r\n\t\t\t\tfillPosition = this.indexToPosition(index, fill.location);\r\n\t\t\t\tfillEndPosition = this.indexToPosition(fillEndIndex, fill.location);\r\n\t\t\t}\r\n\r\n\t\t\trenderer.updateFillElement(fill, fillPosition, fillEndPosition);\r\n\t\t\tif (!dataItem.isRange) {\r\n\t\t\t\tthis.fillRule(dataItem, itemIndex);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (dataItem.bullet) {\r\n\t\t\trenderer.updateBullet(dataItem.bullet, position, endPosition);\r\n\t\t}\r\n\r\n\r\n\t\tlet mask: AxisFill = dataItem.mask;\r\n\t\tif (mask) {\r\n\t\t\trenderer.updateFillElement(mask, fillPosition, fillEndPosition);\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tpublic disposeData() {\r\n\t\tthis.dataItemsByCategory.clear();\r\n\t\tsuper.disposeData();\r\n\t}\r\n\r\n\t/**\r\n\t * Processes the axis data item.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param dataItem     Data item\r\n\t * @param dataContext  The raw data that corresponds to this data item\r\n\t */\r\n\tpublic processDataItem(dataItem: this[\"_dataItem\"], dataContext: Object): void {\r\n\t\tif (dataItem) {\r\n\t\t\t// creat a collection for fast access\r\n\t\t\tsuper.processDataItem(dataItem, dataContext);\r\n\t\t\t// check if such category already exists\r\n\t\t\t//let existingDataItem: CategoryAxisDataItem = this.dataItemsByCategory.getKey(dataItem.category);\r\n\t\t\t//if (existingDataItem && existingDataItem != dataItem) {\r\n\t\t\t//\tthis.dataItems.remove(existingDataItem);\r\n\t\t\t//}\r\n\r\n\t\t\tif ($type.hasValue(dataItem.category)) {\r\n\t\t\t\tthis.dataItemsByCategory.setKey(dataItem.category, dataItem);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\r\n\tprotected getDataItem(dataContext?: any): this[\"_dataItem\"] {\r\n\t\tlet category: string = <string>(dataContext[this.dataFields.category]);\r\n\t\tif ($type.hasValue(category)) {\r\n\t\t\tlet dataItem: this[\"_dataItem\"] = this.dataItemsByCategory.getKey(category);\r\n\r\n\t\t\tif (dataItem) {\r\n\t\t\t\treturn dataItem;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\treturn this.dataItems.create();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Converts a category index to an actual screen coordinate on the axis.\r\n\t *\r\n\t * `location` identifies relative location within category. 0 - beginning,\r\n\t * 0.5 - middle, 1 - end, and anything inbetween.\r\n\t *\r\n\t * @param index     Index\r\n\t * @param location  Location (0-1)\r\n\t * @return Position (px)\r\n\t */\r\n\tpublic indexToPosition(index: number, location?: AxisItemLocation | number): number {\r\n\t\tif (!$type.isNumber(location)) {\r\n\t\t\tlocation = 0.5;\r\n\t\t}\r\n\r\n\t\tlet startIndex: number = this.startIndex;\r\n\t\tlet endIndex: number = this.endIndex;\r\n\r\n\t\tlet difference: number = this.adjustDifference(startIndex, endIndex);\r\n\r\n\t\tlet startLocation = this.startLocation;\r\n\t\tlet endLocation = this.endLocation;\r\n\r\n\t\tdifference -= startLocation;\r\n\t\tdifference -= (1 - endLocation);\r\n\r\n\t\tif (this._axisBreaks) {\r\n\t\t\tlet axisBreaks = this._axisBreaks;\r\n\r\n\t\t\t$iter.eachContinue(axisBreaks.iterator(), (axisBreak) => {\r\n\t\t\t\tlet breakStartIndex: number = axisBreak.adjustedStartValue;\r\n\t\t\t\tlet breakEndIndex: number = axisBreak.adjustedEndValue;\r\n\r\n\t\t\t\tif (index < startIndex || !$type.isNumber(breakStartIndex) || !$type.isNumber(breakEndIndex)) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ($math.intersect({ start: breakStartIndex, end: breakEndIndex }, { start: startIndex, end: endIndex })) {\r\n\t\t\t\t\tbreakStartIndex = Math.max(startIndex, breakStartIndex);\r\n\t\t\t\t\tbreakEndIndex = Math.min(endIndex, breakEndIndex);\r\n\r\n\t\t\t\t\tlet breakSize: number = axisBreak.breakSize;\r\n\r\n\t\t\t\t\t// value to the right of break end\r\n\t\t\t\t\tif (index > breakEndIndex) {\r\n\t\t\t\t\t\tstartIndex += (breakEndIndex - breakStartIndex) * (1 - breakSize);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// value to the left of break start\r\n\t\t\t\t\telse if (index < breakStartIndex) {\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// value within break\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tindex = breakStartIndex + (index - breakStartIndex) * breakSize;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn true;\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tlet deltaPosition = 0;\r\n\t\tlet dataItem = this.dataItems.getIndex(index);\r\n\t\tif (dataItem) {\r\n\t\t\tdeltaPosition = dataItem.deltaPosition;\r\n\t\t}\r\n\r\n\t\treturn $math.round(deltaPosition + (index + location - startLocation - startIndex) / difference, 5);\r\n\t}\r\n\r\n\t/**\r\n\t * Converts a string category name to relative position on axis.\r\n\t *\r\n\t * `location` identifies relative location within category. 0 - beginning,\r\n\t * 0.5 - middle, 1 - end, and anything inbetween.\r\n\t *\r\n\t * @param category  Category name\r\n\t * @param location  Location (0-1)\r\n\t * @return Position\r\n\t */\r\n\tpublic categoryToPosition(category: string, location?: AxisItemLocation): number {\r\n\t\tlet index: number = this.categoryToIndex(category);\r\n\t\treturn this.indexToPosition(index, location);\r\n\t}\r\n\r\n\t/**\r\n\t * Converts a string category name to a orientation point (x, y, angle) on axis\r\n\t *\r\n\t * `location` identifies relative location within category. 0 - beginning,\r\n\t * 0.5 - middle, 1 - end, and anything inbetween.\r\n\t * @param category  Category name\r\n\t * @param location  Location (0-1)\r\n\t * @return Orientation point\r\n\t */\r\n\tpublic categoryToPoint(category: string, location?: AxisItemLocation): IOrientationPoint {\r\n\t\tlet position = this.categoryToPosition(category, location);\r\n\t\tlet point = this.renderer.positionToPoint(position);\r\n\t\tlet angle = this.renderer.positionToAngle(position);\r\n\t\treturn { x: point.x, y: point.y, angle: angle };\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Converts a string category name to a orientation point (x, y, angle) on axis\r\n\t *\r\n\t * `location` identifies relative location within category. 0 - beginning,\r\n\t * 0.5 - middle, 1 - end, and anything inbetween.\r\n\t * @param category  Category name\r\n\t * @param location  Location (0-1)\r\n\t * @return Orientation point\r\n\t */\r\n\tanyToPoint(category: string, location?: AxisItemLocation): IOrientationPoint {\r\n\t\treturn this.categoryToPoint(category, location);\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Converts a string category name to relative position on axis.\r\n\t *\r\n\t * An alias to `categoryToPosition()`.\r\n\t *\r\n\t * @param category  Category name\r\n\t * @param location  Location (0-1)\r\n\t * @return Relative position\r\n\t */\r\n\tpublic anyToPosition(category: string, location?: AxisItemLocation): number {\r\n\t\treturn this.categoryToPosition(category, location);\r\n\t}\r\n\r\n\t/**\r\n\t * Converts named category to an index of data item it corresponds to.\r\n\t *\r\n\t * @param category  Category\r\n\t * @return Data item index\r\n\t */\r\n\tpublic categoryToIndex(category: string): number {\r\n\t\tif ($type.hasValue(category)) {\r\n\t\t\tlet dataItem: this[\"_dataItem\"] = this.dataItemsByCategory.getKey(category);\r\n\t\t\tif (dataItem) {\r\n\t\t\t\treturn dataItem.index;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Zooms the axis to specific named ctaegories.\r\n\t *\r\n\t * @param startCategory  Start category\r\n\t * @param endCategory    End category\r\n\t */\r\n\tpublic zoomToCategories(startCategory: string, endCategory: string): void {\r\n\t\tthis.zoomToIndexes(this.categoryToIndex(startCategory), this.categoryToIndex(endCategory) + 1);\r\n\t}\r\n\r\n\t/**\r\n\t * [getAnyRangePath description]\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description\r\n\t * @param start         [description]\r\n\t * @param end           [description]\r\n\t * @param startLocation [description]\r\n\t * @param endLocation   [description]\r\n\t * @return [description]\r\n\t */\r\n\tpublic getAnyRangePath(start: string, end: string, startLocation?: AxisItemLocation, endLocation?: AxisItemLocation): string {\r\n\t\tlet startPos: number = this.categoryToPosition(start, startLocation);\r\n\t\tlet endPos: number = this.categoryToPosition(end, endLocation);\r\n\t\treturn this.getPositionRangePath(startPos, endPos); // Base class (Axis) gets range shape from AxisRenderer\r\n\t}\r\n\r\n\t/**\r\n\t * Takes an absolute position (px) within axis and adjust it to a specific\r\n\t * `location` within category it corresponds to.\r\n\t *\r\n\t * @param position  Source position (px)\r\n\t * @param location  Location within category (0-1)\r\n\t * @return Adjusted position (px)\r\n\t */\r\n\tpublic roundPosition(position: number, location?: AxisItemLocation): number {\r\n\t\tlet index: number = this.positionToIndex(position);\r\n\t\treturn this.indexToPosition(index, location);\r\n\t}\r\n\r\n\t/**\r\n\t * Finds and returns first series data item with specific category\r\n\t * @param series    Target series\r\n\t * @param category  Category\r\n\t * @return XYSeriesDataItem data item\r\n\t */\r\n\tpublic getFirstSeriesDataItem(series: XYSeries, category: string): XYSeriesDataItem {\r\n\r\n\t\tfor (let i = 0; i < series.dataItems.length; i++) {\r\n\t\t\tlet dataItem = series.dataItems.getIndex(i);\r\n\t\t\tif (series.xAxis == this) {\r\n\t\t\t\tif (dataItem.categoryX == category) {\r\n\t\t\t\t\treturn dataItem;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (series.yAxis == this) {\r\n\t\t\t\tif (dataItem.categoryY == category) {\r\n\t\t\t\t\treturn dataItem;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Finds and returns last series data item with specific category.\r\n\t * @param series    Target series\r\n\t * @param category  Category\r\n\t * @return XYSeriesDataItem data item\r\n\t */\r\n\tpublic getLastSeriesDataItem(series: XYSeries, category: string): XYSeriesDataItem {\r\n\r\n\t\tfor (let i = series.dataItems.length - 1; i >= 0; i--) {\r\n\t\t\tlet dataItem = series.dataItems.getIndex(i);\r\n\t\t\tif (series.xAxis == this) {\r\n\t\t\t\tif (dataItem.categoryX == category) {\r\n\t\t\t\t\treturn dataItem;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (series.yAxis == this) {\r\n\t\t\t\tif (dataItem.categoryY == category) {\r\n\t\t\t\t\treturn dataItem;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// todo: optimize\r\n\tpublic getSeriesDataItemByCategory(category: string, series: XYSeries): XYSeriesDataItem {\r\n\t\tlet seriesDataItem: XYSeriesDataItem;\r\n\t\tseries.dataItems.each((dataItem) => {\r\n\t\t\tif (series.xAxis == this) {\r\n\t\t\t\tif (dataItem.categoryX == category) {\r\n\t\t\t\t\tseriesDataItem = dataItem;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse if (series.yAxis == this) {\r\n\t\t\t\tif (dataItem.categoryY == category) {\r\n\t\t\t\t\tseriesDataItem = dataItem;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t})\r\n\t\treturn seriesDataItem;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Returns a data item from Series that corresponds to a specific absolute\r\n\t * position on the Axis.\r\n\t *\r\n\t * @param series    Target series\r\n\t * @param position  Position (px)\r\n\t * @return XYSeriesDataItem data item\r\n\t */\r\n\tpublic getSeriesDataItem(series: XYSeries, position: number, findNearest?: boolean): XYSeriesDataItem {\r\n\r\n\t\tif ($type.isNumber(position)) {\r\n\r\n\t\t\tlet index = this.positionToIndex(position);\r\n\r\n\t\t\tif (index >= this.dataItems.length) {\r\n\t\t\t\tindex--;\r\n\t\t\t}\r\n\r\n\t\t\tlet dataItem = this.dataItems.getIndex(index);\r\n\r\n\t\t\tif (dataItem) {\r\n\t\t\t\tlet category = dataItem.category;\r\n\t\t\t\tlet sdi: XYSeriesDataItem;\r\n\r\n\t\t\t\tlet seriesDataItem = series.dataItems.getIndex(index);\r\n\t\t\t\tif (seriesDataItem) {\r\n\t\t\t\t\tif (series.xAxis == this) {\r\n\t\t\t\t\t\tif (seriesDataItem.categoryX == category) {\r\n\t\t\t\t\t\t\treturn seriesDataItem;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (series.yAxis == this) {\r\n\t\t\t\t\t\tif (seriesDataItem.categoryY == category) {\r\n\t\t\t\t\t\t\treturn seriesDataItem;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\r\n\t\t\t\tseries.dataItems.each((dataItem) => {\r\n\t\t\t\t\tif (series.xAxis == this) {\r\n\t\t\t\t\t\tif (dataItem.categoryX == category) {\r\n\t\t\t\t\t\t\tif (!sdi) {\r\n\t\t\t\t\t\t\t\tsdi = dataItem;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif (Math.abs(index - sdi.index) > Math.abs(index - dataItem.index)) {\r\n\t\t\t\t\t\t\t\tsdi = dataItem;\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (series.yAxis == this) {\r\n\t\t\t\t\t\tif (dataItem.categoryY == category) {\r\n\t\t\t\t\t\t\tif (!sdi) {\r\n\t\t\t\t\t\t\t\tsdi = dataItem;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif (Math.abs(index - sdi.index) > Math.abs(index - dataItem.index)) {\r\n\t\t\t\t\t\t\t\tsdi = dataItem;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\r\n\t\t\t\t//@todo\r\n\t\t\t\tif (findNearest) {\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn sdi;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Returns the X coordinate for series' data item.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description (review)\r\n\t * @param dataItem  Data item\r\n\t * @param key       Category\r\n\t * @param location  Location (0-1)\r\n\t * @return X coordinate (px)\r\n\t */\r\n\tpublic getX(dataItem: XYSeriesDataItem, key?: string, location?: number, stackKey?: string, range?: IRange): number {\r\n\t\tlet position = this.getPositionX(dataItem, key, location, stackKey, range);\r\n\r\n\t\tif ($type.isNaN(position)) {\r\n\t\t\treturn this.basePoint.x;\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn this.renderer.positionToPoint(position).x;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Returns relative position on axis for series' data item.\r\n\t *\r\n\t * @since 4.5.14\r\n\t * @param  dataItem  Data item\r\n\t * @param  key       Category\r\n\t * @param  location  Location (0-1)\r\n\t * @return           Relative position\r\n\t */\r\n\tpublic getPositionX(dataItem: XYSeriesDataItem, key?: string, location?: number, stackKey?: string, range?: IRange): number {\r\n\t\tlet position;\r\n\t\tif ($type.hasValue(key)) {\r\n\t\t\tposition = this.categoryToPosition(dataItem.categories[key], location);\r\n\t\t}\r\n\r\n\t\tif (range) {\r\n\t\t\tposition = $math.fitToRange(position, range.start, range.end);\r\n\t\t}\r\n\r\n\t\treturn position;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the Y coordinate for series' data item.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description (review)\r\n\t * @param dataItem  Data item\r\n\t * @param key       Category\r\n\t * @param location  Location (0-1)\r\n\t * @return Y coordinate (px)\r\n\t */\r\n\tpublic getY(dataItem: XYSeriesDataItem, key?: string, location?: number, stackKey?: string, range?: IRange): number {\r\n\r\n\t\tlet position = this.getPositionY(dataItem, key, location, stackKey, range);\r\n\r\n\t\tif ($type.isNaN(position)) {\r\n\t\t\treturn this.basePoint.y;\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn this.renderer.positionToPoint(position).y;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Returns relative position on axis for series' data item.\r\n\t *\r\n\t * @since 4.5.14\r\n\t * @param  dataItem  Data item\r\n\t * @param  key       Category\r\n\t * @param  location  Location (0-1)\r\n\t * @return           Relative position\r\n\t */\r\n\tpublic getPositionY(dataItem: XYSeriesDataItem, key?: string, location?: number, stackKey?: string, range?: IRange): number {\r\n\t\tlet position;\r\n\t\tif ($type.hasValue(key)) {\r\n\t\t\tposition = this.categoryToPosition(dataItem.categories[key], location);\r\n\t\t}\r\n\r\n\t\tif (range) {\r\n\t\t\tposition = $math.fitToRange(position, range.start, range.end);\r\n\t\t}\r\n\r\n\t\treturn position;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns an angle for series data item.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description (review)\r\n\t * @param dataItem  Data item\r\n\t * @param key       Category\r\n\t * @param location  Location (0-1)\r\n\t * @param stackKey  Stack key (?)\r\n\t * @param range Range to fit in\r\n\t * @return Angle\r\n\t */\r\n\tpublic getAngle(dataItem: XYSeriesDataItem, key: string, location?: number, stackKey?: string, range?: IRange): number {\r\n\t\tlet position = this.categoryToPosition(dataItem.categories[key], location);\r\n\r\n\t\tif (range) {\r\n\t\t\tposition = $math.fitToRange(position, range.start, range.end);\r\n\t\t}\r\n\r\n\t\treturn this.positionToAngle(position);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns an absolute pixel coordinate of the start of the cell (category),\r\n\t * that specific position value falls into.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description (review)\r\n\t * @param position  Position (px)\r\n\t * @return Cell start position (px)\r\n\t */\r\n\tpublic getCellStartPosition(position: number): number {\r\n\t\treturn this.roundPosition(position, 0);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns an absolute pixel coordinate of the end of the cell (category),\r\n\t * that specific position value falls into.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description (review)\r\n\t * @param position  Position (px)\r\n\t * @return Cell end position (px)\r\n\t */\r\n\tpublic getCellEndPosition(position: number): number {\r\n\t\treturn this.roundPosition(position, 1);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns text to show in a category tooltip, based on specific position\r\n\t * within axis.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param position  Position (px)\r\n\t * @return Label (category)\r\n\t */\r\n\tpublic getTooltipText(position: number): string {\r\n\t\tlet dataItem: this[\"_dataItem\"] = this.dataItems.getIndex(this.positionToIndex(position));\r\n\r\n\t\tif (dataItem) {\r\n\t\t\tthis.tooltipDataItem = dataItem;\r\n\t\t\tthis.tooltip.dataItem = dataItem;\r\n\t\t\tif (this.tooltipText) {\r\n\t\t\t\treturn this.tooltipText;\r\n\t\t\t}\r\n\r\n\t\t\tif (!this._adapterO) {\r\n\t\t\t\treturn dataItem.category;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\treturn this._adapterO.apply(\"getTooltipText\", dataItem.category);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Returns an index of the category that corresponds to specific pixel\r\n\t * position within axis.\r\n\t *\r\n\t * @param position  Position (px)\r\n\t * @return Category index\r\n\t */\r\n\tpublic positionToIndex(position: number): number {\r\n\t\tposition = $math.round(position, 10);\r\n\t\tif (position < 0) {\r\n\t\t\tposition = 0;\r\n\t\t}\r\n\r\n\t\tif (position > 1) {\r\n\t\t\tposition = 1;\r\n\t\t}\r\n\r\n\t\tlet startIndex: number = this.startIndex;\r\n\t\tlet endIndex: number = this.endIndex;\r\n\t\tlet difference: number = endIndex - startIndex - this.startLocation - (1 - this.endLocation);\r\n\r\n\t\tposition += 1 / difference * this.startLocation;\r\n\t\tlet index: number = null;\r\n\r\n\t\tif (this._axisBreaks) {\r\n\t\t\tlet axisBreaks = this._axisBreaks;\r\n\r\n\t\t\t// in case we have some axis breaks\r\n\t\t\t$iter.eachContinue(axisBreaks.iterator(), (axisBreak) => {\r\n\t\t\t\tlet breakStartPosition: number = axisBreak.startPosition;\r\n\t\t\t\tlet breakEndPosition: number = axisBreak.endPosition;\r\n\r\n\t\t\t\tlet breakStartIndex: number = axisBreak.adjustedStartValue;\r\n\t\t\t\tlet breakEndIndex: number = axisBreak.adjustedEndValue;\r\n\r\n\t\t\t\tbreakStartIndex = $math.max(breakStartIndex, startIndex);\r\n\t\t\t\tbreakEndIndex = $math.min(breakEndIndex, endIndex);\r\n\r\n\t\t\t\tlet breakSize: number = axisBreak.breakSize;\r\n\r\n\t\t\t\tdifference -= (breakEndIndex - breakStartIndex) * (1 - breakSize);\r\n\r\n\t\t\t\t// position to the right of break end\r\n\t\t\t\tif (position > breakEndPosition) {\r\n\t\t\t\t\tstartIndex += (breakEndIndex - breakStartIndex) * (1 - breakSize);\r\n\t\t\t\t}\r\n\t\t\t\t// position to the left of break start\r\n\t\t\t\telse if (position < breakStartPosition) {\r\n\r\n\t\t\t\t}\r\n\t\t\t\t// value within break\r\n\t\t\t\telse {\r\n\t\t\t\t\tlet breakPosition = (position - breakStartPosition) / (breakEndPosition - breakStartPosition);\r\n\t\t\t\t\tindex = breakStartIndex + Math.round(breakPosition * (breakEndIndex - breakStartIndex));\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn true;\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tif (!$type.isNumber(index)) {\r\n\t\t\tindex = Math.floor(position * difference + startIndex);\r\n\t\t}\r\n\t\tif (index >= this.dataItems.length) {\r\n\t\t\tindex = this.dataItems.length - 1;\r\n\t\t}\r\n\t\t// not good, when panning out of bounds, each time one less item gets selected\r\n\t\t//if (index >= endIndex) {\r\n\t\t//\tindex--;\r\n\t\t//}\r\n\r\n\t\treturn index;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns category based on position.\r\n\t *\r\n\t * Please note that `position` represents position within axis which may be\r\n\t * zoomed and not correspond to Cursor's `position`.\r\n\t *\r\n\t * To convert Cursor's `position` to Axis' `position` use `toAxisPosition()` method.\r\n\t *\r\n\t * This is a synonim of `getPositionLabel()` implemented here for consistentcy.\r\n\t *\r\n\t * @since 4.3.8\r\n\t * @see {@link https://www.amcharts.com/docs/v4/tutorials/tracking-cursors-position-via-api/#Tracking_Cursor_s_position} For more information about cursor tracking.\r\n\t * @param position  Relative position on axis (0-1)\r\n\t * @return Position label\r\n\t */\r\n\tpublic positionToCategory(position: number): string {\r\n\t\treturn this.getPositionLabel(position);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns category based on position.\r\n\t *\r\n\t * Please note that `position` represents position within axis which may be\r\n\t * zoomed and not correspond to Cursor's `position`.\r\n\t *\r\n\t * To convert Cursor's `position` to Axis' `position` use `toAxisPosition()` method.\r\n\t *\r\n\t * @see {@link https://www.amcharts.com/docs/v4/tutorials/tracking-cursors-position-via-api/#Tracking_Cursor_s_position} For more information about cursor tracking.\r\n\t * @param position  Relative position on axis (0-1)\r\n\t * @return Position label\r\n\t */\r\n\tpublic getPositionLabel(position: number): string {\r\n\t\tlet dataItem: this[\"_dataItem\"] = this.dataItems.getIndex(this.positionToIndex(position));\r\n\t\tif (dataItem) {\r\n\t\t\treturn dataItem.category;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Coordinates of the actual axis start.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @return Base point\r\n\t */\r\n\tpublic get basePoint(): IPoint {\r\n\t\t// This makes base grid to be drawn at the end of the axis and adds extra\r\n\t\t// grid which we need to nicely close the chart.\r\n\t\treturn this.renderer.positionToPoint(1);\r\n\t}\r\n\r\n\t/**\r\n\t * Initializes Axis' renderer.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic initRenderer(): void {\r\n\t\tsuper.initRenderer();\r\n\r\n\t\tlet renderer = this.renderer;\r\n\t\trenderer.baseGrid.disabled = true;\r\n\t}\r\n\r\n\t/**\r\n\t * Current frequency of labels of the axis.\r\n\t *\r\n\t * Normally it would be 1, but when labels start to be hidden due\r\n\t * to `minGridDistance` this read-only property will increase.\r\n\t *\r\n\t * @readonly\r\n\t * @since 4.2.0\r\n\t * @return Label frequency\r\n\t */\r\n\tpublic get frequency(): number {\r\n\t\treturn this._frequency;\r\n\t}\r\n\r\n\t/**\r\n\t * If set to a reference of [[ColumnSeries]] the categories will be sorted\r\n\t * by actual values.\r\n\t *\r\n\t * The categories are ordered in descending order (from highest values to\r\n\t * lowest). To reverse the order, use axis renderer's `inversed` setting.\r\n\t * E.g.:\r\n\t *\r\n\t * ```TypeScript\r\n\t * categoryAxis.sortBySeries = series;\r\n\t * categoryAxis.renderer.inversed = true;\r\n\t * ```\r\n\t * ```JavaScript\r\n\t * categoryAxis.sortBySeries = series;\r\n\t * categoryAxis.renderer.inversed = true;\r\n\t * ```\r\n\t * ```JSON\r\n\t * {\r\n\t *   // ...\r\n\t *   \"xAxes\": [{\r\n\t *     // ...\r\n\t *     \"sortBySeries\": \"s1\",\r\n\t *     \"renderer\": {\r\n\t *       // ...\r\n\t *       \"inversed\": true\r\n\t *     }\r\n\t *   }]\r\n\t * }\r\n\t * ```\r\n\t *\r\n\t * @since 4.8.7\r\n\t * @param  value  Sort categories?\r\n\t */\r\n\tpublic set sortBySeries(value: ColumnSeries) {\r\n\t\tthis.setPropertyValue(\"sortBySeries\", value, true);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Sort categories?\r\n\t */\r\n\tpublic get sortBySeries(): ColumnSeries {\r\n\t\treturn this.getPropertyValue(\"sortBySeries\");\r\n\t}\r\n\r\n\t/**\r\n\t * Processes JSON-based config before it is applied to the object.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param config  Config\r\n\t */\r\n\tpublic processConfig(config?: { [index: string]: any }): void {\r\n\r\n\t\tif (config) {\r\n\r\n\t\t\tif ($type.hasValue(config.sortBySeries) && $type.isString(config.sortBySeries)) {\r\n\t\t\t\tif (this.map.hasKey(config.sortBySeries)) {\r\n\t\t\t\t\tconfig.sortBySeries = this.map.getKey(config.sortBySeries);\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tthis.addDelayedMap(\"sortBySeries\", config.sortBySeries);\r\n\t\t\t\t\tdelete config.sortBySeries;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tsuper.processConfig(config);\r\n\r\n\t}\r\n}\r\n\r\n/**\r\n * Register class, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\r\nregistry.registeredClasses[\"CategoryAxis\"] = CategoryAxis;\r\nregistry.registeredClasses[\"CategoryAxisDataItem\"] = CategoryAxisDataItem;\r\n"]},"metadata":{},"sourceType":"module"}