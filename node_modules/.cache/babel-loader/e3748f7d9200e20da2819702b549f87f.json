{"ast":null,"code":"/**\r\n * Legend-related functionality.\r\n */\nimport { __extends } from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\nimport { Component } from \"../core/Component\";\nimport { DataItem } from \"../core/DataItem\";\nimport { ListTemplate, ListDisposer } from \"../core/utils/List\";\nimport { RoundedRectangle } from \"../core/elements/RoundedRectangle\";\nimport { Container } from \"../core/Container\";\nimport { Label } from \"../core/elements/Label\";\nimport { keyboard } from \"../core/utils/Keyboard\";\nimport { registry } from \"../core/Registry\";\nimport { getInteraction } from \"../core/interaction/Interaction\";\nimport { percent, Percent } from \"../core/utils/Percent\";\nimport { InterfaceColorSet } from \"../core/utils/InterfaceColorSet\";\nimport * as $utils from \"../core/utils/Utils\";\nimport * as $type from \"../core/utils/Type\";\nimport * as $math from \"../core/utils/Math\";\nimport { Sprite } from \"../core/Sprite\";\nimport { Disposer } from \"../core/utils/Disposer\";\nimport { MouseCursorStyle } from \"../core/interaction/Mouse\";\nimport { defaultRules, ResponsiveBreakpoints } from \"../core/utils/Responsive\";\nimport { Scrollbar } from \"../core/elements/Scrollbar\";\n/**\r\n * ============================================================================\r\n * DATA ITEM\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * Defines a [[DataItem]] for [[Legend]].\r\n *\r\n * @see {@link DataItem}\r\n */\n\nvar LegendDataItem =\n/** @class */\nfunction (_super) {\n  __extends(LegendDataItem, _super);\n  /**\r\n   * Constructor\r\n   */\n\n\n  function LegendDataItem() {\n    var _this = _super.call(this) || this;\n    /**\r\n     * @ignore\r\n     */\n\n\n    _this.childrenCreated = false;\n    _this.className = \"LegendDataItem\";\n\n    _this.applyTheme();\n\n    return _this;\n  }\n\n  Object.defineProperty(LegendDataItem.prototype, \"label\", {\n    /**\r\n     * A legend item's [[Label]] element.\r\n     *\r\n     * @return Label\r\n     */\n    get: function () {\n      var _this = this;\n\n      if (!this._label) {\n        var label_1 = this.component.labels.create();\n        this._label = label_1;\n        this.addSprite(label_1);\n\n        this._disposers.push(label_1);\n\n        label_1.parent = this.itemContainer;\n\n        this._disposers.push(new Disposer(function () {\n          if ($type.hasValue(_this.component)) {\n            _this.component.labels.removeValue(label_1);\n          }\n        }));\n      }\n\n      return this._label;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(LegendDataItem.prototype, \"color\", {\n    /**\r\n     * @return Main color\r\n     */\n    get: function () {\n      return this.properties.color;\n    },\n\n    /**\r\n     * Main color of legend data item.\r\n     *\r\n     * This is set by the target element this legend item represents, like\r\n     * a Series or a Slice.\r\n     *\r\n     * It can be used to derive a color in legend's sub-items, like label:\r\n     *\r\n     * ```TypeScript\r\n     * chart.legend.labels.template.text = \"[{color}]{name}[/]\";\r\n     * ```\r\n     * ```JavaScript\r\n     * chart.legend.labels.template.text = \"[{color}]{name}[/]\";\r\n     * ```\r\n     * ```JSON\r\n     * {\r\n     *   // ...\r\n     *   \"legend\": {\r\n     *     // ...\r\n     *     \"labels\": {\r\n     *       \"text\": \"[{color}]{name}[/]\"\r\n     *     }\r\n     *   }\r\n     * }\r\n     * ```\r\n     *\r\n     * @see {@link https://www.amcharts.com/docs/v4/concepts/legend/#Legend_labels} For more information about configuring legend labels.\r\n     * @param value  Main color\r\n     */\n    set: function (value) {\n      this.setProperty(\"color\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(LegendDataItem.prototype, \"valueLabel\", {\n    /**\r\n     * A legend item's [[Label]] element for \"value label\".\r\n     *\r\n     * @return Label\r\n     */\n    get: function () {\n      var _this = this;\n\n      if (!this._valueLabel) {\n        var valueLabel_1 = this.component.valueLabels.create();\n        this._valueLabel = valueLabel_1;\n        this.addSprite(valueLabel_1);\n\n        this._disposers.push(valueLabel_1);\n\n        valueLabel_1.parent = this.itemContainer;\n\n        this._disposers.push(new Disposer(function () {\n          if ($type.hasValue(_this.component)) {\n            _this.component.valueLabels.removeValue(valueLabel_1);\n          }\n        }));\n      }\n\n      return this._valueLabel;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(LegendDataItem.prototype, \"itemContainer\", {\n    /**\r\n     * A reference to the main [[Container]] that holds legend item's elements:\r\n     * marker and labels.\r\n     *\r\n     * @return Item container\r\n     */\n    get: function () {\n      var _this = this;\n\n      if (!this._itemContainer) {\n        var component_1 = this.component;\n        var itemContainer_1 = component_1.itemContainers.create();\n        itemContainer_1.parent = component_1;\n        this._itemContainer = itemContainer_1;\n        this.addSprite(itemContainer_1);\n\n        this._disposers.push(itemContainer_1); // Add click/tap event to toggle item\n\n\n        if (itemContainer_1.togglable) {\n          itemContainer_1.events.on(\"toggled\", function (ev) {\n            component_1.toggleDataItem(ev.target.dataItem);\n          }, undefined, false);\n        } // Add focus event so that we can track which object is currently in focus\n        // for keyboard toggling\n\n\n        if (itemContainer_1.focusable) {\n          itemContainer_1.events.on(\"hit\", function (ev) {\n            // We need this here in order to reset focused item when it is clicked\n            // normally so that it is not toggled by ENTER afterwards\n            component_1.focusedItem = undefined;\n          }, undefined, false);\n          itemContainer_1.events.on(\"focus\", function (ev) {\n            component_1.focusedItem = ev.target.dataItem;\n          }, undefined, false);\n          itemContainer_1.events.on(\"blur\", function (ev) {\n            component_1.focusedItem = undefined;\n          }, undefined, false);\n        }\n\n        this._disposers.push(new Disposer(function () {\n          if ($type.hasValue(_this.component)) {\n            _this.component.itemContainers.removeValue(itemContainer_1);\n          }\n        }));\n\n        if (this.dataContext.uidAttr) {\n          itemContainer_1.readerControls = this.dataContext.uidAttr();\n          itemContainer_1.readerLabelledBy = this.dataContext.uidAttr();\n        }\n\n        var sprite = this.dataContext;\n\n        if ((sprite instanceof DataItem || sprite instanceof Sprite) && !sprite.isDisposed()) {\n          var visibilitychanged = function (ev) {\n            itemContainer_1.readerChecked = ev.visible;\n            itemContainer_1.events.disableType(\"toggled\");\n            itemContainer_1.isActive = !ev.visible;\n            itemContainer_1.events.enableType(\"toggled\");\n          };\n\n          sprite.addDisposer(new Disposer(function () {\n            if (_this.component) {\n              _this.component.dataItems.remove(_this);\n            }\n          }));\n\n          if (sprite instanceof Sprite) {\n            itemContainer_1.addDisposer(sprite.events.on(\"visibilitychanged\", visibilitychanged, undefined, false));\n            itemContainer_1.addDisposer(sprite.events.on(\"hidden\", function (ev) {\n              itemContainer_1.readerChecked = false;\n              itemContainer_1.events.disableType(\"toggled\");\n              itemContainer_1.isActive = true;\n              itemContainer_1.events.enableType(\"toggled\");\n            }, undefined, false));\n            itemContainer_1.addDisposer(sprite.events.on(\"shown\", function (ev) {\n              itemContainer_1.readerChecked = true;\n              itemContainer_1.events.disableType(\"toggled\");\n              itemContainer_1.isActive = false;\n              itemContainer_1.events.enableType(\"toggled\");\n            }, undefined, false));\n          } else {\n            itemContainer_1.addDisposer(sprite.events.on(\"visibilitychanged\", visibilitychanged, undefined, false));\n          }\n        }\n      }\n\n      return this._itemContainer;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(LegendDataItem.prototype, \"marker\", {\n    /**\r\n     * A [[Container]] that holds legend item's marker element.\r\n     *\r\n     * @return Marker\r\n     */\n    get: function () {\n      var _this = this;\n\n      if (!this._marker) {\n        var marker_1 = this.component.markers.create();\n        this._marker = marker_1;\n        marker_1.parent = this.itemContainer;\n        this.addSprite(marker_1);\n\n        this._disposers.push(marker_1);\n\n        this._disposers.push(new Disposer(function () {\n          if ($type.hasValue(_this.component)) {\n            _this.component.markers.removeValue(marker_1);\n          }\n        }));\n      }\n\n      return this._marker;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return LegendDataItem;\n}(DataItem);\n\nexport { LegendDataItem };\n/**\r\n * ============================================================================\r\n * REQUISITES\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * Defines a class that carries legend settings.\r\n *\r\n * A legend might change its settings dynamically. Legend can also be shared\r\n * by several elements, requiring different settings.\r\n *\r\n * Having legend's settings in a separate object is a good way to \"hot swap\"\r\n * a set of settings for the legend.\r\n */\n\nvar LegendSettings =\n/** @class */\nfunction () {\n  function LegendSettings() {\n    /**\r\n     * Should marker be created for each legend item.\r\n     */\n    this.createMarker = true;\n  }\n\n  return LegendSettings;\n}();\n\nexport { LegendSettings };\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * [[Legend]] class is used to create legend for the chart.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v4/concepts/legend/} for Legend documentation\r\n * @see {@link ILegendEvents} for a list of available events\r\n * @see {@link ILegendAdapters} for a list of available Adapters\r\n */\n\nvar Legend =\n/** @class */\nfunction (_super) {\n  __extends(Legend, _super);\n  /**\r\n   * Constructor\r\n   */\n\n\n  function Legend() {\n    var _this = _super.call(this) || this;\n\n    _this.className = \"Legend\"; // Set defaults\n\n    _this.layout = \"grid\";\n\n    _this.setPropertyValue(\"useDefaultMarker\", false);\n\n    _this.setPropertyValue(\"scrollable\", false);\n\n    _this.setPropertyValue(\"contentAlign\", \"center\"); // Create a template container and list for legend items\n\n\n    var itemContainer = new Container();\n    itemContainer.applyOnClones = true;\n    itemContainer.padding(8, 0, 8, 0);\n    itemContainer.margin(0, 10, 0, 10);\n    itemContainer.layout = \"horizontal\";\n    itemContainer.clickable = true;\n    itemContainer.focusable = true;\n    itemContainer.role = \"switch\";\n    itemContainer.togglable = true;\n    itemContainer.cursorOverStyle = MouseCursorStyle.pointer;\n    itemContainer.background.fillOpacity = 0; // creates hit area\n    // Create container list using item template we just created\n\n    _this.itemContainers = new ListTemplate(itemContainer);\n\n    _this._disposers.push(new ListDisposer(_this.itemContainers));\n\n    _this._disposers.push(_this.itemContainers.template); // Set up global keyboard events for toggling elements\n\n\n    _this._disposers.push(getInteraction().body.events.on(\"keyup\", function (ev) {\n      if (keyboard.isKey(ev.event, \"enter\") && _this.focusedItem) {\n        var focusedItem = _this.focusedItem;\n        var target = focusedItem.itemContainer;\n\n        if (target.togglable) {\n          _this.toggleDataItem(focusedItem);\n        } else if (target.clickable && target.events.isEnabled(\"hit\")) {\n          target.dispatchImmediately(\"hit\", {\n            event: ev\n          }); // We need this here because \"hit\" event resets `this.focusedItem`\n          // And we need it here\n\n          _this.focusedItem = focusedItem;\n        }\n      }\n    }, _this));\n\n    var interfaceColors = new InterfaceColorSet(); // Create a template container and list for the a marker\n\n    var marker = new Container();\n    marker.width = 23;\n    marker.height = 23;\n    marker.interactionsEnabled = false;\n    marker.applyOnClones = true;\n    marker.setStateOnChildren = true;\n    marker.background.fillOpacity = 0;\n    marker.background.strokeOpacity = 0;\n    marker.propertyFields.fill = \"fill\";\n    marker.valign = \"middle\";\n    var disabledColor = interfaceColors.getFor(\"disabledBackground\");\n    marker.events.on(\"childadded\", function (event) {\n      var child = event.newValue;\n      var activeState = child.states.create(\"active\");\n      activeState.properties.stroke = disabledColor;\n      activeState.properties.fill = disabledColor;\n    });\n    _this.markers = new ListTemplate(marker);\n\n    _this._disposers.push(new ListDisposer(_this.markers));\n\n    _this._disposers.push(_this.markers.template); // Create a legend background element\n\n\n    var rectangle = marker.createChild(RoundedRectangle);\n    rectangle.width = percent(100);\n    rectangle.height = percent(100);\n    rectangle.applyOnClones = true;\n    rectangle.propertyFields.fill = \"fill\"; //othrwise old edge doesn't like as the same pattern is set both on parent and child https://codepen.io/team/amcharts/pen/72d7a98f3fb811d3118795220ff63182\n\n    rectangle.strokeOpacity = 0; // Create a template container and list for item labels\n\n    var label = new Label();\n    label.text = \"{name}\";\n    label.margin(0, 5, 0, 5);\n    label.valign = \"middle\";\n    label.applyOnClones = true;\n    label.states.create(\"active\").properties.fill = interfaceColors.getFor(\"disabledBackground\");\n    _this.labels = new ListTemplate(label);\n\n    _this._disposers.push(new ListDisposer(_this.labels));\n\n    _this._disposers.push(_this.labels.template);\n\n    label.interactionsEnabled = false;\n    label.truncate = true;\n    label.fullWords = false; // Create a template container and list for item value labels\n\n    var valueLabel = new Label();\n    valueLabel.margin(0, 5, 0, 0);\n    valueLabel.valign = \"middle\";\n    valueLabel.width = 50; // to avoid rearranging legend entries when value changes.\n\n    valueLabel.align = \"right\";\n    valueLabel.textAlign = \"end\";\n    valueLabel.applyOnClones = true;\n    valueLabel.states.create(\"active\").properties.fill = interfaceColors.getFor(\"disabledBackground\");\n    valueLabel.interactionsEnabled = false;\n    _this.valueLabels = new ListTemplate(valueLabel);\n\n    _this._disposers.push(new ListDisposer(_this.valueLabels));\n\n    _this._disposers.push(_this.valueLabels.template);\n\n    _this.position = \"bottom\"; // don't use setPropertyValue here!\n    // Create a state for disabled legend items\n\n    itemContainer.states.create(\"active\");\n    itemContainer.setStateOnChildren = true; // Apply accessibility settings\n\n    _this.role = \"group\";\n\n    _this.events.on(\"layoutvalidated\", _this.handleScrollbar, _this, false);\n\n    _this.applyTheme();\n\n    return _this;\n  }\n  /**\r\n   * Sets defaults that instantiate some objects that rely on parent, so they\r\n   * cannot be set in constructor.\r\n   */\n\n\n  Legend.prototype.applyInternalDefaults = function () {\n    _super.prototype.applyInternalDefaults.call(this);\n\n    if (!$type.hasValue(this.readerTitle)) {\n      this.readerTitle = this.language.translate(\"Legend\");\n    }\n  };\n  /**\r\n   * Returns a new/empty DataItem of the type appropriate for this object.\r\n   *\r\n   * @see {@link DataItem}\r\n   * @return Data Item\r\n   */\n\n\n  Legend.prototype.createDataItem = function () {\n    return new LegendDataItem();\n  };\n  /**\r\n   * [validateDataElements description]\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description\r\n   */\n\n\n  Legend.prototype.validateDataElements = function () {\n    if (this.scrollbar) {\n      this.scrollbar.start = 0;\n      this.scrollbar.end = 1;\n    }\n\n    _super.prototype.validateDataElements.call(this);\n  };\n  /**\r\n   * [validateDataElement description]\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param dataItem Data item\r\n   * @todo Description\r\n   * @todo Figure out how to update appearance of legend item without losing focus\r\n   * @todo Update legend marker appearance as apperance of related series changes\r\n   */\n\n\n  Legend.prototype.validateDataElement = function (dataItem) {\n    _super.prototype.validateDataElement.call(this, dataItem); // Get data item (legend item's) container\n\n\n    var container = dataItem.itemContainer;\n    var marker = dataItem.marker;\n    $utils.used(dataItem.label);\n    var valueLabel = dataItem.valueLabel; // Set parent and update current state\n\n    container.readerChecked = dataItem.dataContext.visible; // Tell series its legend data item\n\n    dataItem.dataContext.legendDataItem = dataItem;\n    var tempMaxWidth = dataItem.label.maxWidth;\n\n    if (!(dataItem.label.width instanceof Percent)) {\n      dataItem.label.width = undefined;\n    }\n\n    if (tempMaxWidth > 0) {\n      dataItem.label.maxWidth = tempMaxWidth;\n    }\n\n    if (valueLabel.align == \"right\") {\n      valueLabel.width = undefined;\n    }\n\n    var legendSettings = dataItem.dataContext.legendSettings; // If we are not using default markers, create a unique legend marker based\n    // on the data item type\n\n    var dataContext = dataItem.dataContext;\n\n    if (dataContext.createLegendMarker && (!this.useDefaultMarker || !(dataContext instanceof Sprite))) {\n      if (!dataItem.childrenCreated) {\n        dataContext.createLegendMarker(marker);\n        dataItem.childrenCreated = true;\n      }\n    } else {\n      this.markers.template.propertyFields.fill = undefined;\n    }\n\n    if (dataContext.updateLegendValue) {\n      dataContext.updateLegendValue(); // this solves issue with external legend, as legend is created after chart updates legend values\n    }\n\n    if (dataContext.component && dataContext.component.updateLegendValue) {\n      dataContext.component.updateLegendValue(dataContext);\n    }\n\n    if (valueLabel.invalid) {\n      valueLabel.validate();\n    }\n\n    if (valueLabel.text == \"\" || valueLabel.text == undefined) {\n      valueLabel.__disabled = true;\n    } else {\n      valueLabel.__disabled = false;\n    }\n\n    if (legendSettings && (legendSettings.itemValueText != undefined || legendSettings.valueText != undefined)) {\n      valueLabel.__disabled = false;\n    }\n\n    var visible = dataItem.dataContext.visible;\n\n    if (visible === undefined) {\n      visible = true;\n    }\n\n    visible = $type.toBoolean(visible);\n    dataItem.dataContext.visible = visible;\n    container.events.disableType(\"toggled\");\n    container.isActive = !visible;\n\n    if (container.isActive) {\n      container.setState(\"active\", 0);\n    } else {\n      container.setState(\"default\", 0);\n    }\n\n    container.events.enableType(\"toggled\");\n  };\n\n  Legend.prototype.afterDraw = function () {\n    var _this = this;\n\n    var maxWidth = this.getPropertyValue(\"maxWidth\");\n    var maxLabelWidth = 0;\n    this.labels.each(function (label) {\n      if (label.invalid) {\n        label.maxWidth = undefined;\n        label.validate();\n      }\n\n      if (label.measuredWidth + label.pixelMarginLeft + label.pixelMarginRight > maxLabelWidth) {\n        maxLabelWidth = label.measuredWidth + label.pixelMarginLeft + label.pixelMarginRight;\n      }\n    });\n    var maxValueLabelWidth = 0;\n    this.valueLabels.each(function (label) {\n      if (label.invalid) {\n        label.validate();\n      }\n\n      if (label.measuredWidth + label.pixelMarginLeft + label.pixelMarginRight > maxValueLabelWidth) {\n        maxValueLabelWidth = label.measuredWidth + label.pixelMarginLeft + label.pixelMarginRight;\n      }\n    });\n    var maxMarkerWidth = 0;\n    this.markers.each(function (marker) {\n      if (marker.invalid) {\n        marker.validate();\n      }\n\n      if (marker.measuredWidth + marker.pixelMarginLeft + marker.pixelMarginRight > maxMarkerWidth) {\n        maxMarkerWidth = marker.measuredWidth + marker.pixelMarginLeft + marker.pixelMarginRight;\n      }\n    });\n    var itemContainer = this.itemContainers.template;\n    var margin = itemContainer.pixelMarginRight + itemContainer.pixelMarginLeft;\n    var maxAdjustedLabelWidth;\n    var trueMaxWidth = maxLabelWidth + maxValueLabelWidth + maxMarkerWidth;\n\n    if (!$type.isNumber(maxWidth)) {\n      maxAdjustedLabelWidth = maxLabelWidth;\n    } else {\n      maxWidth = maxWidth - margin;\n\n      if (maxWidth > trueMaxWidth) {\n        maxWidth = trueMaxWidth;\n      }\n\n      maxAdjustedLabelWidth = maxWidth - maxMarkerWidth - maxValueLabelWidth;\n    }\n\n    this.labels.each(function (label) {\n      if (_this.valueLabels.template.align == \"right\" || label.measuredWidth > maxAdjustedLabelWidth) {\n        if (!(label.width instanceof Percent)) {\n          label.width = Math.min(label.maxWidth, maxAdjustedLabelWidth - label.pixelMarginLeft - label.pixelMarginRight);\n          label.maxWidth = label.width;\n        }\n      }\n    });\n\n    if (this.valueLabels.template.align == \"right\") {\n      this.valueLabels.each(function (valueLabel) {\n        valueLabel.width = maxValueLabelWidth - valueLabel.pixelMarginRight - valueLabel.pixelMarginLeft;\n      });\n    }\n\n    _super.prototype.afterDraw.call(this);\n  };\n\n  Legend.prototype.handleScrollbar = function () {\n    var scrollbar = this.scrollbar;\n\n    if (this.scrollable && scrollbar) {\n      scrollbar.height = this.measuredHeight;\n      scrollbar.x = this.measuredWidth - scrollbar.pixelWidth - scrollbar.pixelMarginLeft;\n\n      if (this.contentHeight > this.measuredHeight) {\n        scrollbar.visible = true;\n        scrollbar.thumb.height = scrollbar.height * this.measuredHeight / this.contentHeight;\n        this.paddingRight = scrollbar.pixelWidth + scrollbar.pixelMarginLeft + +scrollbar.pixelMarginRight;\n      } else {\n        scrollbar.visible = false;\n      }\n\n      this.updateMasks();\n    }\n  };\n\n  Object.defineProperty(Legend.prototype, \"position\", {\n    /**\r\n     * @return Position\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"position\");\n    },\n\n    /**\r\n     * Position of the legend.\r\n     *\r\n     * Options: \"left\", \"right\", \"top\", \"bottom\" (default), or \"absolute\".\r\n     *\r\n     * IMPORTANT: [[MapChart]] will ignore this setting, as it is using different\r\n     * layout structure than other charts.\r\n     *\r\n     * To position legend in [[MapChart]] set legend's `align` (`\"left\"` or\r\n     * `\"right\"`) and `valign` (`\"top\"` or `\"bottom\"`) properties instead.\r\n     *\r\n     * @default \"bottom\"\r\n     * @param value  Position\r\n     */\n    set: function (value) {\n      if (this.setPropertyValue(\"position\", value)) {\n        if (value == \"left\" || value == \"right\") {\n          this.margin(10, 5, 10, 10);\n          this.valign = \"middle\";\n          this.contentAlign = \"none\";\n          this.valueLabels.template.align = \"right\";\n\n          if (!$type.isNumber(this.maxColumns)) {\n            this.maxColumns = 1;\n          }\n\n          this.width = undefined;\n          this.maxWidth = 220;\n        } else {\n          this.maxColumns = undefined;\n          this.width = percent(100);\n          this.valueLabels.template.align = \"left\";\n        }\n\n        this.invalidate();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Legend.prototype, \"useDefaultMarker\", {\n    /**\r\n     * @return Use default marker?\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"useDefaultMarker\");\n    },\n\n    /**\r\n     * Should legend try to mirror the look of the related item when building\r\n     * the marker for legend item?\r\n     *\r\n     * If set to `false` it will try to make the marker look like its related\r\n     * item.\r\n     *\r\n     * E.g. if an item is for a Line Series, it will display a line of the\r\n     * same thickness, color, and will use the same bullets if series have them.\r\n     *\r\n     * If set to `true`, all markers will be shown as squares, regardless of te\r\n     * series type.\r\n     *\r\n     * @default false\r\n     * @param value Use default marker?\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"useDefaultMarker\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Legend.prototype, \"scrollable\", {\n    /**\r\n     * @return Legend Scrollable?\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"scrollable\");\n    },\n\n    /**\r\n     * If set to `true` the Legend will display a scrollbar if its contents do\r\n     * not fit into its `maxHeight`.\r\n     *\r\n     * Please note that `maxHeight` is automatically set for Legend when its\r\n     * `position` is set to `\"left\"` or `\"right\"`.\r\n     *\r\n     * @default false\r\n     * @since 4.8.0\r\n     * @param  value  Legend Scrollable?\r\n     */\n    set: function (value) {\n      if (this.setPropertyValue(\"scrollable\", value, true)) {\n        if (value) {\n          var scrollbar = this.createChild(Scrollbar);\n          this.scrollbar = scrollbar;\n          scrollbar.isMeasured = false;\n          scrollbar.orientation = \"vertical\";\n          scrollbar.endGrip.__disabled = true;\n          scrollbar.startGrip.__disabled = true;\n          scrollbar.visible = false;\n          scrollbar.marginLeft = 5;\n          this._mouseWheelDisposer = this.events.on(\"wheel\", this.handleWheel, this, false);\n\n          this._disposers.push(this._mouseWheelDisposer);\n\n          this._disposers.push(scrollbar.events.on(\"rangechanged\", this.updateMasks, this, false));\n        } else {\n          if (this._mouseWheelDisposer) {\n            this._mouseWheelDisposer.dispose();\n\n            if (this.scrollbar) {\n              this.scrollbar.dispose();\n              this.scrollbar = undefined;\n            }\n          }\n        }\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Handles mouse wheel scrolling of legend.\r\n   *\r\n   * @param  event  Event\r\n   */\n\n  Legend.prototype.handleWheel = function (event) {\n    var shift = event.shift.y;\n    var scrollbar = this.scrollbar;\n\n    if (scrollbar) {\n      var ds = shift / 1000 * this.measuredHeight / this.contentHeight;\n      var delta = scrollbar.end - scrollbar.start;\n\n      if (shift > 0) {\n        scrollbar.start = $math.max(0, scrollbar.start - ds);\n        scrollbar.end = scrollbar.start + delta;\n      } else {\n        scrollbar.end = $math.min(1, scrollbar.end - ds);\n        scrollbar.start = scrollbar.end - delta;\n      }\n    }\n  };\n  /**\r\n   * @ignore\r\n   */\n\n\n  Legend.prototype.updateMasks = function () {\n    var _this = this;\n\n    if (this.scrollbar) {\n      this.itemContainers.each(function (itemContainer) {\n        itemContainer.dy = -_this.scrollbar.thumb.pixelY * _this.contentHeight / _this.measuredHeight;\n        itemContainer.maskRectangle = {\n          x: 0,\n          y: -itemContainer.dy,\n          width: _this.measuredWidth,\n          height: _this.measuredHeight\n        };\n      });\n    }\n  };\n  /**\r\n   * Toggles a legend item.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param item Legend item\r\n   * @todo Maybe do it with togglable instead\r\n   */\n\n\n  Legend.prototype.toggleDataItem = function (item) {\n    var dataContext = item.dataContext;\n\n    if (!dataContext.visible || dataContext.isHiding || dataContext instanceof Sprite && dataContext.isHidden) {\n      item.color = item.colorOrig;\n      dataContext.appeared = true;\n      item.itemContainer.isActive = false;\n\n      if (dataContext.hidden === true) {\n        dataContext.hidden = false;\n      }\n\n      if (dataContext.show) {\n        dataContext.show();\n      } else {\n        dataContext.visible = true;\n      }\n\n      this.svgContainer.readerAlert(this.language.translate(\"%1 shown\", this.language.locale, item.label.readerTitle));\n    } else {\n      item.itemContainer.isActive = true;\n      dataContext.appeared = true;\n\n      if (dataContext.hide) {\n        dataContext.hide();\n      } else {\n        dataContext.visible = false;\n      }\n\n      this.svgContainer.readerAlert(this.language.translate(\"%1 hidden\", this.language.locale, item.label.readerTitle));\n      item.color = new InterfaceColorSet().getFor(\"disabledBackground\");\n    }\n  };\n\n  Object.defineProperty(Legend.prototype, \"preloader\", {\n    /**\r\n     * Override preloader method so that legend does not accidentally show its\r\n     * own preloader.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @return Always `undefined`\r\n     */\n    get: function () {\n      return;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * [handleDataItemPropertyChange description]\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n  Legend.prototype.handleDataItemPropertyChange = function (dataItem, name) {\n    dataItem.valueLabel.invalidate();\n    dataItem.label.invalidate();\n  };\n\n  return Legend;\n}(Component);\n\nexport { Legend };\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\n\nregistry.registeredClasses[\"Legend\"] = Legend;\n/**\r\n * Add default responsive rules\r\n */\n\n/**\r\n * Move legend to below the chart if chart is narrow\r\n */\n\ndefaultRules.push({\n  relevant: ResponsiveBreakpoints.widthXS,\n  state: function (target, stateId) {\n    if (target instanceof Legend && (target.position == \"left\" || target.position == \"right\")) {\n      var state = target.states.create(stateId);\n      state.properties.position = \"bottom\";\n      return state;\n    }\n\n    return null;\n  }\n});\n/**\r\n * Move legend to the right if chart is very short\r\n */\n\ndefaultRules.push({\n  relevant: ResponsiveBreakpoints.heightXS,\n  state: function (target, stateId) {\n    if (target instanceof Legend && (target.position == \"top\" || target.position == \"bottom\")) {\n      var state = target.states.create(stateId);\n      state.properties.position = \"right\";\n      return state;\n    }\n\n    return null;\n  }\n});\n/**\r\n * Disable legend altogether on small charts\r\n */\n\ndefaultRules.push({\n  relevant: ResponsiveBreakpoints.isXS,\n  state: function (target, stateId) {\n    if (target instanceof Legend) {\n      var state = target.states.create(stateId);\n      state.properties.disabled = true;\n      return state;\n    }\n\n    return null;\n  }\n});","map":{"version":3,"mappings":"AAAA;;;;AAIA;;;;;;;AAMA,SAASA,SAAT,QAA4G,mBAA5G;AACA,SAASC,QAAT,QAA0C,kBAA1C;AACA,SAASC,YAAT,EAAuBC,YAAvB,QAA2C,oBAA3C;AACA,SAASC,gBAAT,QAAiC,mCAAjC;AACA,SAASC,SAAT,QAA0B,mBAA1B;AACA,SAASC,KAAT,QAAsB,wBAAtB;AAGA,SAASC,QAAT,QAAyB,wBAAzB;AACA,SAASC,QAAT,QAAyB,kBAAzB;AACA,SAASC,cAAT,QAA+B,iCAA/B;AACA,SAASC,OAAT,EAAkBC,OAAlB,QAAiC,uBAAjC;AACA,SAASC,iBAAT,QAAkC,iCAAlC;AAKA,OAAO,KAAKC,MAAZ,MAAwB,qBAAxB;AACA,OAAO,KAAKC,KAAZ,MAAuB,oBAAvB;AACA,OAAO,KAAKC,KAAZ,MAAuB,oBAAvB;AACA,SAASC,MAAT,QAA+C,gBAA/C;AACA,SAASC,QAAT,QAAoC,wBAApC;AACA,SAASC,gBAAT,QAAiC,2BAAjC;AACA,SAASC,YAAT,EAAuBC,qBAAvB,QAAoD,0BAApD;AACA,SAASC,SAAT,QAA0B,4BAA1B;AAIA;;;;;;;AAOA;;;;;;AAKA;AAAA;AAAA;AAAoCC;AA2CnC;;;;;AAGA;AAAA,gBACCC,qBAAO,IADR;AAdA;;;;;AAGOC,4BAA2B,KAA3B;AAaNA,SAAI,CAACC,SAAL,GAAiB,gBAAjB;;AACAD,SAAI,CAACE,UAAL;;;AACA;;AAODC,wBAAWC,wBAAX,EAAW,OAAX,EAAgB;AALhB;;;;;SAKA;AAAA;;AACC,UAAI,CAAC,KAAKC,MAAV,EAAkB;AACjB,YAAIC,OAAK,GAAG,KAAKC,SAAL,CAAeC,MAAf,CAAsBC,MAAtB,EAAZ;AACA,aAAKJ,MAAL,GAAcC,OAAd;AACA,aAAKI,SAAL,CAAeJ,OAAf;;AACA,aAAKK,UAAL,CAAgBC,IAAhB,CAAqBN,OAArB;;AACAA,eAAK,CAACO,MAAN,GAAe,KAAKC,aAApB;;AAEA,aAAKH,UAAL,CAAgBC,IAAhB,CAAqB,IAAInB,QAAJ,CAAa;AACjC,cAAIH,KAAK,CAACyB,QAAN,CAAef,KAAI,CAACO,SAApB,CAAJ,EAAoC;AACnCP,iBAAI,CAACO,SAAL,CAAeC,MAAf,CAAsBQ,WAAtB,CAAkCV,OAAlC;AACA;AACD,SAJoB,CAArB;AAKA;;AACD,aAAO,KAAKD,MAAZ;AACA,KAfe;oBAAA;;AAAA,GAAhB;AA8CAF,wBAAWC,wBAAX,EAAW,OAAX,EAAgB;AAIhB;;;SAGA;AACC,aAAO,KAAKa,UAAL,CAAgBC,KAAvB;AACA,KATe;;AA7BhB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;SA6BA,UAAiBC,KAAjB,EAAyF;AACxF,WAAKC,WAAL,CAAiB,OAAjB,EAA0BD,KAA1B;AACA,KAFe;oBAAA;;AAAA,GAAhB;AAgBAhB,wBAAWC,wBAAX,EAAW,YAAX,EAAqB;AALrB;;;;;SAKA;AAAA;;AACC,UAAI,CAAC,KAAKiB,WAAV,EAAuB;AACtB,YAAIC,YAAU,GAAG,KAAKf,SAAL,CAAegB,WAAf,CAA2Bd,MAA3B,EAAjB;AACA,aAAKY,WAAL,GAAmBC,YAAnB;AAEA,aAAKZ,SAAL,CAAeY,YAAf;;AACA,aAAKX,UAAL,CAAgBC,IAAhB,CAAqBU,YAArB;;AACAA,oBAAU,CAACT,MAAX,GAAoB,KAAKC,aAAzB;;AAEA,aAAKH,UAAL,CAAgBC,IAAhB,CAAqB,IAAInB,QAAJ,CAAa;AACjC,cAAIH,KAAK,CAACyB,QAAN,CAAef,KAAI,CAACO,SAApB,CAAJ,EAAoC;AACnCP,iBAAI,CAACO,SAAL,CAAegB,WAAf,CAA2BP,WAA3B,CAAuCM,YAAvC;AACA;AACD,SAJoB,CAArB;AAKA;;AACD,aAAO,KAAKD,WAAZ;AACA,KAhBoB;oBAAA;;AAAA,GAArB;AAwBAlB,wBAAWC,wBAAX,EAAW,eAAX,EAAwB;AANxB;;;;;;SAMA;AAAA;;AACC,UAAI,CAAC,KAAKoB,cAAV,EAA0B;AAEzB,YAAIC,WAAS,GAAG,KAAKlB,SAArB;AAEA,YAAImB,eAAa,GAAGD,WAAS,CAACE,cAAV,CAAyBlB,MAAzB,EAApB;AACAiB,uBAAa,CAACb,MAAd,GAAuBY,WAAvB;AAEA,aAAKD,cAAL,GAAsBE,eAAtB;AACA,aAAKhB,SAAL,CAAegB,eAAf;;AACA,aAAKf,UAAL,CAAgBC,IAAhB,CAAqBc,eAArB,EATyB,CAWzB;;;AACA,YAAIA,eAAa,CAACE,SAAlB,EAA6B;AAC5BF,yBAAa,CAACG,MAAd,CAAqBC,EAArB,CAAwB,SAAxB,EAAmC,UAACC,EAAD,EAAG;AACrCN,uBAAS,CAACO,cAAV,CAA+BD,EAAE,CAACE,MAAH,CAAUC,QAAzC;AACA,WAFD,EAEGC,SAFH,EAEc,KAFd;AAGA,SAhBwB,CAkBzB;AACA;;;AACA,YAAIT,eAAa,CAACU,SAAlB,EAA6B;AAC5BV,yBAAa,CAACG,MAAd,CAAqBC,EAArB,CAAwB,KAAxB,EAA+B,UAACC,EAAD,EAAG;AACjC;AACA;AACAN,uBAAS,CAACY,WAAV,GAAwBF,SAAxB;AACA,WAJD,EAIGA,SAJH,EAIc,KAJd;AAKAT,yBAAa,CAACG,MAAd,CAAqBC,EAArB,CAAwB,OAAxB,EAAiC,UAACC,EAAD,EAAG;AACnCN,uBAAS,CAACY,WAAV,GAA8BN,EAAE,CAACE,MAAH,CAAUC,QAAxC;AACA,WAFD,EAEGC,SAFH,EAEc,KAFd;AAGAT,yBAAa,CAACG,MAAd,CAAqBC,EAArB,CAAwB,MAAxB,EAAgC,UAACC,EAAD,EAAG;AAClCN,uBAAS,CAACY,WAAV,GAAwBF,SAAxB;AACA,WAFD,EAEGA,SAFH,EAEc,KAFd;AAGA;;AAED,aAAKxB,UAAL,CAAgBC,IAAhB,CAAqB,IAAInB,QAAJ,CAAa;AACjC,cAAIH,KAAK,CAACyB,QAAN,CAAef,KAAI,CAACO,SAApB,CAAJ,EAAoC;AACnCP,iBAAI,CAACO,SAAL,CAAeoB,cAAf,CAA8BX,WAA9B,CAA0CU,eAA1C;AACA;AACD,SAJoB,CAArB;;AAMA,YAAI,KAAKY,WAAL,CAAiBC,OAArB,EAA8B;AAC7Bb,yBAAa,CAACc,cAAd,GAA+B,KAAKF,WAAL,CAAiBC,OAAjB,EAA/B;AACAb,yBAAa,CAACe,gBAAd,GAAiC,KAAKH,WAAL,CAAiBC,OAAjB,EAAjC;AACA;;AAED,YAAIG,MAAM,GAAQ,KAAKJ,WAAvB;;AACA,YAAI,CAACI,MAAM,YAAYjE,QAAlB,IAA8BiE,MAAM,YAAYlD,MAAjD,KAA4D,CAACkD,MAAM,CAACC,UAAP,EAAjE,EAAsF;AACrF,cAAMC,iBAAiB,GAAG,UAASb,EAAT,EAA6F;AACtHL,2BAAa,CAACmB,aAAd,GAA8Bd,EAAE,CAACe,OAAjC;AACApB,2BAAa,CAACG,MAAd,CAAqBkB,WAArB,CAAiC,SAAjC;AACArB,2BAAa,CAACsB,QAAd,GAAyB,CAACjB,EAAE,CAACe,OAA7B;AACApB,2BAAa,CAACG,MAAd,CAAqBoB,UAArB,CAAgC,SAAhC;AACA,WALD;;AAOAP,gBAAM,CAACQ,WAAP,CAAmB,IAAIzD,QAAJ,CAAa;AAC/B,gBAAIO,KAAI,CAACO,SAAT,EAAoB;AACnBP,mBAAI,CAACO,SAAL,CAAe4C,SAAf,CAAyBC,MAAzB,CAAgCpD,KAAhC;AACA;AACD,WAJkB,CAAnB;;AAMA,cAAI0C,MAAM,YAAYlD,MAAtB,EAA8B;AAC7BkC,2BAAa,CAACwB,WAAd,CACCR,MAAM,CAACb,MAAP,CAAcC,EAAd,CAAiB,mBAAjB,EAAsCc,iBAAtC,EAAyDT,SAAzD,EAAoE,KAApE,CADD;AAIAT,2BAAa,CAACwB,WAAd,CACCR,MAAM,CAACb,MAAP,CAAcC,EAAd,CAAiB,QAAjB,EAA2B,UAACC,EAAD,EAAG;AAC7BL,6BAAa,CAACmB,aAAd,GAA8B,KAA9B;AACAnB,6BAAa,CAACG,MAAd,CAAqBkB,WAArB,CAAiC,SAAjC;AACArB,6BAAa,CAACsB,QAAd,GAAyB,IAAzB;AACAtB,6BAAa,CAACG,MAAd,CAAqBoB,UAArB,CAAgC,SAAhC;AACA,aALD,EAKGd,SALH,EAKc,KALd,CADD;AAQAT,2BAAa,CAACwB,WAAd,CACCR,MAAM,CAACb,MAAP,CAAcC,EAAd,CAAiB,OAAjB,EAA0B,UAACC,EAAD,EAAG;AAC5BL,6BAAa,CAACmB,aAAd,GAA8B,IAA9B;AACAnB,6BAAa,CAACG,MAAd,CAAqBkB,WAArB,CAAiC,SAAjC;AACArB,6BAAa,CAACsB,QAAd,GAAyB,KAAzB;AACAtB,6BAAa,CAACG,MAAd,CAAqBoB,UAArB,CAAgC,SAAhC;AACA,aALD,EAKGd,SALH,EAKc,KALd,CADD;AASA,WAtBD,MAsBO;AACNT,2BAAa,CAACwB,WAAd,CACCR,MAAM,CAACb,MAAP,CAAcC,EAAd,CAAiB,mBAAjB,EAAsCc,iBAAtC,EAAyDT,SAAzD,EAAoE,KAApE,CADD;AAGA;AACD;AACD;;AACD,aAAO,KAAKX,cAAZ;AACA,KA3FuB;oBAAA;;AAAA,GAAxB;AAkGArB,wBAAWC,wBAAX,EAAW,QAAX,EAAiB;AALjB;;;;;SAKA;AAAA;;AACC,UAAI,CAAC,KAAKiD,OAAV,EAAmB;AAClB,YAAIC,QAAM,GAAG,KAAK/C,SAAL,CAAegD,OAAf,CAAuB9C,MAAvB,EAAb;AACA,aAAK4C,OAAL,GAAeC,QAAf;AACAA,gBAAM,CAACzC,MAAP,GAAgB,KAAKC,aAArB;AACA,aAAKJ,SAAL,CAAe4C,QAAf;;AACA,aAAK3C,UAAL,CAAgBC,IAAhB,CAAqB0C,QAArB;;AAEA,aAAK3C,UAAL,CAAgBC,IAAhB,CAAqB,IAAInB,QAAJ,CAAa;AACjC,cAAIH,KAAK,CAACyB,QAAN,CAAef,KAAI,CAACO,SAApB,CAAJ,EAAoC;AACnCP,iBAAI,CAACO,SAAL,CAAegD,OAAf,CAAuBvC,WAAvB,CAAmCsC,QAAnC;AACA;AACD,SAJoB,CAArB;AAKA;;AACD,aAAO,KAAKD,OAAZ;AACA,KAfgB;oBAAA;;AAAA,GAAjB;AAgBD;AAjQA,EAAoC5E,QAApC;;;AAoQA;;;;;;;AAOA;;;;;;;;;;AASA;AAAA;AAAA;AAAA;AA0BC;;;AAGO,wBAAwB,IAAxB;AACP;;AAAD;AAAC,CA9BD;;;AA8GA;;;;;;;AAOA;;;;;;;;AAOA;AAAA;AAAA;AAA4BqB;AAyD3B;;;;;AAGA;AAAA,gBACCC,qBAAO,IADR;;AAECC,SAAI,CAACC,SAAL,GAAiB,QAAjB,CAFD,CAIC;;AACAD,SAAI,CAACwD,MAAL,GAAc,MAAd;;AACAxD,SAAI,CAACyD,gBAAL,CAAsB,kBAAtB,EAA0C,KAA1C;;AACAzD,SAAI,CAACyD,gBAAL,CAAsB,YAAtB,EAAoC,KAApC;;AACAzD,SAAI,CAACyD,gBAAL,CAAsB,cAAtB,EAAsC,QAAtC,EARD,CAUC;;;AACA,QAAI3C,aAAa,GAAc,IAAIjC,SAAJ,EAA/B;AACAiC,iBAAa,CAAC4C,aAAd,GAA8B,IAA9B;AACA5C,iBAAa,CAAC6C,OAAd,CAAsB,CAAtB,EAAyB,CAAzB,EAA4B,CAA5B,EAA+B,CAA/B;AACA7C,iBAAa,CAAC8C,MAAd,CAAqB,CAArB,EAAwB,EAAxB,EAA4B,CAA5B,EAA+B,EAA/B;AACA9C,iBAAa,CAAC0C,MAAd,GAAuB,YAAvB;AACA1C,iBAAa,CAAC+C,SAAd,GAA0B,IAA1B;AACA/C,iBAAa,CAACsB,SAAd,GAA0B,IAA1B;AACAtB,iBAAa,CAACgD,IAAd,GAAqB,QAArB;AACAhD,iBAAa,CAACc,SAAd,GAA0B,IAA1B;AACAd,iBAAa,CAACiD,eAAd,GAAgCrE,gBAAgB,CAACsE,OAAjD;AACAlD,iBAAa,CAACmD,UAAd,CAAyBC,WAAzB,GAAuC,CAAvC,CArBD,CAqB2C;AAE1C;;AACAlE,SAAI,CAAC2B,cAAL,GAAsB,IAAIjD,YAAJ,CAA4BoC,aAA5B,CAAtB;;AACAd,SAAI,CAACW,UAAL,CAAgBC,IAAhB,CAAqB,IAAIjC,YAAJ,CAAiBqB,KAAI,CAAC2B,cAAtB,CAArB;;AACA3B,SAAI,CAACW,UAAL,CAAgBC,IAAhB,CAAqBZ,KAAI,CAAC2B,cAAL,CAAoBwC,QAAzC,EA1BD,CA4BC;;;AACAnE,SAAI,CAACW,UAAL,CAAgBC,IAAhB,CAAqB3B,cAAc,GAAGmF,IAAjB,CAAsBvC,MAAtB,CAA6BC,EAA7B,CAAgC,OAAhC,EAAyC,UAACC,EAAD,EAAG;AAChE,UAAIhD,QAAQ,CAACsF,KAAT,CAAetC,EAAE,CAACuC,KAAlB,EAAyB,OAAzB,KAAqCtE,KAAI,CAACqC,WAA9C,EAA2D;AAC1D,YAAMA,WAAW,GAAGrC,KAAI,CAACqC,WAAzB;AACA,YAAMJ,MAAM,GAAGI,WAAW,CAACvB,aAA3B;;AACA,YAAImB,MAAM,CAACL,SAAX,EAAsB;AACrB5B,eAAI,CAACgC,cAAL,CAAoBK,WAApB;AACA,SAFD,MAGK,IAAIJ,MAAM,CAAC4B,SAAP,IAAoB5B,MAAM,CAACJ,MAAP,CAAc0C,SAAd,CAAwB,KAAxB,CAAxB,EAAwD;AAC5DtC,gBAAM,CAACuC,mBAAP,CAA2B,KAA3B,EAAkC;AAAEF,iBAAK,EAAEvC;AAAT,WAAlC,EAD4D,CAG5D;AACA;;AACA/B,eAAI,CAACqC,WAAL,GAAmBA,WAAnB;AACA;AACD;AACD,KAfoB,EAelBrC,KAfkB,CAArB;;AAiBA,QAAIyE,eAAe,GAAG,IAAIrF,iBAAJ,EAAtB,CA9CD,CAgDC;;AACA,QAAIsF,MAAM,GAAc,IAAI7F,SAAJ,EAAxB;AACA6F,UAAM,CAACC,KAAP,GAAe,EAAf;AACAD,UAAM,CAACE,MAAP,GAAgB,EAAhB;AACAF,UAAM,CAACG,mBAAP,GAA6B,KAA7B;AACAH,UAAM,CAAChB,aAAP,GAAuB,IAAvB;AACAgB,UAAM,CAACI,kBAAP,GAA4B,IAA5B;AACAJ,UAAM,CAACT,UAAP,CAAkBC,WAAlB,GAAgC,CAAhC;AACAQ,UAAM,CAACT,UAAP,CAAkBc,aAAlB,GAAkC,CAAlC;AACAL,UAAM,CAACM,cAAP,CAAsBC,IAAtB,GAA6B,MAA7B;AACAP,UAAM,CAACQ,MAAP,GAAgB,QAAhB;AAEA,QAAIC,aAAa,GAAGV,eAAe,CAACW,MAAhB,CAAuB,oBAAvB,CAApB;AAEAV,UAAM,CAAC7C,MAAP,CAAcC,EAAd,CAAiB,YAAjB,EAA+B,UAACwC,KAAD,EAAM;AACpC,UAAIe,KAAK,GAAGf,KAAK,CAACgB,QAAlB;AACA,UAAIC,WAAW,GAAGF,KAAK,CAACG,MAAN,CAAa/E,MAAb,CAAoB,QAApB,CAAlB;AACA8E,iBAAW,CAACtE,UAAZ,CAAuBwE,MAAvB,GAAgCN,aAAhC;AACAI,iBAAW,CAACtE,UAAZ,CAAuBgE,IAAvB,GAA8BE,aAA9B;AACA,KALD;AAOAnF,SAAI,CAACuD,OAAL,GAAe,IAAI7E,YAAJ,CAA4BgG,MAA5B,CAAf;;AACA1E,SAAI,CAACW,UAAL,CAAgBC,IAAhB,CAAqB,IAAIjC,YAAJ,CAAiBqB,KAAI,CAACuD,OAAtB,CAArB;;AACAvD,SAAI,CAACW,UAAL,CAAgBC,IAAhB,CAAqBZ,KAAI,CAACuD,OAAL,CAAaY,QAAlC,EAvED,CAyEC;;;AACA,QAAIuB,SAAS,GAAqBhB,MAAM,CAACiB,WAAP,CAAmB/G,gBAAnB,CAAlC;AACA8G,aAAS,CAACf,KAAV,GAAkBzF,OAAO,CAAC,GAAD,CAAzB;AACAwG,aAAS,CAACd,MAAV,GAAmB1F,OAAO,CAAC,GAAD,CAA1B;AACAwG,aAAS,CAAChC,aAAV,GAA0B,IAA1B;AACAgC,aAAS,CAACV,cAAV,CAAyBC,IAAzB,GAAgC,MAAhC,CA9ED,CA8EyC;;AACxCS,aAAS,CAACX,aAAV,GAA0B,CAA1B,CA/ED,CAiFC;;AACA,QAAIa,KAAK,GAAU,IAAI9G,KAAJ,EAAnB;AACA8G,SAAK,CAACC,IAAN,GAAa,QAAb;AACAD,SAAK,CAAChC,MAAN,CAAa,CAAb,EAAgB,CAAhB,EAAmB,CAAnB,EAAsB,CAAtB;AACAgC,SAAK,CAACV,MAAN,GAAe,QAAf;AACAU,SAAK,CAAClC,aAAN,GAAsB,IAAtB;AACAkC,SAAK,CAACJ,MAAN,CAAa/E,MAAb,CAAoB,QAApB,EAA8BQ,UAA9B,CAAyCgE,IAAzC,GAAgDR,eAAe,CAACW,MAAhB,CAAuB,oBAAvB,CAAhD;AACApF,SAAI,CAACQ,MAAL,GAAc,IAAI9B,YAAJ,CAAwBkH,KAAxB,CAAd;;AACA5F,SAAI,CAACW,UAAL,CAAgBC,IAAhB,CAAqB,IAAIjC,YAAJ,CAAiBqB,KAAI,CAACQ,MAAtB,CAArB;;AACAR,SAAI,CAACW,UAAL,CAAgBC,IAAhB,CAAqBZ,KAAI,CAACQ,MAAL,CAAY2D,QAAjC;;AACAyB,SAAK,CAACf,mBAAN,GAA4B,KAA5B;AACAe,SAAK,CAACE,QAAN,GAAiB,IAAjB;AACAF,SAAK,CAACG,SAAN,GAAkB,KAAlB,CA7FD,CA+FC;;AACA,QAAIC,UAAU,GAAU,IAAIlH,KAAJ,EAAxB;AACAkH,cAAU,CAACpC,MAAX,CAAkB,CAAlB,EAAqB,CAArB,EAAwB,CAAxB,EAA2B,CAA3B;AACAoC,cAAU,CAACd,MAAX,GAAoB,QAApB;AACAc,cAAU,CAACrB,KAAX,GAAmB,EAAnB,CAnGD,CAmGwB;;AACvBqB,cAAU,CAACC,KAAX,GAAmB,OAAnB;AACAD,cAAU,CAACE,SAAX,GAAuB,KAAvB;AACAF,cAAU,CAACtC,aAAX,GAA2B,IAA3B;AACAsC,cAAU,CAACR,MAAX,CAAkB/E,MAAlB,CAAyB,QAAzB,EAAmCQ,UAAnC,CAA8CgE,IAA9C,GAAqDR,eAAe,CAACW,MAAhB,CAAuB,oBAAvB,CAArD;AACAY,cAAU,CAACnB,mBAAX,GAAiC,KAAjC;AAEA7E,SAAI,CAACuB,WAAL,GAAmB,IAAI7C,YAAJ,CAAwBsH,UAAxB,CAAnB;;AACAhG,SAAI,CAACW,UAAL,CAAgBC,IAAhB,CAAqB,IAAIjC,YAAJ,CAAiBqB,KAAI,CAACuB,WAAtB,CAArB;;AACAvB,SAAI,CAACW,UAAL,CAAgBC,IAAhB,CAAqBZ,KAAI,CAACuB,WAAL,CAAiB4C,QAAtC;;AAEAnE,SAAI,CAACmG,QAAL,GAAgB,QAAhB,CA9GD,CA8G2B;AAE1B;;AACArF,iBAAa,CAAC0E,MAAd,CAAqB/E,MAArB,CAA4B,QAA5B;AACAK,iBAAa,CAACgE,kBAAd,GAAmC,IAAnC,CAlHD,CAoHC;;AACA9E,SAAI,CAAC8D,IAAL,GAAY,OAAZ;;AAEA9D,SAAI,CAAC6B,MAAL,CAAYC,EAAZ,CAAe,iBAAf,EAAkC9B,KAAI,CAACoG,eAAvC,EAAwDpG,KAAxD,EAA8D,KAA9D;;AAEAA,SAAI,CAACE,UAAL;;;AACA;AAED;;;;;;AAIUmG,2CAAV;AACCtG,qBAAMuG,qBAAN,CAA2BC,IAA3B,CAA2B,IAA3B;;AACA,QAAI,CAACjH,KAAK,CAACyB,QAAN,CAAe,KAAKyF,WAApB,CAAL,EAAuC;AACtC,WAAKA,WAAL,GAAmB,KAAKC,QAAL,CAAcC,SAAd,CAAwB,QAAxB,CAAnB;AACA;AACD,GALS;AAOV;;;;;;;;AAMUL,oCAAV;AACC,WAAO,IAAIjG,cAAJ,EAAP;AACA,GAFS;AAIV;;;;;;;;AAMUiG,0CAAV;AACC,QAAI,KAAKM,SAAT,EAAoB;AACnB,WAAKA,SAAL,CAAeC,KAAf,GAAuB,CAAvB;AACA,WAAKD,SAAL,CAAeE,GAAf,GAAqB,CAArB;AACA;;AACD9G,qBAAM+G,oBAAN,CAA0BP,IAA1B,CAA0B,IAA1B;AACA,GANS;AAQV;;;;;;;;;;;AASOF,yCAAP,UAA2BnE,QAA3B,EAAsD;AACrDnC,qBAAMgH,mBAAN,CAAyBR,IAAzB,CAAyB,IAAzB,EAA0BrE,QAA1B,EADqD,CAErD;;;AACA,QAAI8E,SAAS,GAAG9E,QAAQ,CAACpB,aAAzB;AAEA,QAAI4D,MAAM,GAAGxC,QAAQ,CAACwC,MAAtB;AAEArF,UAAM,CAAC4H,IAAP,CAAY/E,QAAQ,CAAC0D,KAArB;AACA,QAAII,UAAU,GAAG9D,QAAQ,CAAC8D,UAA1B,CARqD,CAUrD;;AACAgB,aAAS,CAACnE,aAAV,GAA0BX,QAAQ,CAACI,WAAT,CAAqBQ,OAA/C,CAXqD,CAarD;;AACAZ,YAAQ,CAACI,WAAT,CAAqB4E,cAArB,GAAsChF,QAAtC;AAEA,QAAIiF,YAAY,GAAGjF,QAAQ,CAAC0D,KAAT,CAAewB,QAAlC;;AACA,QAAG,EAAElF,QAAQ,CAAC0D,KAAT,CAAejB,KAAf,YAAgCxF,OAAlC,CAAH,EAA8C;AAC7C+C,cAAQ,CAAC0D,KAAT,CAAejB,KAAf,GAAuBxC,SAAvB;AACA;;AAED,QAAIgF,YAAY,GAAG,CAAnB,EAAsB;AACrBjF,cAAQ,CAAC0D,KAAT,CAAewB,QAAf,GAA0BD,YAA1B;AACA;;AACD,QAAInB,UAAU,CAACC,KAAX,IAAoB,OAAxB,EAAiC;AAChCD,gBAAU,CAACrB,KAAX,GAAmBxC,SAAnB;AACA;;AAED,QAAIkF,cAAc,GAAGnF,QAAQ,CAACI,WAAT,CAAqB+E,cAA1C,CA5BqD,CA8BrD;AACA;;AACA,QAAI/E,WAAW,GAAGJ,QAAQ,CAACI,WAA3B;;AAEA,QAAIA,WAAW,CAACgF,kBAAZ,KAAmC,CAAC,KAAKC,gBAAN,IAA0B,EAAEjF,WAAW,YAAY9C,MAAzB,CAA7D,CAAJ,EAAoG;AACnG,UAAI,CAAC0C,QAAQ,CAACsF,eAAd,EAA+B;AAC9BlF,mBAAW,CAACgF,kBAAZ,CAA+B5C,MAA/B;AACAxC,gBAAQ,CAACsF,eAAT,GAA2B,IAA3B;AACA;AACD,KALD,MAMK;AACJ,WAAKjE,OAAL,CAAaY,QAAb,CAAsBa,cAAtB,CAAqCC,IAArC,GAA4C9C,SAA5C;AACA;;AAED,QAAIG,WAAW,CAACmF,iBAAhB,EAAmC;AAClCnF,iBAAW,CAACmF,iBAAZ,GADkC,CACD;AACjC;;AAED,QAAInF,WAAW,CAAC/B,SAAZ,IAAyB+B,WAAW,CAAC/B,SAAZ,CAAsBkH,iBAAnD,EAAsE;AACrEnF,iBAAW,CAAC/B,SAAZ,CAAsBkH,iBAAtB,CAAwCnF,WAAxC;AACA;;AAED,QAAI0D,UAAU,CAAC0B,OAAf,EAAwB;AACvB1B,gBAAU,CAAC2B,QAAX;AACA;;AAED,QAAI3B,UAAU,CAACH,IAAX,IAAmB,EAAnB,IAAyBG,UAAU,CAACH,IAAX,IAAmB1D,SAAhD,EAA2D;AAC1D6D,gBAAU,CAAC4B,UAAX,GAAwB,IAAxB;AACA,KAFD,MAGK;AACJ5B,gBAAU,CAAC4B,UAAX,GAAwB,KAAxB;AACA;;AAED,QAAIP,cAAc,KAAKA,cAAc,CAACQ,aAAf,IAAgC1F,SAAhC,IAA6CkF,cAAc,CAACS,SAAf,IAA4B3F,SAA9E,CAAlB,EAA4G;AAC3G6D,gBAAU,CAAC4B,UAAX,GAAwB,KAAxB;AACA;;AAED,QAAI9E,OAAO,GAAGZ,QAAQ,CAACI,WAAT,CAAqBQ,OAAnC;;AAEA,QAAIA,OAAO,KAAKX,SAAhB,EAA2B;AAC1BW,aAAO,GAAG,IAAV;AACA;;AACDA,WAAO,GAAGxD,KAAK,CAACyI,SAAN,CAAgBjF,OAAhB,CAAV;AACAZ,YAAQ,CAACI,WAAT,CAAqBQ,OAArB,GAA+BA,OAA/B;AAEAkE,aAAS,CAACnF,MAAV,CAAiBkB,WAAjB,CAA6B,SAA7B;AAEAiE,aAAS,CAAChE,QAAV,GAAqB,CAACF,OAAtB;;AACA,QAAIkE,SAAS,CAAChE,QAAd,EAAwB;AACvBgE,eAAS,CAACgB,QAAV,CAAmB,QAAnB,EAA6B,CAA7B;AACA,KAFD,MAGK;AACJhB,eAAS,CAACgB,QAAV,CAAmB,SAAnB,EAA8B,CAA9B;AACA;;AACDhB,aAAS,CAACnF,MAAV,CAAiBoB,UAAjB,CAA4B,SAA5B;AACA,GArFM;;AAwFAoD,+BAAP;AAAA;;AACC,QAAIe,QAAQ,GAAG,KAAKa,gBAAL,CAAsB,UAAtB,CAAf;AACA,QAAIC,aAAa,GAAG,CAApB;AACA,SAAK1H,MAAL,CAAY2H,IAAZ,CAAiB,UAACvC,KAAD,EAAM;AACtB,UAAIA,KAAK,CAAC8B,OAAV,EAAmB;AAClB9B,aAAK,CAACwB,QAAN,GAAiBjF,SAAjB;AACAyD,aAAK,CAAC+B,QAAN;AACA;;AACD,UAAI/B,KAAK,CAACwC,aAAN,GAAsBxC,KAAK,CAACyC,eAA5B,GAA8CzC,KAAK,CAAC0C,gBAApD,GAAuEJ,aAA3E,EAA0F;AACzFA,qBAAa,GAAGtC,KAAK,CAACwC,aAAN,GAAsBxC,KAAK,CAACyC,eAA5B,GAA8CzC,KAAK,CAAC0C,gBAApE;AACA;AAED,KATD;AAWA,QAAIC,kBAAkB,GAAG,CAAzB;AACA,SAAKhH,WAAL,CAAiB4G,IAAjB,CAAsB,UAACvC,KAAD,EAAM;AAC3B,UAAIA,KAAK,CAAC8B,OAAV,EAAmB;AAClB9B,aAAK,CAAC+B,QAAN;AACA;;AACD,UAAI/B,KAAK,CAACwC,aAAN,GAAsBxC,KAAK,CAACyC,eAA5B,GAA8CzC,KAAK,CAAC0C,gBAApD,GAAuEC,kBAA3E,EAA+F;AAC9FA,0BAAkB,GAAG3C,KAAK,CAACwC,aAAN,GAAsBxC,KAAK,CAACyC,eAA5B,GAA8CzC,KAAK,CAAC0C,gBAAzE;AACA;AACD,KAPD;AASA,QAAIE,cAAc,GAAG,CAArB;AACA,SAAKjF,OAAL,CAAa4E,IAAb,CAAkB,UAACzD,MAAD,EAAO;AACxB,UAAIA,MAAM,CAACgD,OAAX,EAAoB;AACnBhD,cAAM,CAACiD,QAAP;AACA;;AACD,UAAIjD,MAAM,CAAC0D,aAAP,GAAuB1D,MAAM,CAAC2D,eAA9B,GAAgD3D,MAAM,CAAC4D,gBAAvD,GAA0EE,cAA9E,EAA8F;AAC7FA,sBAAc,GAAG9D,MAAM,CAAC0D,aAAP,GAAuB1D,MAAM,CAAC2D,eAA9B,GAAgD3D,MAAM,CAAC4D,gBAAxE;AACA;AACD,KAPD;AAQA,QAAIxH,aAAa,GAAG,KAAKa,cAAL,CAAoBwC,QAAxC;AACA,QAAIP,MAAM,GAAG9C,aAAa,CAACwH,gBAAd,GAAiCxH,aAAa,CAACuH,eAA5D;AACA,QAAII,qBAAJ;AACA,QAAIC,YAAY,GAAGR,aAAa,GAAGK,kBAAhB,GAAqCC,cAAxD;;AACA,QAAI,CAAClJ,KAAK,CAACqJ,QAAN,CAAevB,QAAf,CAAL,EAA+B;AAC9BqB,2BAAqB,GAAGP,aAAxB;AACA,KAFD,MAGK;AACJd,cAAQ,GAAGA,QAAQ,GAAGxD,MAAtB;;AACA,UAAIwD,QAAQ,GAAGsB,YAAf,EAA6B;AAC5BtB,gBAAQ,GAAGsB,YAAX;AACA;;AACDD,2BAAqB,GAAGrB,QAAQ,GAAGoB,cAAX,GAA4BD,kBAApD;AACA;;AAED,SAAK/H,MAAL,CAAY2H,IAAZ,CAAiB,UAACvC,KAAD,EAAM;AACtB,UAAI5F,KAAI,CAACuB,WAAL,CAAiB4C,QAAjB,CAA0B8B,KAA1B,IAAmC,OAAnC,IAA8CL,KAAK,CAACwC,aAAN,GAAsBK,qBAAxE,EAA+F;AAC9F,YAAG,EAAE7C,KAAK,CAACjB,KAAN,YAAuBxF,OAAzB,CAAH,EAAqC;AACpCyG,eAAK,CAACjB,KAAN,GAAciE,IAAI,CAACC,GAAL,CAASjD,KAAK,CAACwB,QAAf,EAAyBqB,qBAAqB,GAAG7C,KAAK,CAACyC,eAA9B,GAAgDzC,KAAK,CAAC0C,gBAA/E,CAAd;AACA1C,eAAK,CAACwB,QAAN,GAAiBxB,KAAK,CAACjB,KAAvB;AACA;AACD;AACD,KAPD;;AAQA,QAAI,KAAKpD,WAAL,CAAiB4C,QAAjB,CAA0B8B,KAA1B,IAAmC,OAAvC,EAAgD;AAC/C,WAAK1E,WAAL,CAAiB4G,IAAjB,CAAsB,UAACnC,UAAD,EAAW;AAChCA,kBAAU,CAACrB,KAAX,GAAmB4D,kBAAkB,GAAGvC,UAAU,CAACsC,gBAAhC,GAAmDtC,UAAU,CAACqC,eAAjF;AACA,OAFD;AAGA;;AAEDtI,qBAAM+I,SAAN,CAAevC,IAAf,CAAe,IAAf;AACA,GA/DM;;AAkEGF,qCAAV;AACC,QAAIM,SAAS,GAAG,KAAKA,SAArB;;AACA,QAAI,KAAKoC,UAAL,IAAmBpC,SAAvB,EAAkC;AACjCA,eAAS,CAAC/B,MAAV,GAAmB,KAAKoE,cAAxB;AACArC,eAAS,CAACsC,CAAV,GAAc,KAAKb,aAAL,GAAqBzB,SAAS,CAACuC,UAA/B,GAA4CvC,SAAS,CAAC0B,eAApE;;AAEA,UAAI,KAAKc,aAAL,GAAqB,KAAKH,cAA9B,EAA8C;AAC7CrC,iBAAS,CAAC7D,OAAV,GAAoB,IAApB;AACA6D,iBAAS,CAACyC,KAAV,CAAgBxE,MAAhB,GAAyB+B,SAAS,CAAC/B,MAAV,GAAmB,KAAKoE,cAAxB,GAAyC,KAAKG,aAAvE;AACA,aAAKE,YAAL,GAAoB1C,SAAS,CAACuC,UAAV,GAAuBvC,SAAS,CAAC0B,eAAjC,GAAmD,CAAE1B,SAAS,CAAC2B,gBAAnF;AACA,OAJD,MAKK;AACJ3B,iBAAS,CAAC7D,OAAV,GAAoB,KAApB;AACA;;AAED,WAAKwG,WAAL;AACA;AACD,GAjBS;;AAiCVnJ,wBAAWkG,gBAAX,EAAW,UAAX,EAAmB;AAwBnB;;;SAGA;AACC,aAAO,KAAK4B,gBAAL,CAAsB,UAAtB,CAAP;AACA,KA7BkB;;AAdnB;;;;;;;;;;;;;;SAcA,UAAoB9G,KAApB,EAAyC;AACxC,UAAI,KAAKsC,gBAAL,CAAsB,UAAtB,EAAkCtC,KAAlC,CAAJ,EAA8C;AAC7C,YAAIA,KAAK,IAAI,MAAT,IAAmBA,KAAK,IAAI,OAAhC,EAAyC;AACxC,eAAKyC,MAAL,CAAY,EAAZ,EAAgB,CAAhB,EAAmB,EAAnB,EAAuB,EAAvB;AACA,eAAKsB,MAAL,GAAc,QAAd;AACA,eAAKqE,YAAL,GAAoB,MAApB;AACA,eAAKhI,WAAL,CAAiB4C,QAAjB,CAA0B8B,KAA1B,GAAkC,OAAlC;;AAEA,cAAI,CAAC3G,KAAK,CAACqJ,QAAN,CAAe,KAAKa,UAApB,CAAL,EAAsC;AACrC,iBAAKA,UAAL,GAAkB,CAAlB;AACA;;AAED,eAAK7E,KAAL,GAAaxC,SAAb;AACA,eAAKiF,QAAL,GAAgB,GAAhB;AACA,SAZD,MAaK;AACJ,eAAKoC,UAAL,GAAkBrH,SAAlB;AACA,eAAKwC,KAAL,GAAazF,OAAO,CAAC,GAAD,CAApB;AACA,eAAKqC,WAAL,CAAiB4C,QAAjB,CAA0B8B,KAA1B,GAAkC,MAAlC;AACA;;AACD,aAAKwD,UAAL;AACA;AACD,KAtBkB;oBAAA;;AAAA,GAAnB;AA+CAtJ,wBAAWkG,gBAAX,EAAW,kBAAX,EAA2B;AAI3B;;;SAGA;AACC,aAAO,KAAK4B,gBAAL,CAAsB,kBAAtB,CAAP;AACA,KAT0B;;AAhB3B;;;;;;;;;;;;;;;;SAgBA,UAA4B9G,KAA5B,EAA0C;AACzC,WAAKsC,gBAAL,CAAsB,kBAAtB,EAA0CtC,KAA1C,EAAiD,IAAjD;AACA,KAF0B;oBAAA;;AAAA,GAA3B;AAsBAhB,wBAAWkG,gBAAX,EAAW,YAAX,EAAqB;AA+DrB;;;SAGA;AACC,aAAO,KAAK4B,gBAAL,CAAsB,YAAtB,CAAP;AACA,KApEoB;;AAXrB;;;;;;;;;;;SAWA,UAAsB9G,KAAtB,EAAoC;AACnC,UAAI,KAAKsC,gBAAL,CAAsB,YAAtB,EAAoCtC,KAApC,EAA2C,IAA3C,CAAJ,EAAsD;AACrD,YAAIA,KAAJ,EAAW;AACV,cAAIwF,SAAS,GAAG,KAAKhB,WAAL,CAAiB9F,SAAjB,CAAhB;AACA,eAAK8G,SAAL,GAAiBA,SAAjB;AACAA,mBAAS,CAAC+C,UAAV,GAAuB,KAAvB;AACA/C,mBAAS,CAACgD,WAAV,GAAwB,UAAxB;AACAhD,mBAAS,CAACiD,OAAV,CAAkBhC,UAAlB,GAA+B,IAA/B;AACAjB,mBAAS,CAACkD,SAAV,CAAoBjC,UAApB,GAAiC,IAAjC;AACAjB,mBAAS,CAAC7D,OAAV,GAAoB,KAApB;AACA6D,mBAAS,CAACmD,UAAV,GAAuB,CAAvB;AAEA,eAAKC,mBAAL,GAA2B,KAAKlI,MAAL,CAAYC,EAAZ,CAAe,OAAf,EAAwB,KAAKkI,WAA7B,EAA0C,IAA1C,EAAgD,KAAhD,CAA3B;;AACA,eAAKrJ,UAAL,CAAgBC,IAAhB,CAAqB,KAAKmJ,mBAA1B;;AAEA,eAAKpJ,UAAL,CAAgBC,IAAhB,CAAqB+F,SAAS,CAAC9E,MAAV,CAAiBC,EAAjB,CAAoB,cAApB,EAAoC,KAAKwH,WAAzC,EAAsD,IAAtD,EAA4D,KAA5D,CAArB;AACA,SAdD,MAeK;AACJ,cAAI,KAAKS,mBAAT,EAA8B;AAC7B,iBAAKA,mBAAL,CAAyBE,OAAzB;;AACA,gBAAI,KAAKtD,SAAT,EAAoB;AACnB,mBAAKA,SAAL,CAAesD,OAAf;AACA,mBAAKtD,SAAL,GAAiBxE,SAAjB;AACA;AACD;AACD;AACD;AACD,KA3BoB;oBAAA;;AAAA,GAArB;AA6BA;;;;;;AAKUkE,iCAAV,UAAsB/B,KAAtB,EAAoE;AACnE,QAAI4F,KAAK,GAAG5F,KAAK,CAAC4F,KAAN,CAAYC,CAAxB;AACA,QAAIxD,SAAS,GAAG,KAAKA,SAArB;;AACA,QAAIA,SAAJ,EAAe;AACd,UAAIyD,EAAE,GAAIF,KAAK,GAAG,IAAR,GAAe,KAAKlB,cAApB,GAAqC,KAAKG,aAApD;AACA,UAAIkB,KAAK,GAAG1D,SAAS,CAACE,GAAV,GAAgBF,SAAS,CAACC,KAAtC;;AACA,UAAIsD,KAAK,GAAG,CAAZ,EAAe;AACdvD,iBAAS,CAACC,KAAV,GAAkBrH,KAAK,CAAC+K,GAAN,CAAU,CAAV,EAAa3D,SAAS,CAACC,KAAV,GAAkBwD,EAA/B,CAAlB;AACAzD,iBAAS,CAACE,GAAV,GAAgBF,SAAS,CAACC,KAAV,GAAkByD,KAAlC;AACA,OAHD,MAIK;AACJ1D,iBAAS,CAACE,GAAV,GAAgBtH,KAAK,CAACsJ,GAAN,CAAU,CAAV,EAAalC,SAAS,CAACE,GAAV,GAAgBuD,EAA7B,CAAhB;AACAzD,iBAAS,CAACC,KAAV,GAAkBD,SAAS,CAACE,GAAV,GAAgBwD,KAAlC;AACA;AACD;AACD,GAfS;AAiBV;;;;;AAGUhE,iCAAV;AAAA;;AACC,QAAI,KAAKM,SAAT,EAAoB;AACnB,WAAKhF,cAAL,CAAoBwG,IAApB,CAAyB,UAACrH,aAAD,EAAc;AACtCA,qBAAa,CAACyJ,EAAd,GAAmB,CAACvK,KAAI,CAAC2G,SAAL,CAAeyC,KAAf,CAAqBoB,MAAtB,GAA+BxK,KAAI,CAACmJ,aAApC,GAAoDnJ,KAAI,CAACgJ,cAA5E;AACAlI,qBAAa,CAAC2J,aAAd,GAA8B;AAAExB,WAAC,EAAE,CAAL;AAAQkB,WAAC,EAAE,CAACrJ,aAAa,CAACyJ,EAA1B;AAA8B5F,eAAK,EAAE3E,KAAI,CAACoI,aAA1C;AAAyDxD,gBAAM,EAAE5E,KAAI,CAACgJ;AAAtE,SAA9B;AACA,OAHD;AAIA;AACD,GAPS;AAgBV;;;;;;;;;AAOO3C,oCAAP,UAAsBqE,IAAtB,EAA6C;AAC5C,QAAIpI,WAAW,GAAGoI,IAAI,CAACpI,WAAvB;;AAEA,QAAI,CAACA,WAAW,CAACQ,OAAb,IAAwBR,WAAW,CAACqI,QAApC,IAAiDrI,WAAW,YAAY9C,MAAvB,IAAiC8C,WAAW,CAACsI,QAAlG,EAA6G;AAC5GF,UAAI,CAACxJ,KAAL,GAAawJ,IAAI,CAACG,SAAlB;AAEAvI,iBAAW,CAACwI,QAAZ,GAAuB,IAAvB;AACAJ,UAAI,CAAC5J,aAAL,CAAmBkC,QAAnB,GAA8B,KAA9B;;AAEA,UAAIV,WAAW,CAACyI,MAAZ,KAAuB,IAA3B,EAAiC;AAChCzI,mBAAW,CAACyI,MAAZ,GAAqB,KAArB;AACA;;AAED,UAAIzI,WAAW,CAAC0I,IAAhB,EAAsB;AACrB1I,mBAAW,CAAC0I,IAAZ;AACA,OAFD,MAGK;AACJ1I,mBAAW,CAACQ,OAAZ,GAAsB,IAAtB;AACA;;AAED,WAAKmI,YAAL,CAAkBC,WAAlB,CAA8B,KAAKzE,QAAL,CAAcC,SAAd,CAAwB,UAAxB,EAAoC,KAAKD,QAAL,CAAc0E,MAAlD,EAA0DT,IAAI,CAAC9E,KAAL,CAAWY,WAArE,CAA9B;AAEA,KAnBD,MAoBK;AACJkE,UAAI,CAAC5J,aAAL,CAAmBkC,QAAnB,GAA8B,IAA9B;AACAV,iBAAW,CAACwI,QAAZ,GAAuB,IAAvB;;AAEA,UAAIxI,WAAW,CAAC8I,IAAhB,EAAsB;AACrB9I,mBAAW,CAAC8I,IAAZ;AACA,OAFD,MAGK;AACJ9I,mBAAW,CAACQ,OAAZ,GAAsB,KAAtB;AACA;;AAED,WAAKmI,YAAL,CAAkBC,WAAlB,CAA8B,KAAKzE,QAAL,CAAcC,SAAd,CAAwB,WAAxB,EAAqC,KAAKD,QAAL,CAAc0E,MAAnD,EAA2DT,IAAI,CAAC9E,KAAL,CAAWY,WAAtE,CAA9B;AACAkE,UAAI,CAACxJ,KAAL,GAAa,IAAI9B,iBAAJ,GAAwBgG,MAAxB,CAA+B,oBAA/B,CAAb;AACA;AAED,GAtCM;;AA+CPjF,wBAAWkG,gBAAX,EAAW,WAAX,EAAoB;AAPpB;;;;;;;SAOA;AACC;AACA,KAFmB;oBAAA;;AAAA,GAApB;AAIA;;;;;;AAKOA,kDAAP,UAAoCnE,QAApC,EAAkEmJ,IAAlE,EAA+E;AAC9EnJ,YAAQ,CAAC8D,UAAT,CAAoByD,UAApB;AACAvH,YAAQ,CAAC0D,KAAT,CAAe6D,UAAf;AACA,GAHM;;AAKR;AA9mBA,EAA4BjL,SAA5B;;;AAgnBA;;;;;;;AAMAQ,QAAQ,CAACsM,iBAAT,CAA2B,QAA3B,IAAuCjF,MAAvC;AAGA;;;;AAIA;;;;AAGA1G,YAAY,CAACiB,IAAb,CAAkB;AACjB2K,UAAQ,EAAE3L,qBAAqB,CAAC4L,OADf;AAEjBC,OAAK,EAAE,UAASxJ,MAAT,EAAiByJ,OAAjB,EAAwB;AAC9B,QAAIzJ,MAAM,YAAYoE,MAAlB,KAA6BpE,MAAM,CAACkE,QAAP,IAAmB,MAAnB,IAA6BlE,MAAM,CAACkE,QAAP,IAAmB,OAA7E,CAAJ,EAA2F;AAC1F,UAAIsF,KAAK,GAAGxJ,MAAM,CAACuD,MAAP,CAAc/E,MAAd,CAAqBiL,OAArB,CAAZ;AACAD,WAAK,CAACxK,UAAN,CAAiBkF,QAAjB,GAA4B,QAA5B;AACA,aAAOsF,KAAP;AACA;;AAED,WAAO,IAAP;AACA;AAVgB,CAAlB;AAaA;;;;AAGA9L,YAAY,CAACiB,IAAb,CAAkB;AACjB2K,UAAQ,EAAE3L,qBAAqB,CAAC+L,QADf;AAEjBF,OAAK,EAAE,UAASxJ,MAAT,EAAiByJ,OAAjB,EAAwB;AAC9B,QAAIzJ,MAAM,YAAYoE,MAAlB,KAA6BpE,MAAM,CAACkE,QAAP,IAAmB,KAAnB,IAA4BlE,MAAM,CAACkE,QAAP,IAAmB,QAA5E,CAAJ,EAA2F;AAC1F,UAAIsF,KAAK,GAAGxJ,MAAM,CAACuD,MAAP,CAAc/E,MAAd,CAAqBiL,OAArB,CAAZ;AACAD,WAAK,CAACxK,UAAN,CAAiBkF,QAAjB,GAA4B,OAA5B;AACA,aAAOsF,KAAP;AACA;;AAED,WAAO,IAAP;AACA;AAVgB,CAAlB;AAaA;;;;AAGA9L,YAAY,CAACiB,IAAb,CAAkB;AACjB2K,UAAQ,EAAE3L,qBAAqB,CAACgM,IADf;AAEjBH,OAAK,EAAE,UAASxJ,MAAT,EAAiByJ,OAAjB,EAAwB;AAC9B,QAAIzJ,MAAM,YAAYoE,MAAtB,EAA8B;AAC7B,UAAIoF,KAAK,GAAGxJ,MAAM,CAACuD,MAAP,CAAc/E,MAAd,CAAqBiL,OAArB,CAAZ;AACAD,WAAK,CAACxK,UAAN,CAAiB4K,QAAjB,GAA4B,IAA5B;AACA,aAAOJ,KAAP;AACA;;AAED,WAAO,IAAP;AACA;AAVgB,CAAlB","names":["Component","DataItem","ListTemplate","ListDisposer","RoundedRectangle","Container","Label","keyboard","registry","getInteraction","percent","Percent","InterfaceColorSet","$utils","$type","$math","Sprite","Disposer","MouseCursorStyle","defaultRules","ResponsiveBreakpoints","Scrollbar","__extends","_super","_this","className","applyTheme","Object","LegendDataItem","_label","label_1","component","labels","create","addSprite","_disposers","push","parent","itemContainer","hasValue","removeValue","properties","color","value","setProperty","_valueLabel","valueLabel_1","valueLabels","_itemContainer","component_1","itemContainer_1","itemContainers","togglable","events","on","ev","toggleDataItem","target","dataItem","undefined","focusable","focusedItem","dataContext","uidAttr","readerControls","readerLabelledBy","sprite","isDisposed","visibilitychanged","readerChecked","visible","disableType","isActive","enableType","addDisposer","dataItems","remove","_marker","marker_1","markers","layout","setPropertyValue","applyOnClones","padding","margin","clickable","role","cursorOverStyle","pointer","background","fillOpacity","template","body","isKey","event","isEnabled","dispatchImmediately","interfaceColors","marker","width","height","interactionsEnabled","setStateOnChildren","strokeOpacity","propertyFields","fill","valign","disabledColor","getFor","child","newValue","activeState","states","stroke","rectangle","createChild","label","text","truncate","fullWords","valueLabel","align","textAlign","position","handleScrollbar","Legend","applyInternalDefaults","call","readerTitle","language","translate","scrollbar","start","end","validateDataElements","validateDataElement","container","used","legendDataItem","tempMaxWidth","maxWidth","legendSettings","createLegendMarker","useDefaultMarker","childrenCreated","updateLegendValue","invalid","validate","__disabled","itemValueText","valueText","toBoolean","setState","getPropertyValue","maxLabelWidth","each","measuredWidth","pixelMarginLeft","pixelMarginRight","maxValueLabelWidth","maxMarkerWidth","maxAdjustedLabelWidth","trueMaxWidth","isNumber","Math","min","afterDraw","scrollable","measuredHeight","x","pixelWidth","contentHeight","thumb","paddingRight","updateMasks","contentAlign","maxColumns","invalidate","isMeasured","orientation","endGrip","startGrip","marginLeft","_mouseWheelDisposer","handleWheel","dispose","shift","y","ds","delta","max","dy","pixelY","maskRectangle","item","isHiding","isHidden","colorOrig","appeared","hidden","show","svgContainer","readerAlert","locale","hide","name","registeredClasses","relevant","widthXS","state","stateId","heightXS","isXS","disabled"],"sourceRoot":"","sources":["../../../../src/.internal/charts/Legend.ts"],"sourcesContent":["/**\r\n * Legend-related functionality.\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { Component, IComponentProperties, IComponentDataFields, IComponentAdapters, IComponentEvents } from \"../core/Component\";\r\nimport { DataItem, IDataItemEvents } from \"../core/DataItem\";\r\nimport { ListTemplate, ListDisposer } from \"../core/utils/List\";\r\nimport { RoundedRectangle } from \"../core/elements/RoundedRectangle\";\r\nimport { Container } from \"../core/Container\";\r\nimport { Label } from \"../core/elements/Label\";\r\nimport { Optional } from \"../core/utils/Type\";\r\nimport { Preloader } from \"../core/elements/Preloader\";\r\nimport { keyboard } from \"../core/utils/Keyboard\";\r\nimport { registry } from \"../core/Registry\";\r\nimport { getInteraction } from \"../core/interaction/Interaction\";\r\nimport { percent, Percent } from \"../core/utils/Percent\";\r\nimport { InterfaceColorSet } from \"../core/utils/InterfaceColorSet\";\r\nimport { Color } from \"../core/utils/Color\";\r\nimport { RadialGradient } from \"../core/rendering/fills/RadialGradient\";\r\nimport { LinearGradient } from \"../core/rendering/fills/LinearGradient\";\r\nimport { Pattern } from \"../core/rendering/fills/Pattern\";\r\nimport * as $utils from \"../core/utils/Utils\";\r\nimport * as $type from \"../core/utils/Type\";\r\nimport * as $math from \"../core/utils/Math\";\r\nimport { Sprite, ISpriteEvents, AMEvent } from \"../core/Sprite\";\r\nimport { Disposer, IDisposer } from \"../core/utils/Disposer\";\r\nimport { MouseCursorStyle } from \"../core/interaction/Mouse\";\r\nimport { defaultRules, ResponsiveBreakpoints } from \"../core/utils/Responsive\";\r\nimport { Scrollbar } from \"../core/elements/Scrollbar\";\r\n\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * DATA ITEM\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Defines a [[DataItem]] for [[Legend]].\r\n *\r\n * @see {@link DataItem}\r\n */\r\nexport class LegendDataItem extends DataItem {\r\n\r\n\t/**\r\n\t * A container data item's elements will be placed in.\r\n\t */\r\n\tprotected _itemContainer: Container;\r\n\r\n\t/**\r\n\t * A [[Label]] element for the item label.\r\n\t */\r\n\tprotected _label: Label;\r\n\r\n\t/**\r\n\t * A [[Container]] for legend item marker.\r\n\t */\r\n\tprotected _marker: Container;\r\n\r\n\t/**\r\n\t * A [[Label]] element for the value label.\r\n\t */\r\n\tprotected _valueLabel: Label;\r\n\r\n\t/**\r\n\t * A data context for legend item.\r\n\t */\r\n\tpublic dataContext: any;\r\n\r\n\t/**\r\n\t * Defines a type of [[Component]] this data item is used for.\r\n\t */\r\n\tpublic _component!: Legend;\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tpublic childrenCreated: boolean = false;\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tpublic colorOrig: $type.Optional<Color | Pattern | LinearGradient | RadialGradient>;\r\n\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor() {\r\n\t\tsuper();\r\n\t\tthis.className = \"LegendDataItem\";\r\n\t\tthis.applyTheme();\r\n\t}\r\n\r\n\t/**\r\n\t * A legend item's [[Label]] element.\r\n\t *\r\n\t * @return Label\r\n\t */\r\n\tpublic get label(): Label {\r\n\t\tif (!this._label) {\r\n\t\t\tlet label = this.component.labels.create();\r\n\t\t\tthis._label = label;\r\n\t\t\tthis.addSprite(label);\r\n\t\t\tthis._disposers.push(label);\r\n\t\t\tlabel.parent = this.itemContainer;\r\n\r\n\t\t\tthis._disposers.push(new Disposer(() => {\r\n\t\t\t\tif ($type.hasValue(this.component)) {\r\n\t\t\t\t\tthis.component.labels.removeValue(label);\r\n\t\t\t\t}\r\n\t\t\t}));\r\n\t\t}\r\n\t\treturn this._label;\r\n\t}\r\n\r\n\t/**\r\n\t * Main color of legend data item.\r\n\t *\r\n\t * This is set by the target element this legend item represents, like\r\n\t * a Series or a Slice.\r\n\t *\r\n\t * It can be used to derive a color in legend's sub-items, like label:\r\n\t *\r\n\t * ```TypeScript\r\n\t * chart.legend.labels.template.text = \"[{color}]{name}[/]\";\r\n\t * ```\r\n\t * ```JavaScript\r\n\t * chart.legend.labels.template.text = \"[{color}]{name}[/]\";\r\n\t * ```\r\n\t * ```JSON\r\n\t * {\r\n\t *   // ...\r\n\t *   \"legend\": {\r\n\t *     // ...\r\n\t *     \"labels\": {\r\n\t *       \"text\": \"[{color}]{name}[/]\"\r\n\t *     }\r\n\t *   }\r\n\t * }\r\n\t * ```\r\n\t *\r\n\t * @see {@link https://www.amcharts.com/docs/v4/concepts/legend/#Legend_labels} For more information about configuring legend labels.\r\n\t * @param value  Main color\r\n\t */\r\n\tpublic set color(value: $type.Optional<Color | Pattern | LinearGradient | RadialGradient>) {\r\n\t\tthis.setProperty(\"color\", value);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Main color\r\n\t */\r\n\tpublic get color(): $type.Optional<Color | Pattern | LinearGradient | RadialGradient> {\r\n\t\treturn this.properties.color;\r\n\t}\r\n\r\n\t/**\r\n\t * A legend item's [[Label]] element for \"value label\".\r\n\t *\r\n\t * @return Label\r\n\t */\r\n\tpublic get valueLabel(): Label {\r\n\t\tif (!this._valueLabel) {\r\n\t\t\tlet valueLabel = this.component.valueLabels.create();\r\n\t\t\tthis._valueLabel = valueLabel;\r\n\r\n\t\t\tthis.addSprite(valueLabel);\r\n\t\t\tthis._disposers.push(valueLabel);\r\n\t\t\tvalueLabel.parent = this.itemContainer;\r\n\r\n\t\t\tthis._disposers.push(new Disposer(() => {\r\n\t\t\t\tif ($type.hasValue(this.component)) {\r\n\t\t\t\t\tthis.component.valueLabels.removeValue(valueLabel);\r\n\t\t\t\t}\r\n\t\t\t}));\r\n\t\t}\r\n\t\treturn this._valueLabel;\r\n\t}\r\n\r\n\t/**\r\n\t * A reference to the main [[Container]] that holds legend item's elements:\r\n\t * marker and labels.\r\n\t *\r\n\t * @return Item container\r\n\t */\r\n\tpublic get itemContainer(): Container {\r\n\t\tif (!this._itemContainer) {\r\n\r\n\t\t\tlet component = this.component;\r\n\r\n\t\t\tlet itemContainer = component.itemContainers.create();\r\n\t\t\titemContainer.parent = component;\r\n\t\t\t\r\n\t\t\tthis._itemContainer = itemContainer;\r\n\t\t\tthis.addSprite(itemContainer);\r\n\t\t\tthis._disposers.push(itemContainer);\r\n\r\n\t\t\t// Add click/tap event to toggle item\r\n\t\t\tif (itemContainer.togglable) {\r\n\t\t\t\titemContainer.events.on(\"toggled\", (ev) => {\r\n\t\t\t\t\tcomponent.toggleDataItem(<this>ev.target.dataItem);\r\n\t\t\t\t}, undefined, false);\r\n\t\t\t}\r\n\r\n\t\t\t// Add focus event so that we can track which object is currently in focus\r\n\t\t\t// for keyboard toggling\r\n\t\t\tif (itemContainer.focusable) {\r\n\t\t\t\titemContainer.events.on(\"hit\", (ev) => {\r\n\t\t\t\t\t// We need this here in order to reset focused item when it is clicked\r\n\t\t\t\t\t// normally so that it is not toggled by ENTER afterwards\r\n\t\t\t\t\tcomponent.focusedItem = undefined;\r\n\t\t\t\t}, undefined, false);\r\n\t\t\t\titemContainer.events.on(\"focus\", (ev) => {\r\n\t\t\t\t\tcomponent.focusedItem = <this>ev.target.dataItem;\r\n\t\t\t\t}, undefined, false);\r\n\t\t\t\titemContainer.events.on(\"blur\", (ev) => {\r\n\t\t\t\t\tcomponent.focusedItem = undefined;\r\n\t\t\t\t}, undefined, false);\r\n\t\t\t}\r\n\r\n\t\t\tthis._disposers.push(new Disposer(() => {\r\n\t\t\t\tif ($type.hasValue(this.component)) {\r\n\t\t\t\t\tthis.component.itemContainers.removeValue(itemContainer);\r\n\t\t\t\t}\r\n\t\t\t}));\r\n\r\n\t\t\tif (this.dataContext.uidAttr) {\r\n\t\t\t\titemContainer.readerControls = this.dataContext.uidAttr();\r\n\t\t\t\titemContainer.readerLabelledBy = this.dataContext.uidAttr();\r\n\t\t\t}\r\n\r\n\t\t\tlet sprite = <any>this.dataContext;\r\n\t\t\tif ((sprite instanceof DataItem || sprite instanceof Sprite) && !sprite.isDisposed()) {\r\n\t\t\t\tconst visibilitychanged = function(ev: AMEvent<Sprite | DataItem, ISpriteEvents & IDataItemEvents>[\"visibilitychanged\"]) {\r\n\t\t\t\t\titemContainer.readerChecked = ev.visible;\r\n\t\t\t\t\titemContainer.events.disableType(\"toggled\");\r\n\t\t\t\t\titemContainer.isActive = !ev.visible;\r\n\t\t\t\t\titemContainer.events.enableType(\"toggled\");\r\n\t\t\t\t};\r\n\r\n\t\t\t\tsprite.addDisposer(new Disposer(() => {\r\n\t\t\t\t\tif (this.component) {\r\n\t\t\t\t\t\tthis.component.dataItems.remove(this);\r\n\t\t\t\t\t}\r\n\t\t\t\t}))\r\n\r\n\t\t\t\tif (sprite instanceof Sprite) {\r\n\t\t\t\t\titemContainer.addDisposer(\r\n\t\t\t\t\t\tsprite.events.on(\"visibilitychanged\", visibilitychanged, undefined, false)\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t\titemContainer.addDisposer(\r\n\t\t\t\t\t\tsprite.events.on(\"hidden\", (ev) => {\r\n\t\t\t\t\t\t\titemContainer.readerChecked = false;\r\n\t\t\t\t\t\t\titemContainer.events.disableType(\"toggled\");\r\n\t\t\t\t\t\t\titemContainer.isActive = true;\r\n\t\t\t\t\t\t\titemContainer.events.enableType(\"toggled\");\r\n\t\t\t\t\t\t}, undefined, false)\r\n\t\t\t\t\t)\r\n\t\t\t\t\titemContainer.addDisposer(\r\n\t\t\t\t\t\tsprite.events.on(\"shown\", (ev) => {\r\n\t\t\t\t\t\t\titemContainer.readerChecked = true;\r\n\t\t\t\t\t\t\titemContainer.events.disableType(\"toggled\");\r\n\t\t\t\t\t\t\titemContainer.isActive = false;\r\n\t\t\t\t\t\t\titemContainer.events.enableType(\"toggled\");\r\n\t\t\t\t\t\t}, undefined, false)\r\n\t\t\t\t\t)\r\n\r\n\t\t\t\t} else {\r\n\t\t\t\t\titemContainer.addDisposer(\r\n\t\t\t\t\t\tsprite.events.on(\"visibilitychanged\", visibilitychanged, undefined, false)\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn this._itemContainer;\r\n\t}\r\n\r\n\t/**\r\n\t * A [[Container]] that holds legend item's marker element.\r\n\t *\r\n\t * @return Marker\r\n\t */\r\n\tpublic get marker(): Container {\r\n\t\tif (!this._marker) {\r\n\t\t\tlet marker = this.component.markers.create();\r\n\t\t\tthis._marker = marker;\r\n\t\t\tmarker.parent = this.itemContainer;\r\n\t\t\tthis.addSprite(marker);\r\n\t\t\tthis._disposers.push(marker);\r\n\r\n\t\t\tthis._disposers.push(new Disposer(() => {\r\n\t\t\t\tif ($type.hasValue(this.component)) {\r\n\t\t\t\t\tthis.component.markers.removeValue(marker);\r\n\t\t\t\t}\r\n\t\t\t}));\r\n\t\t}\r\n\t\treturn this._marker;\r\n\t}\r\n}\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * REQUISITES\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Defines a class that carries legend settings.\r\n *\r\n * A legend might change its settings dynamically. Legend can also be shared\r\n * by several elements, requiring different settings.\r\n *\r\n * Having legend's settings in a separate object is a good way to \"hot swap\"\r\n * a set of settings for the legend.\r\n */\r\nexport class LegendSettings {\r\n\r\n\t/**\r\n\t * [valueText description]\r\n\t *\r\n\t * @todo Description\r\n\t */\r\n\tpublic valueText: string;\r\n\r\n\t/**\r\n\t * [labelText description]\r\n\t *\r\n\t * @todo Description\r\n\t */\r\n\tpublic labelText: string;\r\n\r\n\t/**\r\n\t * A text template for the value part of the legend item.\r\n\t */\r\n\tpublic itemValueText: string;\r\n\r\n\t/**\r\n\t * A text template for the label part of the legend item.\r\n\t */\r\n\tpublic itemLabelText: string;\r\n\r\n\t/**\r\n\t * Should marker be created for each legend item.\r\n\t */\r\n\tpublic createMarker: boolean = true;\r\n}\r\n\r\n/**\r\n * Represents types available for Legend position. Not all charts will pay attention to this, like MapChart. You'll need to use legend.align and legend.valign properties to position legend on MapChart.\r\n */\r\nexport type LegendPosition = \"left\" | \"right\" | \"top\" | \"bottom\" | \"absolute\";\r\n\r\n/**\r\n * Defines data fields for [[Legend]].\r\n */\r\nexport interface ILegendDataFields extends IComponentDataFields {\r\n\r\n\t/**\r\n\t * A field name in the data item which holds name of the legend item.\r\n\t */\r\n\tname?: string;\r\n\r\n\t/**\r\n\t * A field name in data item which holds boolean value whether item should\r\n\t * be displayed in legend or not.\r\n\t */\r\n\tvisible?: string;\r\n}\r\n\r\n/**\r\n * Defines properties for [[Legend]].\r\n */\r\nexport interface ILegendProperties extends IComponentProperties {\r\n\r\n\t/**\r\n\t * Should legend use default marker?\r\n\t *\r\n\t * If set to `false`, the legend will try to mirror the look of the actual\r\n\t * item, like series.\r\n\t *\r\n\t * @default true\r\n\t */\r\n\tuseDefaultMarker?: boolean;\r\n\r\n\t/**\r\n\t * Position of the legend.\r\n\t *\r\n\t * Options: \"left\", \"right\", \"top\", \"bottom\" (default), or \"absolute\".\r\n\t *\r\n\t * @default \"bottom\"\r\n\t */\r\n\tposition?: LegendPosition;\r\n\r\n\t/**\r\n\t * If set to `true` the Legend will display a scrollbar if its contents do\r\n\t * not fit into its `maxHeight`.\r\n\t *\r\n\t * @default false\r\n\t * @since 4.8.0\r\n\t */\r\n\tscrollable?: boolean;\r\n\r\n}\r\n\r\n/**\r\n * Defines events for [[Legend]].\r\n */\r\nexport interface ILegendEvents extends IComponentEvents { }\r\n\r\n/**\r\n * Defines adapters for [[Legend]].\r\n *\r\n * @see {@link Adapter}\r\n */\r\nexport interface ILegendAdapters extends IComponentAdapters, ILegendProperties { }\r\n\r\nexport interface ILegendItemEvents {\r\n\tpropertychanged: {\r\n\t\t/**\r\n\t\t * Property key.\r\n\t\t */\r\n\t\tproperty: string;\r\n\t};\r\n}\r\n\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * [[Legend]] class is used to create legend for the chart.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v4/concepts/legend/} for Legend documentation\r\n * @see {@link ILegendEvents} for a list of available events\r\n * @see {@link ILegendAdapters} for a list of available Adapters\r\n */\r\nexport class Legend extends Component {\r\n\r\n\t/**\r\n\t * Defines the type of the data fields.\r\n\t */\r\n\tpublic _dataFields: ILegendDataFields;\r\n\r\n\t/**\r\n\t * Defines available properties.\r\n\t */\r\n\tpublic _properties!: ILegendProperties;\r\n\r\n\t/**\r\n\t * Defines available adapters.\r\n\t */\r\n\tpublic _adapter!: ILegendAdapters;\r\n\r\n\t/**\r\n\t * Defines available events.\r\n\t */\r\n\tpublic _events!: ILegendEvents;\r\n\r\n\t/**\r\n\t * Defines data item type.\r\n\t */\r\n\tpublic _dataItem: LegendDataItem;\r\n\r\n\t/**\r\n\t * List of legend Item containers. Legend item containers contain marker, title label and value label.\r\n\t */\r\n\tpublic itemContainers: ListTemplate<Container>;\r\n\r\n\t/**\r\n\t * List of legend item labels.\r\n\t */\r\n\tpublic labels: ListTemplate<Label>;\r\n\r\n\t/**\r\n\t * List of legend item markers.\r\n\t */\r\n\tpublic markers: ListTemplate<Container>;\r\n\r\n\t/**\r\n\t * List of legend item value labels.\r\n\t */\r\n\tpublic valueLabels: ListTemplate<Label>;\r\n\r\n\t/**\r\n\t * Currently focused legend item (for toggling via keyboard)\r\n\t */\r\n\tpublic focusedItem: Optional<this[\"_dataItem\"]>;\r\n\r\n\r\n\tpublic scrollbar: Scrollbar;\r\n\r\n\tprotected _mouseWheelDisposer: IDisposer;\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor() {\r\n\t\tsuper();\r\n\t\tthis.className = \"Legend\";\r\n\r\n\t\t// Set defaults\r\n\t\tthis.layout = \"grid\";\r\n\t\tthis.setPropertyValue(\"useDefaultMarker\", false);\r\n\t\tthis.setPropertyValue(\"scrollable\", false);\r\n\t\tthis.setPropertyValue(\"contentAlign\", \"center\");\r\n\r\n\t\t// Create a template container and list for legend items\r\n\t\tlet itemContainer: Container = new Container();\r\n\t\titemContainer.applyOnClones = true;\r\n\t\titemContainer.padding(8, 0, 8, 0);\r\n\t\titemContainer.margin(0, 10, 0, 10);\r\n\t\titemContainer.layout = \"horizontal\";\r\n\t\titemContainer.clickable = true;\r\n\t\titemContainer.focusable = true;\r\n\t\titemContainer.role = \"switch\";\r\n\t\titemContainer.togglable = true;\r\n\t\titemContainer.cursorOverStyle = MouseCursorStyle.pointer;\r\n\t\titemContainer.background.fillOpacity = 0; // creates hit area\r\n\r\n\t\t// Create container list using item template we just created\r\n\t\tthis.itemContainers = new ListTemplate<Container>(itemContainer);\r\n\t\tthis._disposers.push(new ListDisposer(this.itemContainers));\r\n\t\tthis._disposers.push(this.itemContainers.template);\r\n\r\n\t\t// Set up global keyboard events for toggling elements\r\n\t\tthis._disposers.push(getInteraction().body.events.on(\"keyup\", (ev) => {\r\n\t\t\tif (keyboard.isKey(ev.event, \"enter\") && this.focusedItem) {\r\n\t\t\t\tconst focusedItem = this.focusedItem;\r\n\t\t\t\tconst target = focusedItem.itemContainer;\r\n\t\t\t\tif (target.togglable) {\r\n\t\t\t\t\tthis.toggleDataItem(focusedItem);\r\n\t\t\t\t}\r\n\t\t\t\telse if (target.clickable && target.events.isEnabled(\"hit\")) {\r\n\t\t\t\t\ttarget.dispatchImmediately(\"hit\", { event: ev });\r\n\r\n\t\t\t\t\t// We need this here because \"hit\" event resets `this.focusedItem`\r\n\t\t\t\t\t// And we need it here\r\n\t\t\t\t\tthis.focusedItem = focusedItem;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}, this));\r\n\r\n\t\tlet interfaceColors = new InterfaceColorSet();\r\n\r\n\t\t// Create a template container and list for the a marker\r\n\t\tlet marker: Container = new Container();\r\n\t\tmarker.width = 23;\r\n\t\tmarker.height = 23;\r\n\t\tmarker.interactionsEnabled = false;\r\n\t\tmarker.applyOnClones = true;\r\n\t\tmarker.setStateOnChildren = true;\r\n\t\tmarker.background.fillOpacity = 0;\r\n\t\tmarker.background.strokeOpacity = 0;\r\n\t\tmarker.propertyFields.fill = \"fill\";\r\n\t\tmarker.valign = \"middle\";\r\n\r\n\t\tlet disabledColor = interfaceColors.getFor(\"disabledBackground\");\r\n\r\n\t\tmarker.events.on(\"childadded\", (event) => {\r\n\t\t\tlet child = event.newValue;\r\n\t\t\tlet activeState = child.states.create(\"active\");\r\n\t\t\tactiveState.properties.stroke = disabledColor;\r\n\t\t\tactiveState.properties.fill = disabledColor;\r\n\t\t});\r\n\r\n\t\tthis.markers = new ListTemplate<Container>(marker);\r\n\t\tthis._disposers.push(new ListDisposer(this.markers));\r\n\t\tthis._disposers.push(this.markers.template);\r\n\r\n\t\t// Create a legend background element\r\n\t\tlet rectangle: RoundedRectangle = marker.createChild(RoundedRectangle);\r\n\t\trectangle.width = percent(100);\r\n\t\trectangle.height = percent(100);\r\n\t\trectangle.applyOnClones = true;\r\n\t\trectangle.propertyFields.fill = \"fill\"; //othrwise old edge doesn't like as the same pattern is set both on parent and child https://codepen.io/team/amcharts/pen/72d7a98f3fb811d3118795220ff63182\r\n\t\trectangle.strokeOpacity = 0;\r\n\r\n\t\t// Create a template container and list for item labels\r\n\t\tlet label: Label = new Label();\r\n\t\tlabel.text = \"{name}\";\r\n\t\tlabel.margin(0, 5, 0, 5);\r\n\t\tlabel.valign = \"middle\";\r\n\t\tlabel.applyOnClones = true;\r\n\t\tlabel.states.create(\"active\").properties.fill = interfaceColors.getFor(\"disabledBackground\");\r\n\t\tthis.labels = new ListTemplate<Label>(label);\r\n\t\tthis._disposers.push(new ListDisposer(this.labels));\r\n\t\tthis._disposers.push(this.labels.template);\r\n\t\tlabel.interactionsEnabled = false;\r\n\t\tlabel.truncate = true;\r\n\t\tlabel.fullWords = false;\r\n\r\n\t\t// Create a template container and list for item value labels\r\n\t\tlet valueLabel: Label = new Label();\r\n\t\tvalueLabel.margin(0, 5, 0, 0);\r\n\t\tvalueLabel.valign = \"middle\";\r\n\t\tvalueLabel.width = 50; // to avoid rearranging legend entries when value changes.\r\n\t\tvalueLabel.align = \"right\";\r\n\t\tvalueLabel.textAlign = \"end\";\r\n\t\tvalueLabel.applyOnClones = true;\r\n\t\tvalueLabel.states.create(\"active\").properties.fill = interfaceColors.getFor(\"disabledBackground\");\r\n\t\tvalueLabel.interactionsEnabled = false;\r\n\r\n\t\tthis.valueLabels = new ListTemplate<Label>(valueLabel);\r\n\t\tthis._disposers.push(new ListDisposer(this.valueLabels));\r\n\t\tthis._disposers.push(this.valueLabels.template);\r\n\r\n\t\tthis.position = \"bottom\"; // don't use setPropertyValue here!\r\n\r\n\t\t// Create a state for disabled legend items\r\n\t\titemContainer.states.create(\"active\");\r\n\t\titemContainer.setStateOnChildren = true;\r\n\r\n\t\t// Apply accessibility settings\r\n\t\tthis.role = \"group\";\r\n\r\n\t\tthis.events.on(\"layoutvalidated\", this.handleScrollbar, this, false);\r\n\r\n\t\tthis.applyTheme();\r\n\t}\r\n\r\n\t/**\r\n\t * Sets defaults that instantiate some objects that rely on parent, so they\r\n\t * cannot be set in constructor.\r\n\t */\r\n\tprotected applyInternalDefaults(): void {\r\n\t\tsuper.applyInternalDefaults();\r\n\t\tif (!$type.hasValue(this.readerTitle)) {\r\n\t\t\tthis.readerTitle = this.language.translate(\"Legend\");\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a new/empty DataItem of the type appropriate for this object.\r\n\t *\r\n\t * @see {@link DataItem}\r\n\t * @return Data Item\r\n\t */\r\n\tprotected createDataItem(): this[\"_dataItem\"] {\r\n\t\treturn new LegendDataItem();\r\n\t}\r\n\r\n\t/**\r\n\t * [validateDataElements description]\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description\r\n\t */\r\n\tprotected validateDataElements() {\r\n\t\tif (this.scrollbar) {\r\n\t\t\tthis.scrollbar.start = 0;\r\n\t\t\tthis.scrollbar.end = 1;\r\n\t\t}\r\n\t\tsuper.validateDataElements();\r\n\t}\r\n\r\n\t/**\r\n\t * [validateDataElement description]\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param dataItem Data item\r\n\t * @todo Description\r\n\t * @todo Figure out how to update appearance of legend item without losing focus\r\n\t * @todo Update legend marker appearance as apperance of related series changes\r\n\t */\r\n\tpublic validateDataElement(dataItem: this[\"_dataItem\"]): void {\r\n\t\tsuper.validateDataElement(dataItem);\r\n\t\t// Get data item (legend item's) container\r\n\t\tlet container = dataItem.itemContainer;\r\n\r\n\t\tlet marker = dataItem.marker;\r\n\r\n\t\t$utils.used(dataItem.label);\r\n\t\tlet valueLabel = dataItem.valueLabel;\r\n\r\n\t\t// Set parent and update current state\r\n\t\tcontainer.readerChecked = dataItem.dataContext.visible;\r\n\r\n\t\t// Tell series its legend data item\r\n\t\tdataItem.dataContext.legendDataItem = dataItem;\r\n\r\n\t\tlet tempMaxWidth = dataItem.label.maxWidth;\r\n\t\tif(!(dataItem.label.width instanceof Percent)){\r\n\t\t\tdataItem.label.width = undefined;\t\r\n\t\t}\r\n\t\t\r\n\t\tif (tempMaxWidth > 0) {\r\n\t\t\tdataItem.label.maxWidth = tempMaxWidth;\r\n\t\t}\r\n\t\tif (valueLabel.align == \"right\") {\r\n\t\t\tvalueLabel.width = undefined;\r\n\t\t}\r\n\r\n\t\tlet legendSettings = dataItem.dataContext.legendSettings;\r\n\r\n\t\t// If we are not using default markers, create a unique legend marker based\r\n\t\t// on the data item type\r\n\t\tlet dataContext = dataItem.dataContext;\r\n\r\n\t\tif (dataContext.createLegendMarker && (!this.useDefaultMarker || !(dataContext instanceof Sprite))) {\r\n\t\t\tif (!dataItem.childrenCreated) {\r\n\t\t\t\tdataContext.createLegendMarker(marker);\r\n\t\t\t\tdataItem.childrenCreated = true;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\tthis.markers.template.propertyFields.fill = undefined;\r\n\t\t}\r\n\r\n\t\tif (dataContext.updateLegendValue) {\r\n\t\t\tdataContext.updateLegendValue(); // this solves issue with external legend, as legend is created after chart updates legend values\r\n\t\t}\r\n\r\n\t\tif (dataContext.component && dataContext.component.updateLegendValue) {\r\n\t\t\tdataContext.component.updateLegendValue(dataContext);\r\n\t\t}\r\n\r\n\t\tif (valueLabel.invalid) {\r\n\t\t\tvalueLabel.validate();\r\n\t\t}\r\n\r\n\t\tif (valueLabel.text == \"\" || valueLabel.text == undefined) {\r\n\t\t\tvalueLabel.__disabled = true;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tvalueLabel.__disabled = false;\r\n\t\t}\r\n\r\n\t\tif (legendSettings && (legendSettings.itemValueText != undefined || legendSettings.valueText != undefined)) {\r\n\t\t\tvalueLabel.__disabled = false;\r\n\t\t}\r\n\r\n\t\tlet visible = dataItem.dataContext.visible;\r\n\r\n\t\tif (visible === undefined) {\r\n\t\t\tvisible = true;\r\n\t\t}\r\n\t\tvisible = $type.toBoolean(visible);\r\n\t\tdataItem.dataContext.visible = visible;\r\n\r\n\t\tcontainer.events.disableType(\"toggled\");\r\n\r\n\t\tcontainer.isActive = !visible;\r\n\t\tif (container.isActive) {\r\n\t\t\tcontainer.setState(\"active\", 0);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tcontainer.setState(\"default\", 0);\r\n\t\t}\r\n\t\tcontainer.events.enableType(\"toggled\");\r\n\t}\r\n\r\n\r\n\tpublic afterDraw() {\r\n\t\tlet maxWidth = this.getPropertyValue(\"maxWidth\");\r\n\t\tlet maxLabelWidth = 0;\r\n\t\tthis.labels.each((label) => {\r\n\t\t\tif (label.invalid) {\r\n\t\t\t\tlabel.maxWidth = undefined;\r\n\t\t\t\tlabel.validate();\r\n\t\t\t}\r\n\t\t\tif (label.measuredWidth + label.pixelMarginLeft + label.pixelMarginRight > maxLabelWidth) {\r\n\t\t\t\tmaxLabelWidth = label.measuredWidth + label.pixelMarginLeft + label.pixelMarginRight;\r\n\t\t\t}\r\n\r\n\t\t})\r\n\r\n\t\tlet maxValueLabelWidth = 0;\r\n\t\tthis.valueLabels.each((label) => {\r\n\t\t\tif (label.invalid) {\t\t\t\t\r\n\t\t\t\tlabel.validate();\r\n\t\t\t}\r\n\t\t\tif (label.measuredWidth + label.pixelMarginLeft + label.pixelMarginRight > maxValueLabelWidth) {\r\n\t\t\t\tmaxValueLabelWidth = label.measuredWidth + label.pixelMarginLeft + label.pixelMarginRight;\r\n\t\t\t}\r\n\t\t})\r\n\r\n\t\tlet maxMarkerWidth = 0;\r\n\t\tthis.markers.each((marker) => {\r\n\t\t\tif (marker.invalid) {\r\n\t\t\t\tmarker.validate();\r\n\t\t\t}\r\n\t\t\tif (marker.measuredWidth + marker.pixelMarginLeft + marker.pixelMarginRight > maxMarkerWidth) {\r\n\t\t\t\tmaxMarkerWidth = marker.measuredWidth + marker.pixelMarginLeft + marker.pixelMarginRight;\r\n\t\t\t}\r\n\t\t})\r\n\t\tlet itemContainer = this.itemContainers.template;\r\n\t\tlet margin = itemContainer.pixelMarginRight + itemContainer.pixelMarginLeft;\r\n\t\tlet maxAdjustedLabelWidth: number;\r\n\t\tlet trueMaxWidth = maxLabelWidth + maxValueLabelWidth + maxMarkerWidth;\r\n\t\tif (!$type.isNumber(maxWidth)) {\r\n\t\t\tmaxAdjustedLabelWidth = maxLabelWidth;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tmaxWidth = maxWidth - margin;\r\n\t\t\tif (maxWidth > trueMaxWidth) {\r\n\t\t\t\tmaxWidth = trueMaxWidth;\r\n\t\t\t}\r\n\t\t\tmaxAdjustedLabelWidth = maxWidth - maxMarkerWidth - maxValueLabelWidth;\r\n\t\t}\r\n\r\n\t\tthis.labels.each((label) => {\r\n\t\t\tif (this.valueLabels.template.align == \"right\" || label.measuredWidth > maxAdjustedLabelWidth) {\r\n\t\t\t\tif(!(label.width instanceof Percent)){\r\n\t\t\t\t\tlabel.width = Math.min(label.maxWidth, maxAdjustedLabelWidth - label.pixelMarginLeft - label.pixelMarginRight);\r\n\t\t\t\t\tlabel.maxWidth = label.width;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t})\r\n\t\tif (this.valueLabels.template.align == \"right\") {\r\n\t\t\tthis.valueLabels.each((valueLabel) => {\r\n\t\t\t\tvalueLabel.width = maxValueLabelWidth - valueLabel.pixelMarginRight - valueLabel.pixelMarginLeft;\r\n\t\t\t})\r\n\t\t}\r\n\r\n\t\tsuper.afterDraw();\r\n\t}\r\n\r\n\r\n\tprotected handleScrollbar() {\r\n\t\tlet scrollbar = this.scrollbar;\r\n\t\tif (this.scrollable && scrollbar) {\r\n\t\t\tscrollbar.height = this.measuredHeight;\r\n\t\t\tscrollbar.x = this.measuredWidth - scrollbar.pixelWidth - scrollbar.pixelMarginLeft;\r\n\r\n\t\t\tif (this.contentHeight > this.measuredHeight) {\r\n\t\t\t\tscrollbar.visible = true;\r\n\t\t\t\tscrollbar.thumb.height = scrollbar.height * this.measuredHeight / this.contentHeight;\r\n\t\t\t\tthis.paddingRight = scrollbar.pixelWidth + scrollbar.pixelMarginLeft + + scrollbar.pixelMarginRight;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tscrollbar.visible = false;\r\n\t\t\t}\r\n\r\n\t\t\tthis.updateMasks();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Position of the legend.\r\n\t *\r\n\t * Options: \"left\", \"right\", \"top\", \"bottom\" (default), or \"absolute\".\r\n\t *\r\n\t * IMPORTANT: [[MapChart]] will ignore this setting, as it is using different\r\n\t * layout structure than other charts.\r\n\t *\r\n\t * To position legend in [[MapChart]] set legend's `align` (`\"left\"` or\r\n\t * `\"right\"`) and `valign` (`\"top\"` or `\"bottom\"`) properties instead.\r\n\t *\r\n\t * @default \"bottom\"\r\n\t * @param value  Position\r\n\t */\r\n\tpublic set position(value: LegendPosition) {\r\n\t\tif (this.setPropertyValue(\"position\", value)) {\r\n\t\t\tif (value == \"left\" || value == \"right\") {\r\n\t\t\t\tthis.margin(10, 5, 10, 10);\r\n\t\t\t\tthis.valign = \"middle\";\r\n\t\t\t\tthis.contentAlign = \"none\";\r\n\t\t\t\tthis.valueLabels.template.align = \"right\";\r\n\r\n\t\t\t\tif (!$type.isNumber(this.maxColumns)) {\r\n\t\t\t\t\tthis.maxColumns = 1;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.width = undefined;\r\n\t\t\t\tthis.maxWidth = 220;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tthis.maxColumns = undefined;\r\n\t\t\t\tthis.width = percent(100);\r\n\t\t\t\tthis.valueLabels.template.align = \"left\";\r\n\t\t\t}\r\n\t\t\tthis.invalidate();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @return Position\r\n\t */\r\n\tpublic get position(): LegendPosition {\r\n\t\treturn this.getPropertyValue(\"position\");\r\n\t}\r\n\r\n\t/**\r\n\t * Should legend try to mirror the look of the related item when building\r\n\t * the marker for legend item?\r\n\t *\r\n\t * If set to `false` it will try to make the marker look like its related\r\n\t * item.\r\n\t *\r\n\t * E.g. if an item is for a Line Series, it will display a line of the\r\n\t * same thickness, color, and will use the same bullets if series have them.\r\n\t *\r\n\t * If set to `true`, all markers will be shown as squares, regardless of te\r\n\t * series type.\r\n\t *\r\n\t * @default false\r\n\t * @param value Use default marker?\r\n\t */\r\n\tpublic set useDefaultMarker(value: boolean) {\r\n\t\tthis.setPropertyValue(\"useDefaultMarker\", value, true);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Use default marker?\r\n\t */\r\n\tpublic get useDefaultMarker(): boolean {\r\n\t\treturn this.getPropertyValue(\"useDefaultMarker\");\r\n\t}\r\n\r\n\t/**\r\n\t * If set to `true` the Legend will display a scrollbar if its contents do\r\n\t * not fit into its `maxHeight`.\r\n\t *\r\n\t * Please note that `maxHeight` is automatically set for Legend when its\r\n\t * `position` is set to `\"left\"` or `\"right\"`.\r\n\t *\r\n\t * @default false\r\n\t * @since 4.8.0\r\n\t * @param  value  Legend Scrollable?\r\n\t */\r\n\tpublic set scrollable(value: boolean) {\r\n\t\tif (this.setPropertyValue(\"scrollable\", value, true)) {\r\n\t\t\tif (value) {\r\n\t\t\t\tlet scrollbar = this.createChild(Scrollbar);\r\n\t\t\t\tthis.scrollbar = scrollbar;\r\n\t\t\t\tscrollbar.isMeasured = false;\r\n\t\t\t\tscrollbar.orientation = \"vertical\";\r\n\t\t\t\tscrollbar.endGrip.__disabled = true;\r\n\t\t\t\tscrollbar.startGrip.__disabled = true;\r\n\t\t\t\tscrollbar.visible = false;\r\n\t\t\t\tscrollbar.marginLeft = 5;\r\n\r\n\t\t\t\tthis._mouseWheelDisposer = this.events.on(\"wheel\", this.handleWheel, this, false);\r\n\t\t\t\tthis._disposers.push(this._mouseWheelDisposer);\r\n\r\n\t\t\t\tthis._disposers.push(scrollbar.events.on(\"rangechanged\", this.updateMasks, this, false));\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tif (this._mouseWheelDisposer) {\r\n\t\t\t\t\tthis._mouseWheelDisposer.dispose();\r\n\t\t\t\t\tif (this.scrollbar) {\r\n\t\t\t\t\t\tthis.scrollbar.dispose();\r\n\t\t\t\t\t\tthis.scrollbar = undefined;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Handles mouse wheel scrolling of legend.\r\n\t *\r\n\t * @param  event  Event\r\n\t */\r\n\tprotected handleWheel(event: AMEvent<Sprite, ISpriteEvents>[\"wheel\"]): void {\r\n\t\tlet shift = event.shift.y;\r\n\t\tlet scrollbar = this.scrollbar\r\n\t\tif (scrollbar) {\r\n\t\t\tlet ds = (shift / 1000 * this.measuredHeight / this.contentHeight);\r\n\t\t\tlet delta = scrollbar.end - scrollbar.start;\r\n\t\t\tif (shift > 0) {\r\n\t\t\t\tscrollbar.start = $math.max(0, scrollbar.start - ds);\r\n\t\t\t\tscrollbar.end = scrollbar.start + delta;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tscrollbar.end = $math.min(1, scrollbar.end - ds);\r\n\t\t\t\tscrollbar.start = scrollbar.end - delta;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tprotected updateMasks(): void {\r\n\t\tif (this.scrollbar) {\r\n\t\t\tthis.itemContainers.each((itemContainer) => {\r\n\t\t\t\titemContainer.dy = -this.scrollbar.thumb.pixelY * this.contentHeight / this.measuredHeight;\r\n\t\t\t\titemContainer.maskRectangle = { x: 0, y: -itemContainer.dy, width: this.measuredWidth, height: this.measuredHeight }\r\n\t\t\t})\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @return Legend Scrollable?\r\n\t */\r\n\tpublic get scrollable(): boolean {\r\n\t\treturn this.getPropertyValue(\"scrollable\");\r\n\t}\r\n\r\n\t/**\r\n\t * Toggles a legend item.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param item Legend item\r\n\t * @todo Maybe do it with togglable instead\r\n\t */\r\n\tpublic toggleDataItem(item: this[\"_dataItem\"]): void {\r\n\t\tlet dataContext = item.dataContext;\r\n\r\n\t\tif (!dataContext.visible || dataContext.isHiding || (dataContext instanceof Sprite && dataContext.isHidden)) {\r\n\t\t\titem.color = item.colorOrig;\r\n\r\n\t\t\tdataContext.appeared = true;\r\n\t\t\titem.itemContainer.isActive = false;\r\n\r\n\t\t\tif (dataContext.hidden === true) {\r\n\t\t\t\tdataContext.hidden = false;\r\n\t\t\t}\r\n\r\n\t\t\tif (dataContext.show) {\r\n\t\t\t\tdataContext.show();\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tdataContext.visible = true;\r\n\t\t\t}\r\n\r\n\t\t\tthis.svgContainer.readerAlert(this.language.translate(\"%1 shown\", this.language.locale, item.label.readerTitle));\r\n\r\n\t\t}\r\n\t\telse {\r\n\t\t\titem.itemContainer.isActive = true;\r\n\t\t\tdataContext.appeared = true;\r\n\r\n\t\t\tif (dataContext.hide) {\r\n\t\t\t\tdataContext.hide();\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tdataContext.visible = false;\r\n\t\t\t}\r\n\r\n\t\t\tthis.svgContainer.readerAlert(this.language.translate(\"%1 hidden\", this.language.locale, item.label.readerTitle));\r\n\t\t\titem.color = new InterfaceColorSet().getFor(\"disabledBackground\");\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Override preloader method so that legend does not accidentally show its\r\n\t * own preloader.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @return Always `undefined`\r\n\t */\r\n\tpublic get preloader(): Optional<Preloader> {\r\n\t\treturn;\r\n\t}\r\n\r\n\t/**\r\n\t * [handleDataItemPropertyChange description]\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic handleDataItemPropertyChange(dataItem?: this[\"_dataItem\"], name?: string): void {\r\n\t\tdataItem.valueLabel.invalidate();\r\n\t\tdataItem.label.invalidate();\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\r\nregistry.registeredClasses[\"Legend\"] = Legend;\r\n\r\n\r\n/**\r\n * Add default responsive rules\r\n */\r\n\r\n/**\r\n * Move legend to below the chart if chart is narrow\r\n */\r\ndefaultRules.push({\r\n\trelevant: ResponsiveBreakpoints.widthXS,\r\n\tstate: function(target, stateId) {\r\n\t\tif (target instanceof Legend && (target.position == \"left\" || target.position == \"right\")) {\r\n\t\t\tlet state = target.states.create(stateId);\r\n\t\t\tstate.properties.position = \"bottom\";\r\n\t\t\treturn state;\r\n\t\t}\r\n\r\n\t\treturn null;\r\n\t}\r\n});\r\n\r\n/**\r\n * Move legend to the right if chart is very short\r\n */\r\ndefaultRules.push({\r\n\trelevant: ResponsiveBreakpoints.heightXS,\r\n\tstate: function(target, stateId) {\r\n\t\tif (target instanceof Legend && (target.position == \"top\" || target.position == \"bottom\")) {\r\n\t\t\tlet state = target.states.create(stateId);\r\n\t\t\tstate.properties.position = \"right\";\r\n\t\t\treturn state;\r\n\t\t}\r\n\r\n\t\treturn null;\r\n\t}\r\n});\r\n\r\n/**\r\n * Disable legend altogether on small charts\r\n */\r\ndefaultRules.push({\r\n\trelevant: ResponsiveBreakpoints.isXS,\r\n\tstate: function(target, stateId) {\r\n\t\tif (target instanceof Legend) {\r\n\t\t\tlet state = target.states.create(stateId);\r\n\t\t\tstate.properties.disabled = true;\r\n\t\t\treturn state;\r\n\t\t}\r\n\r\n\t\treturn null;\r\n\t}\r\n});\r\n"]},"metadata":{},"sourceType":"module"}