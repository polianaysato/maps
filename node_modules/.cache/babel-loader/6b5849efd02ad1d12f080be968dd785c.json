{"ast":null,"code":"import { __extends } from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\nimport { registry } from \"../Registry\";\nimport * as $path from \"./Path\";\nimport * as $array from \"../utils/Array\";\nimport * as $utils from \"../utils/Utils\";\nimport * as $math from \"../utils/Math\";\n/**\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n */\n\nvar Tension =\n/** @class */\nfunction () {\n  /**\r\n   * Constructor.\r\n   *\r\n   * @param tensionX [description]\r\n   * @param tensionY [description]\r\n   */\n  function Tension(tensionX, tensionY) {\n    this._tensionX = tensionX;\n    this._tensionY = tensionY;\n  }\n  /**\r\n   * [smooth description]\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description\r\n   * @param points  [description]\r\n   * @return [description]\r\n   */\n\n\n  Tension.prototype.smooth = function (points) {\n    for (var i = points.length - 1; i > 0; i--) {\n      var p0 = points[i];\n      var p1 = points[i - 1];\n\n      if (Math.abs(p0.x - p1.x) < 0.1 && Math.abs(p0.y - p1.y) < 0.1) {\n        points.splice(i - 1, 1);\n      }\n    }\n\n    var tensionX = this._tensionX;\n    var tensionY = this._tensionY;\n\n    if (points.length < 3 || tensionX >= 1 && tensionY >= 1) {\n      return $path.polyline(points);\n    }\n\n    var first = points[0];\n    var last = points[points.length - 1];\n    var closed = false;\n\n    if ($math.round(first.x, 3) == $math.round(last.x) && $math.round(first.y) == $math.round(last.y)) {\n      closed = true;\n    } // Can't moveTo here, as it wont be possible to have fill then.\n\n\n    var path = \"\";\n\n    for (var i = 0, len = points.length - 1; i < len; i++) {\n      var p0 = points[i - 1];\n      var p1 = points[i];\n      var p2 = points[i + 1];\n      var p3 = points[i + 2];\n\n      if (i === 0) {\n        if (closed) {\n          p0 = points[points.length - 2];\n        } else {\n          p0 = points[i];\n        }\n      } else if (i == points.length - 2) {\n        if (closed) {\n          p3 = points[1];\n        } else {\n          p3 = points[i + 1];\n        }\n      }\n\n      var controlPointA = $math.getCubicControlPointA(p0, p1, p2, p3, tensionX, tensionY);\n      var controlPointB = $math.getCubicControlPointB(p0, p1, p2, p3, tensionX, tensionY);\n      path += $path.cubicCurveTo(p2, controlPointA, controlPointB);\n    }\n\n    return path;\n  };\n\n  return Tension;\n}();\n\nexport { Tension };\n/**\r\n * Returns a waved line SVG path between two points.\r\n *\r\n * @ignore Exclude from docs\r\n * @param point1            Starting point\r\n * @param point2            Ending point\r\n * @param waveLength        Wave length\r\n * @param waveHeight        Wave height\r\n * @param adjustWaveLength  Adjust wave length based on the actual line length\r\n * @return SVG path\r\n */\n\nexport function wavedLine(point1, point2, waveLength, waveHeight, tension, adjustWaveLength) {\n  var x1 = point1.x;\n  var y1 = point1.y;\n  var x2 = point2.x;\n  var y2 = point2.y;\n  var distance = $math.getDistance(point1, point2);\n\n  if (adjustWaveLength) {\n    waveLength = distance / Math.round(distance / waveLength);\n  }\n\n  var d = registry.getCache($utils.stringify([\"wavedLine\", point1.x, point2.x, point1.y, point2.y, waveLength, waveHeight]));\n\n  if (!d) {\n    if (distance > 0) {\n      var angle = Math.atan2(y2 - y1, x2 - x1);\n      var cos = Math.cos(angle);\n      var sin = Math.sin(angle);\n      var waveLengthX = waveLength * cos;\n      var waveLengthY = waveLength * sin;\n\n      if (waveLength <= 1 || waveHeight <= 1) {\n        d = $path.lineTo(point2);\n      } else {\n        var halfWaveCount = Math.round(2 * distance / waveLength);\n        var points = [];\n        var sign_1 = 1;\n\n        if (x2 < x1) {\n          sign_1 *= -1;\n        }\n\n        if (y2 < y1) {\n          sign_1 *= -1;\n        }\n\n        for (var i = 0; i <= halfWaveCount; i++) {\n          sign_1 *= -1;\n          var x = x1 + i * waveLengthX / 2 + sign_1 * waveHeight / 2 * sin;\n          var y = y1 + i * waveLengthY / 2 - sign_1 * waveHeight / 2 * cos;\n          points.push({\n            x: x,\n            y: y\n          });\n        }\n\n        d = new Tension(tension, tension).smooth(points);\n      }\n    } else {\n      d = \"\";\n    }\n\n    registry.setCache($utils.stringify([\"wavedLine\", point1.x, point2.x, point1.y, point2.y, waveLength, waveHeight]), d);\n  }\n\n  return d;\n}\n\nvar Monotone =\n/** @class */\nfunction () {\n  function Monotone(reversed, info) {\n    this._reversed = reversed;\n    this._closed = info.closed;\n  } // According to https://en.wikipedia.org/wiki/Cubic_Hermite_spline#Representations\n  // \"you can express cubic Hermite interpolation in terms of cubic Bézier curves\n  // with respect to the four values p0, p0 + m0 / 3, p1 - m1 / 3, p1\".\n\n\n  Monotone.prototype._curve = function (x0, x1, y0, y1, t0, t1) {\n    var dx = (x1 - x0) / 3;\n\n    if (this._reversed) {\n      return $path.cubicCurveTo({\n        x: y1,\n        y: x1\n      }, {\n        x: y0 + dx * t0,\n        y: x0 + dx\n      }, {\n        x: y1 - dx * t1,\n        y: x1 - dx\n      });\n    } else {\n      return $path.cubicCurveTo({\n        x: x1,\n        y: y1\n      }, {\n        x: x0 + dx,\n        y: y0 + dx * t0\n      }, {\n        x: x1 - dx,\n        y: y1 - dx * t1\n      });\n    }\n  };\n\n  Monotone.prototype.smooth = function (points) {\n    var _this = this;\n\n    var x0 = NaN;\n    var x1 = NaN;\n    var y0 = NaN;\n    var y1 = NaN;\n    var t0 = NaN;\n    var point = 0;\n    var output = \"\";\n    $array.each(points, function (_a) {\n      var x = _a.x,\n          y = _a.y;\n\n      if (_this._reversed) {\n        var temp = x;\n        x = y;\n        y = temp;\n      }\n\n      var t1 = NaN;\n\n      if (!(x === x1 && y === y1)) {\n        switch (point) {\n          case 0:\n            point = 1;\n\n            if (_this._reversed) {\n              output += $path.lineTo({\n                x: y,\n                y: x\n              });\n            } else {\n              output += $path.lineTo({\n                x: x,\n                y: y\n              });\n            }\n\n            break;\n\n          case 1:\n            point = 2;\n            break;\n\n          case 2:\n            point = 3;\n            output += _this._curve(x0, x1, y0, y1, slope2(x0, x1, y0, y1, t1 = slope3(x0, x1, y0, y1, x, y)), t1);\n            break;\n\n          default:\n            output += _this._curve(x0, x1, y0, y1, t0, t1 = slope3(x0, x1, y0, y1, x, y));\n            break;\n        }\n\n        x0 = x1;\n        x1 = x;\n        y0 = y1;\n        y1 = y;\n        t0 = t1;\n      }\n    });\n\n    switch (point) {\n      case 2:\n        if (this._reversed) {\n          output += $path.lineTo({\n            x: y1,\n            y: x1\n          });\n        } else {\n          output += $path.lineTo({\n            x: x1,\n            y: y1\n          });\n        }\n\n        break;\n\n      case 3:\n        output += this._curve(x0, x1, y0, y1, t0, slope2(x0, x1, y0, y1, t0));\n        break;\n    }\n\n    if (this._closed) {\n      output += $path.closePath();\n    }\n\n    return output;\n  };\n\n  return Monotone;\n}();\n\nexport { Monotone }; // TODO move this someplace else\n\nfunction sign(x) {\n  return x < 0 ? -1 : 1;\n}\n\nfunction slope2(x0, x1, y0, y1, t) {\n  var h = x1 - x0;\n  return h ? (3 * (y1 - y0) / h - t) / 2 : t;\n}\n\nfunction slope3(x0, x1, y0, y1, x2, y2) {\n  var h0 = x1 - x0;\n  var h1 = x2 - x1;\n  var s0 = (y1 - y0) / (h0 || h1 < 0 && -0);\n  var s1 = (y2 - y1) / (h1 || h0 < 0 && -0);\n  var p = (s0 * h1 + s1 * h0) / (h0 + h1);\n  return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;\n}\n\nvar MonotoneX =\n/** @class */\nfunction (_super) {\n  __extends(MonotoneX, _super);\n\n  function MonotoneX(info) {\n    return _super.call(this, false, info) || this;\n  }\n\n  return MonotoneX;\n}(Monotone);\n\nexport { MonotoneX };\n\nvar MonotoneY =\n/** @class */\nfunction (_super) {\n  __extends(MonotoneY, _super);\n\n  function MonotoneY(info) {\n    return _super.call(this, true, info) || this;\n  }\n\n  return MonotoneY;\n}(Monotone);\n\nexport { MonotoneY };\n/**\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n */\n\nvar Basis =\n/** @class */\nfunction () {\n  /**\r\n   * Constructor.\r\n   *\r\n   * @param info  [description]\r\n   */\n  function Basis(info) {\n    this._closed = info.closed;\n  }\n  /**\r\n   * [smooth description]\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description\r\n   * @param points  [description]\r\n   * @return [description]\r\n   */\n\n\n  Basis.prototype.smooth = function (points) {\n    var _this = this;\n\n    var x0 = NaN;\n    var x1 = NaN;\n    var x2 = NaN;\n    var x3 = NaN;\n    var x4 = NaN;\n    var y0 = NaN;\n    var y1 = NaN;\n    var y2 = NaN;\n    var y3 = NaN;\n    var y4 = NaN;\n    var point = 0;\n    var output = \"\";\n\n    var pushCurve = function (x, y) {\n      output += $path.cubicCurveTo({\n        x: (x0 + 4 * x1 + x) / 6,\n        y: (y0 + 4 * y1 + y) / 6\n      }, {\n        x: (2 * x0 + x1) / 3,\n        y: (2 * y0 + y1) / 3\n      }, {\n        x: (x0 + 2 * x1) / 3,\n        y: (y0 + 2 * y1) / 3\n      });\n    };\n\n    var pushPoint = function (_a) {\n      var x = _a.x,\n          y = _a.y;\n\n      switch (point) {\n        case 0:\n          point = 1;\n\n          if (_this._closed) {\n            x2 = x;\n            y2 = y;\n          } else {\n            output += $path.lineTo({\n              x: x,\n              y: y\n            });\n          }\n\n          break;\n\n        case 1:\n          point = 2;\n\n          if (_this._closed) {\n            x3 = x;\n            y3 = y;\n          }\n\n          break;\n\n        case 2:\n          point = 3;\n\n          if (_this._closed) {\n            x4 = x;\n            y4 = y;\n            output += $path.moveTo({\n              x: (x0 + 4 * x1 + x) / 6,\n              y: (y0 + 4 * y1 + y) / 6\n            });\n            break;\n          } else {\n            output += $path.lineTo({\n              x: (5 * x0 + x1) / 6,\n              y: (5 * y0 + y1) / 6\n            }); // fall-through\n          }\n\n        default:\n          pushCurve(x, y);\n          break;\n      }\n\n      x0 = x1;\n      x1 = x;\n      y0 = y1;\n      y1 = y;\n    };\n\n    $array.each(points, pushPoint);\n\n    if (this._closed) {\n      switch (point) {\n        case 1:\n          output += $path.moveTo({\n            x: x2,\n            y: y2\n          });\n          output += $path.closePath();\n          break;\n\n        case 2:\n          output += $path.moveTo({\n            x: (x2 + 2 * x3) / 3,\n            y: (y2 + 2 * y3) / 3\n          });\n          output += $path.lineTo({\n            x: (x3 + 2 * x2) / 3,\n            y: (y3 + 2 * y2) / 3\n          });\n          output += $path.closePath();\n          break;\n\n        case 3:\n          pushPoint({\n            x: x2,\n            y: y2\n          });\n          pushPoint({\n            x: x3,\n            y: y3\n          });\n          pushPoint({\n            x: x4,\n            y: y4\n          });\n          break;\n      }\n    } else {\n      switch (point) {\n        case 3:\n          pushCurve(x1, y1);\n        // fall-through\n\n        case 2:\n          output += $path.lineTo({\n            x: x1,\n            y: y1\n          });\n          break;\n      }\n\n      output += $path.closePath();\n    }\n\n    return output;\n  };\n\n  return Basis;\n}();\n\nexport { Basis };","map":{"version":3,"mappings":"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","names":["registry","$path","$array","$utils","$math","tensionX","tensionY","_tensionX","_tensionY","Tension","points","i","length","p0","p1","Math","abs","x","y","splice","polyline","first","last","closed","round","path","len","p2","p3","controlPointA","getCubicControlPointA","controlPointB","getCubicControlPointB","cubicCurveTo","wavedLine","point1","point2","waveLength","waveHeight","tension","adjustWaveLength","x1","y1","x2","y2","distance","getDistance","d","getCache","stringify","angle","atan2","cos","sin","waveLengthX","waveLengthY","lineTo","halfWaveCount","sign_1","push","smooth","setCache","reversed","info","_reversed","_closed","Monotone","x0","y0","t0","t1","dx","NaN","point","output","each","_a","_this","temp","_curve","slope2","slope3","closePath","sign","t","h","h0","h1","s0","s1","p","min","__extends","_super","Basis","x3","x4","y3","y4","pushCurve","pushPoint","moveTo"],"sourceRoot":"","sources":["../../../../../src/.internal/core/rendering/Smoothing.ts"],"sourcesContent":["/**\n * ============================================================================\n * IMPORTS\n * ============================================================================\n * @hidden\n */\nimport { registry } from \"../Registry\";\nimport * as $path from \"./Path\";\nimport * as $array from \"../utils/Array\";\nimport * as $utils from \"../utils/Utils\";\nimport * as $math from \"../utils/Math\";\nimport { IPoint } from \"../defs/IPoint\";\n\n\n/**\n * ============================================================================\n * PATH FUNCTIONS\n * ============================================================================\n * @hidden\n */\n\n/**\n * @ignore Exclude from docs\n * @todo Description\n */\nexport interface ISmoothing {\n\tsmooth(points: Array<IPoint>): string;\n}\n\n/**\n * @ignore Exclude from docs\n * @todo Description\n */\nexport class Tension implements ISmoothing {\n\n\t/**\n\t * [_tensionX description]\n\t *\n\t * @todo Description\n\t */\n\tprivate _tensionX: number;\n\n\t/**\n\t * [_tensionY description]\n\t *\n\t * @todo Description\n\t */\n\tprivate _tensionY: number;\n\n\t/**\n\t * Constructor.\n\t *\n\t * @param tensionX [description]\n\t * @param tensionY [description]\n\t */\n\tconstructor(tensionX: number, tensionY: number) {\n\t\tthis._tensionX = tensionX;\n\t\tthis._tensionY = tensionY;\n\t}\n\n\t/**\n\t * [smooth description]\n\t *\n\t * @ignore Exclude from docs\n\t * @todo Description\n\t * @param points  [description]\n\t * @return [description]\n\t */\n\tpublic smooth(points: Array<IPoint>): string {\n\n\t\tfor (let i = points.length - 1; i > 0; i--) {\n\t\t\tlet p0 = points[i];\n\t\t\tlet p1 = points[i - 1];\n\n\t\t\tif (Math.abs(p0.x - p1.x) < 0.1 && Math.abs(p0.y - p1.y) < 0.1) {\n\t\t\t\tpoints.splice(i - 1, 1);\n\t\t\t}\n\t\t}\n\n\n\t\tlet tensionX = this._tensionX;\n\t\tlet tensionY = this._tensionY;\n\n\t\tif (points.length < 3 || (tensionX >= 1 && tensionY >= 1)) {\n\t\t\treturn $path.polyline(points);\n\t\t}\n\n\t\tlet first: IPoint = points[0];\n\t\tlet last: IPoint = points[points.length - 1];\n\n\t\tlet closed: boolean = false;\n\n\t\tif ($math.round(first.x, 3) == $math.round(last.x) && $math.round(first.y) == $math.round(last.y)) {\n\t\t\tclosed = true;\n\t\t}\n\n\t\t// Can't moveTo here, as it wont be possible to have fill then.\n\t\tlet path: string = \"\";\n\n\t\tfor (let i = 0, len = points.length - 1; i < len; i++) {\n\t\t\tlet p0: IPoint = points[i - 1];\n\n\t\t\tlet p1: IPoint = points[i];\n\n\t\t\tlet p2: IPoint = points[i + 1];\n\n\t\t\tlet p3: IPoint = points[i + 2];\n\n\t\t\tif (i === 0) {\n\t\t\t\tif (closed) {\n\t\t\t\t\tp0 = points[points.length - 2];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tp0 = points[i];\n\t\t\t\t}\n\t\t\t} else if (i == points.length - 2) {\n\t\t\t\tif (closed) {\n\t\t\t\t\tp3 = points[1];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tp3 = points[i + 1];\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\tlet controlPointA: IPoint = $math.getCubicControlPointA(p0, p1, p2, p3, tensionX, tensionY);\n\t\t\tlet controlPointB: IPoint = $math.getCubicControlPointB(p0, p1, p2, p3, tensionX, tensionY);\n\n\t\t\tpath += $path.cubicCurveTo(p2, controlPointA, controlPointB);\n\t\t}\n\n\t\treturn path;\n\t}\n}\n\n\n/**\n * Returns a waved line SVG path between two points.\n *\n * @ignore Exclude from docs\n * @param point1            Starting point\n * @param point2            Ending point\n * @param waveLength        Wave length\n * @param waveHeight        Wave height\n * @param adjustWaveLength  Adjust wave length based on the actual line length\n * @return SVG path\n */\nexport function wavedLine(point1: IPoint, point2: IPoint, waveLength: number, waveHeight: number, tension: number, adjustWaveLength?: boolean): string {\n\n\tlet x1: number = point1.x;\n\tlet y1: number = point1.y;\n\n\tlet x2: number = point2.x;\n\tlet y2: number = point2.y;\n\n\tlet distance: number = $math.getDistance(point1, point2);\n\n\tif (adjustWaveLength) {\n\t\twaveLength = distance / Math.round(distance / waveLength);\n\t}\n\n\tlet d: string = registry.getCache($utils.stringify([\"wavedLine\", point1.x, point2.x, point1.y, point2.y, waveLength, waveHeight]));\n\tif (!d) {\n\t\tif (distance > 0) {\n\t\t\tlet angle: number = Math.atan2(y2 - y1, x2 - x1);\n\n\t\t\tlet cos: number = Math.cos(angle);\n\t\t\tlet sin: number = Math.sin(angle);\n\n\t\t\tlet waveLengthX: number = waveLength * cos;\n\t\t\tlet waveLengthY: number = waveLength * sin;\n\n\t\t\tif (waveLength <= 1 || waveHeight <= 1) {\n\t\t\t\td = $path.lineTo(point2);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlet halfWaveCount: number = Math.round(2 * distance / waveLength);\n\n\t\t\t\tlet points: IPoint[] = [];\n\t\t\t\tlet sign: number = 1;\n\n\t\t\t\tif (x2 < x1) {\n\t\t\t\t\tsign *= -1;\n\t\t\t\t}\n\n\t\t\t\tif (y2 < y1) {\n\t\t\t\t\tsign *= -1;\n\t\t\t\t}\n\n\t\t\t\tfor (let i: number = 0; i <= halfWaveCount; i++) {\n\t\t\t\t\tsign *= -1;\n\t\t\t\t\tlet x: number = x1 + i * waveLengthX / 2 + sign * waveHeight / 2 * sin;\n\t\t\t\t\tlet y: number = y1 + i * waveLengthY / 2 - sign * waveHeight / 2 * cos;\n\t\t\t\t\tpoints.push({ x: x, y: y });\n\t\t\t\t}\n\n\t\t\t\td = new Tension(tension, tension).smooth(points);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\td = \"\";\n\t\t}\n\n\t\tregistry.setCache($utils.stringify([\"wavedLine\", point1.x, point2.x, point1.y, point2.y, waveLength, waveHeight]), d);\n\t}\n\n\treturn d;\n}\n\n\nexport class Monotone implements ISmoothing {\n\tprivate _reversed: boolean;\n\tprivate _closed: boolean;\n\n\tconstructor(reversed: boolean, info: { closed: boolean }) {\n\t\tthis._reversed = reversed;\n\t\tthis._closed = info.closed;\n\t}\n\n\t// According to https://en.wikipedia.org/wiki/Cubic_Hermite_spline#Representations\n\t// \"you can express cubic Hermite interpolation in terms of cubic Bézier curves\n\t// with respect to the four values p0, p0 + m0 / 3, p1 - m1 / 3, p1\".\n\tprivate _curve(x0: number, x1: number, y0: number, y1: number, t0: number, t1: number): string {\n\t\tconst dx = (x1 - x0) / 3;\n\n\t\tif (this._reversed) {\n\t\t\treturn $path.cubicCurveTo(\n\t\t\t\t{ x: y1, y: x1 },\n\t\t\t\t{ x: y0 + dx * t0, y: x0 + dx },\n\t\t\t\t{ x: y1 - dx * t1, y: x1 - dx }\n\t\t\t);\n\n\t\t} else {\n\t\t\treturn $path.cubicCurveTo(\n\t\t\t\t{ x: x1, y: y1 },\n\t\t\t\t{ x: x0 + dx, y: y0 + dx * t0 },\n\t\t\t\t{ x: x1 - dx, y: y1 - dx * t1 }\n\t\t\t);\n\t\t}\n\t}\n\n\tpublic smooth(points: Array<IPoint>): string {\n\t\tlet x0: number = NaN;\n\t\tlet x1: number = NaN;\n\t\tlet y0: number = NaN;\n\t\tlet y1: number = NaN;\n\t\tlet t0: number = NaN;\n\t\tlet point: number = 0;\n\n\t\tlet output = \"\";\n\n\t\t$array.each(points, ({ x, y }) => {\n\t\t\tif (this._reversed) {\n\t\t\t\tlet temp = x;\n\t\t\t\tx = y;\n\t\t\t\ty = temp;\n\t\t\t}\n\n\t\t\tlet t1 = NaN;\n\n\t\t\tif (!(x === x1 && y === y1)) {\n\t\t\t\tswitch (point) {\n\t\t\t\tcase 0:\n\t\t\t\t\tpoint = 1;\n\n\t\t\t\t\tif (this._reversed) {\n\t\t\t\t\t\toutput += $path.lineTo({ x: y, y: x });\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\toutput += $path.lineTo({ x, y });\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tpoint = 2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tpoint = 3;\n\t\t\t\t\toutput += this._curve(x0, x1, y0, y1, slope2(x0, x1, y0, y1, t1 = slope3(x0, x1, y0, y1, x, y)), t1);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\toutput += this._curve(x0, x1, y0, y1, t0, t1 = slope3(x0, x1, y0, y1, x, y));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tx0 = x1;\n\t\t\t\tx1 = x;\n\t\t\t\ty0 = y1;\n\t\t\t\ty1 = y;\n\t\t\t\tt0 = t1;\n\t\t\t}\n\t\t});\n\n\t\tswitch (point) {\n\t\tcase 2:\n\t\t\tif (this._reversed) {\n\t\t\t\toutput += $path.lineTo({ x: y1, y: x1 });\n\n\t\t\t} else {\n\t\t\t\toutput += $path.lineTo({ x: x1, y: y1 });\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\toutput += this._curve(x0, x1, y0, y1, t0, slope2(x0, x1, y0, y1, t0));\n\t\t\tbreak;\n\t\t}\n\n\t\tif (this._closed) {\n\t\t\toutput += $path.closePath();\n\t\t}\n\n\t\treturn output;\n\t}\n}\n\n\n// TODO move this someplace else\nfunction sign(x: number): -1 | 1 {\n\treturn x < 0 ? -1 : 1;\n}\n\n\nfunction slope2(x0: number, x1: number, y0: number, y1: number, t: number): number {\n\tconst h = x1 - x0;\n\treturn h ? (3 * (y1 - y0) / h - t) / 2 : t;\n}\n\n\nfunction slope3(x0: number, x1: number, y0: number, y1: number, x2: number, y2: number): number {\n\tconst h0 = x1 - x0;\n\tconst h1 = x2 - x1;\n\tconst s0 = (y1 - y0) / (h0 || h1 < 0 && -0);\n\tconst s1 = (y2 - y1) / (h1 || h0 < 0 && -0);\n\tconst p = (s0 * h1 + s1 * h0) / (h0 + h1);\n\treturn (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;\n}\n\n\nexport class MonotoneX extends Monotone {\n\tconstructor(info: { closed: boolean }) {\n\t\tsuper(false, info);\n\t}\n}\n\nexport class MonotoneY extends Monotone {\n\tconstructor(info: { closed: boolean }) {\n\t\tsuper(true, info);\n\t}\n}\n\n\n/**\n * @ignore Exclude from docs\n * @todo Description\n */\nexport class Basis implements ISmoothing {\n\n\t/**\n\t * [_closed description]\n\t *\n\t * @ignore Exclude from docs\n\t * @todo Description\n\t */\n\tprivate _closed: boolean;\n\n\t/**\n\t * Constructor.\n\t *\n\t * @param info  [description]\n\t */\n\tconstructor(info: { closed: boolean }) {\n\t\tthis._closed = info.closed;\n\t}\n\n\t/**\n\t * [smooth description]\n\t *\n\t * @ignore Exclude from docs\n\t * @todo Description\n\t * @param points  [description]\n\t * @return [description]\n\t */\n\tpublic smooth(points: Array<IPoint>): string {\n\t\tlet x0: number = NaN;\n\t\tlet x1: number = NaN;\n\t\tlet x2: number = NaN;\n\t\tlet x3: number = NaN;\n\t\tlet x4: number = NaN;\n\t\tlet y0: number = NaN;\n\t\tlet y1: number = NaN;\n\t\tlet y2: number = NaN;\n\t\tlet y3: number = NaN;\n\t\tlet y4: number = NaN;\n\t\tlet point: number = 0;\n\n\t\tlet output = \"\";\n\n\t\tconst pushCurve = (x: number, y: number): void => {\n\t\t\toutput += $path.cubicCurveTo(\n\t\t\t\t{\n\t\t\t\t\tx: (x0 + 4 * x1 + x) / 6\n\t\t\t\t\t, y: (y0 + 4 * y1 + y) / 6\n\t\t\t\t},\n\n\t\t\t\t{\n\t\t\t\t\tx: (2 * x0 + x1) / 3\n\t\t\t\t\t, y: (2 * y0 + y1) / 3\n\t\t\t\t},\n\n\t\t\t\t{\n\t\t\t\t\tx: (x0 + 2 * x1) / 3\n\t\t\t\t\t, y: (y0 + 2 * y1) / 3\n\t\t\t\t}\n\t\t\t);\n\t\t};\n\n\t\tconst pushPoint = ({ x, y }: IPoint): void => {\n\t\t\tswitch (point) {\n\t\t\t\tcase 0:\n\t\t\t\t\tpoint = 1;\n\n\t\t\t\t\tif (this._closed) {\n\t\t\t\t\t\tx2 = x;\n\t\t\t\t\t\ty2 = y;\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\toutput += $path.lineTo({ x, y });\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 1:\n\t\t\t\t\tpoint = 2;\n\n\t\t\t\t\tif (this._closed) {\n\t\t\t\t\t\tx3 = x;\n\t\t\t\t\t\ty3 = y;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 2:\n\t\t\t\t\tpoint = 3;\n\n\t\t\t\t\tif (this._closed) {\n\t\t\t\t\t\tx4 = x;\n\t\t\t\t\t\ty4 = y;\n\t\t\t\t\t\toutput += $path.moveTo({ x: (x0 + 4 * x1 + x) / 6, y: (y0 + 4 * y1 + y) / 6 });\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\toutput += $path.lineTo({ x: (5 * x0 + x1) / 6, y: (5 * y0 + y1) / 6 });\n\t\t\t\t\t\t// fall-through\n\t\t\t\t\t}\n\n\t\t\t\tdefault:\n\t\t\t\t\tpushCurve(x, y);\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tx0 = x1;\n\t\t\tx1 = x;\n\t\t\ty0 = y1;\n\t\t\ty1 = y;\n\t\t};\n\n\t\t$array.each(points, pushPoint);\n\n\t\tif (this._closed) {\n\t\t\tswitch (point) {\n\t\t\t\tcase 1:\n\t\t\t\t\toutput += $path.moveTo({ x: x2, y: y2 });\n\t\t\t\t\toutput += $path.closePath();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\toutput += $path.moveTo({ x: (x2 + 2 * x3) / 3, y: (y2 + 2 * y3) / 3 });\n\t\t\t\t\toutput += $path.lineTo({ x: (x3 + 2 * x2) / 3, y: (y3 + 2 * y2) / 3 });\n\t\t\t\t\toutput += $path.closePath();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\tpushPoint({ x: x2, y: y2 });\n\t\t\t\t\tpushPoint({ x: x3, y: y3 });\n\t\t\t\t\tpushPoint({ x: x4, y: y4 });\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t} else {\n\t\t\tswitch (point) {\n\t\t\t\tcase 3:\n\t\t\t\t\tpushCurve(x1, y1);\n\t\t\t\t// fall-through\n\t\t\t\tcase 2:\n\t\t\t\t\toutput += $path.lineTo({ x: x1, y: y1 });\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\toutput += $path.closePath();\n\t\t}\n\n\t\treturn output;\n\t}\n\n}\n"]},"metadata":{},"sourceType":"module"}