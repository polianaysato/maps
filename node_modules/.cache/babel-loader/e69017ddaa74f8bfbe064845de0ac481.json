{"ast":null,"code":"/**\r\n * Data parser module.\r\n */\n\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\nimport { DateFormatter } from \"../formatters/DateFormatter\";\nimport * as $utils from \"../utils/Utils\";\nimport * as $type from \"../utils/Type\";\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * Base class for the data parsers.\r\n */\n\nvar DataParser =\n/** @class */\nfunction () {\n  function DataParser() {}\n  /**\r\n   * A \"placeholder\" function for real parsers to override.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param data  Source data\r\n   * @return Parsed data (empty)\r\n   */\n\n\n  DataParser.prototype.parse = function (data) {\n    return [];\n  };\n\n  ;\n  Object.defineProperty(DataParser.prototype, \"parsableNumbers\", {\n    /**\r\n     * Checks if there are any numeric fields that need to be converted to\r\n     * numbers.\r\n     *\r\n     * @return Numeric fields?\r\n     */\n    get: function () {\n      return this.options.numberFields && this.options.numberFields.length > 0;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Converts a value to 'number' if it is in `numberFields`.\r\n   *\r\n   * @param field  Field name\r\n   * @param value  Value\r\n   * @return Parsed or original value\r\n   */\n\n  DataParser.prototype.maybeToNumber = function (field, value) {\n    if (this.options.numberFields.indexOf(field) !== -1) {\n      return $utils.anyToNumber(value);\n    }\n\n    return value;\n  };\n\n  Object.defineProperty(DataParser.prototype, \"parsableDates\", {\n    /**\r\n     * Checks if there are any date fields that need to be converted to `Date`\r\n     * objects.\r\n     *\r\n     * @return Date fields?\r\n     */\n    get: function () {\n      return this.options.dateFields && this.options.dateFields.length > 0;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Converts a value to `Date` if it is in `dateFields`.\r\n   *\r\n   * @param field  Field name\r\n   * @param value  Value\r\n   * @return Parsed or original value\r\n   */\n\n  DataParser.prototype.maybeToDate = function (field, value) {\n    if (this.options.dateFields.indexOf(field) !== -1) {\n      return this.options.dateFormatter.parse(value, this.dateFormat);\n    }\n\n    return value;\n  };\n  /**\r\n   * Replaces empty value with something else.\r\n   *\r\n   * @param value  Source value\r\n   * @return Source value or replacement\r\n   */\n\n\n  DataParser.prototype.maybeToEmpty = function (value) {\n    if ((!$type.hasValue(value) || value == \"\") && $type.hasValue(this.options.emptyAs)) {\n      return this.options.emptyAs;\n    }\n\n    return value;\n  };\n\n  Object.defineProperty(DataParser.prototype, \"dateFormatter\", {\n    /**\r\n     * [[DateFormatter]] object for date parsing.\r\n     *\r\n     * If there was not [[DateFormatter]] supplied in parser options, a new one\r\n     * is created.\r\n     *\r\n     * @return Date formatter\r\n     * @see {@link DateFormatter}\r\n     */\n    get: function () {\n      if (!this.options.dateFormatter) {\n        this.options.dateFormatter = new DateFormatter();\n\n        if (this.options.dateFormat) {\n          this.options.dateFormat = this.options.dateFormat;\n        }\n      }\n\n      return this.options.dateFormatter;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DataParser.prototype, \"dateFormat\", {\n    /**\r\n     * A date format to use when parsing dates.\r\n     *\r\n     * @return Date format\r\n     * @see {@link DateFormatter}\r\n     */\n    get: function () {\n      return this.options.dateFormat || this.dateFormatter.inputDateFormat;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return DataParser;\n}();\n\nexport { DataParser };","map":{"version":3,"mappings":"AAAA;;;;AAKA;;;;;;AAMA,SAASA,aAAT,QAA8B,6BAA9B;AACA,OAAO,KAAKC,MAAZ,MAAwB,gBAAxB;AACA,OAAO,KAAKC,KAAZ,MAAuB,eAAvB;AAuDA;;;;;;;AAOA;;;;AAGA;AAAA;AAAA;AAAA,yBAmHC;AArGA;;;;;;;;;AAOOC,+BAAP,UAAaC,IAAb,EAAyB;AACxB,WAAO,EAAP;AACA,GAFM;;AAEN;AAQDC,wBAAcF,oBAAd,EAAc,iBAAd,EAA6B;AAN7B;;;;;;SAMA;AACC,aAAO,KAAKG,OAAL,CAAaC,YAAb,IAA8B,KAAKD,OAAL,CAAaC,YAAb,CAA0BC,MAA1B,GAAmC,CAAxE;AACA,KAF4B;oBAAA;;AAAA,GAA7B;AAIA;;;;;;;;AAOUL,uCAAV,UAAwBM,KAAxB,EAAuCC,KAAvC,EAAiD;AAChD,QAAI,KAAKJ,OAAL,CAAaC,YAAb,CAA0BI,OAA1B,CAAkCF,KAAlC,MAA6C,CAAC,CAAlD,EAAqD;AACpD,aAAOR,MAAM,CAACW,WAAP,CAAmBF,KAAnB,CAAP;AACA;;AACD,WAAOA,KAAP;AACA,GALS;;AAaVL,wBAAcF,oBAAd,EAAc,eAAd,EAA2B;AAN3B;;;;;;SAMA;AACC,aAAO,KAAKG,OAAL,CAAaO,UAAb,IAA4B,KAAKP,OAAL,CAAaO,UAAb,CAAwBL,MAAxB,GAAiC,CAApE;AACA,KAF0B;oBAAA;;AAAA,GAA3B;AAIA;;;;;;;;AAOUL,qCAAV,UAAsBM,KAAtB,EAAqCC,KAArC,EAA+C;AAC9C,QAAI,KAAKJ,OAAL,CAAaO,UAAb,CAAwBF,OAAxB,CAAgCF,KAAhC,MAA2C,CAAC,CAAhD,EAAmD;AAClD,aAAO,KAAKH,OAAL,CAAaQ,aAAb,CAA2BC,KAA3B,CAAiCL,KAAjC,EAAwC,KAAKM,UAA7C,CAAP;AACA;;AACD,WAAON,KAAP;AACA,GALS;AAOV;;;;;;;;AAMUP,sCAAV,UAAuBO,KAAvB,EAAiC;AAChC,QAAI,CAAC,CAACR,KAAK,CAACe,QAAN,CAAeP,KAAf,CAAD,IAA0BA,KAAK,IAAI,EAApC,KAA2CR,KAAK,CAACe,QAAN,CAAe,KAAKX,OAAL,CAAaY,OAA5B,CAA/C,EAAqF;AACpF,aAAO,KAAKZ,OAAL,CAAaY,OAApB;AACA;;AACD,WAAOR,KAAP;AACA,GALS;;AAgBVL,wBAAcF,oBAAd,EAAc,eAAd,EAA2B;AAT3B;;;;;;;;;SASA;AACC,UAAI,CAAC,KAAKG,OAAL,CAAaQ,aAAlB,EAAiC;AAChC,aAAKR,OAAL,CAAaQ,aAAb,GAA6B,IAAId,aAAJ,EAA7B;;AACA,YAAI,KAAKM,OAAL,CAAaU,UAAjB,EAA6B;AAC5B,eAAKV,OAAL,CAAaU,UAAb,GAA0B,KAAKV,OAAL,CAAaU,UAAvC;AACA;AACD;;AACD,aAAO,KAAKV,OAAL,CAAaQ,aAApB;AACA,KAR0B;oBAAA;;AAAA,GAA3B;AAgBAT,wBAAcF,oBAAd,EAAc,YAAd,EAAwB;AANxB;;;;;;SAMA;AACC,aAAO,KAAKG,OAAL,CAAaU,UAAb,IAA2B,KAAKF,aAAL,CAAmBK,eAArD;AACA,KAFuB;oBAAA;;AAAA,GAAxB;AAID;AAAC,CAnHD","names":["DateFormatter","$utils","$type","DataParser","data","Object","options","numberFields","length","field","value","indexOf","anyToNumber","dateFields","dateFormatter","parse","dateFormat","hasValue","emptyAs","inputDateFormat"],"sourceRoot":"","sources":["../../../../../src/.internal/core/data/DataParser.ts"],"sourcesContent":["/**\r\n * Data parser module.\r\n */\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { DateFormatter } from \"../formatters/DateFormatter\";\r\nimport * as $utils from \"../utils/Utils\";\r\nimport * as $type from \"../utils/Type\";\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * REQUISITES\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Defines common options for all data parsers.\r\n */\r\nexport interface IDataParserOptions {\r\n\r\n\t/**\r\n\t * Empty values (e.g. empty strings, `null`, etc.) will be replaced with\r\n\t * this.\r\n\t */\r\n\temptyAs?: any;\r\n\r\n\t/**\r\n\t * List of fields in data that hold numeric values. Parser will try to\r\n\t * convert the value in those fields to a `number`.\r\n\t */\r\n\tnumberFields?: string[];\r\n\r\n\t/**\r\n\t * List of fields in data that need to be treated as Dates, i.e. converted\r\n\t * to `Date` objects from whatever source format they are currently in.\r\n\t */\r\n\tdateFields?: string[];\r\n\r\n\t/**\r\n\t * An instance of [[DateFormatter]] to use when parsing string-based dates.\r\n\t * If it's not set, the parser will create it's own instance of\r\n\t * [[DateFormatter]], should any date parsing required. (`dateFields` is set)\r\n\t *\r\n\t * Unless `dateFormat` is set in parser options, the parser will try to look\r\n\t * for `dateFormat` in `dateFormatter`.\r\n\t *\r\n\t * @see {@link https://www.amcharts.com/docs/v4/concepts/formatters/formatting-date-time/#Parsing_Dates} Tutorial on date parsing\r\n\t */\r\n\tdateFormatter?: DateFormatter;\r\n\r\n\t/**\r\n\t * Override date format set in `dateFormatter`.\r\n\t *\r\n\t * @see {@link https://www.amcharts.com/docs/v4/concepts/formatters/formatting-date-time/#Parsing_Dates} Tutorial on date parsing\r\n\t */\r\n\tdateFormat?: string;\r\n\r\n}\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Base class for the data parsers.\r\n */\r\nexport class DataParser {\r\n\r\n\t/**\r\n\t * Content type, relevant to the specific format.\r\n\t */\r\n\tpublic contentType: string;\r\n\r\n\t/**\r\n\t * Parser options.\r\n\t *\r\n\t * @see {@link IDataParserOptions} for description of each option\r\n\t */\r\n\tpublic options: IDataParserOptions;\r\n\r\n\t/**\r\n\t * A \"placeholder\" function for real parsers to override.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param data  Source data\r\n\t * @return Parsed data (empty)\r\n\t */\r\n\tpublic parse(data: string): any {\r\n\t\treturn [];\r\n\t};\r\n\r\n\t/**\r\n\t * Checks if there are any numeric fields that need to be converted to\r\n\t * numbers.\r\n\t *\r\n\t * @return Numeric fields?\r\n\t */\r\n\tprotected get parsableNumbers(): boolean {\r\n\t\treturn this.options.numberFields && (this.options.numberFields.length > 0);\r\n\t}\r\n\r\n\t/**\r\n\t * Converts a value to 'number' if it is in `numberFields`.\r\n\t *\r\n\t * @param field  Field name\r\n\t * @param value  Value\r\n\t * @return Parsed or original value\r\n\t */\r\n\tprotected maybeToNumber(field: string, value: any): any {\r\n\t\tif (this.options.numberFields.indexOf(field) !== -1) {\r\n\t\t\treturn $utils.anyToNumber(value);\r\n\t\t}\r\n\t\treturn value;\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if there are any date fields that need to be converted to `Date`\r\n\t * objects.\r\n\t *\r\n\t * @return Date fields?\r\n\t */\r\n\tprotected get parsableDates(): boolean {\r\n\t\treturn this.options.dateFields && (this.options.dateFields.length > 0);\r\n\t}\r\n\r\n\t/**\r\n\t * Converts a value to `Date` if it is in `dateFields`.\r\n\t *\r\n\t * @param field  Field name\r\n\t * @param value  Value\r\n\t * @return Parsed or original value\r\n\t */\r\n\tprotected maybeToDate(field: string, value: any): any {\r\n\t\tif (this.options.dateFields.indexOf(field) !== -1) {\r\n\t\t\treturn this.options.dateFormatter.parse(value, this.dateFormat);\r\n\t\t}\r\n\t\treturn value;\r\n\t}\r\n\r\n\t/**\r\n\t * Replaces empty value with something else.\r\n\t *\r\n\t * @param value  Source value\r\n\t * @return Source value or replacement\r\n\t */\r\n\tprotected maybeToEmpty(value: any): any {\r\n\t\tif ((!$type.hasValue(value) || value == \"\") && $type.hasValue(this.options.emptyAs)) {\r\n\t\t\treturn this.options.emptyAs;\r\n\t\t}\r\n\t\treturn value;\r\n\t}\r\n\r\n\t/**\r\n\t * [[DateFormatter]] object for date parsing.\r\n\t *\r\n\t * If there was not [[DateFormatter]] supplied in parser options, a new one\r\n\t * is created.\r\n\t *\r\n\t * @return Date formatter\r\n\t * @see {@link DateFormatter}\r\n\t */\r\n\tprotected get dateFormatter(): DateFormatter {\r\n\t\tif (!this.options.dateFormatter) {\r\n\t\t\tthis.options.dateFormatter = new DateFormatter;\r\n\t\t\tif (this.options.dateFormat) {\r\n\t\t\t\tthis.options.dateFormat = this.options.dateFormat;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn this.options.dateFormatter;\r\n\t}\r\n\r\n\t/**\r\n\t * A date format to use when parsing dates.\r\n\t *\r\n\t * @return Date format\r\n\t * @see {@link DateFormatter}\r\n\t */\r\n\tprotected get dateFormat(): string {\r\n\t\treturn this.options.dateFormat || this.dateFormatter.inputDateFormat;\r\n\t}\r\n\r\n}\r\n"]},"metadata":{},"sourceType":"module"}