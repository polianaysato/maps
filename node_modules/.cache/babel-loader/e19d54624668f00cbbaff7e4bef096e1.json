{"ast":null,"code":"/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\nimport { Dictionary } from \"./Dictionary\";\nimport * as $type from \"./Type\";\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * Represents object cache.\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Better storage\r\n * @todo TTL logging\r\n * @todo Garbage collector\r\n */\n\nvar Cache =\n/** @class */\nfunction () {\n  function Cache() {\n    /**\r\n     * Storage for cache items.\r\n     */\n    this._storage = new Dictionary();\n    /**\r\n     * Default TTL in milliseconds.\r\n     */\n\n    this.ttl = 1000;\n  }\n  /**\r\n   * Caches or updates cached value, resets TTL.\r\n   *\r\n   * If `ttl` is set to zero, item will never expire.\r\n   *\r\n   * @param owner  An id of the object that owns this cache\r\n   * @param key    Index key\r\n   * @param value  Value\r\n   * @param ttl    TTL of the cache to live in milliseconds\r\n   */\n\n\n  Cache.prototype.set = function (owner, key, value, ttl) {\n    // Create if storage does not exist for this owner\n    var ownerStorage = this._storage.insertKeyIfEmpty(owner, function () {\n      return new Dictionary();\n    }); // Create cache item\n\n\n    var item = {\n      \"touched\": new Date().getTime(),\n      \"ttl\": $type.isNumber(ttl) ? ttl : this.ttl,\n      \"value\": value\n    }; // Set\n\n    ownerStorage.setKey(key, item);\n  };\n  /**\r\n   * Rerturns cached item, respecting TTL.\r\n   *\r\n   * @param owner  An id of the object that owns this cache\r\n   * @param key    Index key\r\n   * @param value  Value to return if cache not available\r\n   * @return Value, or `undefined` if not set\r\n   */\n\n\n  Cache.prototype.get = function (owner, key, value) {\n    if (value === void 0) {\n      value = undefined;\n    } // \t\t || ypeof this._storage[owner][key] === \"undefined\" || this._storage[owner][key].expired === true) {\n\n\n    if (this._storage.hasKey(owner)) {\n      var ownerStorage = this._storage.getKey(owner);\n\n      if (ownerStorage.hasKey(key)) {\n        var cacheItem = ownerStorage.getKey(key);\n\n        if (cacheItem.ttl && cacheItem.touched + cacheItem.ttl < new Date().getTime()) {\n          cacheItem.expired = true;\n        }\n\n        if (cacheItem.expired) {\n          ownerStorage.removeKey(key);\n          return value;\n        }\n\n        return cacheItem.value;\n      } else {\n        return value;\n      }\n    } else {\n      return value;\n    }\n  };\n  /**\r\n   * Clears cache for specific owner or everything.\r\n   *\r\n   * @param owner Owner to clear cache for\r\n   */\n\n\n  Cache.prototype.clear = function (owner) {\n    if (owner) {\n      this._storage.removeKey(owner);\n    } else {\n      this._storage.clear();\n    }\n  };\n\n  return Cache;\n}();\n\nexport { Cache };\n/**\r\n * ============================================================================\r\n * GLOBAL INSTANCE\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * A global instance of cache. Use this instance to cache any values.\r\n *\r\n * @ignore Exclude from docs\r\n */\n\nexport var cache = new Cache();","map":{"version":3,"mappings":"AAAA;;;;;;AAMA,SAASA,UAAT,QAA2B,cAA3B;AACA,OAAO,KAAKC,KAAZ,MAAuB,QAAvB;AAwCA;;;;;;;AAOA;;;;;;;;;AAQA;AAAA;AAAA;AAAA;AAEC;;;AAGQ,oBAAW,IAAID,UAAJ,EAAX;AAER;;;;AAGO,eAAc,IAAd;AA2EP;AAzEA;;;;;;;;;;;;AAUOE,wBAAP,UAAWC,KAAX,EAA0BC,GAA1B,EAAuCC,KAAvC,EAAiDC,GAAjD,EAA6D;AAE5D;AACA,QAAIC,YAAY,GAAG,KAAKC,QAAL,CAAcC,gBAAd,CAA+BN,KAA/B,EAAsC;AAAM,iBAAIH,UAAJ;AAAsC,KAAlF,CAAnB,CAH4D,CAK5D;;;AACA,QAAIU,IAAI,GAAiB;AACxB,iBAAW,IAAIC,IAAJ,GAAWC,OAAX,EADa;AAExB,aAAOX,KAAK,CAACY,QAAN,CAAeP,GAAf,IAAsBA,GAAtB,GAA4B,KAAKA,GAFhB;AAGxB,eAASD;AAHe,KAAzB,CAN4D,CAY5D;;AACAE,gBAAY,CAACO,MAAb,CAAoBV,GAApB,EAAyBM,IAAzB;AACA,GAdM;AAgBP;;;;;;;;;;AAQOR,wBAAP,UAAWC,KAAX,EAA0BC,GAA1B,EAAuCC,KAAvC,EAA6D;AAAtB;AAAAA;AAAsB,MAC5D;;;AACA,QAAI,KAAKG,QAAL,CAAcO,MAAd,CAAqBZ,KAArB,CAAJ,EAAiC;AAChC,UAAII,YAAY,GAAqC,KAAKC,QAAL,CAAcQ,MAAd,CAAqBb,KAArB,CAArD;;AAEA,UAAII,YAAY,CAACQ,MAAb,CAAoBX,GAApB,CAAJ,EAA8B;AAC7B,YAAIa,SAAS,GAA+BV,YAAY,CAACS,MAAb,CAAoBZ,GAApB,CAA5C;;AACA,YAAIa,SAAS,CAACX,GAAV,IAAmBW,SAAS,CAACC,OAAV,GAAoBD,SAAS,CAACX,GAA/B,GAAsC,IAAIK,IAAJ,GAAWC,OAAX,EAA5D,EAAmF;AAClFK,mBAAS,CAACE,OAAV,GAAoB,IAApB;AACA;;AACD,YAAIF,SAAS,CAACE,OAAd,EAAuB;AACtBZ,sBAAY,CAACa,SAAb,CAAuBhB,GAAvB;AACA,iBAAOC,KAAP;AACA;;AACD,eAAOY,SAAS,CAACZ,KAAjB;AACA,OAVD,MAWK;AACJ,eAAOA,KAAP;AACA;AACD,KAjBD,MAkBK;AACJ,aAAOA,KAAP;AACA;AACD,GAvBM;AAyBP;;;;;;;AAKOH,0BAAP,UAAaC,KAAb,EAA2B;AAC1B,QAAIA,KAAJ,EAAW;AACV,WAAKK,QAAL,CAAcY,SAAd,CAAwBjB,KAAxB;AACA,KAFD,MAGK;AACJ,WAAKK,QAAL,CAAca,KAAd;AACA;AACD,GAPM;;AASR;AAAC,CArFD;;;AAuFA;;;;;;;AAOA;;;;;;AAKA,OAAO,IAAIC,KAAK,GAAe,IAAIpB,KAAJ,EAAxB","names":["Dictionary","$type","Cache","owner","key","value","ttl","ownerStorage","_storage","insertKeyIfEmpty","item","Date","getTime","isNumber","setKey","hasKey","getKey","cacheItem","touched","expired","removeKey","clear","cache"],"sourceRoot":"","sources":["../../../../../src/.internal/core/utils/Cache.ts"],"sourcesContent":["/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { Dictionary } from \"./Dictionary\";\r\nimport * as $type from \"./Type\";\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * REQUISITES\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Defines an interface for cache items.\r\n */\r\ninterface CacheItem<A> {\r\n\r\n\t/**\r\n\t * A timestamp of when the item was created/updated.\r\n\t */\r\n\t\"touched\": number,\r\n\r\n\t/**\r\n\t * TTL (time to live) in milliseconds.\r\n\t */\r\n\t\"ttl\"?: number,\r\n\r\n\t/**\r\n\t * Cached value.\r\n\t */\r\n\t\"value\": A,\r\n\r\n\t/**\r\n\t * Is this item expired?\r\n\t *\r\n\t * @todo a system process that would check chace element TTLs and expire them\r\n\t */\r\n\t\"expired\"?: boolean\r\n\r\n}\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Represents object cache.\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Better storage\r\n * @todo TTL logging\r\n * @todo Garbage collector\r\n */\r\nexport class Cache<A> {\r\n\r\n\t/**\r\n\t * Storage for cache items.\r\n\t */\r\n\tprivate _storage = new Dictionary<string, Dictionary<string, CacheItem<A>>>();\r\n\r\n\t/**\r\n\t * Default TTL in milliseconds.\r\n\t */\r\n\tpublic ttl: number = 1000;\r\n\r\n\t/**\r\n\t * Caches or updates cached value, resets TTL.\r\n\t *\r\n\t * If `ttl` is set to zero, item will never expire.\r\n\t *\r\n\t * @param owner  An id of the object that owns this cache\r\n\t * @param key    Index key\r\n\t * @param value  Value\r\n\t * @param ttl    TTL of the cache to live in milliseconds\r\n\t */\r\n\tpublic set(owner: string, key: string, value: A, ttl?: number): void {\r\n\r\n\t\t// Create if storage does not exist for this owner\r\n\t\tlet ownerStorage = this._storage.insertKeyIfEmpty(owner, () => new Dictionary<string, CacheItem<A>>());\r\n\r\n\t\t// Create cache item\r\n\t\tlet item: CacheItem<A> = {\r\n\t\t\t\"touched\": new Date().getTime(),\r\n\t\t\t\"ttl\": $type.isNumber(ttl) ? ttl : this.ttl,\r\n\t\t\t\"value\": value\r\n\t\t};\r\n\r\n\t\t// Set\r\n\t\townerStorage.setKey(key, item);\r\n\t}\r\n\r\n\t/**\r\n\t * Rerturns cached item, respecting TTL.\r\n\t *\r\n\t * @param owner  An id of the object that owns this cache\r\n\t * @param key    Index key\r\n\t * @param value  Value to return if cache not available\r\n\t * @return Value, or `undefined` if not set\r\n\t */\r\n\tpublic get(owner: string, key: string, value: any = undefined): $type.Optional<A> {\r\n\t\t// \t\t || ypeof this._storage[owner][key] === \"undefined\" || this._storage[owner][key].expired === true) {\r\n\t\tif (this._storage.hasKey(owner)) {\r\n\t\t\tlet ownerStorage = <Dictionary<string, CacheItem<A>>>this._storage.getKey(owner);\r\n\r\n\t\t\tif (ownerStorage.hasKey(key)) {\r\n\t\t\t\tlet cacheItem: CacheItem<A> = <CacheItem<A>>ownerStorage.getKey(key);\r\n\t\t\t\tif (cacheItem.ttl && ((cacheItem.touched + cacheItem.ttl) < new Date().getTime())) {\r\n\t\t\t\t\tcacheItem.expired = true;\r\n\t\t\t\t}\r\n\t\t\t\tif (cacheItem.expired) {\r\n\t\t\t\t\townerStorage.removeKey(key);\r\n\t\t\t\t\treturn value;\r\n\t\t\t\t}\r\n\t\t\t\treturn cacheItem.value;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\treturn value;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn value;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Clears cache for specific owner or everything.\r\n\t *\r\n\t * @param owner Owner to clear cache for\r\n\t */\r\n\tpublic clear(owner?: string): void {\r\n\t\tif (owner) {\r\n\t\t\tthis._storage.removeKey(owner);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tthis._storage.clear();\r\n\t\t}\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * ============================================================================\r\n * GLOBAL INSTANCE\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * A global instance of cache. Use this instance to cache any values.\r\n *\r\n * @ignore Exclude from docs\r\n */\r\nexport let cache: Cache<any> = new Cache();\r\n"]},"metadata":{},"sourceType":"module"}