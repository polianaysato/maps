{"ast":null,"code":"/**\r\n * Axis Label module\r\n */\nimport { __extends } from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\nimport { AxisLabel } from \"./AxisLabel\";\nimport { registry } from \"../../core/Registry\";\nimport * as $math from \"../../core/utils/Math\";\nimport * as $type from \"../../core/utils/Type\";\nimport * as $path from \"../../core/rendering/Path\";\nimport * as $utils from \"../../core/utils/Utils\";\nimport { Percent } from \"../../core/utils/Percent\";\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * Use to create labels on circular axis.\r\n *\r\n * @see {@link IAxisLabelCircularEvents} for a list of available events\r\n * @see {@link IAxisLabelCircularAdapters} for a list of available Adapters\r\n */\n\nvar AxisLabelCircular =\n/** @class */\nfunction (_super) {\n  __extends(AxisLabelCircular, _super);\n  /**\r\n   * Constructor\r\n   */\n\n\n  function AxisLabelCircular() {\n    var _this = _super.call(this) || this;\n    /**\r\n     *\r\n     * @ignore\r\n     */\n\n\n    _this.fdx = 0;\n    /**\r\n     *\r\n     * @ignore\r\n     */\n\n    _this.fdy = 0;\n    _this.className = \"AxisLabelCircular\";\n\n    _this.padding(0, 0, 0, 0);\n\n    _this.location = 0.5;\n    _this.locationOnPath = 0.5;\n    _this.radius = 0;\n    _this.isMeasured = false;\n\n    _this.applyTheme();\n\n    return _this;\n  }\n\n  Object.defineProperty(AxisLabelCircular.prototype, \"relativeRotation\", {\n    /**\r\n     * @return Rotation angle\r\n     */\n    get: function get() {\n      return this.getPropertyValue(\"relativeRotation\");\n    },\n\n    /**\r\n     * Relative rotation of the label.\r\n     *\r\n     * It is an angle to circle. In case 90, labels will be positioned like rays\r\n     * of light, if 0 - positioned along the circle.\r\n     *\r\n     * @param value Rotation angle\r\n     */\n    set: function set(value) {\n      this.setPropertyValue(\"relativeRotation\", value, true);\n\n      if (!$type.hasValue(value)) {\n        this.rotation = undefined;\n        var dataItem = this.dataItem;\n\n        if (dataItem && dataItem.component) {\n          dataItem.component.invalidateDataItems();\n        }\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(AxisLabelCircular.prototype, \"radius\", {\n    /**\r\n     * @return Distance (px)\r\n     */\n    get: function get() {\n      return this.getPropertyValue(\"radius\");\n    },\n\n    /**\r\n     * Distance from axis circle to label in pixels or percent.\r\n     *\r\n     * @param value Distance (px or percent)\r\n     */\n    set: function set(value) {\n      this.setPercentProperty(\"radius\", value, true, false, 10, false);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(AxisLabelCircular.prototype, \"bent\", {\n    /**\r\n     * @return Bent?\r\n     */\n    get: function get() {\n      return this.getPropertyValue(\"bent\");\n    },\n\n    /**\r\n     * Specifies if label should be bent along the circle.\r\n     *\r\n     * IMPORTANT: Use this with caution, since it is quite CPU-greedy.\r\n     *\r\n     * @since 4.1.2\r\n     * @default false\r\n     * @param  value  Bent?\r\n     */\n    set: function set(value) {\n      this.setPropertyValue(\"bent\", value, true);\n      this.setPropertyValue(\"wrap\", false);\n      this.setPropertyValue(\"horizontalCenter\", \"none\");\n      this.setPropertyValue(\"verticalCenter\", \"none\");\n\n      if (value) {\n        this.setPropertyValue(\"dx\", 0);\n        this.setPropertyValue(\"dy\", 0);\n        this.setPropertyValue(\"x\", 0);\n        this.setPropertyValue(\"y\", 0);\n        this.setPropertyValue(\"rotation\", 0); //this.setPropertyValue(\"relativeRotation\", undefined);\n\n        this.fdx = 0;\n        this.fdy = 0;\n        this.textAlign = \"middle\";\n      } else {\n        if (this.textPathElement) {\n          this.textPathElement.dispose();\n          this.textPathElement = undefined;\n        }\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Returns label radius in pixels.\r\n   *\r\n   * @param   axisRadius  Radius\r\n   * @return              Pixel radius\r\n   */\n\n  AxisLabelCircular.prototype.pixelRadius = function (axisRadius) {\n    var sign = 1;\n\n    if (this.inside) {\n      sign = -1;\n    }\n\n    return $utils.relativeToValue(this.radius, axisRadius) * sign;\n  };\n  /**\r\n   * Returns label horizontal radius in pixels.\r\n   *\r\n   * @param   axisRadius   Radius\r\n   * @param   axisRadiusY  Vertical radius\r\n   * @return               Radius\r\n   */\n\n\n  AxisLabelCircular.prototype.pixelRadiusY = function (axisRadius, axisRadiusY) {\n    var sign = 1;\n\n    if (this.inside) {\n      sign = -1;\n    }\n\n    var radius = this.radius;\n\n    if ($type.isNumber(radius)) {\n      radius *= axisRadiusY / axisRadius;\n      return $utils.relativeToValue(radius, axisRadius) * sign;\n    } else {\n      return $utils.relativeToValue(radius, axisRadiusY) * sign;\n    }\n  };\n  /**\r\n   * [fixPosition description]\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description\r\n   * @param point       Label affixation point\r\n   * @param axisRadius  Distance from point (px)\r\n   */\n\n\n  AxisLabelCircular.prototype.fixPosition = function (angle, axisRadius, axisRadiusY, dx, dy) {\n    if (!$type.isNumber(axisRadiusY)) {\n      axisRadiusY = axisRadius;\n    }\n\n    if (!$type.isNumber(dx)) {\n      dx = 0;\n    }\n\n    if (!$type.isNumber(dy)) {\n      dy = 0;\n    }\n\n    var point = {\n      x: axisRadius * $math.cos(angle),\n      y: axisRadiusY * $math.sin(angle)\n    };\n\n    if (this.invalid) {\n      this.validate(); //@todo\" check if we need this\n    }\n\n    var isNegative = false;\n    var realRadius = this.radius;\n\n    if (realRadius instanceof Percent && realRadius.value < 0) {\n      isNegative = true;\n    } else if (realRadius < 0) {\n      isNegative = true;\n    }\n\n    var relativeRotation = this.relativeRotation;\n    var labelRadius = this.pixelRadius(axisRadius);\n\n    if (this.bent) {\n      var point_1 = {\n        x: (axisRadius + labelRadius) * $math.cos(angle + 180),\n        y: (axisRadiusY + labelRadius * axisRadiusY / axisRadius) * $math.sin(angle + 180)\n      };\n      this.path = $path.moveTo(point_1) + $path.arcTo(angle + 180, 360, axisRadius + labelRadius, axisRadiusY + labelRadius * axisRadiusY / axisRadius);\n\n      if (this.textPathElement) {\n        this.textPathElement.attr({\n          \"startOffset\": this.locationOnPath * 100 + \"%\"\n        });\n      }\n\n      return;\n    } // WHEN ROTATED\n\n\n    if ($type.isNumber(relativeRotation)) {\n      this.horizontalCenter = \"none\";\n      this.verticalCenter = \"none\";\n      angle = $math.fitAngleToRange(angle, -180, 180);\n      var pixelWidth = this.bbox.width;\n      var pixelHeight = this.bbox.height;\n      var pixelPaddingBottom = this.pixelPaddingBottom;\n      var pixelPaddingTop = this.pixelPaddingTop;\n      var pixelPaddingLeft = this.pixelPaddingLeft;\n      var pixelPaddingRight = this.pixelPaddingRight;\n\n      if (angle > 90 || angle < -90) {\n        if (relativeRotation == -90) {\n          relativeRotation = 90;\n          pixelWidth = 0;\n        }\n      } else {\n        if (relativeRotation == -90) {\n          pixelHeight = -pixelHeight;\n        }\n\n        if (relativeRotation == 90) {\n          relativeRotation = -90;\n          pixelWidth = -pixelPaddingLeft - pixelPaddingRight;\n          pixelHeight = -pixelHeight - pixelPaddingTop - pixelPaddingBottom;\n        }\n      }\n\n      this.rotation = relativeRotation + angle + 90;\n      var dH = $math.sin(relativeRotation) / 2;\n      var dW = $math.cos(relativeRotation) / 2;\n      var rotation = this.rotation;\n      this.dx = pixelHeight * dH * $math.sin(rotation) - pixelWidth * dW * $math.cos(rotation);\n      this.dy = -pixelHeight * dH * $math.cos(rotation) - pixelWidth * dW * $math.sin(rotation);\n\n      if (!this.inside) {\n        labelRadius += (pixelHeight + pixelPaddingBottom + pixelPaddingTop) * $math.cos(relativeRotation) + (pixelWidth + pixelPaddingLeft + pixelPaddingRight) * $math.sin(relativeRotation);\n      } else {\n        if (angle > 90 || angle < -90) {\n          labelRadius -= (pixelPaddingBottom + pixelPaddingTop) * $math.cos(relativeRotation) + (pixelPaddingLeft + pixelPaddingRight) * $math.sin(relativeRotation);\n        } else {\n          labelRadius += (pixelPaddingBottom + this.bbox.height + pixelPaddingTop) * $math.cos(relativeRotation) + (pixelPaddingLeft + pixelPaddingRight + this.bbox.width) * $math.sin(relativeRotation);\n        }\n      }\n\n      point.x += $math.cos(angle) * labelRadius;\n      point.y += $math.sin(angle) * labelRadius * axisRadiusY / axisRadius;\n    } else {\n      // END OF ROTATED\n      this.horizontalCenter = \"middle\";\n      this.verticalCenter = \"middle\";\n\n      if (isNegative) {\n        this.dx = 0;\n        this.dy = 0;\n        point.x = (axisRadius + labelRadius) * $math.cos(angle);\n        point.y = (axisRadiusY + labelRadius * axisRadiusY / axisRadius) * $math.sin(angle);\n      } else {\n        // we don't use valign for labels because then they would jump while animating. instead we modify dy depending on a y position\n        // this math makes dy to be 1 at the top of the circle, 0.5 at the middle and 1 at the bottom\n        // @todo with this math doesn't work well with inside = true\n        this.dy = this._measuredHeight / 2 * $math.sin(angle); //(1 - (point.y + axisRadiusY) / (2 * axisRadiusY));\n        // simmilar with dx\n\n        this.dx = this._measuredWidth / 2 * $math.cos(angle); //(1 - (point.x + axisRadius) / (2 * axisRadius));\n\n        point.x += $math.cos(angle) * labelRadius;\n        point.y += $math.sin(angle) * labelRadius * axisRadiusY / axisRadius;\n      }\n    }\n\n    point.x += dx;\n    point.y += dy;\n    this.fdx = this.dx;\n    this.fdy = this.dy;\n    this.moveTo(point);\n  };\n\n  return AxisLabelCircular;\n}(AxisLabel);\n\nexport { AxisLabelCircular };\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\n\nregistry.registeredClasses[\"AxisLabelCircular\"] = AxisLabelCircular;","map":{"version":3,"mappings":"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","names":["AxisLabel","registry","$math","$type","$path","$utils","Percent","__extends","_super","_this","className","padding","location","locationOnPath","radius","isMeasured","applyTheme","Object","AxisLabelCircular","getPropertyValue","value","setPropertyValue","hasValue","rotation","undefined","dataItem","component","invalidateDataItems","setPercentProperty","fdx","fdy","textAlign","textPathElement","dispose","axisRadius","sign","inside","relativeToValue","axisRadiusY","isNumber","angle","dx","dy","point","x","cos","y","sin","invalid","validate","isNegative","realRadius","relativeRotation","labelRadius","pixelRadius","bent","point_1","path","moveTo","arcTo","attr","horizontalCenter","verticalCenter","fitAngleToRange","pixelWidth","bbox","width","pixelHeight","height","pixelPaddingBottom","pixelPaddingTop","pixelPaddingLeft","pixelPaddingRight","dH","dW","_measuredHeight","_measuredWidth","registeredClasses"],"sourceRoot":"","sources":["../../../../../src/.internal/charts/axes/AxisLabelCircular.ts"],"sourcesContent":["/**\r\n * Axis Label module\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { AxisLabel, IAxisLabelProperties, IAxisLabelAdapters, IAxisLabelEvents } from \"./AxisLabel\";\r\nimport { registry } from \"../../core/Registry\";\r\nimport * as $math from \"../../core/utils/Math\";\r\nimport * as $type from \"../../core/utils/Type\";\r\nimport * as $path from \"../../core/rendering/Path\";\r\nimport * as $utils from \"../../core/utils/Utils\";\r\nimport { Percent } from \"../../core/utils/Percent\";\r\n\r\n/**\r\n * ============================================================================\r\n * REQUISITES\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Defines properties for [[AxisLabelCircular]].\r\n */\r\nexport interface IAxisLabelCircularProperties extends IAxisLabelProperties {\r\n\r\n\t/**\r\n\t * Rotation angle of the label in relation to circle line.\r\n\t */\r\n\trelativeRotation?: number;\r\n\r\n\t/**\r\n\t * Distance of the label from circle line.\r\n\t */\r\n\tradius?: number | Percent;\r\n\r\n\t/**\r\n\t * Specifies if label should be bent along the circle\r\n\t *\r\n\t * @type {boolean}\r\n\t */\r\n\tbent?: boolean;\r\n}\r\n\r\n/**\r\n * Defines events for [[AxisLabelCircular]].\r\n */\r\nexport interface IAxisLabelCircularEvents extends IAxisLabelEvents { }\r\n\r\n/**\r\n * Defines adapters for [[AxisLabelCircular]].\r\n *\r\n * @see {@link Adapter}\r\n */\r\nexport interface IAxisLabelCircularAdapters extends IAxisLabelAdapters, IAxisLabelCircularProperties { }\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Use to create labels on circular axis.\r\n *\r\n * @see {@link IAxisLabelCircularEvents} for a list of available events\r\n * @see {@link IAxisLabelCircularAdapters} for a list of available Adapters\r\n */\r\nexport class AxisLabelCircular extends AxisLabel {\r\n\r\n\t/**\r\n\t * Defines available properties.\r\n\t */\r\n\tpublic _properties!: IAxisLabelCircularProperties;\r\n\r\n\t/**\r\n\t * Defines available adapters.\r\n\t */\r\n\tpublic _adapter!: IAxisLabelCircularAdapters;\r\n\r\n\t/**\r\n\t * Defines available events.\r\n\t */\r\n\tpublic _events!: IAxisLabelCircularEvents;\r\n\r\n\t/**\r\n\t * Related data item.\r\n\t */\r\n\tpublic _dataItem: any;\r\n\r\n\t/**\r\n\t *\r\n\t * @ignore\r\n\t */\r\n\tpublic fdx: number = 0;\r\n\r\n\t/**\r\n\t *\r\n\t * @ignore\r\n\t */\r\n\tpublic fdy: number = 0;\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor() {\r\n\t\tsuper();\r\n\t\tthis.className = \"AxisLabelCircular\";\r\n\t\tthis.padding(0, 0, 0, 0);\r\n\t\tthis.location = 0.5;\r\n\t\tthis.locationOnPath = 0.5;\r\n\t\tthis.radius = 0;\r\n\t\tthis.isMeasured = false;\r\n\t\tthis.applyTheme();\r\n\t}\r\n\r\n\t/**\r\n\t * Relative rotation of the label.\r\n\t *\r\n\t * It is an angle to circle. In case 90, labels will be positioned like rays\r\n\t * of light, if 0 - positioned along the circle.\r\n\t *\r\n\t * @param value Rotation angle\r\n\t */\r\n\tpublic set relativeRotation(value: number) {\r\n\t\tthis.setPropertyValue(\"relativeRotation\", value, true);\r\n\t\tif (!$type.hasValue(value)) {\r\n\t\t\tthis.rotation = undefined;\r\n\r\n\t\t\tlet dataItem = this.dataItem;\r\n\t\t\tif (dataItem && dataItem.component) {\r\n\t\t\t\tdataItem.component.invalidateDataItems();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @return Rotation angle\r\n\t */\r\n\tpublic get relativeRotation(): number {\r\n\t\treturn this.getPropertyValue(\"relativeRotation\");\r\n\t}\r\n\r\n\t/**\r\n\t * Distance from axis circle to label in pixels or percent.\r\n\t *\r\n\t * @param value Distance (px or percent)\r\n\t */\r\n\tpublic set radius(value: number | Percent) {\r\n\t\tthis.setPercentProperty(\"radius\", value, true, false, 10, false);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Distance (px)\r\n\t */\r\n\tpublic get radius(): number | Percent {\r\n\t\treturn this.getPropertyValue(\"radius\");\r\n\t}\r\n\r\n\t/**\r\n\t * Specifies if label should be bent along the circle.\r\n\t *\r\n\t * IMPORTANT: Use this with caution, since it is quite CPU-greedy.\r\n\t *\r\n\t * @since 4.1.2\r\n\t * @default false\r\n\t * @param  value  Bent?\r\n\t */\r\n\tpublic set bent(value: boolean) {\r\n\t\tthis.setPropertyValue(\"bent\", value, true);\r\n\t\tthis.setPropertyValue(\"wrap\", false);\r\n\t\tthis.setPropertyValue(\"horizontalCenter\", \"none\");\r\n\t\tthis.setPropertyValue(\"verticalCenter\", \"none\");\r\n\r\n\t\tif (value) {\r\n\t\t\tthis.setPropertyValue(\"dx\", 0);\r\n\t\t\tthis.setPropertyValue(\"dy\", 0);\r\n\t\t\tthis.setPropertyValue(\"x\", 0);\r\n\t\t\tthis.setPropertyValue(\"y\", 0);\r\n\t\t\tthis.setPropertyValue(\"rotation\", 0)\r\n\t\t\t//this.setPropertyValue(\"relativeRotation\", undefined);\r\n\t\t\tthis.fdx = 0;\r\n\t\t\tthis.fdy = 0;\r\n\t\t\tthis.textAlign = \"middle\";\r\n\t\t}\r\n\t\telse{\r\n\t\t\tif(this.textPathElement){\r\n\t\t\t\tthis.textPathElement.dispose();\r\n\t\t\t\tthis.textPathElement = undefined;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @return Bent?\r\n\t */\r\n\tpublic get bent(): boolean {\r\n\t\treturn this.getPropertyValue(\"bent\");\r\n\t}\r\n\r\n\t/**\r\n\t * Returns label radius in pixels.\r\n\t * \r\n\t * @param   axisRadius  Radius\r\n\t * @return              Pixel radius\r\n\t */\r\n\tpublic pixelRadius(axisRadius: number): number {\r\n\t\tlet sign: number = 1;\r\n\t\tif (this.inside) {\r\n\t\t\tsign = -1;\r\n\t\t}\r\n\r\n\t\treturn $utils.relativeToValue(this.radius, axisRadius) * sign;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns label horizontal radius in pixels.\r\n\t * \r\n\t * @param   axisRadius   Radius\r\n\t * @param   axisRadiusY  Vertical radius\r\n\t * @return               Radius\r\n\t */\r\n\tpublic pixelRadiusY(axisRadius: number, axisRadiusY: number): number {\r\n\t\tlet sign: number = 1;\r\n\t\tif (this.inside) {\r\n\t\t\tsign = -1;\r\n\t\t}\r\n\r\n\t\tlet radius = this.radius;\r\n\r\n\t\tif ($type.isNumber(radius)) {\r\n\t\t\tradius *= axisRadiusY / axisRadius;\r\n\t\t\treturn $utils.relativeToValue(radius, axisRadius) * sign;\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn $utils.relativeToValue(radius, axisRadiusY) * sign;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * [fixPosition description]\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description\r\n\t * @param point       Label affixation point\r\n\t * @param axisRadius  Distance from point (px)\r\n\t */\r\n\tpublic fixPosition(angle: number, axisRadius: number, axisRadiusY?: number, dx?: number, dy?: number) {\r\n\t\tif (!$type.isNumber(axisRadiusY)) {\r\n\t\t\taxisRadiusY = axisRadius;\r\n\t\t}\r\n\r\n\t\tif (!$type.isNumber(dx)) {\r\n\t\t\tdx = 0;\r\n\t\t}\r\n\r\n\t\tif (!$type.isNumber(dy)) {\r\n\t\t\tdy = 0;\r\n\t\t}\r\n\r\n\t\tlet point = { x: axisRadius * $math.cos(angle), y: axisRadiusY * $math.sin(angle) };\r\n\r\n\t\tif (this.invalid) {\r\n\t\t\tthis.validate();  //@todo\" check if we need this\r\n\t\t}\r\n\r\n\t\tlet isNegative = false;\r\n\t\tlet realRadius = this.radius;\r\n\r\n\t\tif (realRadius instanceof Percent && realRadius.value < 0) {\r\n\t\t\tisNegative = true;\r\n\t\t}\r\n\t\telse if (realRadius < 0) {\r\n\t\t\tisNegative = true;\r\n\t\t}\r\n\r\n\t\tlet relativeRotation = this.relativeRotation;\r\n\t\tlet labelRadius = this.pixelRadius(axisRadius);\r\n\r\n\t\tif (this.bent) {\r\n\t\t\tlet point = { x: (axisRadius + labelRadius )* $math.cos(angle + 180), y: (axisRadiusY + labelRadius * axisRadiusY / axisRadius) * $math.sin(angle + 180) };\r\n\t\t\tthis.path = $path.moveTo(point) + $path.arcTo(angle + 180, 360, axisRadius + labelRadius, axisRadiusY + labelRadius * axisRadiusY / axisRadius);\r\n\t\t\t\r\n\t\t\tif (this.textPathElement) {\r\n\t\t\t\tthis.textPathElement.attr({ \"startOffset\": (this.locationOnPath * 100) + \"%\" })\r\n\t\t\t}\r\n\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// WHEN ROTATED\r\n\t\tif ($type.isNumber(relativeRotation)) {\r\n\r\n\t\t\tthis.horizontalCenter = \"none\";\r\n\t\t\tthis.verticalCenter = \"none\";\r\n\r\n\t\t\tangle = $math.fitAngleToRange(angle, -180, 180);\r\n\r\n\t\t\tlet pixelWidth = this.bbox.width;\r\n\t\t\tlet pixelHeight = this.bbox.height;\r\n\r\n\t\t\tlet pixelPaddingBottom = this.pixelPaddingBottom;\r\n\t\t\tlet pixelPaddingTop = this.pixelPaddingTop;\r\n\t\t\tlet pixelPaddingLeft = this.pixelPaddingLeft;\r\n\t\t\tlet pixelPaddingRight = this.pixelPaddingRight;\r\n\r\n\t\t\tif (angle > 90 || angle < -90) {\r\n\t\t\t\tif (relativeRotation == -90) {\r\n\t\t\t\t\trelativeRotation = 90;\r\n\t\t\t\t\tpixelWidth = 0;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tif (relativeRotation == -90) {\r\n\t\t\t\t\tpixelHeight = - pixelHeight;\r\n\t\t\t\t}\r\n\t\t\t\tif (relativeRotation == 90) {\r\n\t\t\t\t\trelativeRotation = -90;\r\n\t\t\t\t\tpixelWidth = -pixelPaddingLeft - pixelPaddingRight;\r\n\t\t\t\t\tpixelHeight = - pixelHeight - pixelPaddingTop - pixelPaddingBottom;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tthis.rotation = relativeRotation + angle + 90;\r\n\r\n\t\t\tlet dH = $math.sin(relativeRotation) / 2;\r\n\t\t\tlet dW = $math.cos(relativeRotation) / 2;\r\n\r\n\t\t\tlet rotation = this.rotation;\r\n\r\n\t\t\tthis.dx = pixelHeight * dH * $math.sin(rotation) - pixelWidth * dW * $math.cos(rotation);\r\n\t\t\tthis.dy = -pixelHeight * dH * $math.cos(rotation) - pixelWidth * dW * $math.sin(rotation);\r\n\r\n\t\t\tif (!this.inside) {\r\n\t\t\t\tlabelRadius += (pixelHeight + pixelPaddingBottom + pixelPaddingTop) * $math.cos(relativeRotation) + (pixelWidth + pixelPaddingLeft + pixelPaddingRight) * $math.sin(relativeRotation);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tif (angle > 90 || angle < -90) {\r\n\t\t\t\t\tlabelRadius -= (pixelPaddingBottom + pixelPaddingTop) * $math.cos(relativeRotation) + (pixelPaddingLeft + pixelPaddingRight) * $math.sin(relativeRotation);\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tlabelRadius += (pixelPaddingBottom + this.bbox.height + pixelPaddingTop) * $math.cos(relativeRotation) + (pixelPaddingLeft + pixelPaddingRight + this.bbox.width) * $math.sin(relativeRotation);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tpoint.x += $math.cos(angle) * labelRadius;\r\n\t\t\tpoint.y += $math.sin(angle) * labelRadius * axisRadiusY / axisRadius;\r\n\t\t}\r\n\t\telse {\r\n\t\t\t// END OF ROTATED\r\n\t\t\tthis.horizontalCenter = \"middle\";\r\n\t\t\tthis.verticalCenter = \"middle\";\r\n\r\n\t\t\tif (isNegative) {\r\n\t\t\t\tthis.dx = 0;\r\n\t\t\t\tthis.dy = 0;\r\n\t\t\t\tpoint.x = (axisRadius + labelRadius) * $math.cos(angle);\r\n\t\t\t\tpoint.y = (axisRadiusY + labelRadius * axisRadiusY / axisRadius) * $math.sin(angle);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t// we don't use valign for labels because then they would jump while animating. instead we modify dy depending on a y position\r\n\t\t\t\t// this math makes dy to be 1 at the top of the circle, 0.5 at the middle and 1 at the bottom\r\n\t\t\t\t// @todo with this math doesn't work well with inside = true\r\n\t\t\t\tthis.dy = this._measuredHeight / 2 * $math.sin(angle) //(1 - (point.y + axisRadiusY) / (2 * axisRadiusY));\r\n\t\t\t\t// simmilar with dx\r\n\t\t\t\tthis.dx = this._measuredWidth / 2 * $math.cos(angle) //(1 - (point.x + axisRadius) / (2 * axisRadius));\r\n\r\n\t\t\t\tpoint.x += $math.cos(angle) * labelRadius;\r\n\t\t\t\tpoint.y += $math.sin(angle) * labelRadius * axisRadiusY / axisRadius;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tpoint.x += dx;\r\n\t\tpoint.y += dy;\r\n\r\n\t\tthis.fdx = this.dx;\r\n\t\tthis.fdy = this.dy;\r\n\r\n\t\tthis.moveTo(point);\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\r\nregistry.registeredClasses[\"AxisLabelCircular\"] = AxisLabelCircular;\r\n"]},"metadata":{},"sourceType":"module"}