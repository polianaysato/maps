{"ast":null,"code":"/**\r\n * Polygon module.\r\n */\nimport { __extends } from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\nimport { Sprite } from \"../Sprite\";\nimport { Morpher } from \"../utils/Morpher\";\nimport { registry } from \"../Registry\";\nimport * as $path from \"../rendering/Path\";\nimport * as $type from \"../utils/Type\";\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * Draws a polygon.\r\n *\r\n * @see {@link IPolygonEvents} for a list of available events\r\n * @see {@link IPolygonAdapters} for a list of available Adapters\r\n */\n\nvar Polygon =\n/** @class */\nfunction (_super) {\n  __extends(Polygon, _super);\n  /**\r\n   * Constructor\r\n   */\n\n\n  function Polygon() {\n    var _this = _super.call(this) || this;\n\n    _this.className = \"Polygon\";\n    _this.element = _this.paper.add(\"path\");\n    _this.shapeRendering = \"auto\";\n    _this._currentPoints = [];\n\n    _this.applyTheme();\n\n    return _this;\n  }\n\n  Object.defineProperty(Polygon.prototype, \"points\", {\n    /**\r\n     * @return Polygon points\r\n     */\n    get: function get() {\n      var points = this.getPropertyValue(\"points\");\n      var path = this.path;\n\n      if (path && (!points || points.length == 0)) {\n        var valueStr = path.slice(1, path.length - 1);\n        var segments = valueStr.split(\"ZM\");\n\n        for (var s = 0; s < segments.length; s++) {\n          var segment = segments[s];\n\n          if (segment.length > 0) {\n            var areaHole = segment.split(\"M\");\n            var areaArr = areaHole[0];\n            var holeArr = areaHole[1];\n\n            if (areaArr && areaArr.length > 0) {\n              var pointsArr = areaArr.split(\"L\");\n\n              if (pointsArr.length > 0) {\n                var area = [];\n                var areaAndHole = [area];\n                points.push(areaAndHole);\n\n                for (var p = 0; p < pointsArr.length; p++) {\n                  var coords = pointsArr[p].split(\",\");\n                  area.push({\n                    x: +coords[0],\n                    y: +coords[1]\n                  });\n                }\n\n                if (holeArr && holeArr.length > 0) {\n                  var pointsArr_1 = holeArr.split(\"L\");\n\n                  if (pointsArr_1.length > 0) {\n                    var hole = [];\n                    areaAndHole.push(hole);\n\n                    for (var p = pointsArr_1.length - 1; p >= 0; p--) {\n                      var coords = pointsArr_1[p].split(\",\");\n                      hole.push({\n                        x: +coords[0],\n                        y: +coords[1]\n                      });\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n\n        this.setPropertyValue(\"points\", points);\n        this._currentPoints = points;\n      }\n\n      return points;\n    },\n\n    /**\r\n     * An array of X/Y coordinates for each elbow of the polygon.\r\n     *\r\n     * @todo Example\r\n     * @param points  Polygon points\r\n     */\n    set: function set(points) {\n      this.setPropertyValue(\"points\", points, true);\n      this._currentPoints = points;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Polygon.prototype, \"currentPoints\", {\n    /**\r\n     * @return Polygon points\r\n     */\n    get: function get() {\n      if ((!this._currentPoints || this._currentPoints.length == 0) && this.path) {\n        this._currentPoints = this.points;\n      }\n\n      return this._currentPoints;\n    },\n\n    /**\r\n     * Current points. Used when morphing the element, so that original `points`\r\n     * are not overwritten.\r\n     *\r\n     * @param points  Polygon points\r\n     */\n    set: function set(points) {\n      if (this._currentPoints != points) {\n        this._currentPoints = points;\n        this.draw();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Draws the element.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n  Polygon.prototype.draw = function () {\n    var path = \"\";\n    var points = this._currentPoints;\n    var left;\n    var right;\n    var top;\n    var bottom;\n\n    if (points.length > 0) {\n      // separate areas\n      for (var i = 0, len = points.length; i < len; i++) {\n        // surface\n        var surface = points[i][0];\n        var hole = points[i][1];\n\n        if (surface && surface.length > 0) {\n          var point = surface[0];\n          path += $path.moveTo(point);\n\n          for (var s = 0; s < surface.length; s++) {\n            point = surface[s];\n            path += $path.lineTo(point);\n\n            if (!$type.isNumber(right) || right < point.x) {\n              right = point.x;\n            }\n\n            if (!$type.isNumber(left) || left > point.x) {\n              left = point.x;\n            }\n\n            if (!$type.isNumber(top) || top > point.y) {\n              top = point.y;\n            }\n\n            if (!$type.isNumber(bottom) || bottom < point.y) {\n              bottom = point.y;\n            }\n          }\n        } // hole\n\n\n        if (hole && hole.length > 0) {\n          var point = hole[0];\n          path += $path.moveTo(point);\n\n          for (var h = 0, hlen = hole.length; h < hlen; h++) {\n            point = hole[h];\n            path += $path.lineTo(point);\n          }\n        }\n      }\n\n      if (path) {\n        path += $path.closePath();\n      }\n\n      this.bbox.x = left;\n      this.bbox.y = top;\n      this.bbox.width = right - left;\n      this.bbox.height = bottom - top;\n\n      _super.prototype.setPath.call(this, path);\n    }\n  };\n  /**\r\n   * @ignore\r\n   */\n\n\n  Polygon.prototype.setPath = function (value) {\n    if (_super.prototype.setPath.call(this, value)) {\n      this.points = [];\n      this._bbox = this.group.getBBox();\n      return true;\n    }\n\n    return false;\n  };\n  /**\r\n   * Measures element\r\n   */\n\n\n  Polygon.prototype.measureElement = function () {// Overriding to avoid extra measurement.\n  };\n\n  Object.defineProperty(Polygon.prototype, \"centerPoint\", {\n    /**\r\n     * A calculated center point for the shape.\r\n     *\r\n     * @readonly\r\n     * @return Center\r\n     */\n    get: function get() {\n      return {\n        x: this.bbox.x + this.bbox.width / 2,\n        y: this.bbox.y + this.bbox.height / 2\n      };\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Polygon.prototype, \"morpher\", {\n    /**\r\n     * A [[Morpher]] instance that is used to morph polygon into some other\r\n     * shape.\r\n     *\r\n     * @readonly\r\n     * @return Morpher instance\r\n     */\n    get: function get() {\n      if (!this._morpher) {\n        this._morpher = new Morpher(this);\n\n        this._disposers.push(this._morpher);\n      }\n\n      return this._morpher;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return Polygon;\n}(Sprite);\n\nexport { Polygon };\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\n\nregistry.registeredClasses[\"Polygon\"] = Polygon;","map":{"version":3,"mappings":"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","names":["Sprite","Morpher","registry","$path","$type","__extends","_super","_this","className","element","paper","add","shapeRendering","_currentPoints","applyTheme","Object","Polygon","points","getPropertyValue","path","length","valueStr","slice","segments","split","s","segment","areaHole","areaArr","holeArr","pointsArr","area","areaAndHole","push","p","coords","x","y","pointsArr_1","hole","setPropertyValue","draw","left","right","top","bottom","i","len","surface","point","moveTo","lineTo","isNumber","h","hlen","closePath","bbox","width","height","setPath","call","value","_bbox","group","getBBox","_morpher","_disposers","registeredClasses"],"sourceRoot":"","sources":["../../../../../src/.internal/core/elements/Polygon.ts"],"sourcesContent":["/**\r\n * Polygon module.\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { Sprite, ISpriteProperties, ISpriteAdapters, ISpriteEvents } from \"../Sprite\";\r\nimport { IPoint } from \"../defs/IPoint\";\r\nimport { Morpher } from \"../utils/Morpher\";\r\nimport { IMorphable } from \"../defs/IMorphable\";\r\nimport { registry } from \"../Registry\";\r\nimport * as $path from \"../rendering/Path\";\r\nimport * as $type from \"../utils/Type\";\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * REQUISITES\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Defines properties for [[Polygon]].\r\n */\r\nexport interface IPolygonProperties extends ISpriteProperties {\r\n\r\n\t/**\r\n\t * An array of X/Y coordinates for each elbow of the polygon.\r\n\t */\r\n\tpoints?: Array<Array<Array<IPoint>>>;\r\n\r\n}\r\n\r\n/**\r\n * Defines events for [[Polygon]].\r\n */\r\nexport interface IPolygonEvents extends ISpriteEvents { }\r\n\r\n/**\r\n * Defines adapters for [[Polygon]].\r\n *\r\n * @see {@link Adapter}\r\n */\r\nexport interface IPolygonAdapters extends ISpriteAdapters, IPolygonProperties { }\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Draws a polygon.\r\n *\r\n * @see {@link IPolygonEvents} for a list of available events\r\n * @see {@link IPolygonAdapters} for a list of available Adapters\r\n */\r\nexport class Polygon extends Sprite implements IMorphable {\r\n\r\n\t/**\r\n\t * Defines available properties.\r\n\t */\r\n\tpublic _properties!: IPolygonProperties;\r\n\r\n\t/**\r\n\t * Defines available adapters.\r\n\t */\r\n\tpublic _adapter!: IPolygonAdapters;\r\n\r\n\t/**\r\n\t * Defines available events.\r\n\t */\r\n\tpublic _events!: IPolygonEvents;\r\n\r\n\t/**\r\n\t * A morpher instance that is used to morph polygon into some other shape.\r\n\t */\r\n\tprotected _morpher: $type.Optional<Morpher>;\r\n\r\n\t/**\r\n\t * Current points that morpher uses. This is needed so that we don't\r\n\t * overwrite polygons original points.\r\n\t */\r\n\tprotected _currentPoints: Array<Array<Array<IPoint>>>;\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor() {\r\n\t\tsuper();\r\n\t\tthis.className = \"Polygon\";\r\n\t\tthis.element = this.paper.add(\"path\");\r\n\t\tthis.shapeRendering = \"auto\";\r\n\t\tthis._currentPoints = [];\r\n\t\tthis.applyTheme();\r\n\t}\r\n\r\n\t/**\r\n\t * An array of X/Y coordinates for each elbow of the polygon.\r\n\t *\r\n\t * @todo Example\r\n\t * @param points  Polygon points\r\n\t */\r\n\tpublic set points(points: Array<Array<Array<IPoint>>>) {\r\n\t\tthis.setPropertyValue(\"points\", points, true);\r\n\t\tthis._currentPoints = points;\r\n\t}\r\n\r\n\t/**\r\n\t * @return Polygon points\r\n\t */\r\n\tpublic get points(): Array<Array<Array<IPoint>>> {\r\n\t\tlet points = this.getPropertyValue(\"points\");\r\n\t\tlet path = this.path;\r\n\r\n\t\tif (path && (!points || points.length == 0)) {\r\n\r\n\t\t\tlet valueStr = path.slice(1, path.length - 1);\r\n\r\n\t\t\tlet segments: string[] = valueStr.split(\"ZM\");\r\n\r\n\t\t\tfor (let s = 0; s < segments.length; s++) {\r\n\t\t\t\tlet segment = segments[s];\r\n\t\t\t\tif (segment.length > 0) {\r\n\t\t\t\t\tlet areaHole = segment.split(\"M\");\r\n\r\n\t\t\t\t\tlet areaArr = areaHole[0];\r\n\t\t\t\t\tlet holeArr = areaHole[1];\r\n\r\n\t\t\t\t\tif (areaArr && areaArr.length > 0) {\r\n\r\n\t\t\t\t\t\tlet pointsArr = areaArr.split(\"L\");\r\n\t\t\t\t\t\tif (pointsArr.length > 0) {\r\n\r\n\t\t\t\t\t\t\tlet area: IPoint[] = [];\r\n\r\n\t\t\t\t\t\t\tlet areaAndHole: Array<Array<IPoint>> = [area];\r\n\t\t\t\t\t\t\tpoints.push(areaAndHole);\r\n\r\n\t\t\t\t\t\t\tfor (let p = 0; p < pointsArr.length; p++) {\r\n\t\t\t\t\t\t\t\tlet coords = pointsArr[p].split(\",\");\r\n\t\t\t\t\t\t\t\tarea.push({ x: +coords[0], y: +coords[1] });\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif (holeArr && holeArr.length > 0) {\r\n\t\t\t\t\t\t\t\tlet pointsArr = holeArr.split(\"L\");\r\n\t\t\t\t\t\t\t\tif (pointsArr.length > 0) {\r\n\t\t\t\t\t\t\t\t\tlet hole: IPoint[] = [];\r\n\t\t\t\t\t\t\t\t\tareaAndHole.push(hole);\r\n\t\t\t\t\t\t\t\t\tfor (let p = pointsArr.length - 1; p >= 0; p--) {\r\n\t\t\t\t\t\t\t\t\t\tlet coords = pointsArr[p].split(\",\");\r\n\t\t\t\t\t\t\t\t\t\thole.push({ x: +coords[0], y: +coords[1] });\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tthis.setPropertyValue(\"points\", points);\r\n\t\t\tthis._currentPoints = points;\r\n\t\t}\r\n\t\treturn points;\r\n\t}\r\n\r\n\t/**\r\n\t * Current points. Used when morphing the element, so that original `points`\r\n\t * are not overwritten.\r\n\t *\r\n\t * @param points  Polygon points\r\n\t */\r\n\tpublic set currentPoints(points: Array<Array<Array<IPoint>>>) {\r\n\t\tif (this._currentPoints != points) {\r\n\t\t\tthis._currentPoints = points;\r\n\t\t\tthis.draw();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @return Polygon points\r\n\t */\r\n\tpublic get currentPoints(): Array<Array<Array<IPoint>>> {\r\n\t\tif((!this._currentPoints || this._currentPoints.length == 0) && this.path){\r\n\t\t\tthis._currentPoints = this.points;\r\n\t\t}\r\n\t\treturn this._currentPoints;\r\n\t}\r\n\r\n\t/**\r\n\t * Draws the element.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic draw(): void {\r\n\t\tlet path: string = \"\";\r\n\t\tlet points: Array<Array<Array<IPoint>>> = this._currentPoints;\r\n\r\n\t\tlet left: $type.Optional<number>;\r\n\t\tlet right: $type.Optional<number>;\r\n\t\tlet top: $type.Optional<number>;\r\n\t\tlet bottom: $type.Optional<number>;\r\n\r\n\t\tif (points.length > 0) {\r\n\t\t\t// separate areas\r\n\t\t\tfor (let i = 0, len = points.length; i < len; i++) {\r\n\t\t\t\t// surface\r\n\t\t\t\tlet surface: IPoint[] = points[i][0];\r\n\t\t\t\tlet hole: IPoint[] = points[i][1];\r\n\r\n\t\t\t\tif (surface && surface.length > 0) {\r\n\t\t\t\t\tlet point: IPoint = surface[0];\r\n\r\n\t\t\t\t\tpath += $path.moveTo(point);\r\n\r\n\t\t\t\t\tfor (let s: number = 0; s < surface.length; s++) {\r\n\t\t\t\t\t\tpoint = surface[s];\r\n\t\t\t\t\t\tpath += $path.lineTo(point);\r\n\r\n\t\t\t\t\t\tif (!$type.isNumber(right) || (right < point.x)) {\r\n\t\t\t\t\t\t\tright = point.x;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (!$type.isNumber(left) || (left > point.x)) {\r\n\t\t\t\t\t\t\tleft = point.x;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif (!$type.isNumber(top) || (top > point.y)) {\r\n\t\t\t\t\t\t\ttop = point.y;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (!$type.isNumber(bottom) || (bottom < point.y)) {\r\n\t\t\t\t\t\t\tbottom = point.y;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t// hole\r\n\t\t\t\tif (hole && hole.length > 0) {\r\n\t\t\t\t\tlet point: IPoint = hole[0];\r\n\t\t\t\t\tpath += $path.moveTo(point);\r\n\r\n\t\t\t\t\tfor (let h = 0, hlen = hole.length; h < hlen; h++) {\r\n\t\t\t\t\t\tpoint = hole[h];\r\n\t\t\t\t\t\tpath += $path.lineTo(point);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (path) {\r\n\t\t\t\tpath += $path.closePath();\r\n\t\t\t}\r\n\r\n\t\t\tthis.bbox.x = left;\r\n\t\t\tthis.bbox.y = top;\r\n\t\t\tthis.bbox.width = right - left;\r\n\t\t\tthis.bbox.height = bottom - top;\r\n\r\n\t\t\tsuper.setPath(path);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tprotected setPath(value: string): boolean {\r\n\t\tif (super.setPath(value)) {\r\n\t\t\tthis.points = [];\r\n\t\t\tthis._bbox = this.group.getBBox();\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Measures element\r\n\t */\r\n\tprotected measureElement(): void {\r\n\r\n\t\t// Overriding to avoid extra measurement.\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * A calculated center point for the shape.\r\n\t *\r\n\t * @readonly\r\n\t * @return Center\r\n\t */\r\n\tpublic get centerPoint(): IPoint {\r\n\t\treturn { x: this.bbox.x + this.bbox.width / 2, y: this.bbox.y + this.bbox.height / 2 };\r\n\t}\r\n\r\n\t/**\r\n\t * A [[Morpher]] instance that is used to morph polygon into some other\r\n\t * shape.\r\n\t *\r\n\t * @readonly\r\n\t * @return Morpher instance\r\n\t */\r\n\tpublic get morpher(): Morpher {\r\n\t\tif (!this._morpher) {\r\n\t\t\tthis._morpher = new Morpher(this);\r\n\t\t\tthis._disposers.push(this._morpher);\r\n\t\t}\r\n\t\treturn this._morpher;\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\r\nregistry.registeredClasses[\"Polygon\"] = Polygon;\r\n"]},"metadata":{},"sourceType":"module"}