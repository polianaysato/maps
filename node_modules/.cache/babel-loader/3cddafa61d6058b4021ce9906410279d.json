{"ast":null,"code":"/**\r\n * Interaction manages all aspects of user interaction - mouse move,\r\n * click, hover, drag events, touch gestures.\r\n *\r\n * [[InteractionObject]] elements that want to use certain events, must attach event\r\n * listeners to Interaction instance.\r\n *\r\n * Interaction itself will not modify [[InteractionObject]] elements, it will be up to\r\n * those elements to handle interaction information received via event triggers.\r\n */\nimport { __extends } from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\nimport { BaseObjectEvents } from \"../Base\";\nimport { List } from \"../utils/List\";\nimport { Animation } from \"../utils/Animation\";\nimport { MultiDisposer } from \"../utils/Disposer\";\nimport { InteractionObject } from \"./InteractionObject\";\nimport { InteractionKeyboardObject } from \"./InteractionKeyboardObject\";\nimport { Dictionary } from \"../utils/Dictionary\";\nimport { Inertia } from \"./Inertia\";\nimport { addEventListener } from \"../utils/DOM\";\nimport { keyboard } from \"../utils/Keyboard\";\nimport { system } from \"./../System\";\nimport { options } from \"./../Options\";\nimport * as $ease from \"../utils/Ease\";\nimport * as $math from \"../utils/Math\";\nimport * as $array from \"../utils/Array\";\nimport * as $dom from \"../utils/DOM\";\nimport * as $iter from \"../utils/Iterator\";\nimport * as $type from \"../utils/Type\";\nimport * as $time from \"../utils/Time\";\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n* Interaction manages all aspects of user interaction - mouse move,\r\n* click, hover, drag events, touch gestures.\r\n*\r\n* [[InteractionObject]] elements that want to use certain events, must attach event\r\n* listeners to Interaction instance.\r\n*\r\n* Interaction itself will not modify [[InteractionObject]] elements, it will be up to\r\n* those elements to handle interaction information received via event triggers.\r\n*\r\n* @see {@link IInteractionEvents} for a list of available events\r\n*/\n\nvar Interaction =\n/** @class */\nfunction (_super) {\n  __extends(Interaction, _super);\n  /**\r\n   * Constructor. Sets up universal document-wide move events to handle stuff\r\n   * outside particular chart container.\r\n   */\n\n\n  function Interaction() {\n    var _this = // Call super\n    _super.call(this) || this;\n    /**\r\n     * An indicator of global events were already initialized.\r\n     */\n\n\n    _this._globalEventsAdded = false;\n    /**\r\n     * Holds which mouse event listeners to use.\r\n     */\n\n    _this._pointerEvents = {\n      \"pointerdown\": \"mousedown\",\n      \"pointerup\": \"mouseup\",\n      \"pointermove\": \"mousemove\",\n      \"pointercancel\": \"mouseup\",\n      \"pointerover\": \"mouseover\",\n      \"pointerout\": \"mouseout\",\n      \"wheel\": \"wheel\"\n    };\n    /**\r\n     * Indicates if Interaction should use only \"pointer\" type events, like\r\n     * \"pointermove\", available in all modern browsers, ignoring \"legacy\"\r\n     * events, like \"touchmove\".\r\n     */\n\n    _this._usePointerEventsOnly = false;\n    /**\r\n     * Use only touch events (for touch only devices such as tablets and phones)\r\n     */\n\n    _this._useTouchEventsOnly = false;\n    /**\r\n     * Add special hover events. Normally, touch device tap will also simulate\r\n     * hover event. On some devices (ahem iOS) we want to prevent that so that\r\n     * over/out events are not duplicated.\r\n     */\n\n    _this._addHoverEvents = true;\n    /**\r\n     * Indicates if passive mode options is supported by this browser.\r\n     */\n\n    _this._passiveSupported = false;\n    /**\r\n     * Holds list of delayed events\r\n     */\n\n    _this._delayedEvents = {\n      out: []\n    };\n    /**\r\n     * List of objects that current have a pointer hovered over them.\r\n     */\n\n    _this.overObjects = new List();\n    /**\r\n     * List of objects that currently has a pressed pointer.\r\n     */\n\n    _this.downObjects = new List();\n    /**\r\n     * List of objects that need mouse position to be reported to them.\r\n     */\n\n    _this.trackedObjects = new List();\n    /**\r\n     * List of objects that are currently being dragged.\r\n     */\n\n    _this.transformedObjects = new List();\n    /**\r\n     * Holds all known pointers.\r\n     */\n\n    _this.pointers = new Dictionary();\n    /**\r\n     * Inertia options that need to be applied to after element drag, if it's\r\n     * `inert = true`.\r\n     *\r\n     * This is just a default, which can and probably will be overridden by\r\n     * actual elements.\r\n     */\n\n    _this.inertiaOptions = new Dictionary();\n    /**\r\n     * Default options for click events. These can be overridden in\r\n     * [[InteractionObject]].\r\n     */\n\n    _this.hitOptions = {\n      \"doubleHitTime\": 300,\n      //\"delayFirstHit\": false,\n      \"hitTolerance\": 10,\n      \"noFocus\": true\n    };\n    /**\r\n     * Default options for hover events. These can be overridden in\r\n     * [[InteractionObject]].\r\n     */\n\n    _this.hoverOptions = {\n      \"touchOutBehavior\": \"leave\",\n      \"touchOutDelay\": 1000\n    };\n    /**\r\n     * Default options for detecting a swipe gesture. These can be overridden in\r\n     * [[InteractionObject]].\r\n     */\n\n    _this.swipeOptions = {\n      \"time\": 500,\n      \"verticalThreshold\": 75,\n      \"horizontalThreshold\": 30\n    };\n    /**\r\n     * Default options for keyboard operations. These can be overridden in\r\n     * [[InteractionObject]].\r\n     */\n\n    _this.keyboardOptions = {\n      \"speed\": 0.1,\n      \"accelleration\": 1.2,\n      \"accellerationDelay\": 2000\n    };\n    /**\r\n     * Default options for keyboard operations. These can be overridden in\r\n     * [[InteractionObject]].\r\n     *\r\n     * @since 4.5.14\r\n     */\n\n    _this.mouseOptions = {\n      \"sensitivity\": 1\n    }; // Set class name\n\n    _this.className = \"Interaction\"; // Create InteractionObject for <body>\n\n    _this.body = _this.getInteraction(document.body);\n\n    _this._disposers.push(_this.body); // Detect browser capabilities and determine what event listeners to use\n\n\n    if (window.hasOwnProperty(\"PointerEvent\")) {\n      // IE10+/Edge without touch controls enabled\n      _this._pointerEvents.pointerdown = \"pointerdown\";\n      _this._pointerEvents.pointerup = \"pointerup\";\n      _this._pointerEvents.pointermove = \"pointermove\";\n      _this._pointerEvents.pointercancel = \"pointercancel\";\n      _this._pointerEvents.pointerover = \"pointerover\";\n      _this._pointerEvents.pointerout = \"pointerout\"; //this._usePointerEventsOnly = true;\n    } else if (window.hasOwnProperty(\"MSPointerEvent\")) {\n      // IE9\n      _this._pointerEvents.pointerdown = \"MSPointerDown\";\n      _this._pointerEvents.pointerup = \"MSPointerUp\";\n      _this._pointerEvents.pointermove = \"MSPointerMove\";\n      _this._pointerEvents.pointercancel = \"MSPointerUp\";\n      _this._pointerEvents.pointerover = \"MSPointerOver\";\n      _this._pointerEvents.pointerout = \"MSPointerOut\"; //this._usePointerEventsOnly = true;\n    } else if (typeof matchMedia !== \"undefined\" && matchMedia('(pointer:fine)').matches) {\n      // This is only for Safari as it does not support PointerEvent\n      // Do nothing and let it use regular `mouse*` events\n      // Hi Apple ;)\n      // Additionally disable hover events for iOS devices\n      if ('ontouchstart' in window) {\n        _this._addHoverEvents = false;\n        _this._useTouchEventsOnly = true;\n      }\n    } else if (window.navigator.userAgent.match(/MSIE /)) {\n      // Oh looky, an MSIE that does not support PointerEvent. Hi granpa IE9!\n      _this._usePointerEventsOnly = true;\n    } else if (_this.fullFF()) {\n      // Old FF, let's use regular events.\n      // (Newer FFs would be detected by the PointerEvent availability check)\n      _this._usePointerEventsOnly = true;\n    } else {\n      // Uses defaults for normal browsers\n      // We also assume that this must be a touch device that does not have\n      // any pointer events\n      _this._useTouchEventsOnly = true;\n    } // Detect if device has a mouse\n    // This is turning out to be not reliable\n    // @todo remove\n\n    /*if (!window.navigator.msPointerEnabled && (typeof matchMedia !== \"undefined\") && !matchMedia('(pointer:fine)').matches && !this.fullFF()) {\r\n        this._useTouchEventsOnly = true;\r\n    }*/\n    // Detect proper mouse wheel events\n\n\n    if (\"onwheel\" in document.createElement(\"div\")) {\n      // Modern browsers\n      _this._pointerEvents.wheel = \"wheel\";\n    } else if ($type.hasValue(document.onmousewheel)) {\n      // Webkit and IE support at least \"mousewheel\"\n      _this._pointerEvents.wheel = \"mousewheel\";\n    } // Set up default inertia options\n\n\n    _this.inertiaOptions.setKey(\"move\", {\n      \"time\": 100,\n      \"duration\": 500,\n      \"factor\": 1,\n      \"easing\": $ease.polyOut3\n    });\n\n    _this.inertiaOptions.setKey(\"resize\", {\n      \"time\": 100,\n      \"duration\": 500,\n      \"factor\": 1,\n      \"easing\": $ease.polyOut3\n    }); // Set the passive mode support\n\n\n    _this._passiveSupported = Interaction.passiveSupported; // Apply theme\n\n    _this.applyTheme();\n\n    return _this;\n  }\n  /**\r\n   * This is a nasty detection for Firefox. The reason why we have is that\r\n   * Firefox ESR version does not support matchMedia correctly.\r\n   *\r\n   * On iOS, Firefox uses different userAgent, so we don't have to detect iOS.\r\n   *\r\n   * @return Full Firefox?\r\n   */\n\n\n  Interaction.prototype.fullFF = function () {\n    return window.navigator.userAgent.match(/Firefox/) && !window.navigator.userAgent.match(/Android/);\n  };\n\n  Interaction.prototype.debug = function () {};\n  /**\r\n   * ==========================================================================\r\n   * Processing\r\n   * ==========================================================================\r\n   * @hidden\r\n   */\n\n  /**\r\n   * Sets up global events.\r\n   *\r\n   * We need this so that we can track drag movement beyond chart's container.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  Interaction.prototype.addGlobalEvents = function () {\n    var _this = this;\n\n    if (!this._globalEventsAdded) {\n      if (!this._useTouchEventsOnly) {\n        this._disposers.push(addEventListener(document, this._pointerEvents.pointerdown, function (ev) {\n          _this.handleGlobalPointerDown(ev);\n        }));\n\n        this._disposers.push(addEventListener(document, this._pointerEvents.pointermove, function (ev) {\n          _this.handleGlobalPointerMove(ev);\n        }));\n\n        this._disposers.push(addEventListener(document, this._pointerEvents.pointerup, function (ev) {\n          _this.handleGlobalPointerUp(ev);\n        }));\n\n        this._disposers.push(addEventListener(document, this._pointerEvents.pointercancel, function (ev) {\n          _this.handleGlobalPointerUp(ev, true);\n        }));\n\n        this._disposers.push(addEventListener(document, \"mouseenter\", function (ev) {\n          if (!$type.hasValue(ev.relatedTarget) && (ev.buttons == 0 || ev.which == 0)) {\n            _this.handleDocumentLeave(ev);\n          }\n        }));\n      } // No need to duplicate events for hubrid systems that support both\n      // pointer events and touch events. Touch events are need only for\n      // some touch-only systems, like Mobile Safari.\n\n\n      if (!this._usePointerEventsOnly) {\n        this._disposers.push(addEventListener(document, \"touchstart\", function (ev) {\n          _this.handleGlobalTouchStart(ev);\n        }));\n\n        this._disposers.push(addEventListener(document, \"touchmove\", function (ev) {\n          _this.handleGlobalTouchMove(ev);\n        }));\n\n        this._disposers.push(addEventListener(document, \"touchend\", function (ev) {\n          _this.handleGlobalTouchEnd(ev);\n        }));\n      }\n\n      this._disposers.push(addEventListener(document, \"keydown\", function (ev) {\n        _this.handleGlobalKeyDown(ev);\n      }));\n\n      this._disposers.push(addEventListener(document, \"keyup\", function (ev) {\n        _this.handleGlobalKeyUp(ev);\n      }));\n\n      this._globalEventsAdded = true;\n    }\n  };\n  /**\r\n   * Sets if [[InteractionObject]] is clickable.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io [[InteractionObject]] instance\r\n   */\n\n\n  Interaction.prototype.processClickable = function (io) {\n    // Add or remove touch events\n    this.processTouchable(io);\n  };\n  /**\r\n   * Sets if [[InteractionObject]] will display context menu when right-clicked.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io [[InteractionObject]] instance\r\n   */\n\n\n  Interaction.prototype.processContextMenu = function (io) {\n    if (io.contextMenuDisabled) {\n      if (!io.eventDisposers.hasKey(\"contextMenuDisabled\")) {\n        io.eventDisposers.setKey(\"contextMenuDisabled\", addEventListener(io.element, \"contextmenu\", function (e) {\n          e.preventDefault();\n        }));\n      }\n    } else {\n      if (io.eventDisposers.hasKey(\"contextMenuDisabled\")) {\n        io.eventDisposers.getKey(\"contextMenuDisabled\").dispose();\n      }\n    }\n  };\n  /**\r\n   * Sets if [[InteractionObject]] is hoverable.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io [[InteractionObject]] instance\r\n   */\n\n\n  Interaction.prototype.processHoverable = function (io) {\n    var _this = this;\n\n    if (io.hoverable || io.trackable) {\n      // Add global events\n      this.addGlobalEvents(); // Add hover styles\n\n      this.applyCursorOverStyle(io); // Add local events\n\n      if (!io.eventDisposers.hasKey(\"hoverable\") && this._addHoverEvents) {\n        io.eventDisposers.setKey(\"hoverable\", new MultiDisposer([addEventListener(io.element, this._pointerEvents.pointerout, function (e) {\n          return _this.handlePointerOut(io, e);\n        }), addEventListener(io.element, this._pointerEvents.pointerover, function (e) {\n          return _this.handlePointerOver(io, e);\n        })]));\n      }\n\n      if (io.trackable) {//sprite.addEventListener(\"touchmove\", this.handleTouchMove, false, this);\n      }\n    } else {\n      var disposer = io.eventDisposers.getKey(\"hoverable\");\n\n      if (disposer != null) {\n        disposer.dispose();\n        io.eventDisposers.removeKey(\"hoverable\");\n      }\n    } // Add or remove touch events\n\n\n    this.processTouchable(io);\n  };\n  /**\r\n   * Sets up [[InteractionObject]] as movable. Movable can be any\r\n   * transformation, e.g. drag, swipe, resize, track.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io  Element\r\n   */\n\n\n  Interaction.prototype.processMovable = function (io) {\n    // Add unified events\n    if (io.draggable || io.swipeable || io.trackable || io.resizable) {\n      // Prep the element\n      if (!this.isGlobalElement(io) && !io.isTouchProtected) {\n        this.prepElement(io);\n      } // Add hover styles\n\n\n      this.applyCursorOverStyle(io);\n    } // Add or remove touch events\n\n\n    this.processTouchable(io);\n  };\n  /**\r\n   * Checks if [[InteractionObject]] is trackable and sets relative events.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io  Element\r\n   */\n\n\n  Interaction.prototype.processTrackable = function (io) {\n    this.processHoverable(io);\n    this.processMovable(io);\n\n    if (io.trackable) {\n      this.trackedObjects.moveValue(io);\n    } else {\n      this.trackedObjects.removeValue(io);\n    }\n  };\n  /**\r\n   * Checks if [[InteractionObject]] is draggable.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io  Element\r\n   */\n\n\n  Interaction.prototype.processDraggable = function (io) {\n    this.processMovable(io);\n  };\n  /**\r\n   * Checks if [[InteractionObject]] is swipeable and sets relative events.\r\n   *\r\n   * A swipe event is triggered when a horizontal drag of 75px or more (and\r\n   * less than 30px vertically) occurs within 700 milliseconds. This can be\r\n   * overridden in sprites [[swipeOptions]].\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io  Element\r\n   */\n\n\n  Interaction.prototype.processSwipeable = function (io) {\n    this.processMovable(io);\n  };\n  /**\r\n   * Checks if [[InteractionObject]] is resizable and attaches required events\r\n   * to it.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io  Element\r\n   */\n\n\n  Interaction.prototype.processResizable = function (io) {\n    this.processMovable(io);\n  };\n  /**\r\n   * Checks if [[InteractionObject]] is supposed to capture mouse wheel events\r\n   * and prepares it to catch those events.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io  Element\r\n   */\n\n\n  Interaction.prototype.processWheelable = function (io) {\n    var _this = this;\n\n    if (io.wheelable) {\n      //io.hoverable = true;\n      if (!io.eventDisposers.hasKey(\"wheelable\")) {\n        io.eventDisposers.setKey(\"wheelable\", new MultiDisposer([addEventListener(io.element, this._pointerEvents.wheel, function (e) {\n          return _this.handleMouseWheel(io, e);\n        }, this._passiveSupported ? {\n          passive: false\n        } : false), io.events.on(\"out\", function (e) {\n          if (io.wheelable) {\n            _this.unlockWheel();\n          }\n        }), io.events.on(\"over\", function (e) {\n          //console.log(\"whelab over\")\n          if (io.wheelable) {\n            _this.lockWheel();\n          }\n        })]));\n      }\n    } else {\n      var disposer = io.eventDisposers.getKey(\"wheelable\");\n\n      if (disposer != null) {\n        disposer.dispose();\n        io.eventDisposers.removeKey(\"wheelable\");\n      }\n    }\n  };\n  /**\r\n   * Checks if [[InteractionObject]] is focusable. A focusable element is an\r\n   * element that will be highlighted when users presses TAB key. If the\r\n   * element is focusable, this function will attach relative focus/blur\r\n   * events to it.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io  Element\r\n   */\n\n\n  Interaction.prototype.processFocusable = function (io) {\n    var _this = this;\n\n    if (io.focusable === true && io.tabindex > -1 && !this._useTouchEventsOnly) {\n      if (!io.eventDisposers.hasKey(\"focusable\")) {\n        io.eventDisposers.setKey(\"focusable\", new MultiDisposer([addEventListener(io.element, \"focus\", function (e) {\n          return _this.handleFocus(io, e);\n        }), addEventListener(io.element, \"blur\", function (e) {\n          return _this.handleBlur(io, e);\n        }), addEventListener(io.element, this._pointerEvents.pointerdown, function (e) {\n          return _this.handleFocusBlur(io, e);\n        }), addEventListener(io.element, \"touchstart\", function (e) {\n          return _this.handleFocusBlur(io, e);\n        }, this._passiveSupported ? {\n          passive: false\n        } : false)]));\n      }\n    } else {\n      var disposer = io.eventDisposers.getKey(\"focusable\");\n\n      if (disposer != null) {\n        disposer.dispose();\n        io.eventDisposers.removeKey(\"focusable\");\n      }\n    }\n  };\n  /**\r\n   * Checks if [[InteractionObject]] is \"touchable\". It means any interaction\r\n   * whatsoever: mouse click, touch screen tap, swipe, drag, resize, etc.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io  Element\r\n   */\n\n\n  Interaction.prototype.processTouchable = function (io) {\n    var _this = this; // Add unified events\n\n\n    if (io.clickable || io.hoverable || io.trackable || io.draggable || io.swipeable || io.resizable) {\n      // Add global events\n      this.addGlobalEvents(); // Add local events\n\n      if (!io.eventDisposers.hasKey(\"touchable\")) {\n        if (!this._useTouchEventsOnly && !this._usePointerEventsOnly) {\n          io.eventDisposers.setKey(\"touchable\", new MultiDisposer([addEventListener(io.element, this._pointerEvents.pointerdown, function (e) {\n            return _this.handlePointerDown(io, e);\n          }), addEventListener(io.element, \"touchstart\", function (e) {\n            return _this.handleTouchDown(io, e);\n          }, this._passiveSupported ? {\n            passive: false\n          } : false)]));\n        } else if (!this._useTouchEventsOnly) {\n          io.eventDisposers.setKey(\"touchable\", addEventListener(io.element, this._pointerEvents.pointerdown, function (e) {\n            return _this.handlePointerDown(io, e);\n          }));\n        } else if (!this._usePointerEventsOnly) {\n          io.eventDisposers.setKey(\"touchable\", addEventListener(io.element, \"touchstart\", function (e) {\n            return _this.handleTouchDown(io, e);\n          }, this._passiveSupported ? {\n            passive: false\n          } : false));\n        }\n      }\n    } else {\n      var disposer = io.eventDisposers.getKey(\"touchable\");\n\n      if (disposer != null) {\n        disposer.dispose();\n        io.eventDisposers.removeKey(\"touchable\");\n      }\n    }\n  };\n  /**\r\n   * ==========================================================================\r\n   * Non-pointer events\r\n   * ==========================================================================\r\n   * @hidden\r\n   */\n\n  /**\r\n   * Dispatches \"focus\" event when element gains focus.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io  Element\r\n   * @param ev  Original event\r\n   */\n\n\n  Interaction.prototype.handleFocus = function (io, ev) {\n    if (!io.focusable) {\n      ev.preventDefault();\n      return;\n    }\n\n    io.isFocused = true;\n\n    if (io.events.isEnabled(\"focus\") && !system.isPaused) {\n      var imev = {\n        type: \"focus\",\n        target: io,\n        event: ev\n      };\n      io.events.dispatchImmediately(\"focus\", imev);\n    }\n  };\n  /**\r\n   * Used by regular click events to prevent focus if \"noFocus\" is set.\r\n   *\r\n   * This should not be called by \"focus\" handlers.\r\n   *\r\n   * @param io  Element\r\n   * @param ev  Original event\r\n   */\n\n\n  Interaction.prototype.handleFocusBlur = function (io, ev) {\n    if (io.focusable !== false && this.getHitOption(io, \"noFocus\")) {\n      io.events.once(\"focus\", function () {\n        io.events.disableType(\"blur\");\n        $dom.blur();\n\n        if (io.sprite) {\n          io.sprite.handleBlur();\n        }\n\n        io.events.enableType(\"blur\");\n      });\n    }\n  };\n  /**\r\n   * Dispatches \"blur\" event when element loses focus.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io  Element\r\n   * @param ev  Original event\r\n   */\n\n\n  Interaction.prototype.handleBlur = function (io, ev) {\n    if (!io.focusable) {\n      ev.preventDefault();\n      return;\n    }\n\n    io.isFocused = false;\n\n    if (io.events.isEnabled(\"blur\") && !system.isPaused) {\n      var imev = {\n        type: \"blur\",\n        target: io,\n        event: ev\n      };\n      io.events.dispatchImmediately(\"blur\", imev);\n    }\n  };\n  /**\r\n   * ==========================================================================\r\n   * Global keyboard-related even handlers\r\n   * ==========================================================================\r\n   * @hidden\r\n   */\n\n  /**\r\n   * Checks if there is an item that has currently focus and that they key is\r\n   * one of the directional keys. If both of the conditions are true, it\r\n   * creates an object to simulate movement of dragable element with keyboard.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param ev An original keyboard event\r\n   */\n\n\n  Interaction.prototype.handleGlobalKeyDown = function (ev) {\n    if (this.focusedObject) {\n      if (keyboard.isKey(ev, \"esc\")) {\n        // ESC removes focus\n        $dom.blur();\n      } else if (this.focusedObject.draggable && keyboard.isKey(ev, [\"up\", \"down\", \"left\", \"right\"])) {\n        // Prevent scrolling of the document\n        ev.preventDefault(); // Get focused object\n\n        var io = this.focusedObject; // Get particular key\n\n        var disposerKey = \"interactionKeyboardObject\"; // If such disposer already exists we know the event is going on so we\n        // just move on\n\n        if (io.eventDisposers.hasKey(disposerKey)) {\n          return;\n        } // Create a keyboard mover\n\n\n        var ko = new InteractionKeyboardObject(io, ev);\n        io.eventDisposers.setKey(disposerKey, ko);\n\n        switch (keyboard.getEventKey(ev)) {\n          case \"up\":\n            ko.directionY = -1;\n            break;\n\n          case \"down\":\n            ko.directionY = 1;\n            break;\n\n          case \"left\":\n            ko.directionX = -1;\n            break;\n\n          case \"right\":\n            ko.directionX = 1;\n            break;\n        }\n      }\n    }\n  };\n  /**\r\n   * Dispatches related events when the keyboard key is realeasd.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param ev An original keyboard event\r\n   */\n\n\n  Interaction.prototype.handleGlobalKeyUp = function (ev) {\n    var disposerKey = \"interactionKeyboardObject\";\n\n    if (this.focusedObject) {\n      var disposer = this.focusedObject.eventDisposers.getKey(disposerKey);\n\n      if (disposer != null) {\n        // Prevent scrolling of the document\n        ev.preventDefault(); // Dispose stuff\n\n        disposer.dispose();\n        this.focusedObject.eventDisposers.removeKey(disposerKey);\n      } // Does focused object have \"hit\" event?\n\n\n      if (keyboard.isKey(ev, \"enter\") && this.focusedObject.sprite && !this.focusedObject.sprite.events.isEnabled(\"toggled\")) {\n        if (this.focusedObject.sprite.events.isEnabled(\"hit\")) {\n          this.focusedObject.dispatchImmediately(\"hit\");\n        } else if (this.focusedObject.sprite.showTooltipOn == \"hit\") {\n          this.focusedObject.dispatchImmediately(\"up\");\n        }\n      }\n    }\n  };\n  /**\r\n   * ==========================================================================\r\n   * Global pointer-related even handlers\r\n   * ==========================================================================\r\n   * @hidden\r\n   */\n\n  /**\r\n   * Handler for a global \"pointermove\" event.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param ev Event object\r\n   */\n\n\n  Interaction.prototype.handleGlobalPointerMove = function (ev) {\n    // Get pointer\n    var pointer = this.getPointer(ev); // Update current point position\n\n    pointer.point = this.getPointerPoint(ev); // Prepare and fire global event\n\n    if (this.events.isEnabled(\"track\") && !system.isPaused) {\n      var imev = {\n        type: \"track\",\n        target: this,\n        event: ev,\n        pointer: pointer,\n        touch: pointer.touch\n      };\n      this.events.dispatchImmediately(\"track\", imev);\n    } // Track\n\n\n    this.addBreadCrumb(pointer, pointer.point); // Process further\n\n    this.handleGlobalMove(pointer, ev);\n  };\n  /**\r\n   * Handler for a global \"pointerdown\" event.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param ev Event object\r\n   */\n\n\n  Interaction.prototype.handleGlobalPointerDown = function (ev) {\n    // Remove delayed hovers\n    this.processDelayed(); // Get pointer\n\n    var pointer = this.getPointer(ev); // Prepare and fire global event\n\n    if (this.events.isEnabled(\"down\") && !system.isPaused) {\n      var imev = {\n        type: \"down\",\n        target: this,\n        event: ev,\n        pointer: pointer,\n        touch: pointer.touch\n      };\n      this.events.dispatchImmediately(\"down\", imev);\n    }\n  };\n  /**\r\n   * Prevents touch action from firing.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param ev Event\r\n   */\n\n\n  Interaction.prototype.preventTouchAction = function (ev) {\n    if (!ev.defaultPrevented) {\n      ev.preventDefault();\n    }\n  };\n  /**\r\n   * Handler for a global \"pointerup\" event.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param ev Event object\r\n   */\n\n\n  Interaction.prototype.handleGlobalPointerUp = function (ev, cancelled) {\n    if (cancelled === void 0) {\n      cancelled = false;\n    } // Get pointer\n\n\n    var pointer = this.getPointer(ev); // Prepare and fire global event\n\n    if (this.events.isEnabled(\"up\") && !system.isPaused) {\n      var imev = {\n        type: \"up\",\n        target: this,\n        event: ev,\n        pointer: pointer,\n        touch: pointer.touch\n      };\n      this.events.dispatchImmediately(\"up\", imev);\n    } // Process further\n\n\n    this.handleGlobalUp(pointer, ev, cancelled);\n  };\n  /**\r\n  * ==========================================================================\r\n  * Global touch-related even handlers\r\n  * ==========================================================================\r\n  */\n\n  /**\r\n   * Handler for a global \"touchmove\" event.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param ev Event object\r\n   */\n\n\n  Interaction.prototype.handleGlobalTouchMove = function (ev) {\n    // Process each changed touch point\n    for (var i = 0; i < ev.changedTouches.length; i++) {\n      // Get pointer\n      var pointer = this.getPointer(ev.changedTouches[i]); // Update current point position\n\n      pointer.point = this.getPointerPoint(ev.changedTouches[i]); // Prepare and fire global event\n\n      if (this.events.isEnabled(\"track\") && !system.isPaused) {\n        var imev = {\n          type: \"track\",\n          target: this,\n          event: ev,\n          pointer: pointer,\n          touch: pointer.touch\n        };\n        this.events.dispatchImmediately(\"track\", imev);\n      } // Track\n\n\n      this.addBreadCrumb(pointer, pointer.point); // Process further\n\n      this.handleGlobalMove(pointer, ev);\n    }\n  };\n  /**\r\n   * Handler for a global \"touchstart\" event.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param ev Event object\r\n   */\n\n\n  Interaction.prototype.handleGlobalTouchStart = function (ev) {\n    // Remove delayed hovers\n    this.processDelayed(); // Process each changed touch point\n\n    for (var i = 0; i < ev.changedTouches.length; i++) {\n      // Get pointer\n      var pointer = this.getPointer(ev.changedTouches[i]); // Prepare and fire global event\n\n      if (!this._usePointerEventsOnly && this.events.isEnabled(\"down\") && !system.isPaused) {\n        var imev = {\n          type: \"down\",\n          target: this,\n          event: ev,\n          pointer: pointer,\n          touch: pointer.touch\n        };\n        this.events.dispatchImmediately(\"down\", imev);\n      }\n    }\n  };\n  /**\r\n   * Handler for a global \"touchend\" event.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param ev Event object\r\n   */\n\n\n  Interaction.prototype.handleGlobalTouchEnd = function (ev) {\n    // Process each changed touch point\n    for (var i = 0; i < ev.changedTouches.length; i++) {\n      // Get pointer\n      var pointer = this.getPointer(ev.changedTouches[i]); // Prepare and fire global event\n\n      if (this.events.isEnabled(\"up\") && !system.isPaused) {\n        var imev = {\n          type: \"up\",\n          target: this,\n          event: ev,\n          pointer: pointer,\n          touch: pointer.touch\n        };\n        this.events.dispatchImmediately(\"up\", imev);\n      } // Handle element-related events\n\n\n      this.handleGlobalUp(pointer, ev);\n    }\n  };\n  /**\r\n   * ==========================================================================\r\n   * Element-specific pointer-related even handlers\r\n   * ==========================================================================\r\n   * @hidden\r\n   */\n\n  /**\r\n   * Handles event when pointer is over [[InteractionObject]] and button is\r\n   * pressed.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io  Element\r\n   * @param ev  Original event\r\n   */\n\n\n  Interaction.prototype.handlePointerDown = function (io, ev) {\n    // Stop further propagation so we don't get multiple triggers on hybrid\n    // devices (both mouse and touch capabilities)\n    //ev.preventDefault();\n    //ev.stopPropagation();\n    //if (ev.defaultPrevented) {\n    //}\n    // Get pointer\n    var pointer = this.getPointer(ev); // Ignore if it's anything but mouse's primary button\n\n    if (!pointer.touch && ev.which != 1 && ev.which != 3) {\n      return;\n    } // Set mouse button\n\n\n    pointer.button = ev.which; // Reset pointer\n\n    this.resetPointer(pointer, ev); // Process down\n\n    this.handleDown(io, pointer, ev);\n  };\n  /**\r\n   * Handles event when [[InteractionObject]] is hovered by a mouse pointer.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io  Element\r\n   * @param ev  Original event\r\n   */\n\n\n  Interaction.prototype.handlePointerOver = function (io, ev) {\n    // Get pointer\n    var pointer = this.getPointer(ev); // Process down\n\n    this.handleOver(io, pointer, ev);\n  };\n  /**\r\n   * Handles event when [[InteractionObject]] loses hover from a mouse pointer.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io  Element\r\n   * @param ev  Original event\r\n   */\n\n\n  Interaction.prototype.handlePointerOut = function (io, ev) {\n    // Get pointer\n    var pointer = this.getPointer(ev); // Process down\n\n    this.handleOut(io, pointer, ev);\n  };\n  /**\r\n   * Handles event when mouse wheel is crolled over the [[InteractionObject]].\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io  Element\r\n   * @param ev  Original event\r\n   * @todo Investigate more-cross browser stuff https://developer.mozilla.org/en-US/docs/Web/Events/wheel\r\n   */\n\n\n  Interaction.prototype.handleMouseWheel = function (io, ev) {\n    // Get pointer\n    var pointer = this.getPointer(ev); // Update current point position\n\n    pointer.point = this.getPointerPoint(ev); // Init delta values\n\n    var deltaX = 0,\n        deltaY = 0; // Set up modifier\n    // This is needed because FireFox reports wheel deltas in \"lines\" instead\n    // of pixels so we have to approximate pixel value\n\n    var mod = 1;\n\n    if (ev.deltaMode == 1) {\n      mod = 50;\n    } // Adjust configurable sensitivity\n\n\n    mod *= this.getMouseOption(io, \"sensitivity\"); // Calculate deltas\n\n    if (ev instanceof WheelEvent) {\n      deltaX = Math.round(-1 * ev.wheelDeltaX || ev.deltaX * mod);\n      deltaY = Math.round(-1 * ev.wheelDeltaY || ev.deltaY * mod);\n    } else {\n      throw new Error(\"Invalid event type\");\n    } // Handle the event\n\n\n    this.handleWheel(io, pointer, deltaX, deltaY, ev);\n  };\n  /**\r\n   * ==========================================================================\r\n   * Element-specific touch-related even handlers\r\n   * ==========================================================================\r\n   * @hidden\r\n   */\n\n  /**\r\n    * Handles an event when an [[InteractionObject]] is touched on a touch\r\n    * device.\r\n    *\r\n    * @ignore Exclude from docs\r\n    * @param io  Element\r\n    * @param ev  Original event\r\n    */\n\n\n  Interaction.prototype.handleTouchDown = function (io, ev) {\n    // Stop further propagation so we don't get multiple triggers on hybrid\n    // devices (both mouse and touch capabilities)\n    //this.maybePreventDefault(io, ev);\n    //return;\n    // Process each changed touch point\n    for (var i = 0; i < ev.changedTouches.length; i++) {\n      // Get pointer\n      var pointer = this.getPointer(ev.changedTouches[i]);\n      this.maybePreventDefault(io, ev, pointer); // Reset pointer\n\n      this.resetPointer(pointer, ev.changedTouches[i]); // Process down\n\n      this.handleDown(io, pointer, ev);\n    }\n  };\n  /**\r\n   * ==========================================================================\r\n   * Universal handlers\r\n   * ==========================================================================\r\n   * @hidden\r\n   */\n\n  /**\r\n   * Handles click/tap. Checks for doublehit.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io       Interaction object\r\n   * @param pointer  Pointer\r\n   * @param ev       Original event\r\n   */\n\n\n  Interaction.prototype.handleHit = function (io, pointer, ev) {\n    // Check if this is a double-hit\n    var now = $time.getTime();\n\n    if (io.lastHit && io.lastHit >= now - this.getHitOption(io, \"doubleHitTime\")) {\n      // Yup - it's a double-hit\n      // Cancel the hit\n      //clearTimeout(io.lastHitPointer.hitTimeout);\n      // If it happened too fast it probably means that hybrid device just\n      // generated two events for the same tap\n      if (now - io.lastHit < 100) {\n        // Ignore\n        return;\n      } // Clear last hit\n\n\n      io.lastHit = undefined;\n      io.lastHitPointer = undefined; // Dispatch event\n\n      if (io.events.isEnabled(\"doublehit\") && !system.isPaused) {\n        var imev = {\n          type: \"doublehit\",\n          target: io,\n          point: pointer.point,\n          event: ev,\n          touch: pointer.touch\n        };\n        io.events.dispatchImmediately(\"doublehit\", imev);\n      }\n    } else {\n      // Log last hit\n      io.lastHit = now;\n      io.lastHitPointer = pointer;\n\n      if (pointer.button === 3) {\n        // Execute HIT now\n        if (io.events.isEnabled(\"rightclick\") && !system.isPaused) {\n          var imev = {\n            type: \"rightclick\",\n            target: io,\n            event: ev\n          };\n          io.events.dispatchImmediately(\"rightclick\", imev);\n        }\n      } else {\n        if (io.events.isEnabled(\"hit\") && !system.isPaused) {\n          var imev = {\n            type: \"hit\",\n            target: io,\n            event: ev,\n            point: pointer.point,\n            touch: pointer.touch\n          };\n          io.events.dispatchImmediately(\"hit\", imev);\n        }\n      }\n    }\n  };\n  /**\r\n   * Handles pointer hovering over [[InteractionObject]].\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io       Interaction object\r\n   * @param pointer  Pointer\r\n   * @param ev       Original event\r\n   * @param soft     Invoked by helper function\r\n   */\n\n\n  Interaction.prototype.handleOver = function (io, pointer, ev, soft) {\n    if (soft === void 0) {\n      soft = false;\n    }\n\n    if (!io.hoverable) {\n      return;\n    }\n\n    var hoversPaused = false;\n\n    if (this.shouldCancelHovers(pointer) && this.areTransformed() && this.moved(pointer, this.getHitOption(io, \"hitTolerance\"))) {\n      hoversPaused = true;\n      this.cancelAllHovers(ev);\n    } // Remove any delayed outs\n\n\n    this.processDelayed(); // Add pointer\n\n    io.overPointers.moveValue(pointer); // Check if object is not yet hovered\n\n    if (!io.isRealHover) {\n      // Set element as hovered\n      if (!hoversPaused) {\n        io.isHover = true;\n        io.isRealHover = true;\n        this.overObjects.moveValue(io);\n      } // Generate body track event. This is needed so that if element loads\n      // under unmoved mouse cursor, we still need all the actions that are\n      // required to happen to kick in.\n\n\n      this.handleTrack(this.body, pointer, ev, true); // Event\n\n      if (io.events.isEnabled(\"over\") && !system.isPaused && !hoversPaused) {\n        var imev = {\n          type: \"over\",\n          target: io,\n          event: ev,\n          pointer: pointer,\n          touch: pointer.touch\n        };\n        io.events.dispatchImmediately(\"over\", imev);\n      }\n    }\n  };\n  /**\r\n   * Handles when [[InteractionObject]] is no longer hovered.\r\n   *\r\n   * If `soft = true`, this means that method is being invoked by some other\r\n   * code, not hard \"out\" function, like `handleUp` which implies we need to\r\n   * run additional checks before unhovering the object.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io       Interaction object\r\n   * @param pointer  Pointer\r\n   * @param ev       Original event\r\n   * @param soft     Invoked by helper function\r\n   * @param force    Force imediate out\r\n   */\n\n\n  Interaction.prototype.handleOut = function (io, pointer, ev, soft, force) {\n    var _this = this;\n\n    if (soft === void 0) {\n      soft = false;\n    }\n\n    if (force === void 0) {\n      force = false;\n    }\n\n    if (!io.hoverable) {\n      return;\n    } // Remove pointer\n\n\n    io.overPointers.removeValue(pointer); // Check if element is still hovered\n\n    if (io.isHover && (!io.hasDelayedOut || force)) {\n      // Should we run additional checks?\n      if (soft && io.overPointers.length) {\n        // There are still pointers hovering - don't do anything else and\n        // wait until either no over pointers are there or we get a hard out\n        // event.\n        return;\n      } // Should we delay \"out\" if this is happening on a touch device?\n\n\n      if (pointer && pointer.touch && !force && !this.old(pointer)) {\n        // This is a touch pointer, and it hasn't moved, let's pretend\n        // the object is still hovered, and act as per \"behavior\" setting\n        var behavior = this.getHoverOption(io, \"touchOutBehavior\");\n\n        if (behavior == \"leave\") {\n          // Set to \"leave\", so we do not execute any \"out\" event.\n          // It will be handled by any other interaction that happens\n          // afterwards.\n          this._delayedEvents.out.push({\n            type: \"out\",\n            io: io,\n            pointer: pointer,\n            event: ev,\n            keepUntil: $time.getTime() + 500\n          });\n\n          io.hasDelayedOut = true;\n          return;\n        } else if (behavior == \"delay\" && this.getHoverOption(io, \"touchOutDelay\")) {\n          this._delayedEvents.out.push({\n            type: \"out\",\n            io: io,\n            pointer: pointer,\n            event: ev,\n            keepUntil: $time.getTime() + 500,\n            timeout: this.setTimeout(function () {\n              _this.handleOut(io, pointer, ev, true);\n            }, this.getHoverOption(io, \"touchOutDelay\"))\n          });\n\n          return;\n        } else {// Nothing for \"remove\" - that's how it works \"out-of-the-box\"\n        }\n      } // Set element as not hovered\n\n\n      io.isHover = false;\n      this.overObjects.removeValue(io); // Invoke event\n\n      if (!io.isDisposed() && io.events.isEnabled(\"out\") && !system.isPaused) {\n        var imev = {\n          type: \"out\",\n          target: io,\n          event: ev,\n          pointer: pointer,\n          touch: pointer.touch\n        };\n        io.events.dispatchImmediately(\"out\", imev);\n      } // Reset object from lefover delayed outs, pointers\n\n\n      io.overPointers.clear();\n      io.hasDelayedOut = false; // @todo (clean delayed)\n    }\n  };\n  /**\r\n   * Processes dalyed events, such as \"out\" event that was initiated for\r\n   * elements by touch.\r\n   */\n\n\n  Interaction.prototype.processDelayed = function () {\n    var delayedEvent;\n\n    while (true) {\n      delayedEvent = this._delayedEvents.out.pop();\n\n      if (!delayedEvent) {\n        break;\n      }\n\n      if (delayedEvent.timeout) {\n        delayedEvent.timeout.dispose();\n      }\n\n      this.handleOut(delayedEvent.io, delayedEvent.pointer, delayedEvent.event, false, true);\n    }\n  };\n  /**\r\n   * Performs tasks on pointer down.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io       Element\r\n   * @param pointer  Pointer\r\n   * @param ev       Original event\r\n   */\n\n\n  Interaction.prototype.handleDown = function (io, pointer, ev) {\n    // Need to prevent default event from happening on transformable objects\n    this.maybePreventDefault(io, ev, pointer); // Stop inertia animations if they're currently being played out\n\n    if (io.inert) {\n      this.stopInertia(io);\n    } // Trigger hover because some touch devices won't trigger over events\n    // on their own\n\n\n    this.handleOver(io, pointer, ev, true); // Add pointer to list\n\n    io.downPointers.moveValue(pointer); // Apply styles if necessary\n\n    this.applyCursorDownStyle(io, pointer); // Check if object is already down\n\n    if (!io.isDown) {\n      // Lose focus if needed\n      if (io.focusable !== false && this.getHitOption(io, \"noFocus\") && this.focusedObject) {\n        $dom.blur();\n      } // Set object as hovered\n\n\n      io.isDown = true;\n      this.downObjects.moveValue(io); // Prep object for dragging and/or resizing\n\n      if (io.draggable) {\n        this.processDragStart(io, pointer, ev);\n      }\n\n      if (io.resizable) {\n        this.processResizeStart(io, pointer, ev);\n      }\n    } // Dispatch \"down\" event\n\n\n    if (io.events.isEnabled(\"down\") && !system.isPaused) {\n      var imev = {\n        type: \"down\",\n        target: io,\n        event: ev,\n        pointer: pointer,\n        touch: pointer.touch\n      };\n      io.events.dispatchImmediately(\"down\", imev);\n    }\n  };\n  /**\r\n   * Performs tasks on pointer up.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param pointer  Pointer\r\n   * @param ev       Original event\r\n   */\n\n\n  Interaction.prototype.handleGlobalUp = function (pointer, ev, cancelled) {\n    var _this = this;\n\n    if (cancelled === void 0) {\n      cancelled = false;\n    }\n\n    var sorted = this.downObjects.values.slice();\n    sorted.sort(function (x, y) {\n      if (x && y) {\n        var pos = x.element.compareDocumentPosition(y.element);\n\n        if (pos & Node.DOCUMENT_POSITION_CONTAINED_BY) {\n          return 1;\n        } else if (pos & Node.DOCUMENT_POSITION_CONTAINS) {\n          return -1;\n        } else {\n          return 0;\n        }\n      } else {\n        return 0;\n      }\n    }); // Process all down objects\n\n    $array.each(sorted, function (io) {\n      // Check if this particular pointer is pressing down\n      // on object\n      if (io && io.downPointers.contains(pointer)) {\n        _this.handleUp(io, pointer, ev, cancelled);\n      }\n    });\n  };\n  /**\r\n   * Simulates all pointers being up once mouse leaves document area.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param ev       Original event\r\n   */\n\n\n  Interaction.prototype.handleDocumentLeave = function (ev) {\n    var _this = this; // Process all down objects\n\n\n    $iter.each(this.downObjects.backwards().iterator(), function (io) {\n      io.downPointers.each(function (pointer) {\n        _this.handleUp(io, pointer, ev);\n      });\n    });\n  };\n  /**\r\n   * Handles when [[InteractionObject]] is no longer hovered.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io       Interaction object\r\n   * @param pointer  Pointer\r\n   * @param ev       Original event\r\n   */\n\n\n  Interaction.prototype.handleUp = function (io, pointer, ev, cancelled) {\n    if (cancelled === void 0) {\n      cancelled = false;\n    } // Restore cursor style\n\n\n    this.restoreCursorDownStyle(io, pointer); // Remove pointer from the list\n\n    io.downPointers.removeValue(pointer); // Trigger out because some touch devices won't trigger out events\n    // on their own\n\n    if (pointer.touch || this._useTouchEventsOnly) {\n      this.handleOut(io, pointer, ev, true);\n    } // Check if object still down\n\n\n    if (io.isDown) {\n      // Check if there are no other pointers hovering this element\n      if (io.downPointers.length == 0) {\n        // Set element as no longer down\n        io.isDown = false;\n        this.downObjects.removeValue(io);\n      } // Dispatch \"up\" event\n\n\n      if (io.events.isEnabled(\"up\") && !system.isPaused) {\n        var imev = {\n          type: \"up\",\n          target: io,\n          event: ev,\n          pointer: pointer,\n          touch: pointer.touch\n        };\n        io.events.dispatchImmediately(\"up\", imev);\n      } // Check if this was not a cancelled event.\n      // If event was canelled (which might happen if gesture resulted in\n      // navigation or page scroll) there's no point in triggering hit and\n      // other actions.\n\n\n      if (!cancelled) {\n        // Handle swiping-related stuff\n        if (io.swipeable && this.swiped(io, pointer)) {\n          // Swiped - nothing else should happen\n          this.handleSwipe(io, pointer, ev);\n        } else {\n          // Check if it maybe a click\n          if (io.clickable && !this.moved(pointer, this.getHitOption(io, \"hitTolerance\"))) {\n            this.handleHit(io, pointer, ev);\n          } // Handle inertia\n\n\n          if (io.inert && this.moved(pointer, this.getHitOption(io, \"hitTolerance\"))) {\n            this.handleInertia(io, pointer);\n          } else if (io.draggable) {\n            this.processDragStop(io, pointer, ev);\n          }\n\n          if (io.resizable) {\n            this.processResizeStop(io, pointer, ev);\n          }\n        }\n      }\n    }\n  };\n  /**\r\n   * Checks if event needs to be prevented on draggable and such items, so that\r\n   * touch gestures like navigation and scroll do not kick in.\r\n   *\r\n   * @param io  Object\r\n   * @param ev  Event\r\n   */\n\n\n  Interaction.prototype.maybePreventDefault = function (io, ev, pointer) {\n    if ($type.hasValue(ev) && (io.draggable || io.swipeable || io.trackable || io.resizable) && !this.isGlobalElement(io) && ev.cancelable !== false && (!io.isTouchProtected || !pointer || !pointer.touch)) {\n      ev.preventDefault();\n    }\n  };\n  /**\r\n   * Cancels all hovers on all currently hovered objects.\r\n   *\r\n   * @param  pointer  Pointer\r\n   * @param  ev       Event\r\n   */\n\n\n  Interaction.prototype.cancelAllHovers = function (ev) {\n    var _this = this; //this.overObjects.each((io) => {\n\n\n    $iter.each(this.overObjects.backwards().iterator(), function (io) {\n      if (io) {\n        var pointer = io.overPointers.getIndex(0);\n\n        _this.handleOut(io, pointer, ev, true, true);\n      }\n    });\n  };\n  /**\r\n   * Checks if hovers should be cancelled on transform as per global options.\r\n   * @param   pointer  Pointer\r\n   * @return           Cancel?\r\n   */\n\n\n  Interaction.prototype.shouldCancelHovers = function (pointer) {\n    return options.disableHoverOnTransform == \"always\" || options.disableHoverOnTransform == \"touch\" && pointer.touch;\n  };\n  /**\r\n   * Handles pointer move.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param pointer  Pointer\r\n   * @param ev       Original event\r\n   */\n\n\n  Interaction.prototype.handleGlobalMove = function (pointer, ev) {\n    var _this = this; // Process hovered elements\n    // We check if the element became unhovered without reporting the mouseout\n    // event. (it happens in some cases)\n\n\n    if (!pointer.touch) {\n      var target_1 = $dom.eventTarget(pointer.lastEvent);\n      $iter.each(this.overObjects.backwards().iterator(), function (io) {\n        // Is this pointer relevant to element?\n        if (io && io.overPointers.contains(pointer) && io.hoverable) {\n          // Check if the element is still hovered\n          var reset = false;\n\n          if (io.element && pointer.lastEvent) {\n            if (!$dom.contains(io.element, target_1)) {\n              reset = true;\n            }\n          } else {\n            reset = true;\n          }\n\n          if (reset) {\n            _this.handleOut(io, pointer, ev, true);\n          }\n        }\n      });\n    } // Process down elements\n\n\n    $iter.each(this.transformedObjects.backwards().iterator(), function (io) {\n      // Is this pointer relevant to element?\n      if (io.downPointers.contains(pointer) && // Swipe still happening?\n      !(io.swipeable && _this.swiping(io, pointer)) && (io.draggable || io.resizable)) {\n        _this.handleTransform(io, ev);\n      }\n    }); // Process tracked elements\n\n    $iter.each(this.trackedObjects.backwards().iterator(), function (io) {\n      // Is this pointer relevant to element?\n      if (!io.overPointers.contains(pointer)) {\n        _this.handleTrack(io, pointer, ev);\n      }\n    });\n  };\n  /**\r\n   * Handles reporting of pointer movement.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io        Element\r\n   * @param pointer    Pointer\r\n   * @param ev         Original event\r\n   * @param skipCheck  Sould we skip check if cursor actually moved\r\n   */\n\n\n  Interaction.prototype.handleTrack = function (io, pointer, ev, skipCheck) {\n    if (skipCheck === void 0) {\n      skipCheck = false;\n    } // Do nothing if the cursor did not actually move\n\n\n    if (!skipCheck && !this.moved(pointer, 0)) {\n      return;\n    } // Initiate TRACK event\n\n\n    if (io.events.isEnabled(\"track\") && !system.isPaused) {\n      var imev = {\n        type: \"track\",\n        target: io,\n        event: ev,\n        point: pointer.point,\n        pointer: pointer,\n        touch: pointer.touch\n      };\n      io.events.dispatchImmediately(\"track\", imev);\n    }\n  };\n  /**\r\n   * Handles swipe action.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io       Element\r\n   * @param pointer  Pointer\r\n   * @param ev       Original event\r\n   */\n\n\n  Interaction.prototype.handleSwipe = function (io, pointer, ev) {\n    // We pass in InteractionEvent with shift in mouse coordinates\n    // between when the drag started and ended\n    if (io.events.isEnabled(\"swipe\") && !system.isPaused) {\n      var imev = {\n        type: \"swipe\",\n        target: io,\n        event: ev,\n        touch: pointer.touch\n      };\n      io.events.dispatchImmediately(\"swipe\", imev);\n    }\n\n    if (pointer.startPoint.x < pointer.point.x) {\n      if (io.events.isEnabled(\"swiperight\") && !system.isPaused) {\n        var imev = {\n          type: \"swiperight\",\n          target: io,\n          event: ev,\n          touch: pointer.touch\n        };\n        io.events.dispatchImmediately(\"swiperight\", imev);\n      }\n    } else {\n      if (io.events.isEnabled(\"swipeleft\") && !system.isPaused) {\n        var imev = {\n          type: \"swipeleft\",\n          target: io,\n          event: ev,\n          touch: pointer.touch\n        };\n        io.events.dispatchImmediately(\"swipeleft\", imev);\n      }\n    }\n  };\n  /**\r\n   * Handles event triggering for wheel rotation.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io       Element\r\n   * @param pointer  Pointer\r\n   * @param deltaX   Horizontal shift\r\n   * @param deltaY   Vertical shift\r\n   * @param ev       Original event\r\n   */\n\n\n  Interaction.prototype.handleWheel = function (io, pointer, deltaX, deltaY, ev) {\n    var shift = {\n      x: deltaX,\n      y: deltaY\n    }; // Trigger generic WHEEL event\n\n    if (io.events.isEnabled(\"wheel\") && !system.isPaused) {\n      io.events.dispatchImmediately(\"wheel\", {\n        type: \"wheel\",\n        target: io,\n        event: ev,\n        point: pointer.point,\n        shift: shift\n      });\n    } // Trigger direction-specific events\n    // Horizontal\n\n\n    if (deltaX < 0) {\n      if (io.events.isEnabled(\"wheelleft\") && !system.isPaused) {\n        io.events.dispatchImmediately(\"wheelleft\", {\n          type: \"wheelleft\",\n          target: io,\n          event: ev,\n          point: pointer.point,\n          shift: shift\n        });\n      }\n    } else if (deltaX > 0) {\n      if (io.events.isEnabled(\"swiperight\") && !system.isPaused) {\n        io.events.dispatchImmediately(\"wheelright\", {\n          type: \"wheelright\",\n          target: io,\n          event: ev,\n          point: pointer.point,\n          shift: shift\n        });\n      } // Vertical\n\n    } else if (deltaY < 0) {\n      if (io.events.isEnabled(\"wheelup\") && !system.isPaused) {\n        io.events.dispatchImmediately(\"wheelup\", {\n          type: \"wheelup\",\n          target: io,\n          event: ev,\n          point: pointer.point,\n          shift: shift\n        });\n      }\n    } else if (deltaY > 0) {\n      if (io.events.isEnabled(\"wheeldown\") && !system.isPaused) {\n        io.events.dispatchImmediately(\"wheeldown\", {\n          type: \"wheeldown\",\n          target: io,\n          event: ev,\n          point: pointer.point,\n          shift: shift\n        });\n      }\n    }\n  };\n  /**\r\n   * Initiates inertia checking sub-routines for different movement types:\r\n   * drag, resize.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param sprite\r\n   * @param pointer\r\n   */\n\n\n  Interaction.prototype.handleInertia = function (io, pointer) {\n    if (io.draggable && io.downPointers.length === 0) {\n      this.handleMoveInertia(io, pointer);\n    }\n\n    if (io.resizable && io.downPointers.length > 1) {\n      this.handleResizeInertia(io, pointer);\n    }\n  };\n  /**\r\n   * Continues moving the element to simulate the effect of inertia. Happens\r\n   * when `inert` and `draggable` object is dragged and then released.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io       Element\r\n   * @param pointer  Pointer\r\n   */\n\n\n  Interaction.prototype.handleMoveInertia = function (io, pointer) {\n    var interaction = io;\n    var type = \"move\";\n    var point = {\n      \"x\": pointer.point.x,\n      \"y\": pointer.point.y\n    };\n    var startPoint = {\n      \"x\": pointer.startPoint.x,\n      \"y\": pointer.startPoint.y\n    }; // Init inertia object\n\n    var inertia = new Inertia(interaction, type, point, startPoint); // Get inertia data\n\n    var ref = this.getTrailPoint(pointer, $time.getTime() - this.getInertiaOption(io, \"move\", \"time\"));\n\n    if (typeof ref === \"undefined\") {\n      this.processDragStop(io, pointer, pointer.lastUpEvent);\n      return;\n    } // Init animation options\n\n\n    var factor = this.getInertiaOption(io, \"move\", \"factor\");\n    var animationOptions = [{\n      \"to\": pointer.point.x + (pointer.point.x - ref.point.x) * factor,\n      \"property\": \"x\"\n    }, {\n      \"to\": pointer.point.y + (pointer.point.y - ref.point.y) * factor,\n      \"property\": \"y\"\n    }]; // Start animation\n\n    var animation = new Animation(inertia, animationOptions, this.getInertiaOption(io, \"move\", \"duration\"), this.getInertiaOption(io, \"move\", \"easing\")).start();\n\n    this._disposers.push(animation.events.on(\"animationended\", function (ev) {\n      inertia.done();\n    })); // Add inertia object\n\n\n    io.inertias.setKey(\"move\", inertia);\n  };\n  /**\r\n   * Continues resizing of a `resizable` element after it is resized and\r\n   * released.\r\n   *\r\n   * **NOTE:** this is is just a placeholder function. No actual fucntionality\r\n   * is implemented, yet.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io       Element\r\n   * @param pointer  Pointer\r\n   */\n\n\n  Interaction.prototype.handleResizeInertia = function (io, pointer) {// Some day, folks. Some day...\n  };\n  /**\r\n   * Recalculates element's position and size based on position of\r\n   * all its related pointers.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io  Element\r\n   * @param ev  Original event\r\n   */\n\n\n  Interaction.prototype.handleTransform = function (io, ev) {\n    // Get primary pointer and its respective points\n    var pointer1 = io.downPointers.getIndex(0);\n    var point1 = null;\n    var startPoint1 = null;\n\n    if (pointer1) {\n      point1 = pointer1.point;\n      startPoint1 = pointer1.startPoint;\n    } // Init secondary pointer\n\n\n    var pointer2;\n    var point2;\n    var startPoint2; // Use center of the sprite to simulate \"second\" point of touch\n\n    point2 = {\n      \"x\": io.originalPosition.x,\n      \"y\": io.originalPosition.y\n    };\n    startPoint2 = point2; // Determine if it's a sinngle pointer or multi\n\n    var singlePoint = true;\n\n    for (var i = 1; i < io.downPointers.length; i++) {\n      // Get pointer\n      var nextPointer = io.downPointers.getIndex(i); // Doublecheck if it's not the same pointer by comparing original position\n\n      if (startPoint1.x != nextPointer.startPoint.x && startPoint1.y != nextPointer.startPoint.y) {\n        // Several pointers down\n        singlePoint = false; // Get second pointer\n\n        pointer2 = nextPointer;\n        point2 = pointer2.point;\n        startPoint2 = pointer2.startPoint; // Stop looking\n\n        break;\n      }\n    } // Primary touch point moved?\n\n\n    var pointer1Moved = pointer1 && this.moved(pointer1, 0); // Report DRAG_START if necessary\n\n    if (io.draggable && pointer1 && pointer1.dragStartEvents && pointer1.dragStartEvents.length && pointer1Moved) {\n      if (io.events.isEnabled(\"dragstart\") && !system.isPaused) {\n        io.events.dispatchImmediately(\"dragstart\", pointer1.dragStartEvents.shift());\n      } //delete pointer1.dragStartEvents;\n\n    } // Determine what we do in order of superiority\n\n\n    if (singlePoint && io.draggable) {\n      // We have only one pointer and the Sprite is draggable\n      // There's nothing else to be done - just move it\n      this.handleTransformMove(io, point1, startPoint1, ev, pointer1Moved, pointer1.touch);\n\n      if (this.shouldCancelHovers(pointer1) && this.moved(pointer1, this.getHitOption(io, \"hitTolerance\"))) {\n        this.cancelAllHovers(ev);\n      }\n    } else {\n      // Check if second touch point moved\n      var pointer2Moved = pointer2 && this.moved(pointer2, 0);\n\n      if (this.shouldCancelHovers(pointer1) && this.moved(pointer1, this.getHitOption(io, \"hitTolerance\")) || this.shouldCancelHovers(pointer2) && this.moved(pointer2, this.getHitOption(io, \"hitTolerance\"))) {\n        this.cancelAllHovers(ev);\n      }\n\n      if (io.draggable && io.resizable) {\n        //this.handleTransformAll(io, point1, startPoint1, point2, startPoint2, ev, pointer1Moved && pointer2Moved);\n        this.handleTransformMove(io, point1, startPoint1, ev, pointer1Moved && pointer2Moved, pointer1.touch);\n        this.handleTransformResize(io, point1, startPoint1, point2, startPoint2, ev, pointer1Moved && pointer2Moved, pointer1.touch);\n      } else {\n        if (io.draggable) {\n          this.handleTransformMove(io, point1, startPoint1, ev, pointer1Moved, pointer1.touch);\n        }\n\n        if (io.resizable && (!singlePoint || ev.ctrlKey)) {\n          this.handleTransformResize(io, point1, startPoint1, point2, startPoint2, ev, pointer1Moved && pointer2Moved, pointer1.touch);\n        }\n      }\n    }\n  };\n  /**\r\n   * Handles movement of the dragged element.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io            Element\r\n   * @param point         Current point of the pointer\r\n   * @param startPoint    Starting point of the pointer\r\n   * @param ev            Original event\r\n   * @param pointerMoved  Did pointer move?\r\n   */\n\n\n  Interaction.prototype.handleTransformMove = function (io, point, startPoint, ev, pointerMoved, touch) {\n    if (pointerMoved) {\n      if (io.events.isEnabled(\"drag\") && !system.isPaused && (!io.isTouchProtected || !touch)) {\n        var imev = {\n          type: \"drag\",\n          target: io,\n          event: ev,\n          shift: {\n            \"x\": point.x - startPoint.x,\n            \"y\": point.y - startPoint.y\n          },\n          startPoint: startPoint,\n          point: point,\n          touch: touch\n        };\n        io.events.dispatchImmediately(\"drag\", imev);\n      }\n    }\n  };\n  /**\r\n   * Handles resizing of the element.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io            Element\r\n   * @param point1        Current position of reference point #1\r\n   * @param startPoint1   Original position of reference point #1\r\n   * @param point2        Current position of reference point #2\r\n   * @param startPoint2   Original position of reference point #2\r\n   * @param ev            Original event\r\n   * @param pointerMoved  Did pointer move?\r\n   */\n\n\n  Interaction.prototype.handleTransformResize = function (io, point1, startPoint1, point2, startPoint2, ev, pointerMoved, touch) {\n    if (io.events.isEnabled(\"resize\") && !system.isPaused && (!io.isTouchProtected || !touch)) {\n      var imev = {\n        type: \"resize\",\n        target: io,\n        event: ev,\n        scale: $math.getScale(point1, startPoint1, point2, startPoint2),\n        startPoint1: startPoint1,\n        point1: point1,\n        startPoint2: startPoint2,\n        point2: point2,\n        touch: touch\n      };\n      io.events.dispatchImmediately(\"resize\", imev);\n    }\n  };\n  /**\r\n   * Handles all the preparations of the element when it starts to be dragged.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io       Element\r\n   * @param pointer  Pointer\r\n   * @param ev       Original event\r\n   */\n\n\n  Interaction.prototype.processDragStart = function (io, pointer, ev) {\n    // Add to draggedObjects\n    this.transformedObjects.moveValue(io);\n\n    if (this.shouldCancelHovers(pointer)) {\n      this.cancelAllHovers(ev);\n    } // Report \"dragstart\"\n\n\n    var imev = {\n      type: \"dragstart\",\n      target: io,\n      event: ev,\n      touch: pointer ? pointer.touch : false\n    }; // Log object that we are starting to drag, so we can check against and\n    // avoid hovers on other objects that might be in the path of movement.\n\n    if (pointer) {\n      pointer.dragTarget = io; //pointer.startPoint = pointer.point;\n    }\n    /**\r\n     * If pointer is set we will not fire the event until the pointer has\r\n     * actually moved. If it's not set we don't have to wait for anything, so we\r\n     * just fire off the event right away.\r\n     */\n\n\n    if (pointer && pointer.dragStartEvents) {\n      pointer.dragStartEvents.push(imev);\n    } else {\n      if (!system.isPaused) {\n        io.dispatchImmediately(\"dragstart\", imev);\n      }\n    }\n  };\n  /**\r\n   * Finishes up element drag operation.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io       Element\r\n   * @param pointer  Pointer\r\n   * @param ev       Original event\r\n   */\n\n\n  Interaction.prototype.processDragStop = function (io, pointer, ev) {\n    // Pointer set?\n    if (!pointer) {\n      pointer = this.getDragPointer(io);\n    } // Unset drag object\n\n\n    if (pointer) {\n      pointer.dragTarget = undefined;\n    } // Removed from transformedObjects\n\n\n    this.transformedObjects.removeValue(io); // Unlock document\n    //this.unlockDocument();\n    // Report dragstop\n\n    if (!pointer || this.moved(pointer, 0)) {\n      if (io.events.isEnabled(\"dragstop\") && !system.isPaused) {\n        var imev = {\n          type: \"dragstop\",\n          target: io,\n          touch: pointer ? pointer.touch : false\n        };\n        io.events.dispatchImmediately(\"dragstop\", imev);\n      }\n    }\n  };\n  /**\r\n   * Handles all the preparations of the element when it starts to be resized.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io       Element\r\n   * @param pointer  Pointer\r\n   * @param ev       Original event\r\n   */\n\n\n  Interaction.prototype.processResizeStart = function (io, pointer, ev) {\n    // Add to draggedObjects\n    this.transformedObjects.moveValue(io);\n  };\n  /**\r\n   * Finishes up element drag operation.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io       Element\r\n   * @param pointer  Pointer\r\n   * @param ev       Original event\r\n   */\n\n\n  Interaction.prototype.processResizeStop = function (io, pointer, ev) {\n    // Removed from transformedObjects\n    this.transformedObjects.removeValue(io);\n  };\n  /**\r\n   * ==========================================================================\r\n   * Controls for InteractionObjects initiating directly\r\n   * ==========================================================================\r\n   * @hidden\r\n   */\n\n  /**\r\n   * Manually triggers drag start on the element. Could be useful in cases\r\n   * where tracking or dragging one element can also influence dragging another\r\n   * element.\r\n   *\r\n   * Passing in `pointer` reference is advisable. If not passed in it will try\r\n   * to determine which pointer to attach to. However, it's better to specify\r\n   * it explicitly.\r\n   *\r\n   * @param io       Element\r\n   * @param pointer  Pointer\r\n   */\n\n\n  Interaction.prototype.dragStart = function (io, pointer) {\n    if (!pointer) {\n      pointer = this.getDragPointer(io);\n    }\n\n    if (pointer) {\n      this.handleDown(io, pointer, pointer.lastDownEvent);\n    }\n  };\n  /**\r\n   * Manually ends drag on the element.\r\n   *\r\n   * @param io       Element\r\n   * @param pointer  Pointer\r\n   */\n\n\n  Interaction.prototype.dragStop = function (io, pointer, cancelled) {\n    if (!pointer) {\n      pointer = this.getDragPointer(io);\n    }\n\n    if (pointer && !cancelled) {\n      this.handleGlobalUp(pointer, pointer.lastUpEvent, cancelled);\n    }\n  };\n  /**\r\n   * This method uses a fuzzy logic to find the pointer to be used for dragging.\r\n   * Beware that this is not a rock-solid solution. If there are a few objects\r\n   * being dragged at the same time, you may get unexepected results.\r\n   *\r\n   * @param io  InteractionObject to get pointers from\r\n   * @return Pointer currently being used for dragging\r\n   */\n\n\n  Interaction.prototype.getDragPointer = function (io) {\n    if (io) {\n      // InteractionObject is supplied\n      // Use it's first down pointer\n      return io.downPointers.getIndex(0);\n    } else if (this.transformedObjects.length) {\n      // Use first dragged object\n      return this.getDragPointer(this.transformedObjects.getIndex(0));\n    } else {\n      return undefined;\n    }\n  };\n  /**\r\n   * ==========================================================================\r\n   * Utils\r\n   * ==========================================================================\r\n   * @hidden\r\n   */\n\n  /**\r\n   * Returns pointer id for the given event object.\r\n   *\r\n   * @param ev  Event\r\n   * @return Pointer ID\r\n   */\n\n\n  Interaction.prototype.getPointerId = function (ev) {\n    var id = \"\";\n\n    if ($type.hasValue(ev.identifier)) {\n      id = \"\" + ev.identifier;\n    } else if ($type.hasValue(ev.pointerId)) {\n      id = \"\" + ev.pointerId;\n    } else {\n      id = \"m\";\n    }\n\n    return id.replace(\"-\", \"\");\n  };\n  /**\r\n   * Returns a cursor position of the event.\r\n   *\r\n   * @param ev  Original event\r\n   * @return Event point\r\n   */\n\n\n  Interaction.prototype.getPointerPoint = function (ev) {\n    return {\n      \"x\": ev.clientX,\n      \"y\": ev.clientY\n    };\n  };\n  /**\r\n   * Returns [[Pointer]] object that is associated with the Event.\r\n   *\r\n   * If no such [[Pointer]] object exists, it is created.\r\n   *\r\n   * @param ev  Event\r\n   * @return Pointer\r\n   */\n\n\n  Interaction.prototype.getPointer = function (ev) {\n    // Get pointer id\n    var id = this.getPointerId(ev); // Get current coordinates\n\n    var point = this.getPointerPoint(ev); // Look for the pointer in the Dictionary if it maybe already exists\n\n    var pointer;\n\n    if (this.pointers.hasKey(id)) {\n      // We already have such pointer\n      pointer = this.pointers.getKey(id); // We need this, because Edge reuses pointer ids across touch and mouse\n\n      pointer.touch = this.isPointerTouch(ev); // Reset pointer\n      //pointer.point = point;\n    } else {\n      // Init pointer\n      pointer = {\n        \"id\": id,\n        //\"touch\": !(ev instanceof MouseEvent) || ((<any>ev).pointerType && (<any>ev).pointerType != \"pointer\"),\n        //\"touch\": !(ev instanceof MouseEvent) || ((<any>ev).pointerType && (<any>ev).pointerType != \"mouse\"),\n        \"touch\": this.isPointerTouch(ev),\n        \"startPoint\": point,\n        \"startTime\": $time.getTime(),\n        \"point\": point,\n        \"track\": [],\n        \"swipeCanceled\": false,\n        \"dragStartEvents\": []\n      }; // Add first breadcrumb\n\n      this.addBreadCrumb(pointer, point); // Add for re-use later\n\n      this.pointers.setKey(id, pointer);\n    } // Log last event\n\n\n    pointer.lastEvent = ev;\n    this.lastPointer = pointer;\n    return pointer;\n  };\n  /**\r\n   * Determines if pointer event originated from a touch pointer or mouse.\r\n   *\r\n   * @param ev  Original event\r\n   * @return Touch pointer?\r\n   */\n\n\n  Interaction.prototype.isPointerTouch = function (ev) {\n    if (typeof Touch !== \"undefined\" && ev instanceof Touch) {\n      return true;\n    } else if (typeof PointerEvent !== \"undefined\" && ev instanceof PointerEvent && $type.hasValue(ev.pointerType)) {\n      switch (ev.pointerType) {\n        case \"touch\":\n        case \"pen\":\n        case 2:\n          return true;\n\n        case \"mouse\":\n        case 4:\n          return false;\n\n        default:\n          return !(ev instanceof MouseEvent);\n      }\n    } else if ($type.hasValue(ev.type)) {\n      if (ev.type.match(/^mouse/)) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n  /**\r\n   * Resets the poiner to original state, i.e. cleans movement information,\r\n   * starting point, etc.\r\n   *\r\n   * @param pointer Pointer\r\n   */\n\n\n  Interaction.prototype.resetPointer = function (pointer, ev) {\n    // Get current coordinates\n    var point = this.getPointerPoint(ev);\n    ;\n    pointer.startTime = $time.getTime();\n    pointer.startPoint = {\n      x: point.x,\n      y: point.y\n    };\n    pointer.point = {\n      x: point.x,\n      y: point.y\n    };\n    pointer.track = [];\n    pointer.swipeCanceled = false; //clearTimeout(pointer.swipeTimeout);\n    //clearTimeout(pointer.holdTimeout);\n  };\n  /**\r\n   * Adds a \"breadcrumb\" point to the [[Pointer]] to log its movement path.\r\n   *\r\n   * @param pointer  Pointer\r\n   * @param point    Point coordinates\r\n   */\n\n\n  Interaction.prototype.addBreadCrumb = function (pointer, point) {\n    pointer.track.push({\n      \"timestamp\": $time.getTime(),\n      \"point\": point\n    });\n  };\n  /**\r\n   * Prepares the document for various touch-related operations.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  Interaction.prototype.lockDocument = function () {\n    this.prepElement(this.body);\n  };\n  /**\r\n   * Restores document functionality.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  Interaction.prototype.unlockDocument = function () {\n    if (this.transformedObjects.length == 0) {\n      this.restoreAllStyles(this.body);\n    }\n  };\n  /**\r\n   * Lock element (disable all touch)\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  Interaction.prototype.lockElement = function (io) {\n    this.prepElement(io);\n  };\n  /**\r\n   * Restores element's functionality.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  Interaction.prototype.unlockElement = function (io) {\n    this.restoreAllStyles(io);\n  };\n  /**\r\n   * Locks document's wheel scroll.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  Interaction.prototype.lockWheel = function () {\n    window.addEventListener(this._pointerEvents.wheel, this.wheelLockEvent, this._passiveSupported ? {\n      passive: false\n    } : false);\n  };\n  /**\r\n   * Unlocks document's wheel scroll.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  Interaction.prototype.unlockWheel = function () {\n    window.removeEventListener(this._pointerEvents.wheel, this.wheelLockEvent);\n  };\n  /**\r\n   * Checks if top element at pointer's position belongs to the SVG.\r\n   *\r\n   * @ignore Exlude from docs\r\n   * @param pointer  Pointer\r\n   * @param svg      The <svg> element\r\n   * @param id       A unique identifier of the object that is checking for locality\r\n   * @return Belongs to SVG\r\n   */\n\n\n  Interaction.prototype.isLocalElement = function (pointer, svg, id) {\n    var cached = this.getCache(\"local_pointer_\" + pointer.id);\n\n    if ($type.hasValue(cached)) {\n      return cached;\n    }\n\n    var doc = $dom.getRoot(svg) || document;\n\n    if (doc.elementFromPoint) {\n      var target = doc.elementFromPoint(pointer.point.x, pointer.point.y);\n      var local = target && $dom.contains(svg, target);\n      this.setCache(\"local_pointer_\" + pointer.id + \"_\" + id, local, 100);\n      return local;\n    }\n\n    return false;\n  };\n  /**\r\n   * A function that cancels mouse wheel scroll.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param ev  Event object\r\n   * @return Returns `false` to cancel\r\n   */\n\n\n  Interaction.prototype.wheelLockEvent = function (ev) {\n    ev.preventDefault();\n    return false;\n  };\n  /**\r\n   * Applies a set of styles to an element. Stores the original styles so they\r\n   * can be restored later.\r\n   *\r\n   * @ignore\r\n   * @param io      Element\r\n   */\n\n\n  Interaction.prototype.prepElement = function (io) {\n    var el = io.element;\n\n    if (el) {\n      // Define possible props\n      var props = [\"touchAction\", \"webkitTouchAction\", \"MozTouchAction\", \"MSTouchAction\", \"msTouchAction\", \"oTouchAction\", \"userSelect\", \"webkitUserSelect\", \"MozUserSelect\", \"MSUserSelect\", \"msUserSelect\", \"oUserSelect\", \"touchSelect\", \"webkitTouchSelect\", \"MozTouchSelect\", \"MSTouchSelect\", \"msTouchSelect\", \"oTouchSelect\", \"touchCallout\", \"webkitTouchCallout\", \"MozTouchCallout\", \"MSTouchCallout\", \"msTouchCallout\", \"oTouchCallout\", \"contentZooming\", \"webkitContentZooming\", \"MozContentZooming\", \"MSContentZooming\", \"msContentZooming\", \"oContentZooming\", \"userDrag\", \"webkitUserDrag\", \"MozUserDrag\", \"MSUserDrag\", \"msUserDrag\", \"oUserDrag\"];\n\n      for (var i = 0; i < props.length; i++) {\n        if (props[i] in el.style) {\n          this.setTemporaryStyle(io, props[i], \"none\");\n        }\n      } // Remove iOS-specific selection;\n\n\n      this.setTemporaryStyle(io, \"tapHighlightColor\", \"rgba(0, 0, 0, 0)\"); //this.setTemporaryStyle(io, \"webkitOverflowScrolling\", \"none\");\n    }\n  };\n  /**\r\n   * Restores replaced styles\r\n   *\r\n   * @ignore\r\n   * @param  io  Element\r\n   */\n\n\n  Interaction.prototype.unprepElement = function (io) {\n    var el = io.element;\n\n    if (el) {\n      // Define possible props\n      var props = [\"touchAction\", \"webkitTouchAction\", \"MozTouchAction\", \"MSTouchAction\", \"msTouchAction\", \"oTouchAction\", \"userSelect\", \"webkitUserSelect\", \"MozUserSelect\", \"MSUserSelect\", \"msUserSelect\", \"oUserSelect\", \"touchSelect\", \"webkitTouchSelect\", \"MozTouchSelect\", \"MSTouchSelect\", \"msTouchSelect\", \"oTouchSelect\", \"touchCallout\", \"webkitTouchCallout\", \"MozTouchCallout\", \"MSTouchCallout\", \"msTouchCallout\", \"oTouchCallout\", \"contentZooming\", \"webkitContentZooming\", \"MozContentZooming\", \"MSContentZooming\", \"msContentZooming\", \"oContentZooming\", \"userDrag\", \"webkitUserDrag\", \"MozUserDrag\", \"MSUserDrag\", \"msUserDrag\", \"oUserDrag\"];\n\n      for (var i = 0; i < props.length; i++) {\n        if (props[i] in el.style) {\n          this.restoreStyle(io, props[i]);\n        }\n      } // Remove iOS-specific selection;\n\n\n      this.restoreStyle(io, \"tapHighlightColor\"); //this.restoreStyle(io, \"webkitOverflowScrolling\");\n    }\n  };\n  /**\r\n   * Returns an option associated with hit events.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io      Element\r\n   * @param option  Option key\r\n   * @return Option value\r\n   */\n\n\n  Interaction.prototype.getHitOption = function (io, option) {\n    var res = io.hitOptions[option];\n\n    if (typeof res === \"undefined\") {\n      res = this.hitOptions[option];\n    }\n\n    return res;\n  };\n  /**\r\n   * Returns an option associated with hover events.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io      Element\r\n   * @param option  Option key\r\n   * @return Option value\r\n   */\n\n\n  Interaction.prototype.getHoverOption = function (io, option) {\n    var res = io.hoverOptions[option];\n\n    if (typeof res === \"undefined\") {\n      res = this.hoverOptions[option];\n    }\n\n    return res;\n  };\n  /**\r\n   * Returns an option associated with swipe events.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io      Element\r\n   * @param option  Option key\r\n   * @return Option value\r\n   */\n\n\n  Interaction.prototype.getSwipeOption = function (io, option) {\n    var res = io.swipeOptions[option];\n\n    if (typeof res === \"undefined\") {\n      res = this.swipeOptions[option];\n    }\n\n    return res;\n  };\n  /**\r\n   * Returns an option for keyboard.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io      Element\r\n   * @param option  Option key\r\n   * @return Option value\r\n   */\n\n\n  Interaction.prototype.getKeyboardOption = function (io, option) {\n    var res = io.keyboardOptions[option];\n\n    if (typeof res === \"undefined\") {\n      res = this.keyboardOptions[option];\n    }\n\n    return res;\n  };\n  /**\r\n   * Returns an option for mouse.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io      Element\r\n   * @param option  Option key\r\n   * @return Option value\r\n   */\n\n\n  Interaction.prototype.getMouseOption = function (io, option) {\n    var res = io.mouseOptions[option];\n\n    if (typeof res === \"undefined\") {\n      res = this.mouseOptions[option];\n    }\n\n    return res;\n  };\n  /**\r\n   * Returns an option associated with inertia.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io      Element\r\n   * @param type    Inertia type\r\n   * @param option  Option key\r\n   * @return Option value\r\n   */\n\n\n  Interaction.prototype.getInertiaOption = function (io, type, option) {\n    var options = io.inertiaOptions.getKey(type);\n    var res;\n\n    if (options && $type.hasValue(options[option])) {\n      res = options[option];\n    } else {\n      res = this.inertiaOptions.getKey(type)[option];\n    }\n\n    return res;\n  };\n  /**\r\n   * Stops currently going on inertia. Useful if inertia is currently being\r\n   * animated and the object is being interacted with.\r\n   *\r\n   * @param io Element\r\n   */\n\n\n  Interaction.prototype.stopInertia = function (io) {\n    var x;\n    var inertias = [\"move\", \"resize\"];\n\n    for (var i = 0; i < inertias.length; i++) {\n      x = inertias[i];\n\n      if (io.inertias.hasKey(x)) {\n        var inertia = io.inertias.getKey(x);\n\n        if (inertia) {\n          inertia.dispose(); //io.inertiaAnimations.removeKey(x);\n          //this.processDragStop(io);\n\n          continue;\n        }\n      }\n    }\n  };\n  /**\r\n   * Check if swiping is currently being performed on an object.\r\n   *\r\n   * @param io       Element\r\n   * @param pointer  Pointer to check\r\n   * @return `true` if swiping\r\n   */\n\n\n  Interaction.prototype.swiping = function (io, pointer) {\n    var now = $time.getTime();\n\n    if (pointer.swipeCanceled || !io.swipeable) {\n      return false;\n    } else if (Math.abs(pointer.startPoint.y - pointer.point.y) < this.getSwipeOption(io, \"verticalThreshold\") && pointer.startTime > now - this.getSwipeOption(io, \"time\")) {\n      return true;\n    } else {\n      return false;\n    }\n  };\n  /**\r\n   * Returns `true` if a successfull swipe action was performed on an element.\r\n   *\r\n   * @param io       Element\r\n   * @param pointer  Pointer\r\n   * @return Swiped?\r\n   */\n\n\n  Interaction.prototype.swiped = function (io, pointer) {\n    var now = $time.getTime();\n\n    if (pointer.swipeCanceled) {\n      return false;\n    } else if (Math.abs(pointer.startPoint.x - pointer.point.x) > this.getSwipeOption(io, \"horizontalThreshold\") && Math.abs(pointer.startPoint.y - pointer.point.y) < this.getSwipeOption(io, \"verticalThreshold\") && pointer.startTime > now - this.getSwipeOption(io, \"time\")) {\n      return true;\n    } else {\n      return false;\n    }\n  };\n  /**\r\n   * Applies style to mouse cursor based on its stage in relation to\r\n   * [[InteractionObject]].\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param Element\r\n   */\n\n\n  Interaction.prototype.applyCursorOverStyle = function (io) {\n    // Get sprite's cursor ooptions\n    var options = io.cursorOptions;\n\n    if (!$type.hasValue(options.overStyle)) {\n      return;\n    } // Apply cursor down styles\n\n\n    for (var i = 0; i < options.overStyle.length; i++) {\n      $dom.setStyle(io.element, options.overStyle[i].property, options.overStyle[i].value);\n    }\n  };\n  /**\r\n   * Applies style to mouse cursor based on its stage in relation to\r\n   * [[InteractionObject]].\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io       Element\r\n   * @param pointer  Pointer\r\n   */\n\n\n  Interaction.prototype.applyCursorDownStyle = function (io, pointer) {\n    // Not applicable for touch pointers since they don't display a cursor\n    if (pointer && pointer.touch) {\n      return;\n    }\n\n    var downStyle = io.cursorOptions.downStyle; // Is down?\n\n    if (io.downPointers.contains(pointer) && $type.hasValue(downStyle)) {\n      // Apply cursor down styles\n      for (var i = 0; i < downStyle.length; i++) {\n        this.setTemporaryStyle(this.body, downStyle[i].property, downStyle[i].value);\n        this.setTemporaryStyle(io, downStyle[i].property, downStyle[i].value);\n      }\n    }\n  };\n  /**\r\n   * Restores original cursor style for the element.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io       Element\r\n   * @param pointer  Pointer\r\n   */\n\n\n  Interaction.prototype.restoreCursorDownStyle = function (io, pointer) {\n    // Not applicable for touch pointers since they don't display a cursor\n    if (pointer && pointer.touch) {\n      return;\n    }\n\n    var downStyle = io.cursorOptions.downStyle; // Is down?\n\n    if (io.downPointers.contains(pointer) && $type.hasValue(downStyle)) {\n      // Apply cursor down styles\n      for (var i = 0; i < downStyle.length; i++) {\n        this.restoreStyle(this.body, downStyle[i].property);\n        this.restoreStyle(io, downStyle[i].property);\n      }\n    }\n  };\n  /**\r\n   * Sets style on the body of the document.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param style  Style definitions\r\n   */\n\n\n  Interaction.prototype.setGlobalStyle = function (style) {\n    var body = getInteraction().body;\n    var styles = $type.isArray(style) ? style : [style];\n\n    for (var i = 0; i < styles.length; i++) {\n      this.setTemporaryStyle(body, styles[i].property, styles[i].value);\n    }\n  };\n  /**\r\n   * Restores style on the body of the document.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param style  Style definitions\r\n   */\n\n\n  Interaction.prototype.restoreGlobalStyle = function (style) {\n    var body = getInteraction().body;\n    var styles = $type.isArray(style) ? style : [style];\n\n    for (var i = 0; i < styles.length; i++) {\n      this.restoreStyle(body, styles[i].property);\n    }\n  };\n  /**\r\n   * Checks if element is a non-cahrt element.\r\n   *\r\n   * @param io  InteractionObject\r\n   * @return Global element?\r\n   */\n\n\n  Interaction.prototype.isGlobalElement = function (io) {\n    return document.body === io.element;\n  };\n  /**\r\n   * Checks if pointer has moved since it was created.\r\n   *\r\n   * @param pointer    Pointer\r\n   * @param tolerance  Tolerance in pixels\r\n   * @param minTime    Minimum time required for the pointer to be down to be considered moved\r\n   * @return `true` if the pointer has moved\r\n   */\n\n\n  Interaction.prototype.moved = function (pointer, tolerance, minTime) {\n    /*// If there was more time, we don't care if cursor actually moved\r\n    let duration = $time.getTime() - pointer.startTime;\r\n    if ($type.hasValue(minTime) && (minTime > duration)) {\r\n        return false;\r\n    }*/\n    if (minTime === void 0) {\n      minTime = 300;\n    } // That was quick measure shift\n\n\n    var shift = this.getShift(pointer);\n    return Math.abs(shift.x) > tolerance || Math.abs(shift.y) > tolerance;\n  };\n  /**\r\n   * Returns if pointer is \"old\", meaning it has been pressing for more than\r\n   * X milliseconds.\r\n   *\r\n   * @ignore\r\n   * @param pointer  Pointer\r\n   * @param minTime  Minimum time to consider pointer old\r\n   * @return {boolean}\r\n   */\n\n\n  Interaction.prototype.old = function (pointer, minTime) {\n    if (minTime === void 0) {\n      minTime = 300;\n    }\n\n    return $time.getTime() - pointer.startTime > minTime;\n  };\n  /**\r\n   * Returns total a shift in pointers coordinates between its original\r\n   * position and now.\r\n   *\r\n   * @param pointer  Pointer\r\n   * @return Shift in coordinates (x/y)\r\n   */\n\n\n  Interaction.prototype.getShift = function (pointer) {\n    return {\n      \"x\": pointer.startPoint.x - pointer.point.x,\n      \"y\": pointer.startPoint.y - pointer.point.y\n    };\n  };\n  /**\r\n   * Returns a point from [[Pointer]]'s move history at a certain timetamp.\r\n   *\r\n   * @param pointer    Pointer\r\n   * @param timestamp  Timestamp\r\n   * @return Point\r\n   */\n\n\n  Interaction.prototype.getTrailPoint = function (pointer, timestamp) {\n    var res;\n\n    for (var i = 0; i < pointer.track.length; i++) {\n      if (pointer.track[i].timestamp >= timestamp) {\n        res = pointer.track[i];\n        break;\n      }\n    }\n\n    return res;\n  };\n  /**\r\n   * Checks if same pointer already exists in the list.\r\n   *\r\n   * @param list     List to check agains\r\n   * @param pointer  Pointer\r\n   * @return Exists?\r\n   */\n\n\n  Interaction.prototype.pointerExists = function (list, pointer) {\n    var exists = false;\n    list.each(function (item) {\n      if (item == pointer) {\n        return;\n      }\n\n      exists = item.point.x == pointer.point.x && item.point.y == pointer.point.y;\n    });\n    return exists;\n  };\n  /**\r\n   * Returns an [[InteractionObject]] representation of a DOM element.\r\n   *\r\n   * You can use this on any HTML or SVG element, to add interactive features\r\n   * to it.\r\n   *\r\n   * @param element  Element\r\n   * @return InteractionObject\r\n   */\n\n\n  Interaction.prototype.getInteraction = function (element) {\n    return new InteractionObject(element);\n  };\n  /**\r\n   * Sets a style property on an element. Stores original value to be restored\r\n   * later with [[restoreStyle]].\r\n   *\r\n   * @see {@link restoreStyle}\r\n   * @param io        Element\r\n   * @param property  Property\r\n   * @param value     Value\r\n   */\n\n\n  Interaction.prototype.setTemporaryStyle = function (io, property, value) {\n    // Get element\n    //let el = io.element.tagName == \"g\" ? <SVGSVGElement>io.element.parentNode : io.element;\n    var el = io.element; // Save original property if it is set and hasn't been saved before already\n\n    if ($type.hasValue(el.style[property]) && !io.replacedStyles.hasKey(property)) {\n      io.replacedStyles.setKey(property, el.style[property]);\n    } // Replace with the new one\n\n\n    $dom.setStyle(el, property, value);\n  };\n  /**\r\n   * Restores specific style on an element.\r\n   *\r\n   * @param io        Element\r\n   * @param property  Style property\r\n   */\n\n\n  Interaction.prototype.restoreStyle = function (io, property) {\n    // Reset style\n    if (io.replacedStyles.hasKey(property)) {\n      io.element.style[property] = io.replacedStyles.getKey(property);\n      io.replacedStyles.removeKey(property);\n    } else {\n      delete io.element.style[property];\n    }\n  };\n  /**\r\n   * Restore temporarily reset styles on an element.\r\n   *\r\n   * @param io Element\r\n   */\n\n\n  Interaction.prototype.restoreAllStyles = function (io) {\n    $iter.each(io.replacedStyles.iterator(), function (a) {\n      var key = a[0];\n      var value = a[1];\n      io.element.style[key] = value;\n      io.replacedStyles.removeKey(key);\n    });\n  };\n  /**\r\n   * Disposes this object and cleans up after itself.\r\n   */\n\n\n  Interaction.prototype.dispose = function () {\n    if (!this.isDisposed()) {\n      _super.prototype.dispose.call(this);\n\n      this.restoreAllStyles(this.body);\n      this.unlockWheel();\n    }\n  }; // @ts-ignore Used for debugging\n\n\n  Interaction.prototype.log = function (text, ev, io) {\n    var show = true;\n\n    if (show) {\n      // Touchlist?\n      if (ev.changedTouches) {\n        for (var i = 0; i < ev.changedTouches.length; i++) {\n          this.logTouch(text, ev.type, ev.changedTouches[i]);\n        }\n\n        return;\n      } // Get type\n\n\n      var type = \"\";\n\n      if (ev.pointerType) {\n        switch (ev.pointerType) {\n          case 2:\n            type = \"touch\";\n            break;\n\n          case 4:\n            type = \"mouse\";\n            break;\n\n          default:\n            type = ev.pointerType;\n            break;\n        }\n      } else if (typeof TouchEvent != \"undefined\" && ev instanceof TouchEvent) {\n        type = \"touch\";\n      } else if (ev.type.match(/^mouse/)) {\n        type = \"mouse\";\n      } else {\n        type = \"???\";\n      } // Get ID\n\n\n      var id = \"\";\n\n      if ($type.hasValue(ev.identifier)) {\n        id = ev.identifier;\n      } else if ($type.hasValue(ev.pointerId)) {\n        id = ev.pointerId;\n      } else {\n        id = \"???\";\n      }\n\n      if (io) {\n        console.log(text + \" (\" + io.uid + \")  \" + ev.type + \"  \" + type + \"  \" + id);\n      } else {\n        console.log(text + \"  \" + ev.type + \"  \" + type + \"  \" + id);\n      }\n    }\n  };\n  /**\r\n   * Checks whether there are currently any objects being transformed (dragged\r\n   * or resized).\r\n   *\r\n   * If `except` is set, that object will be ignored.\r\n   *\r\n   * @since 4.9.3\r\n   * @param   except  Ignore this object(s)\r\n   * @return          Objects are being transformed\r\n   */\n\n\n  Interaction.prototype.areTransformed = function (except) {\n    var count = this.transformedObjects.length;\n\n    if (except) {\n      var ex = $type.isArray(except) ? except : [except];\n\n      for (var i = 0; i < ex.length; i++) {\n        if (this.transformedObjects.contains(ex[i])) {\n          count--;\n        }\n      }\n    }\n\n    return count > 0;\n  };\n  /**\r\n   * Log.\r\n   */\n\n\n  Interaction.prototype.logTouch = function (text, type, ev) {\n    console.log(text + \"  \" + type + \"  \" + \"touch\" + \"  \" + ev.identifier);\n  };\n\n  Object.defineProperty(Interaction, \"passiveSupported\", {\n    /**\r\n     * Indicates if passive mode options is supported by this browser.\r\n     */\n    get: function () {\n      var _this = this;\n\n      if (this._passiveSupported == null) {\n        // Check for passive mode support\n        try {\n          var options_1 = Object.defineProperty({}, \"passive\", {\n            get: function () {\n              _this._passiveSupported = true;\n            }\n          });\n          window.addEventListener(\"test\", options_1, options_1);\n          window.removeEventListener(\"test\", options_1, options_1);\n        } catch (err) {\n          this._passiveSupported = false;\n        }\n      }\n\n      return this._passiveSupported;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return Interaction;\n}(BaseObjectEvents);\n\nexport { Interaction };\nvar interaction = null;\n/**\r\n * Returns a single unified global instance of [[Interaction]].\r\n *\r\n * All code should use this function, rather than create their own instances\r\n * of [[Interaction]].\r\n */\n\nexport function getInteraction() {\n  if (interaction == null) {\n    interaction = new Interaction();\n  }\n\n  return interaction;\n}","map":{"version":3,"mappings":"AAAA;;;;;;;;;;;AAWA;;;;;;;AAMA,SAASA,gBAAT,QAAoD,SAApD;AACA,SAASC,IAAT,QAAqB,eAArB;AAEA,SAASC,SAAT,QAA0B,oBAA1B;AAEA,SAASC,aAAT,QAAyC,mBAAzC;AACA,SAASC,iBAAT,QAA4D,qBAA5D;AACA,SAASC,yBAAT,QAA0C,6BAA1C;AACA,SAASC,UAAT,QAA2B,qBAA3B;AACA,SAASC,OAAT,QAAsC,WAAtC;AAEA,SAASC,gBAAT,QAAiC,cAAjC;AAGA,SAASC,QAAT,QAAyB,mBAAzB;AACA,SAASC,MAAT,QAAuB,aAAvB;AACA,SAASC,OAAT,QAAwB,cAAxB;AACA,OAAO,KAAKC,KAAZ,MAAuB,eAAvB;AACA,OAAO,KAAKC,KAAZ,MAAuB,eAAvB;AACA,OAAO,KAAKC,MAAZ,MAAwB,gBAAxB;AACA,OAAO,KAAKC,IAAZ,MAAsB,cAAtB;AACA,OAAO,KAAKC,KAAZ,MAAuB,mBAAvB;AACA,OAAO,KAAKC,KAAZ,MAAuB,eAAvB;AACA,OAAO,KAAKC,KAAZ,MAAuB,eAAvB;AAqDA;;;;;;;AAQA;;;;;;;;;;;;;AAYA;AAAA;AAAA;AAAiCC;AAmKhC;;;;;;AAIA;AAAA,gBAEC;AACAC,yBAAO,IAHR;AAtJA;;;;;AAGUC,+BAA8B,KAA9B;AAEV;;;;AAGUA,2BAAiB;AAC1B,qBAAe,WADW;AAE1B,mBAAa,SAFa;AAG1B,qBAAe,WAHW;AAI1B,uBAAiB,SAJS;AAK1B,qBAAe,WALW;AAM1B,oBAAc,UANY;AAO1B,eAAS;AAPiB,KAAjB;AAUV;;;;;;AAKUA,kCAAiC,KAAjC;AAEV;;;;AAGUA,gCAA+B,KAA/B;AAEV;;;;;;AAKUA,4BAA2B,IAA3B;AAEV;;;;AAGUA,8BAA6B,KAA7B;AAEV;;;;AAGUA,2BAA2C;AAAEC,SAAG,EAAE;AAAP,KAA3C;AAEV;;;;AAGOD,wBAAuC,IAAIpB,IAAJ,EAAvC;AAEP;;;;AAGOoB,wBAAuC,IAAIpB,IAAJ,EAAvC;AAEP;;;;AAGOoB,2BAA0C,IAAIpB,IAAJ,EAA1C;AAEP;;;;AAGOoB,+BAA8C,IAAIpB,IAAJ,EAA9C;AAQP;;;;AAGOoB,qBAAW,IAAIf,UAAJ,EAAX;AAUP;;;;;;;;AAOOe,2BAAiB,IAAIf,UAAJ,EAAjB;AAEP;;;;;AAIOe,uBAA0B;AAChC,uBAAiB,GADe;AAEhC;AACA,sBAAgB,EAHgB;AAIhC,iBAAW;AAJqB,KAA1B;AAOP;;;;;AAIOA,yBAA8B;AACpC,0BAAoB,OADgB;AAEpC,uBAAiB;AAFmB,KAA9B;AAKP;;;;;AAIOA,yBAA8B;AACpC,cAAQ,GAD4B;AAEpC,2BAAqB,EAFe;AAGpC,6BAAuB;AAHa,KAA9B;AAMP;;;;;AAIOA,4BAAoC;AAC1C,eAAS,GADiC;AAE1C,uBAAiB,GAFyB;AAG1C,4BAAsB;AAHoB,KAApC;AAMP;;;;;;;AAMOA,yBAA8B;AACpC,qBAAe;AADqB,KAA9B,CASP,CAKC;;AACAA,SAAI,CAACE,SAAL,GAAiB,aAAjB,CAND,CAQC;;AACAF,SAAI,CAACG,IAAL,GAAYH,KAAI,CAACI,cAAL,CAAoBC,QAAQ,CAACF,IAA7B,CAAZ;;AAEAH,SAAI,CAACM,UAAL,CAAgBC,IAAhB,CAAqBP,KAAI,CAACG,IAA1B,EAXD,CAaC;;;AACA,QAAIK,MAAM,CAACC,cAAP,CAAsB,cAAtB,CAAJ,EAA2C;AAC1C;AACAT,WAAI,CAACU,cAAL,CAAoBC,WAApB,GAAkC,aAAlC;AACAX,WAAI,CAACU,cAAL,CAAoBE,SAApB,GAAgC,WAAhC;AACAZ,WAAI,CAACU,cAAL,CAAoBG,WAApB,GAAkC,aAAlC;AACAb,WAAI,CAACU,cAAL,CAAoBI,aAApB,GAAoC,eAApC;AACAd,WAAI,CAACU,cAAL,CAAoBK,WAApB,GAAkC,aAAlC;AACAf,WAAI,CAACU,cAAL,CAAoBM,UAApB,GAAiC,YAAjC,CAP0C,CAQ1C;AACA,KATD,MASO,IAAIR,MAAM,CAACC,cAAP,CAAsB,gBAAtB,CAAJ,EAA6C;AACnD;AACAT,WAAI,CAACU,cAAL,CAAoBC,WAApB,GAAkC,eAAlC;AACAX,WAAI,CAACU,cAAL,CAAoBE,SAApB,GAAgC,aAAhC;AACAZ,WAAI,CAACU,cAAL,CAAoBG,WAApB,GAAkC,eAAlC;AACAb,WAAI,CAACU,cAAL,CAAoBI,aAApB,GAAoC,aAApC;AACAd,WAAI,CAACU,cAAL,CAAoBK,WAApB,GAAkC,eAAlC;AACAf,WAAI,CAACU,cAAL,CAAoBM,UAApB,GAAiC,cAAjC,CAPmD,CAQnD;AACA,KATM,MAUF,IAAK,OAAOC,UAAP,KAAsB,WAAvB,IAAuCA,UAAU,CAAC,gBAAD,CAAV,CAA6BC,OAAxE,EAAiF;AACrF;AACA;AACA;AAEA;AACA,UAAI,kBAAkBV,MAAtB,EAA8B;AAC7BR,aAAI,CAACmB,eAAL,GAAuB,KAAvB;AACAnB,aAAI,CAACoB,mBAAL,GAA2B,IAA3B;AACA;AACD,KAVI,MAWA,IAAIZ,MAAM,CAACa,SAAP,CAAiBC,SAAjB,CAA2BC,KAA3B,CAAiC,OAAjC,CAAJ,EAA+C;AACnD;AACAvB,WAAI,CAACwB,qBAAL,GAA6B,IAA7B;AACA,KAHI,MAIA,IAAIxB,KAAI,CAACyB,MAAL,EAAJ,EAAmB;AACvB;AACA;AACAzB,WAAI,CAACwB,qBAAL,GAA6B,IAA7B;AACA,KAJI,MAKA;AACJ;AACA;AACA;AACAxB,WAAI,CAACoB,mBAAL,GAA2B,IAA3B;AACA,KA1DF,CA4DC;AACA;AACA;;AACA;;;AAIA;;;AACA,QAAI,aAAaf,QAAQ,CAACqB,aAAT,CAAuB,KAAvB,CAAjB,EAAgD;AAC/C;AACA1B,WAAI,CAACU,cAAL,CAAoBiB,KAApB,GAA4B,OAA5B;AACA,KAHD,MAIK,IAAI/B,KAAK,CAACgC,QAAN,CAAqBvB,QAAS,CAACwB,YAA/B,CAAJ,EAAkD;AACtD;AACA7B,WAAI,CAACU,cAAL,CAAoBiB,KAApB,GAA4B,YAA5B;AACA,KA3EF,CA6EC;;;AACA3B,SAAI,CAAC8B,cAAL,CAAoBC,MAApB,CAA2B,MAA3B,EAAmC;AAClC,cAAQ,GAD0B;AAElC,kBAAY,GAFsB;AAGlC,gBAAU,CAHwB;AAIlC,gBAAUxC,KAAK,CAACyC;AAJkB,KAAnC;;AAMAhC,SAAI,CAAC8B,cAAL,CAAoBC,MAApB,CAA2B,QAA3B,EAAqC;AACpC,cAAQ,GAD4B;AAEpC,kBAAY,GAFwB;AAGpC,gBAAU,CAH0B;AAIpC,gBAAUxC,KAAK,CAACyC;AAJoB,KAArC,EApFD,CA2FC;;;AACAhC,SAAI,CAACiC,iBAAL,GAAyBC,WAAW,CAACC,gBAArC,CA5FD,CA8FC;;AACAnC,SAAI,CAACoC,UAAL;;;AACA;AAED;;;;;;;;;;AAQUF,iCAAV;AACC,WAAQ1B,MAAM,CAACa,SAAP,CAAiBC,SAAjB,CAA2BC,KAA3B,CAAiC,SAAjC,CAAD,IAAiD,CAAEf,MAAM,CAACa,SAAP,CAAiBC,SAAjB,CAA2BC,KAA3B,CAAiC,SAAjC,CAA1D;AACA,GAFS;;AAIAW,gCAAV,aAA2B,CAAjB;AAGV;;;;;;;AAOA;;;;;;;;;AAOOA,0CAAP;AAAA;;AACC,QAAI,CAAC,KAAKG,kBAAV,EAA8B;AAE7B,UAAI,CAAC,KAAKjB,mBAAV,EAA+B;AAC9B,aAAKd,UAAL,CAAgBC,IAAhB,CAAqBpB,gBAAgB,CACpCkB,QADoC,EAEpC,KAAKK,cAAL,CAAoBC,WAFgB,EAGpC,UAAC2B,EAAD,EAAe;AAAOtC,eAAI,CAACuC,uBAAL,CAA6BD,EAA7B;AAAkC,SAHpB,CAArC;;AAMA,aAAKhC,UAAL,CAAgBC,IAAhB,CAAqBpB,gBAAgB,CACpCkB,QADoC,EAEpC,KAAKK,cAAL,CAAoBG,WAFgB,EAGpC,UAACyB,EAAD,EAAe;AAAOtC,eAAI,CAACwC,uBAAL,CAA6BF,EAA7B;AAAkC,SAHpB,CAArC;;AAMA,aAAKhC,UAAL,CAAgBC,IAAhB,CAAqBpB,gBAAgB,CACpCkB,QADoC,EAEpC,KAAKK,cAAL,CAAoBE,SAFgB,EAGpC,UAAC0B,EAAD,EAAe;AAAOtC,eAAI,CAACyC,qBAAL,CAA2BH,EAA3B;AAAgC,SAHlB,CAArC;;AAMA,aAAKhC,UAAL,CAAgBC,IAAhB,CAAqBpB,gBAAgB,CACpCkB,QADoC,EAEpC,KAAKK,cAAL,CAAoBI,aAFgB,EAGpC,UAACwB,EAAD,EAAe;AAAOtC,eAAI,CAACyC,qBAAL,CAA2BH,EAA3B,EAA+B,IAA/B;AAAsC,SAHxB,CAArC;;AAMA,aAAKhC,UAAL,CAAgBC,IAAhB,CAAqBpB,gBAAgB,CACpCkB,QADoC,EAEpC,YAFoC,EAGpC,UAACiC,EAAD,EAAe;AACd,cAAI,CAAC1C,KAAK,CAACgC,QAAN,CAAeU,EAAE,CAACI,aAAlB,CAAD,KAAsCJ,EAAE,CAACK,OAAH,IAAc,CAAd,IAAmBL,EAAE,CAACM,KAAH,IAAY,CAArE,CAAJ,EAA6E;AAC5E5C,iBAAI,CAAC6C,mBAAL,CAAyBP,EAAzB;AACA;AACD,SAPmC,CAArC;AASA,OApC4B,CAsC7B;AACA;AACA;;;AACA,UAAI,CAAC,KAAKd,qBAAV,EAAiC;AAChC,aAAKlB,UAAL,CAAgBC,IAAhB,CAAqBpB,gBAAgB,CACpCkB,QADoC,EAEpC,YAFoC,EAGpC,UAACiC,EAAD,EAAe;AAAOtC,eAAI,CAAC8C,sBAAL,CAA4BR,EAA5B;AAAiC,SAHnB,CAArC;;AAMA,aAAKhC,UAAL,CAAgBC,IAAhB,CAAqBpB,gBAAgB,CACpCkB,QADoC,EAEpC,WAFoC,EAGpC,UAACiC,EAAD,EAAe;AAAOtC,eAAI,CAAC+C,qBAAL,CAA2BT,EAA3B;AAAgC,SAHlB,CAArC;;AAMA,aAAKhC,UAAL,CAAgBC,IAAhB,CAAqBpB,gBAAgB,CACpCkB,QADoC,EAEpC,UAFoC,EAGpC,UAACiC,EAAD,EAAe;AAAOtC,eAAI,CAACgD,oBAAL,CAA0BV,EAA1B;AAA+B,SAHjB,CAArC;AAKA;;AAED,WAAKhC,UAAL,CAAgBC,IAAhB,CAAqBpB,gBAAgB,CACpCkB,QADoC,EAEpC,SAFoC,EAGpC,UAACiC,EAAD,EAAkB;AAAOtC,aAAI,CAACiD,mBAAL,CAAyBX,EAAzB;AAA8B,OAHnB,CAArC;;AAMA,WAAKhC,UAAL,CAAgBC,IAAhB,CAAqBpB,gBAAgB,CACpCkB,QADoC,EAEpC,OAFoC,EAGpC,UAACiC,EAAD,EAAkB;AAAOtC,aAAI,CAACkD,iBAAL,CAAuBZ,EAAvB;AAA4B,OAHjB,CAArC;;AAMA,WAAKD,kBAAL,GAA0B,IAA1B;AACA;AACD,GA5EM;AA8EP;;;;;;;;AAMOH,2CAAP,UAAwBiB,EAAxB,EAA6C;AAC5C;AACA,SAAKC,gBAAL,CAAsBD,EAAtB;AACA,GAHM;AAKP;;;;;;;;AAMOjB,6CAAP,UAA0BiB,EAA1B,EAA+C;AAC9C,QAAIA,EAAE,CAACE,mBAAP,EAA4B;AAC3B,UAAI,CAACF,EAAE,CAACG,cAAH,CAAkBC,MAAlB,CAAyB,qBAAzB,CAAL,EAAsD;AACrDJ,UAAE,CAACG,cAAH,CAAkBvB,MAAlB,CAAyB,qBAAzB,EACC5C,gBAAgB,CAA4BgE,EAAE,CAACK,OAA/B,EAAwC,aAAxC,EAAuD,UAACC,CAAD,EAAE;AACxEA,WAAC,CAACC,cAAF;AACA,SAFe,CADjB;AAKA;AACD,KARD,MASK;AACJ,UAAIP,EAAE,CAACG,cAAH,CAAkBC,MAAlB,CAAyB,qBAAzB,CAAJ,EAAqD;AACpDJ,UAAE,CAACG,cAAH,CAAkBK,MAAlB,CAAyB,qBAAzB,EAAgDC,OAAhD;AACA;AACD;AACD,GAfM;AAiBP;;;;;;;;AAMO1B,2CAAP,UAAwBiB,EAAxB,EAA6C;AAA7C;;AACC,QAAIA,EAAE,CAACU,SAAH,IAAgBV,EAAE,CAACW,SAAvB,EAAkC;AAEjC;AACA,WAAKC,eAAL,GAHiC,CAKjC;;AACA,WAAKC,oBAAL,CAA0Bb,EAA1B,EANiC,CAQjC;;AACA,UAAI,CAACA,EAAE,CAACG,cAAH,CAAkBC,MAAlB,CAAyB,WAAzB,CAAD,IAA0C,KAAKpC,eAAnD,EAAoE;AACnEgC,UAAE,CAACG,cAAH,CAAkBvB,MAAlB,CAAyB,WAAzB,EAAsC,IAAIjD,aAAJ,CAAkB,CACvDK,gBAAgB,CAA4BgE,EAAE,CAACK,OAA/B,EAAwC,KAAK9C,cAAL,CAAoBM,UAA5D,EAAwE,UAACyC,CAAD,EAAE;AAAK,sBAAI,CAACQ,gBAAL,CAAsBd,EAAtB,EAA0BM,CAA1B;AAA4B,SAA3G,CADuC,EAEvDtE,gBAAgB,CAA4BgE,EAAE,CAACK,OAA/B,EAAwC,KAAK9C,cAAL,CAAoBK,WAA5D,EAAyE,UAAC0C,CAAD,EAAE;AAAK,sBAAI,CAACS,iBAAL,CAAuBf,EAAvB,EAA2BM,CAA3B;AAA6B,SAA7G,CAFuC,CAAlB,CAAtC;AAIA;;AAED,UAAIN,EAAE,CAACW,SAAP,EAAkB,CACjB;AACA;AAED,KApBD,MAoBO;AACN,UAAMK,QAAQ,GAAGhB,EAAE,CAACG,cAAH,CAAkBK,MAAlB,CAAyB,WAAzB,CAAjB;;AAEA,UAAIQ,QAAQ,IAAI,IAAhB,EAAsB;AACrBA,gBAAQ,CAACP,OAAT;AACAT,UAAE,CAACG,cAAH,CAAkBc,SAAlB,CAA4B,WAA5B;AACA;AACD,KA5B2C,CA8B5C;;;AACA,SAAKhB,gBAAL,CAAsBD,EAAtB;AACA,GAhCM;AAkCP;;;;;;;;;AAOOjB,yCAAP,UAAsBiB,EAAtB,EAA2C;AAE1C;AACA,QAAIA,EAAE,CAACkB,SAAH,IAAgBlB,EAAE,CAACmB,SAAnB,IAAgCnB,EAAE,CAACW,SAAnC,IAAgDX,EAAE,CAACoB,SAAvD,EAAkE;AAEjE;AACA,UAAI,CAAC,KAAKC,eAAL,CAAqBrB,EAArB,CAAD,IAA6B,CAACA,EAAE,CAACsB,gBAArC,EAAuD;AACtD,aAAKC,WAAL,CAAiBvB,EAAjB;AACA,OALgE,CAOjE;;;AACA,WAAKa,oBAAL,CAA0Bb,EAA1B;AAEA,KAbyC,CAe1C;;;AACA,SAAKC,gBAAL,CAAsBD,EAAtB;AAEA,GAlBM;AAoBP;;;;;;;;AAMOjB,2CAAP,UAAwBiB,EAAxB,EAA6C;AAC5C,SAAKwB,gBAAL,CAAsBxB,EAAtB;AACA,SAAKyB,cAAL,CAAoBzB,EAApB;;AACA,QAAIA,EAAE,CAACW,SAAP,EAAkB;AACjB,WAAKe,cAAL,CAAoBC,SAApB,CAA8B3B,EAA9B;AACA,KAFD,MAGK;AACJ,WAAK0B,cAAL,CAAoBE,WAApB,CAAgC5B,EAAhC;AACA;AACD,GATM;AAWP;;;;;;;;AAMOjB,2CAAP,UAAwBiB,EAAxB,EAA6C;AAC5C,SAAKyB,cAAL,CAAoBzB,EAApB;AACA,GAFM;AAIP;;;;;;;;;;;;AAUOjB,2CAAP,UAAwBiB,EAAxB,EAA6C;AAC5C,SAAKyB,cAAL,CAAoBzB,EAApB;AACA,GAFM;AAIP;;;;;;;;;AAOOjB,2CAAP,UAAwBiB,EAAxB,EAA6C;AAC5C,SAAKyB,cAAL,CAAoBzB,EAApB;AACA,GAFM;AAIP;;;;;;;;;AAOOjB,2CAAP,UAAwBiB,EAAxB,EAA6C;AAA7C;;AACC,QAAIA,EAAE,CAAC6B,SAAP,EAAkB;AACjB;AACA,UAAI,CAAC7B,EAAE,CAACG,cAAH,CAAkBC,MAAlB,CAAyB,WAAzB,CAAL,EAA4C;AAC3CJ,UAAE,CAACG,cAAH,CAAkBvB,MAAlB,CAAyB,WAAzB,EAAsC,IAAIjD,aAAJ,CAAkB,CACvDK,gBAAgB,CACfgE,EAAE,CAACK,OADY,EAEf,KAAK9C,cAAL,CAAoBiB,KAFL,EAGf,UAAC8B,CAAD,EAAE;AAAK,sBAAI,CAACwB,gBAAL,CAAsB9B,EAAtB,EAA0BM,CAA1B;AAA4B,SAHpB,EAIf,KAAKxB,iBAAL,GAAyB;AAAEiD,iBAAO,EAAE;AAAX,SAAzB,GAA8C,KAJ/B,CADuC,EAOvD/B,EAAE,CAACgC,MAAH,CAAUC,EAAV,CAAa,KAAb,EAAoB,UAAC3B,CAAD,EAAE;AACrB,cAAIN,EAAE,CAAC6B,SAAP,EAAkB;AACjBhF,iBAAI,CAACqF,WAAL;AACA;AACD,SAJD,CAPuD,EAYvDlC,EAAE,CAACgC,MAAH,CAAUC,EAAV,CAAa,MAAb,EAAqB,UAAC3B,CAAD,EAAE;AACxB;AACE,cAAIN,EAAE,CAAC6B,SAAP,EAAkB;AACjBhF,iBAAI,CAACsF,SAAL;AACA;AACD,SALD,CAZuD,CAAlB,CAAtC;AAmBA;AAED,KAxBD,MAwBO;AACN,UAAMnB,QAAQ,GAAGhB,EAAE,CAACG,cAAH,CAAkBK,MAAlB,CAAyB,WAAzB,CAAjB;;AAEA,UAAIQ,QAAQ,IAAI,IAAhB,EAAsB;AACrBA,gBAAQ,CAACP,OAAT;AACAT,UAAE,CAACG,cAAH,CAAkBc,SAAlB,CAA4B,WAA5B;AACA;AACD;AACD,GAjCM;AAmCP;;;;;;;;;;;AASOlC,2CAAP,UAAwBiB,EAAxB,EAA6C;AAA7C;;AACC,QAAIA,EAAE,CAACoC,SAAH,KAAiB,IAAjB,IAA0BpC,EAAE,CAACqC,QAAH,GAAc,CAAC,CAAzC,IAA+C,CAAC,KAAKpE,mBAAzD,EAA8E;AAC7E,UAAI,CAAC+B,EAAE,CAACG,cAAH,CAAkBC,MAAlB,CAAyB,WAAzB,CAAL,EAA4C;AAC3CJ,UAAE,CAACG,cAAH,CAAkBvB,MAAlB,CAAyB,WAAzB,EAAsC,IAAIjD,aAAJ,CAAkB,CACvDK,gBAAgB,CAAagE,EAAE,CAACK,OAAhB,EAAyB,OAAzB,EAAkC,UAACC,CAAD,EAAE;AAAK,sBAAI,CAACgC,WAAL,CAAiBtC,EAAjB,EAAqBM,CAArB;AAAuB,SAAhE,CADuC,EAEvDtE,gBAAgB,CAAagE,EAAE,CAACK,OAAhB,EAAyB,MAAzB,EAAiC,UAACC,CAAD,EAAE;AAAK,sBAAI,CAACiC,UAAL,CAAgBvC,EAAhB,EAAoBM,CAApB;AAAsB,SAA9D,CAFuC,EAGvDtE,gBAAgB,CACfgE,EAAE,CAACK,OADY,EAEf,KAAK9C,cAAL,CAAoBC,WAFL,EAGf,UAAC8C,CAAD,EAAE;AAAK,sBAAI,CAACkC,eAAL,CAAqBxC,EAArB,EAAyBM,CAAzB;AAA2B,SAHnB,CAHuC,EASvDtE,gBAAgB,CACfgE,EAAE,CAACK,OADY,EAEf,YAFe,EAGf,UAACC,CAAD,EAAE;AAAK,sBAAI,CAACkC,eAAL,CAAqBxC,EAArB,EAAyBM,CAAzB;AAA2B,SAHnB,EAIf,KAAKxB,iBAAL,GAAyB;AAAEiD,iBAAO,EAAE;AAAX,SAAzB,GAA8C,KAJ/B,CATuC,CAAlB,CAAtC;AAgBA;AACD,KAnBD,MAoBK;AACJ,UAAMf,QAAQ,GAAGhB,EAAE,CAACG,cAAH,CAAkBK,MAAlB,CAAyB,WAAzB,CAAjB;;AAEA,UAAIQ,QAAQ,IAAI,IAAhB,EAAsB;AACrBA,gBAAQ,CAACP,OAAT;AACAT,UAAE,CAACG,cAAH,CAAkBc,SAAlB,CAA4B,WAA5B;AACA;AACD;AACD,GA7BM;AA+BP;;;;;;;;;AAOOlC,2CAAP,UAAwBiB,EAAxB,EAA6C;AAA7C,qBAA6C,CAE5C;;;AACA,QAAIA,EAAE,CAACyC,SAAH,IAAgBzC,EAAE,CAACU,SAAnB,IAAgCV,EAAE,CAACW,SAAnC,IAAgDX,EAAE,CAACkB,SAAnD,IAAgElB,EAAE,CAACmB,SAAnE,IAAgFnB,EAAE,CAACoB,SAAvF,EAAkG;AAEjG;AACA,WAAKR,eAAL,GAHiG,CAKjG;;AACA,UAAI,CAACZ,EAAE,CAACG,cAAH,CAAkBC,MAAlB,CAAyB,WAAzB,CAAL,EAA4C;AAC3C,YAAI,CAAC,KAAKnC,mBAAN,IAA6B,CAAC,KAAKI,qBAAvC,EAA8D;AAC7D2B,YAAE,CAACG,cAAH,CAAkBvB,MAAlB,CAAyB,WAAzB,EAAsC,IAAIjD,aAAJ,CAAkB,CAEvDK,gBAAgB,CACfgE,EAAE,CAACK,OADY,EAEf,KAAK9C,cAAL,CAAoBC,WAFL,EAGf,UAAC8C,CAAD,EAAE;AAAK,wBAAI,CAACoC,iBAAL,CAAuB1C,EAAvB,EAA2BM,CAA3B;AAA6B,WAHrB,CAFuC,EAQvDtE,gBAAgB,CACfgE,EAAE,CAACK,OADY,EAEf,YAFe,EAGf,UAACC,CAAD,EAAE;AAAK,wBAAI,CAACqC,eAAL,CAAqB3C,EAArB,EAAyBM,CAAzB;AAA2B,WAHnB,EAIf,KAAKxB,iBAAL,GAAyB;AAAEiD,mBAAO,EAAE;AAAX,WAAzB,GAA8C,KAJ/B,CARuC,CAAlB,CAAtC;AAgBA,SAjBD,MAkBK,IAAI,CAAC,KAAK9D,mBAAV,EAA+B;AACnC+B,YAAE,CAACG,cAAH,CAAkBvB,MAAlB,CAAyB,WAAzB,EACC5C,gBAAgB,CACfgE,EAAE,CAACK,OADY,EAEf,KAAK9C,cAAL,CAAoBC,WAFL,EAGf,UAAC8C,CAAD,EAAE;AAAK,wBAAI,CAACoC,iBAAL,CAAuB1C,EAAvB,EAA2BM,CAA3B;AAA6B,WAHrB,CADjB;AAOA,SARI,MASA,IAAI,CAAC,KAAKjC,qBAAV,EAAiC;AACrC2B,YAAE,CAACG,cAAH,CAAkBvB,MAAlB,CAAyB,WAAzB,EACC5C,gBAAgB,CACfgE,EAAE,CAACK,OADY,EAEf,YAFe,EAGf,UAACC,CAAD,EAAE;AAAK,wBAAI,CAACqC,eAAL,CAAqB3C,EAArB,EAAyBM,CAAzB;AAA2B,WAHnB,EAIf,KAAKxB,iBAAL,GAAyB;AAAEiD,mBAAO,EAAE;AAAX,WAAzB,GAA8C,KAJ/B,CADjB;AAQA;AACD;AAED,KA9CD,MA8CO;AACN,UAAMf,QAAQ,GAAGhB,EAAE,CAACG,cAAH,CAAkBK,MAAlB,CAAyB,WAAzB,CAAjB;;AAEA,UAAIQ,QAAQ,IAAI,IAAhB,EAAsB;AACrBA,gBAAQ,CAACP,OAAT;AACAT,UAAE,CAACG,cAAH,CAAkBc,SAAlB,CAA4B,WAA5B;AACA;AACD;AAED,GA1DM;AA4DP;;;;;;;AAOA;;;;;;;;;AAOOlC,sCAAP,UAAmBiB,EAAnB,EAA0Cb,EAA1C,EAAwD;AACvD,QAAI,CAACa,EAAE,CAACoC,SAAR,EAAmB;AAClBjD,QAAE,CAACoB,cAAH;AACA;AACA;;AACDP,MAAE,CAAC4C,SAAH,GAAe,IAAf;;AACA,QAAI5C,EAAE,CAACgC,MAAH,CAAUa,SAAV,CAAoB,OAApB,KAAgC,CAAC3G,MAAM,CAAC4G,QAA5C,EAAsD;AACrD,UAAIC,IAAI,GAAkE;AACzEC,YAAI,EAAE,OADmE;AAEzEC,cAAM,EAAEjD,EAFiE;AAGzEkD,aAAK,EAAE/D;AAHkE,OAA1E;AAKAa,QAAE,CAACgC,MAAH,CAAUmB,mBAAV,CAA8B,OAA9B,EAAuCJ,IAAvC;AACA;AACD,GAdM;AAgBP;;;;;;;;;;AAQQhE,0CAAR,UAAwBiB,EAAxB,EAA+Cb,EAA/C,EAA0E;AACzE,QAAIa,EAAE,CAACoC,SAAH,KAAiB,KAAjB,IAA0B,KAAKgB,YAAL,CAAkBpD,EAAlB,EAAsB,SAAtB,CAA9B,EAAgE;AAC/DA,QAAE,CAACgC,MAAH,CAAUqB,IAAV,CAAe,OAAf,EAAwB;AACvBrD,UAAE,CAACgC,MAAH,CAAUsB,WAAV,CAAsB,MAAtB;AACA/G,YAAI,CAACgH,IAAL;;AACA,YAAIvD,EAAE,CAACwD,MAAP,EAAe;AACdxD,YAAE,CAACwD,MAAH,CAAUjB,UAAV;AACA;;AACDvC,UAAE,CAACgC,MAAH,CAAUyB,UAAV,CAAqB,MAArB;AACA,OAPD;AAQA;AACD,GAXO;AAaR;;;;;;;;;AAOO1E,qCAAP,UAAkBiB,EAAlB,EAAyCb,EAAzC,EAAuD;AACtD,QAAI,CAACa,EAAE,CAACoC,SAAR,EAAmB;AAClBjD,QAAE,CAACoB,cAAH;AACA;AACA;;AACDP,MAAE,CAAC4C,SAAH,GAAe,KAAf;;AACA,QAAI5C,EAAE,CAACgC,MAAH,CAAUa,SAAV,CAAoB,MAApB,KAA+B,CAAC3G,MAAM,CAAC4G,QAA3C,EAAqD;AACpD,UAAIC,IAAI,GAAiE;AACxEC,YAAI,EAAE,MADkE;AAExEC,cAAM,EAAEjD,EAFgE;AAGxEkD,aAAK,EAAE/D;AAHiE,OAAzE;AAKAa,QAAE,CAACgC,MAAH,CAAUmB,mBAAV,CAA8B,MAA9B,EAAsCJ,IAAtC;AACA;AACD,GAdM;AAgBP;;;;;;;AAOA;;;;;;;;;;AAQOhE,8CAAP,UAA2BI,EAA3B,EAA4C;AAE3C,QAAI,KAAKuE,aAAT,EAAwB;AACvB,UAAIzH,QAAQ,CAAC0H,KAAT,CAAexE,EAAf,EAAmB,KAAnB,CAAJ,EAA+B;AAC9B;AACA5C,YAAI,CAACgH,IAAL;AACA,OAHD,MAIK,IAAI,KAAKG,aAAL,CAAmBxC,SAAnB,IAAgCjF,QAAQ,CAAC0H,KAAT,CAAexE,EAAf,EAAmB,CAAC,IAAD,EAAO,MAAP,EAAe,MAAf,EAAuB,OAAvB,CAAnB,CAApC,EAAyF;AAE7F;AACAA,UAAE,CAACoB,cAAH,GAH6F,CAK7F;;AACA,YAAIP,EAAE,GAAG,KAAK0D,aAAd,CAN6F,CAQ7F;;AACA,YAAIE,WAAW,GAAG,2BAAlB,CAT6F,CAW7F;AACA;;AACA,YAAI5D,EAAE,CAACG,cAAH,CAAkBC,MAAlB,CAAyBwD,WAAzB,CAAJ,EAA2C;AAC1C;AACA,SAf4F,CAiB7F;;;AACA,YAAIC,EAAE,GAAG,IAAIhI,yBAAJ,CAA8BmE,EAA9B,EAAkCb,EAAlC,CAAT;AACAa,UAAE,CAACG,cAAH,CAAkBvB,MAAlB,CAAyBgF,WAAzB,EAAsCC,EAAtC;;AACA,gBAAQ5H,QAAQ,CAAC6H,WAAT,CAAqB3E,EAArB,CAAR;AACC,eAAK,IAAL;AACC0E,cAAE,CAACE,UAAH,GAAgB,CAAC,CAAjB;AACA;;AACD,eAAK,MAAL;AACCF,cAAE,CAACE,UAAH,GAAgB,CAAhB;AACA;;AACD,eAAK,MAAL;AACCF,cAAE,CAACG,UAAH,GAAgB,CAAC,CAAjB;AACA;;AACD,eAAK,OAAL;AACCH,cAAE,CAACG,UAAH,GAAgB,CAAhB;AACA;AAZF;AAcA;AACD;AACD,GA3CM;AA6CP;;;;;;;;AAMOjF,4CAAP,UAAyBI,EAAzB,EAA0C;AACzC,QAAIyE,WAAW,GAAG,2BAAlB;;AACA,QAAI,KAAKF,aAAT,EAAwB;AACvB,UAAM1C,QAAQ,GAAG,KAAK0C,aAAL,CAAmBvD,cAAnB,CAAkCK,MAAlC,CAAyCoD,WAAzC,CAAjB;;AAEA,UAAI5C,QAAQ,IAAI,IAAhB,EAAsB;AACrB;AACA7B,UAAE,CAACoB,cAAH,GAFqB,CAIrB;;AACAS,gBAAQ,CAACP,OAAT;AACA,aAAKiD,aAAL,CAAmBvD,cAAnB,CAAkCc,SAAlC,CAA4C2C,WAA5C;AACA,OAVsB,CAYvB;;;AACA,UAAI3H,QAAQ,CAAC0H,KAAT,CAAexE,EAAf,EAAmB,OAAnB,KACA,KAAKuE,aAAL,CAAmBF,MADnB,IAEA,CAAC,KAAKE,aAAL,CAAmBF,MAAnB,CAA0BxB,MAA1B,CAAiCa,SAAjC,CAA2C,SAA3C,CAFL,EAGE;AACD,YAAI,KAAKa,aAAL,CAAmBF,MAAnB,CAA0BxB,MAA1B,CAAiCa,SAAjC,CAA2C,KAA3C,CAAJ,EAAuD;AACtD,eAAKa,aAAL,CAAmBP,mBAAnB,CAAuC,KAAvC;AACA,SAFD,MAGK,IAAI,KAAKO,aAAL,CAAmBF,MAAnB,CAA0BS,aAA1B,IAA2C,KAA/C,EAAsD;AAC1D,eAAKP,aAAL,CAAmBP,mBAAnB,CAAuC,IAAvC;AACA;AACD;AAED;AACD,GA5BM;AA8BP;;;;;;;AAOA;;;;;;;;AAMOpE,kDAAP,UAA+BI,EAA/B,EAA6C;AAC5C;AACA,QAAI+E,OAAO,GAAa,KAAKC,UAAL,CAAgBhF,EAAhB,CAAxB,CAF4C,CAI5C;;AACA+E,WAAO,CAACE,KAAR,GAAgB,KAAKC,eAAL,CAAqBlF,EAArB,CAAhB,CAL4C,CAO5C;;AACA,QAAI,KAAK6C,MAAL,CAAYa,SAAZ,CAAsB,OAAtB,KAAkC,CAAC3G,MAAM,CAAC4G,QAA9C,EAAwD;AACvD,UAAIC,IAAI,GAA+C;AACtDC,YAAI,EAAE,OADgD;AAEtDC,cAAM,EAAE,IAF8C;AAGtDC,aAAK,EAAE/D,EAH+C;AAItD+E,eAAO,EAAEA,OAJ6C;AAKtDI,aAAK,EAAEJ,OAAO,CAACI;AALuC,OAAvD;AAOA,WAAKtC,MAAL,CAAYmB,mBAAZ,CAAgC,OAAhC,EAAyCJ,IAAzC;AACA,KAjB2C,CAmB5C;;;AACA,SAAKwB,aAAL,CAAmBL,OAAnB,EAA4BA,OAAO,CAACE,KAApC,EApB4C,CAsB5C;;AACA,SAAKI,gBAAL,CAAsBN,OAAtB,EAA+B/E,EAA/B;AACA,GAxBM;AA0BP;;;;;;;;AAMOJ,kDAAP,UAA+BI,EAA/B,EAA6C;AAE5C;AACA,SAAKsF,cAAL,GAH4C,CAK5C;;AACA,QAAIP,OAAO,GAAa,KAAKC,UAAL,CAAgBhF,EAAhB,CAAxB,CAN4C,CAQ5C;;AACA,QAAI,KAAK6C,MAAL,CAAYa,SAAZ,CAAsB,MAAtB,KAAiC,CAAC3G,MAAM,CAAC4G,QAA7C,EAAuD;AACtD,UAAIC,IAAI,GAA8C;AACrDC,YAAI,EAAE,MAD+C;AAErDC,cAAM,EAAE,IAF6C;AAGrDC,aAAK,EAAE/D,EAH8C;AAIrD+E,eAAO,EAAEA,OAJ4C;AAKrDI,aAAK,EAAEJ,OAAO,CAACI;AALsC,OAAtD;AAOA,WAAKtC,MAAL,CAAYmB,mBAAZ,CAAgC,MAAhC,EAAwCJ,IAAxC;AACA;AACD,GAnBM;AAqBP;;;;;;;;AAMOhE,6CAAP,UAA0BI,EAA1B,EAAwC;AACvC,QAAI,CAACA,EAAE,CAACuF,gBAAR,EAA0B;AACzBvF,QAAE,CAACoB,cAAH;AACA;AACD,GAJM;AAMP;;;;;;;;AAMOxB,gDAAP,UAA6BI,EAA7B,EAA6CwF,SAA7C,EAAuE;AAA1B;AAAAA;AAA0B,MAEtE;;;AACA,QAAIT,OAAO,GAAa,KAAKC,UAAL,CAAgBhF,EAAhB,CAAxB,CAHsE,CAKtE;;AACA,QAAI,KAAK6C,MAAL,CAAYa,SAAZ,CAAsB,IAAtB,KAA+B,CAAC3G,MAAM,CAAC4G,QAA3C,EAAqD;AACpD,UAAIC,IAAI,GAA4C;AACnDC,YAAI,EAAE,IAD6C;AAEnDC,cAAM,EAAE,IAF2C;AAGnDC,aAAK,EAAE/D,EAH4C;AAInD+E,eAAO,EAAEA,OAJ0C;AAKnDI,aAAK,EAAEJ,OAAO,CAACI;AALoC,OAApD;AAOA,WAAKtC,MAAL,CAAYmB,mBAAZ,CAAgC,IAAhC,EAAsCJ,IAAtC;AACA,KAfqE,CAiBtE;;;AACA,SAAK6B,cAAL,CAAoBV,OAApB,EAA6B/E,EAA7B,EAAiCwF,SAAjC;AAEA,GApBM;AAsBP;;;;;;AAMA;;;;;;;;AAMO5F,gDAAP,UAA6BI,EAA7B,EAA2C;AAE1C;AACA,SAAK,IAAI0F,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG1F,EAAE,CAAC2F,cAAH,CAAkBC,MAAtC,EAA8CF,CAAC,EAA/C,EAAmD;AAClD;AACA,UAAIX,OAAO,GAAa,KAAKC,UAAL,CAAgBhF,EAAE,CAAC2F,cAAH,CAAkBD,CAAlB,CAAhB,CAAxB,CAFkD,CAIlD;;AACAX,aAAO,CAACE,KAAR,GAAgB,KAAKC,eAAL,CAAqBlF,EAAE,CAAC2F,cAAH,CAAkBD,CAAlB,CAArB,CAAhB,CALkD,CAOlD;;AACA,UAAI,KAAK7C,MAAL,CAAYa,SAAZ,CAAsB,OAAtB,KAAkC,CAAC3G,MAAM,CAAC4G,QAA9C,EAAwD;AACvD,YAAIC,IAAI,GAA+C;AACtDC,cAAI,EAAE,OADgD;AAEtDC,gBAAM,EAAE,IAF8C;AAGtDC,eAAK,EAAE/D,EAH+C;AAItD+E,iBAAO,EAAEA,OAJ6C;AAKtDI,eAAK,EAAEJ,OAAO,CAACI;AALuC,SAAvD;AAOA,aAAKtC,MAAL,CAAYmB,mBAAZ,CAAgC,OAAhC,EAAyCJ,IAAzC;AACA,OAjBiD,CAmBlD;;;AACA,WAAKwB,aAAL,CAAmBL,OAAnB,EAA4BA,OAAO,CAACE,KAApC,EApBkD,CAsBlD;;AACA,WAAKI,gBAAL,CAAsBN,OAAtB,EAA+B/E,EAA/B;AACA;AAED,GA7BM;AA+BP;;;;;;;;AAMOJ,iDAAP,UAA8BI,EAA9B,EAA4C;AAE3C;AACA,SAAKsF,cAAL,GAH2C,CAK3C;;AACA,SAAK,IAAII,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG1F,EAAE,CAAC2F,cAAH,CAAkBC,MAAtC,EAA8CF,CAAC,EAA/C,EAAmD;AAElD;AACA,UAAIX,OAAO,GAAa,KAAKC,UAAL,CAAgBhF,EAAE,CAAC2F,cAAH,CAAkBD,CAAlB,CAAhB,CAAxB,CAHkD,CAKlD;;AACA,UAAI,CAAC,KAAKxG,qBAAN,IAA+B,KAAK2D,MAAL,CAAYa,SAAZ,CAAsB,MAAtB,CAA/B,IAAgE,CAAC3G,MAAM,CAAC4G,QAA5E,EAAsF;AACrF,YAAIC,IAAI,GAA8C;AACrDC,cAAI,EAAE,MAD+C;AAErDC,gBAAM,EAAE,IAF6C;AAGrDC,eAAK,EAAE/D,EAH8C;AAIrD+E,iBAAO,EAAEA,OAJ4C;AAKrDI,eAAK,EAAEJ,OAAO,CAACI;AALsC,SAAtD;AAOA,aAAKtC,MAAL,CAAYmB,mBAAZ,CAAgC,MAAhC,EAAwCJ,IAAxC;AACA;AAED;AAED,GAzBM;AA2BP;;;;;;;;AAMOhE,+CAAP,UAA4BI,EAA5B,EAA0C;AAEzC;AACA,SAAK,IAAI0F,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG1F,EAAE,CAAC2F,cAAH,CAAkBC,MAAtC,EAA8CF,CAAC,EAA/C,EAAmD;AAElD;AACA,UAAIX,OAAO,GAAa,KAAKC,UAAL,CAAgBhF,EAAE,CAAC2F,cAAH,CAAkBD,CAAlB,CAAhB,CAAxB,CAHkD,CAKlD;;AACA,UAAI,KAAK7C,MAAL,CAAYa,SAAZ,CAAsB,IAAtB,KAA+B,CAAC3G,MAAM,CAAC4G,QAA3C,EAAqD;AACpD,YAAIC,IAAI,GAA4C;AACnDC,cAAI,EAAE,IAD6C;AAEnDC,gBAAM,EAAE,IAF2C;AAGnDC,eAAK,EAAE/D,EAH4C;AAInD+E,iBAAO,EAAEA,OAJ0C;AAKnDI,eAAK,EAAEJ,OAAO,CAACI;AALoC,SAApD;AAOA,aAAKtC,MAAL,CAAYmB,mBAAZ,CAAgC,IAAhC,EAAsCJ,IAAtC;AACA,OAfiD,CAiBlD;;;AACA,WAAK6B,cAAL,CAAoBV,OAApB,EAA6B/E,EAA7B;AAEA;AAED,GAzBM;AA2BP;;;;;;;AAOA;;;;;;;;;;AAQOJ,4CAAP,UAAyBiB,EAAzB,EAAgDb,EAAhD,EAA6E;AAE5E;AACA;AACA;AACA;AACA;AACA;AAEA;AACA,QAAI+E,OAAO,GAAG,KAAKC,UAAL,CAAgBhF,EAAhB,CAAd,CAV4E,CAY5E;;AACA,QAAI,CAAC+E,OAAO,CAACI,KAAT,IAAkBnF,EAAE,CAACM,KAAH,IAAY,CAA9B,IAAmCN,EAAE,CAACM,KAAH,IAAY,CAAnD,EAAsD;AACrD;AACA,KAf2E,CAiB5E;;;AACAyE,WAAO,CAACc,MAAR,GAAiB7F,EAAE,CAACM,KAApB,CAlB4E,CAoB5E;;AACA,SAAKwF,YAAL,CAAkBf,OAAlB,EAA2B/E,EAA3B,EArB4E,CAuB5E;;AACA,SAAK+F,UAAL,CAAgBlF,EAAhB,EAAoBkE,OAApB,EAA6B/E,EAA7B;AACA,GAzBM;AA2BP;;;;;;;;;AAOOJ,4CAAP,UAAyBiB,EAAzB,EAAgDb,EAAhD,EAA6E;AAC5E;AACA,QAAI+E,OAAO,GAAG,KAAKC,UAAL,CAAgBhF,EAAhB,CAAd,CAF4E,CAI5E;;AACA,SAAKgG,UAAL,CAAgBnF,EAAhB,EAAoBkE,OAApB,EAA6B/E,EAA7B;AACA,GANM;AAQP;;;;;;;;;AAOOJ,2CAAP,UAAwBiB,EAAxB,EAA+Cb,EAA/C,EAA4E;AAE3E;AACA,QAAI+E,OAAO,GAAG,KAAKC,UAAL,CAAgBhF,EAAhB,CAAd,CAH2E,CAK3E;;AACA,SAAKiG,SAAL,CAAepF,EAAf,EAAmBkE,OAAnB,EAA4B/E,EAA5B;AACA,GAPM;AASP;;;;;;;;;;AAQOJ,2CAAP,UAAwBiB,EAAxB,EAA+Cb,EAA/C,EAA6D;AAE5D;AACA,QAAI+E,OAAO,GAAG,KAAKC,UAAL,CAAgBhF,EAAhB,CAAd,CAH4D,CAK5D;;AACA+E,WAAO,CAACE,KAAR,GAAgB,KAAKC,eAAL,CAAqBlF,EAArB,CAAhB,CAN4D,CAQ5D;;AACA,QAAIkG,MAAM,GAAW,CAArB;AAAA,QAAwBC,MAAM,GAAW,CAAzC,CAT4D,CAW5D;AACA;AACA;;AACA,QAAIC,GAAG,GAAG,CAAV;;AACA,QAAIpG,EAAE,CAACqG,SAAH,IAAgB,CAApB,EAAuB;AACtBD,SAAG,GAAG,EAAN;AACA,KAjB2D,CAmB5D;;;AACAA,OAAG,IAAI,KAAKE,cAAL,CAAoBzF,EAApB,EAAwB,aAAxB,CAAP,CApB4D,CAsB5D;;AACA,QAAIb,EAAE,YAAYuG,UAAlB,EAA8B;AAC7BL,YAAM,GAAGM,IAAI,CAACC,KAAL,CAAY,CAAC,CAAD,GAAWzG,EAAG,CAAC0G,WAAhB,IAAiC1G,EAAE,CAACkG,MAAH,GAAYE,GAAxD,CAAT;AACAD,YAAM,GAAGK,IAAI,CAACC,KAAL,CAAY,CAAC,CAAD,GAAWzG,EAAG,CAAC2G,WAAhB,IAAiC3G,EAAE,CAACmG,MAAH,GAAYC,GAAxD,CAAT;AACA,KAHD,MAGO;AACN,YAAM,IAAIQ,KAAJ,CAAU,oBAAV,CAAN;AACA,KA5B2D,CA8B5D;;;AACA,SAAKC,WAAL,CAAiBhG,EAAjB,EAAqBkE,OAArB,EAA8BmB,MAA9B,EAAsCC,MAAtC,EAA8CnG,EAA9C;AACA,GAhCM;AAmCP;;;;;;;AAOA;;;;;;;;;;AAQOJ,0CAAP,UAAuBiB,EAAvB,EAA8Cb,EAA9C,EAA4D;AAE3D;AACA;AACA;AACA;AAEA;AACA,SAAK,IAAI0F,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG1F,EAAE,CAAC2F,cAAH,CAAkBC,MAAtC,EAA8CF,CAAC,EAA/C,EAAmD;AAElD;AACA,UAAIX,OAAO,GAAG,KAAKC,UAAL,CAAgBhF,EAAE,CAAC2F,cAAH,CAAkBD,CAAlB,CAAhB,CAAd;AACA,WAAKoB,mBAAL,CAAyBjG,EAAzB,EAA6Bb,EAA7B,EAAiC+E,OAAjC,EAJkD,CAMlD;;AACA,WAAKe,YAAL,CAAkBf,OAAlB,EAA2B/E,EAAE,CAAC2F,cAAH,CAAkBD,CAAlB,CAA3B,EAPkD,CASlD;;AACA,WAAKK,UAAL,CAAgBlF,EAAhB,EAAoBkE,OAApB,EAA6B/E,EAA7B;AACA;AAED,GArBM;AAwBP;;;;;;;AAOA;;;;;;;;;;AAQOJ,oCAAP,UAAiBiB,EAAjB,EAAwCkE,OAAxC,EAA2D/E,EAA3D,EAAsF;AAErF;AACA,QAAI+G,GAAG,GAAGxJ,KAAK,CAACyJ,OAAN,EAAV;;AACA,QAAInG,EAAE,CAACoG,OAAH,IAAepG,EAAE,CAACoG,OAAH,IAAeF,GAAG,GAAG,KAAK9C,YAAL,CAAkBpD,EAAlB,EAAsB,eAAtB,CAAxC,EAAkF;AAEjF;AAEA;AACA;AAEA;AACA;AACA,UAAKkG,GAAG,GAAGlG,EAAE,CAACoG,OAAV,GAAqB,GAAzB,EAA8B;AAC7B;AACA;AACA,OAZgF,CAcjF;;;AACApG,QAAE,CAACoG,OAAH,GAAaC,SAAb;AACArG,QAAE,CAACsG,cAAH,GAAoBD,SAApB,CAhBiF,CAkBjF;;AACA,UAAIrG,EAAE,CAACgC,MAAH,CAAUa,SAAV,CAAoB,WAApB,KAAoC,CAAC3G,MAAM,CAAC4G,QAAhD,EAA0D;AACzD,YAAIC,IAAI,GAAsE;AAC7EC,cAAI,EAAE,WADuE;AAE7EC,gBAAM,EAAEjD,EAFqE;AAG7EoE,eAAK,EAAEF,OAAO,CAACE,KAH8D;AAI7ElB,eAAK,EAAE/D,EAJsE;AAK7EmF,eAAK,EAAEJ,OAAO,CAACI;AAL8D,SAA9E;AAOAtE,UAAE,CAACgC,MAAH,CAAUmB,mBAAV,CAA8B,WAA9B,EAA2CJ,IAA3C;AACA;AAED,KA9BD,MA+BK;AAEJ;AACA/C,QAAE,CAACoG,OAAH,GAAaF,GAAb;AACAlG,QAAE,CAACsG,cAAH,GAAoBpC,OAApB;;AAEA,UAAIA,OAAO,CAACc,MAAR,KAAmB,CAAvB,EAA0B;AACzB;AACA,YAAIhF,EAAE,CAACgC,MAAH,CAAUa,SAAV,CAAoB,YAApB,KAAqC,CAAC3G,MAAM,CAAC4G,QAAjD,EAA2D;AAC1D,cAAIC,IAAI,GAAuE;AAC9EC,gBAAI,EAAE,YADwE;AAE9EC,kBAAM,EAAEjD,EAFsE;AAG9EkD,iBAAK,EAAE/D;AAHuE,WAA/E;AAKAa,YAAE,CAACgC,MAAH,CAAUmB,mBAAV,CAA8B,YAA9B,EAA4CJ,IAA5C;AACA;AACD,OAVD,MAUO;AACN,YAAI/C,EAAE,CAACgC,MAAH,CAAUa,SAAV,CAAoB,KAApB,KAA8B,CAAC3G,MAAM,CAAC4G,QAA1C,EAAoD;AACnD,cAAIC,IAAI,GAAgE;AACvEC,gBAAI,EAAE,KADiE;AAEvEC,kBAAM,EAAEjD,EAF+D;AAGvEkD,iBAAK,EAAE/D,EAHgE;AAIvEiF,iBAAK,EAAEF,OAAO,CAACE,KAJwD;AAKvEE,iBAAK,EAAEJ,OAAO,CAACI;AALwD,WAAxE;AAOAtE,YAAE,CAACgC,MAAH,CAAUmB,mBAAV,CAA8B,KAA9B,EAAqCJ,IAArC;AACA;AACD;AAED;AAED,GAlEM;AAoEP;;;;;;;;;;;AASOhE,qCAAP,UAAkBiB,EAAlB,EAAyCkE,OAAzC,EAA4D/E,EAA5D,EAAyFoH,IAAzF,EAA8G;AAArB;AAAAA;AAAqB;;AAE7G,QAAI,CAACvG,EAAE,CAACU,SAAR,EAAmB;AAClB;AACA;;AAED,QAAI8F,YAAY,GAAG,KAAnB;;AACA,QAAI,KAAKC,kBAAL,CAAwBvC,OAAxB,KAAoC,KAAKwC,cAAL,EAApC,IAA6D,KAAKC,KAAL,CAAWzC,OAAX,EAAoB,KAAKd,YAAL,CAAkBpD,EAAlB,EAAsB,cAAtB,CAApB,CAAjE,EAA6H;AAC5HwG,kBAAY,GAAG,IAAf;AACA,WAAKI,eAAL,CAAqBzH,EAArB;AACA,KAV4G,CAY7G;;;AACA,SAAKsF,cAAL,GAb6G,CAe7G;;AACAzE,MAAE,CAAC6G,YAAH,CAAgBlF,SAAhB,CAA0BuC,OAA1B,EAhB6G,CAkB7G;;AACA,QAAI,CAAClE,EAAE,CAAC8G,WAAR,EAAqB;AAEpB;AACA,UAAI,CAACN,YAAL,EAAmB;AAClBxG,UAAE,CAAC+G,OAAH,GAAa,IAAb;AACA/G,UAAE,CAAC8G,WAAH,GAAiB,IAAjB;AACA,aAAKE,WAAL,CAAiBrF,SAAjB,CAA2B3B,EAA3B;AACA,OAPmB,CASpB;AACA;AACA;;;AACA,WAAKiH,WAAL,CAAiB,KAAKjK,IAAtB,EAA4BkH,OAA5B,EAAqC/E,EAArC,EAAyC,IAAzC,EAZoB,CAcpB;;AACA,UAAIa,EAAE,CAACgC,MAAH,CAAUa,SAAV,CAAoB,MAApB,KAA+B,CAAC3G,MAAM,CAAC4G,QAAvC,IAAmD,CAAC0D,YAAxD,EAAsE;AACrE,YAAIzD,IAAI,GAAiE;AACxEC,cAAI,EAAE,MADkE;AAExEC,gBAAM,EAAEjD,EAFgE;AAGxEkD,eAAK,EAAE/D,EAHiE;AAIxE+E,iBAAO,EAAEA,OAJ+D;AAKxEI,eAAK,EAAEJ,OAAO,CAACI;AALyD,SAAzE;AAOAtE,UAAE,CAACgC,MAAH,CAAUmB,mBAAV,CAA8B,MAA9B,EAAsCJ,IAAtC;AACA;AAED;AAED,GA/CM;AAiDP;;;;;;;;;;;;;;;;AAcOhE,oCAAP,UAAiBiB,EAAjB,EAAwCkE,OAAxC,EAA2D/E,EAA3D,EAAwFoH,IAAxF,EAA+GW,KAA/G,EAAqI;AAArI;;AAAwF;AAAAX;AAAqB;;AAAE;AAAAW;AAAsB;;AAEpI,QAAI,CAAClH,EAAE,CAACU,SAAR,EAAmB;AAClB;AACA,KAJmI,CAMpI;;;AACAV,MAAE,CAAC6G,YAAH,CAAgBjF,WAAhB,CAA4BsC,OAA5B,EAPoI,CASpI;;AACA,QAAIlE,EAAE,CAAC+G,OAAH,KAAe,CAAC/G,EAAE,CAACmH,aAAJ,IAAqBD,KAApC,CAAJ,EAAgD;AAG/C;AACA,UAAIX,IAAI,IAAIvG,EAAE,CAAC6G,YAAH,CAAgB9B,MAA5B,EAAoC;AACnC;AACA;AACA;AACA;AACA,OAT8C,CAW/C;;;AACA,UAAIb,OAAO,IAAIA,OAAO,CAACI,KAAnB,IAA4B,CAAC4C,KAA7B,IAAsC,CAAC,KAAKE,GAAL,CAASlD,OAAT,CAA3C,EAA8D;AAE7D;AACA;AACA,YAAImD,QAAQ,GAAG,KAAKC,cAAL,CAAoBtH,EAApB,EAAwB,kBAAxB,CAAf;;AACA,YAAIqH,QAAQ,IAAI,OAAhB,EAAyB;AACxB;AACA;AACA;AACA,eAAKE,cAAL,CAAoBzK,GAApB,CAAwBM,IAAxB,CAA6B;AAC5B4F,gBAAI,EAAE,KADsB;AAE5BhD,cAAE,EAAEA,EAFwB;AAG5BkE,mBAAO,EAAEA,OAHmB;AAI5BhB,iBAAK,EAAE/D,EAJqB;AAK5BqI,qBAAS,EAAE9K,KAAK,CAACyJ,OAAN,KAAkB;AALD,WAA7B;;AAOAnG,YAAE,CAACmH,aAAH,GAAmB,IAAnB;AACA;AACA,SAbD,MAcK,IAAIE,QAAQ,IAAI,OAAZ,IAAuB,KAAKC,cAAL,CAAoBtH,EAApB,EAAwB,eAAxB,CAA3B,EAAqE;AACzE,eAAKuH,cAAL,CAAoBzK,GAApB,CAAwBM,IAAxB,CAA6B;AAC5B4F,gBAAI,EAAE,KADsB;AAE5BhD,cAAE,EAAEA,EAFwB;AAG5BkE,mBAAO,EAAEA,OAHmB;AAI5BhB,iBAAK,EAAE/D,EAJqB;AAK5BqI,qBAAS,EAAE9K,KAAK,CAACyJ,OAAN,KAAkB,GALD;AAM5BsB,mBAAO,EAAE,KAAKC,UAAL,CAAgB;AACxB7K,mBAAI,CAACuI,SAAL,CAAepF,EAAf,EAAmBkE,OAAnB,EAA4B/E,EAA5B,EAAgC,IAAhC;AACA,aAFQ,EAEN,KAAKmI,cAAL,CAAoBtH,EAApB,EAAwB,eAAxB,CAFM;AANmB,WAA7B;;AAUA;AACA,SAZI,MAaA,CACJ;AACA;AAED,OAhD8C,CAkD/C;;;AACAA,QAAE,CAAC+G,OAAH,GAAa,KAAb;AACA,WAAKC,WAAL,CAAiBpF,WAAjB,CAA6B5B,EAA7B,EApD+C,CAsD/C;;AACA,UAAI,CAACA,EAAE,CAAC2H,UAAH,EAAD,IAAoB3H,EAAE,CAACgC,MAAH,CAAUa,SAAV,CAAoB,KAApB,CAApB,IAAkD,CAAC3G,MAAM,CAAC4G,QAA9D,EAAwE;AACvE,YAAIC,IAAI,GAAgE;AACvEC,cAAI,EAAE,KADiE;AAEvEC,gBAAM,EAAEjD,EAF+D;AAGvEkD,eAAK,EAAE/D,EAHgE;AAIvE+E,iBAAO,EAAEA,OAJ8D;AAKvEI,eAAK,EAAEJ,OAAO,CAACI;AALwD,SAAxE;AAOAtE,UAAE,CAACgC,MAAH,CAAUmB,mBAAV,CAA8B,KAA9B,EAAqCJ,IAArC;AACA,OAhE8C,CAkE/C;;;AACA/C,QAAE,CAAC6G,YAAH,CAAgBe,KAAhB;AACA5H,QAAE,CAACmH,aAAH,GAAmB,KAAnB,CApE+C,CAqE/C;AAEA;AAED,GAnFM;AAqFP;;;;;;AAIQpI,yCAAR;AACC,QAAI8I,YAAJ;;AAEA,WAAO,IAAP,EAAa;AACZA,kBAAY,GAAG,KAAKN,cAAL,CAAoBzK,GAApB,CAAwBgL,GAAxB,EAAf;;AAEA,UAAI,CAACD,YAAL,EAAmB;AAClB;AACA;;AAED,UAAIA,YAAY,CAACJ,OAAjB,EAA0B;AACzBI,oBAAY,CAACJ,OAAb,CAAqBhH,OAArB;AACA;;AAED,WAAK2E,SAAL,CAAeyC,YAAY,CAAC7H,EAA5B,EAAgC6H,YAAY,CAAC3D,OAA7C,EAAsD2D,YAAY,CAAC3E,KAAnE,EAA0E,KAA1E,EAAiF,IAAjF;AACA;AAED,GAjBO;AAmBR;;;;;;;;;;AAQOnE,qCAAP,UAAkBiB,EAAlB,EAAyCkE,OAAzC,EAA4D/E,EAA5D,EAAmG;AAElG;AACA,SAAK8G,mBAAL,CAAyBjG,EAAzB,EAA6Bb,EAA7B,EAAiC+E,OAAjC,EAHkG,CAKlG;;AACA,QAAIlE,EAAE,CAAC+H,KAAP,EAAc;AACb,WAAKC,WAAL,CAAiBhI,EAAjB;AACA,KARiG,CAUlG;AACA;;;AACA,SAAKmF,UAAL,CAAgBnF,EAAhB,EAAoBkE,OAApB,EAA6B/E,EAA7B,EAAiC,IAAjC,EAZkG,CAclG;;AACAa,MAAE,CAACiI,YAAH,CAAgBtG,SAAhB,CAA0BuC,OAA1B,EAfkG,CAiBlG;;AACA,SAAKgE,oBAAL,CAA0BlI,EAA1B,EAA8BkE,OAA9B,EAlBkG,CAoBlG;;AACA,QAAI,CAAClE,EAAE,CAACmI,MAAR,EAAgB;AAEf;AACA,UAAInI,EAAE,CAACoC,SAAH,KAAiB,KAAjB,IAA0B,KAAKgB,YAAL,CAAkBpD,EAAlB,EAAsB,SAAtB,CAA1B,IAA8D,KAAK0D,aAAvE,EAAsF;AACrFnH,YAAI,CAACgH,IAAL;AACA,OALc,CAOf;;;AACAvD,QAAE,CAACmI,MAAH,GAAY,IAAZ;AACA,WAAKC,WAAL,CAAiBzG,SAAjB,CAA2B3B,EAA3B,EATe,CAWf;;AACA,UAAIA,EAAE,CAACkB,SAAP,EAAkB;AACjB,aAAKmH,gBAAL,CAAsBrI,EAAtB,EAA0BkE,OAA1B,EAAmC/E,EAAnC;AACA;;AACD,UAAIa,EAAE,CAACoB,SAAP,EAAkB;AACjB,aAAKkH,kBAAL,CAAwBtI,EAAxB,EAA4BkE,OAA5B,EAAqC/E,EAArC;AACA;AAED,KAxCiG,CA0ClG;;;AACA,QAAIa,EAAE,CAACgC,MAAH,CAAUa,SAAV,CAAoB,MAApB,KAA+B,CAAC3G,MAAM,CAAC4G,QAA3C,EAAqD;AACpD,UAAIC,IAAI,GAAiE;AACxEC,YAAI,EAAE,MADkE;AAExEC,cAAM,EAAEjD,EAFgE;AAGxEkD,aAAK,EAAE/D,EAHiE;AAIxE+E,eAAO,EAAEA,OAJ+D;AAKxEI,aAAK,EAAEJ,OAAO,CAACI;AALyD,OAAzE;AAOAtE,QAAE,CAACgC,MAAH,CAAUmB,mBAAV,CAA8B,MAA9B,EAAsCJ,IAAtC;AACA;AAED,GAtDM;AAwDP;;;;;;;;;AAOOhE,yCAAP,UAAsBmF,OAAtB,EAAyC/E,EAAzC,EAAkFwF,SAAlF,EAA4G;AAA5G;;AAAkF;AAAAA;AAA0B;;AAC3G,QAAM4D,MAAM,GAAG,KAAKH,WAAL,CAAiBI,MAAjB,CAAwBC,KAAxB,EAAf;AAEAF,UAAM,CAACG,IAAP,CAAY,UAACC,CAAD,EAAIC,CAAJ,EAAK;AAChB,UAAID,CAAC,IAAIC,CAAT,EAAY;AACX,YAAMC,GAAG,GAAGF,CAAC,CAACtI,OAAF,CAAUyI,uBAAV,CAAkCF,CAAC,CAACvI,OAApC,CAAZ;;AAEA,YAAIwI,GAAG,GAAGE,IAAI,CAACC,8BAAf,EAA+C;AAC9C,iBAAO,CAAP;AAEA,SAHD,MAGO,IAAIH,GAAG,GAAGE,IAAI,CAACE,0BAAf,EAA2C;AACjD,iBAAO,CAAC,CAAR;AAEA,SAHM,MAGA;AACN,iBAAO,CAAP;AACA;AAED,OAbD,MAaO;AACN,eAAO,CAAP;AACA;AACD,KAjBD,EAH2G,CAsB3G;;AACA3M,UAAM,CAAC4M,IAAP,CAAYX,MAAZ,EAAoB,UAACvI,EAAD,EAAG;AACtB;AACA;AACA,UAAIA,EAAE,IAAIA,EAAE,CAACiI,YAAH,CAAgBkB,QAAhB,CAAyBjF,OAAzB,CAAV,EAA6C;AAC5CrH,aAAI,CAACuM,QAAL,CAAcpJ,EAAd,EAAkBkE,OAAlB,EAA2B/E,EAA3B,EAA+BwF,SAA/B;AACA;AACD,KAND;AAQA,GA/BM;AAiCP;;;;;;;;AAMO5F,8CAAP,UAA2BI,EAA3B,EAAyC;AAAzC,qBAAyC,CAExC;;;AACA3C,SAAK,CAAC0M,IAAN,CAAW,KAAKd,WAAL,CAAiBiB,SAAjB,GAA6BC,QAA7B,EAAX,EAAoD,UAACtJ,EAAD,EAAG;AACtDA,QAAE,CAACiI,YAAH,CAAgBiB,IAAhB,CAAqB,UAAChF,OAAD,EAAQ;AAC5BrH,aAAI,CAACuM,QAAL,CAAcpJ,EAAd,EAAkBkE,OAAlB,EAA2B/E,EAA3B;AACA,OAFD;AAGA,KAJD;AAMA,GATM;AAWP;;;;;;;;;;AAQOJ,mCAAP,UAAgBiB,EAAhB,EAAuCkE,OAAvC,EAA0D/E,EAA1D,EAAuFwF,SAAvF,EAAiH;AAA1B;AAAAA;AAA0B,MAEhH;;;AACA,SAAK4E,sBAAL,CAA4BvJ,EAA5B,EAAgCkE,OAAhC,EAHgH,CAKhH;;AACAlE,MAAE,CAACiI,YAAH,CAAgBrG,WAAhB,CAA4BsC,OAA5B,EANgH,CAQhH;AACA;;AACA,QAAIA,OAAO,CAACI,KAAR,IAAiB,KAAKrG,mBAA1B,EAA+C;AAC9C,WAAKmH,SAAL,CAAepF,EAAf,EAAmBkE,OAAnB,EAA4B/E,EAA5B,EAAgC,IAAhC;AACA,KAZ+G,CAchH;;;AACA,QAAIa,EAAE,CAACmI,MAAP,EAAe;AAEd;AACA,UAAInI,EAAE,CAACiI,YAAH,CAAgBlD,MAAhB,IAA0B,CAA9B,EAAiC;AAChC;AACA/E,UAAE,CAACmI,MAAH,GAAY,KAAZ;AACA,aAAKC,WAAL,CAAiBxG,WAAjB,CAA6B5B,EAA7B;AACA,OAPa,CASd;;;AACA,UAAIA,EAAE,CAACgC,MAAH,CAAUa,SAAV,CAAoB,IAApB,KAA6B,CAAC3G,MAAM,CAAC4G,QAAzC,EAAmD;AAClD,YAAIC,IAAI,GAA+D;AACtEC,cAAI,EAAE,IADgE;AAEtEC,gBAAM,EAAEjD,EAF8D;AAGtEkD,eAAK,EAAE/D,EAH+D;AAItE+E,iBAAO,EAAEA,OAJ6D;AAKtEI,eAAK,EAAEJ,OAAO,CAACI;AALuD,SAAvE;AAOAtE,UAAE,CAACgC,MAAH,CAAUmB,mBAAV,CAA8B,IAA9B,EAAoCJ,IAApC;AACA,OAnBa,CAqBd;AACA;AACA;AACA;;;AACA,UAAI,CAAC4B,SAAL,EAAgB;AAEf;AACA,YAAI3E,EAAE,CAACmB,SAAH,IAAgB,KAAKqI,MAAL,CAAYxJ,EAAZ,EAAgBkE,OAAhB,CAApB,EAA8C;AAC7C;AACA,eAAKuF,WAAL,CAAiBzJ,EAAjB,EAAqBkE,OAArB,EAA8B/E,EAA9B;AACA,SAHD,MAGO;AAEN;AACA,cAAIa,EAAE,CAACyC,SAAH,IAAgB,CAAC,KAAKkE,KAAL,CAAWzC,OAAX,EAAoB,KAAKd,YAAL,CAAkBpD,EAAlB,EAAsB,cAAtB,CAApB,CAArB,EAAiF;AAChF,iBAAK0J,SAAL,CAAe1J,EAAf,EAAmBkE,OAAnB,EAA4B/E,EAA5B;AACA,WALK,CAON;;;AACA,cAAIa,EAAE,CAAC+H,KAAH,IAAY,KAAKpB,KAAL,CAAWzC,OAAX,EAAoB,KAAKd,YAAL,CAAkBpD,EAAlB,EAAsB,cAAtB,CAApB,CAAhB,EAA4E;AAC3E,iBAAK2J,aAAL,CAAmB3J,EAAnB,EAAuBkE,OAAvB;AACA,WAFD,MAGK,IAAIlE,EAAE,CAACkB,SAAP,EAAkB;AACtB,iBAAK0I,eAAL,CAAqB5J,EAArB,EAAyBkE,OAAzB,EAAkC/E,EAAlC;AACA;;AAED,cAAIa,EAAE,CAACoB,SAAP,EAAkB;AACjB,iBAAKyI,iBAAL,CAAuB7J,EAAvB,EAA2BkE,OAA3B,EAAoC/E,EAApC;AACA;AAED;AAED;AAED;AAED,GAvEM;AAyEP;;;;;;;;;AAOQJ,8CAAR,UAA4BiB,EAA5B,EAAmDb,EAAnD,EAA4F+E,OAA5F,EAA8G;AAC7G,QACCzH,KAAK,CAACgC,QAAN,CAAeU,EAAf,MACIa,EAAE,CAACkB,SAAH,IAAgBlB,EAAE,CAACmB,SAAnB,IAAgCnB,EAAE,CAACW,SAAnC,IAAgDX,EAAE,CAACoB,SADvD,KAEG,CAAC,KAAKC,eAAL,CAAqBrB,EAArB,CAFJ,IAGGb,EAAE,CAAC2K,UAAH,KAAkB,KAHrB,KAII,CAAC9J,EAAE,CAACsB,gBAAJ,IAAwB,CAAC4C,OAAzB,IAAoC,CAACA,OAAO,CAACI,KAJjD,CADD,EAME;AACDnF,QAAE,CAACoB,cAAH;AACA;AACD,GAVO;AAYR;;;;;;;;AAMQxB,0CAAR,UAAwBI,EAAxB,EAAoD;AAApD,qBAAoD,CACnD;;;AACA3C,SAAK,CAAC0M,IAAN,CAAW,KAAKlC,WAAL,CAAiBqC,SAAjB,GAA6BC,QAA7B,EAAX,EAAoD,UAACtJ,EAAD,EAAG;AACtD,UAAIA,EAAJ,EAAQ;AACP,YAAMkE,OAAO,GAAGlE,EAAE,CAAC6G,YAAH,CAAgBkD,QAAhB,CAAyB,CAAzB,CAAhB;;AACAlN,aAAI,CAACuI,SAAL,CAAepF,EAAf,EAAmBkE,OAAnB,EAA4B/E,EAA5B,EAAgC,IAAhC,EAAsC,IAAtC;AACA;AACD,KALD;AAMA,GARO;AAUR;;;;;;;AAKQJ,6CAAR,UAA2BmF,OAA3B,EAA4C;AAC3C,WAAO/H,OAAO,CAAC6N,uBAAR,IAAmC,QAAnC,IAAgD7N,OAAO,CAAC6N,uBAAR,IAAmC,OAAnC,IAA8C9F,OAAO,CAACI,KAA7G;AACA,GAFO;AAIR;;;;;;;;;AAOOvF,2CAAP,UAAwBmF,OAAxB,EAA2C/E,EAA3C,EAAsE;AAAtE,qBAAsE,CAErE;AACA;AACA;;;AACA,QAAI,CAAC+E,OAAO,CAACI,KAAb,EAAoB;AACnB,UAAM2F,QAAM,GAAgB1N,IAAI,CAAC2N,WAAL,CAAwBhG,OAAO,CAACiG,SAAhC,CAA5B;AAEA3N,WAAK,CAAC0M,IAAN,CAAW,KAAKlC,WAAL,CAAiBqC,SAAjB,GAA6BC,QAA7B,EAAX,EAAoD,UAACtJ,EAAD,EAAG;AACtD;AACA,YAAIA,EAAE,IAAIA,EAAE,CAAC6G,YAAH,CAAgBsC,QAAhB,CAAyBjF,OAAzB,CAAN,IAA2ClE,EAAE,CAACU,SAAlD,EAA6D;AAC5D;AACA,cAAI0J,KAAK,GAAG,KAAZ;;AACA,cAAIpK,EAAE,CAACK,OAAH,IAAc6D,OAAO,CAACiG,SAA1B,EAAqC;AACpC,gBAAI,CAAC5N,IAAI,CAAC4M,QAAL,CAAcnJ,EAAE,CAACK,OAAjB,EAA0B4J,QAA1B,CAAL,EAAwC;AACvCG,mBAAK,GAAG,IAAR;AACA;AACD,WAJD,MAKK;AACJA,iBAAK,GAAG,IAAR;AACA;;AACD,cAAIA,KAAJ,EAAW;AACVvN,iBAAI,CAACuI,SAAL,CAAepF,EAAf,EAAmBkE,OAAnB,EAA4B/E,EAA5B,EAAgC,IAAhC;AACA;AACD;AACD,OAjBD;AAkBA,KA1BoE,CA6BrE;;;AACA3C,SAAK,CAAC0M,IAAN,CAAW,KAAKmB,kBAAL,CAAwBhB,SAAxB,GAAoCC,QAApC,EAAX,EAA2D,UAACtJ,EAAD,EAAG;AAC7D;AACA,UAAIA,EAAE,CAACiI,YAAH,CAAgBkB,QAAhB,CAAyBjF,OAAzB,KACH;AACA,QAAElE,EAAE,CAACmB,SAAH,IAAgBtE,KAAI,CAACyN,OAAL,CAAatK,EAAb,EAAiBkE,OAAjB,CAAlB,CAFG,KAGFlE,EAAE,CAACkB,SAAH,IAAgBlB,EAAE,CAACoB,SAHjB,CAAJ,EAGiC;AAChCvE,aAAI,CAAC0N,eAAL,CAAqBvK,EAArB,EAAyBb,EAAzB;AACA;AACD,KARD,EA9BqE,CAwCrE;;AACA3C,SAAK,CAAC0M,IAAN,CAAW,KAAKxH,cAAL,CAAoB2H,SAApB,GAAgCC,QAAhC,EAAX,EAAuD,UAACtJ,EAAD,EAAG;AACzD;AACA,UAAI,CAACA,EAAE,CAAC6G,YAAH,CAAgBsC,QAAhB,CAAyBjF,OAAzB,CAAL,EAAwC;AACvCrH,aAAI,CAACoK,WAAL,CAAiBjH,EAAjB,EAAqBkE,OAArB,EAA8B/E,EAA9B;AACA;AACD,KALD;AAMA,GA/CM;AAiDP;;;;;;;;;;;AASOJ,sCAAP,UAAmBiB,EAAnB,EAA0CkE,OAA1C,EAA6D/E,EAA7D,EAA0FqL,SAA1F,EAA2G;AAAjB;AAAAA;AAAiB,MAE1G;;;AACA,QAAI,CAACA,SAAD,IAAc,CAAC,KAAK7D,KAAL,CAAWzC,OAAX,EAAoB,CAApB,CAAnB,EAA2C;AAC1C;AACA,KALyG,CAO1G;;;AACA,QAAIlE,EAAE,CAACgC,MAAH,CAAUa,SAAV,CAAoB,OAApB,KAAgC,CAAC3G,MAAM,CAAC4G,QAA5C,EAAsD;AACrD,UAAIC,IAAI,GAAkE;AACzEC,YAAI,EAAE,OADmE;AAEzEC,cAAM,EAAEjD,EAFiE;AAGzEkD,aAAK,EAAE/D,EAHkE;AAIzEiF,aAAK,EAAEF,OAAO,CAACE,KAJ0D;AAKzEF,eAAO,EAAEA,OALgE;AAMzEI,aAAK,EAAEJ,OAAO,CAACI;AAN0D,OAA1E;AAQAtE,QAAE,CAACgC,MAAH,CAAUmB,mBAAV,CAA8B,OAA9B,EAAuCJ,IAAvC;AACA;AACD,GAnBM;AAqBP;;;;;;;;;;AAQOhE,sCAAP,UAAmBiB,EAAnB,EAA0CkE,OAA1C,EAA6D/E,EAA7D,EAAwF;AAEvF;AACA;AACA,QAAIa,EAAE,CAACgC,MAAH,CAAUa,SAAV,CAAoB,OAApB,KAAgC,CAAC3G,MAAM,CAAC4G,QAA5C,EAAsD;AACrD,UAAIC,IAAI,GAAkE;AACzEC,YAAI,EAAE,OADmE;AAEzEC,cAAM,EAAEjD,EAFiE;AAGzEkD,aAAK,EAAE/D,EAHkE;AAIzEmF,aAAK,EAAEJ,OAAO,CAACI;AAJ0D,OAA1E;AAMAtE,QAAE,CAACgC,MAAH,CAAUmB,mBAAV,CAA8B,OAA9B,EAAuCJ,IAAvC;AACA;;AAED,QAAImB,OAAO,CAACuG,UAAR,CAAmB9B,CAAnB,GAAuBzE,OAAO,CAACE,KAAR,CAAcuE,CAAzC,EAA4C;AAC3C,UAAI3I,EAAE,CAACgC,MAAH,CAAUa,SAAV,CAAoB,YAApB,KAAqC,CAAC3G,MAAM,CAAC4G,QAAjD,EAA2D;AAC1D,YAAIC,IAAI,GAAuE;AAC9EC,cAAI,EAAE,YADwE;AAE9EC,gBAAM,EAAEjD,EAFsE;AAG9EkD,eAAK,EAAE/D,EAHuE;AAI9EmF,eAAK,EAAEJ,OAAO,CAACI;AAJ+D,SAA/E;AAMAtE,UAAE,CAACgC,MAAH,CAAUmB,mBAAV,CAA8B,YAA9B,EAA4CJ,IAA5C;AACA;AACD,KAVD,MAWK;AACJ,UAAI/C,EAAE,CAACgC,MAAH,CAAUa,SAAV,CAAoB,WAApB,KAAoC,CAAC3G,MAAM,CAAC4G,QAAhD,EAA0D;AACzD,YAAIC,IAAI,GAAsE;AAC7EC,cAAI,EAAE,WADuE;AAE7EC,gBAAM,EAAEjD,EAFqE;AAG7EkD,eAAK,EAAE/D,EAHsE;AAI7EmF,eAAK,EAAEJ,OAAO,CAACI;AAJ8D,SAA9E;AAMAtE,UAAE,CAACgC,MAAH,CAAUmB,mBAAV,CAA8B,WAA9B,EAA2CJ,IAA3C;AACA;AACD;AAED,GArCM;AAuCP;;;;;;;;;;;;AAUOhE,sCAAP,UAAmBiB,EAAnB,EAA0CkE,OAA1C,EAA6DmB,MAA7D,EAA6EC,MAA7E,EAA6FnG,EAA7F,EAA2G;AAC1G,QAAMuL,KAAK,GAAW;AACrB/B,OAAC,EAAEtD,MADkB;AAErBuD,OAAC,EAAEtD;AAFkB,KAAtB,CAD0G,CAM1G;;AACA,QAAItF,EAAE,CAACgC,MAAH,CAAUa,SAAV,CAAoB,OAApB,KAAgC,CAAC3G,MAAM,CAAC4G,QAA5C,EAAsD;AACrD9C,QAAE,CAACgC,MAAH,CAAUmB,mBAAV,CAA8B,OAA9B,EAAuC;AACtCH,YAAI,EAAE,OADgC;AAEtCC,cAAM,EAAEjD,EAF8B;AAGtCkD,aAAK,EAAE/D,EAH+B;AAItCiF,aAAK,EAAEF,OAAO,CAACE,KAJuB;AAKtCsG,aAAK,EAAEA;AAL+B,OAAvC;AAOA,KAfyG,CAiB1G;AAEA;;;AACA,QAAIrF,MAAM,GAAG,CAAb,EAAgB;AACf,UAAIrF,EAAE,CAACgC,MAAH,CAAUa,SAAV,CAAoB,WAApB,KAAoC,CAAC3G,MAAM,CAAC4G,QAAhD,EAA0D;AACzD9C,UAAE,CAACgC,MAAH,CAAUmB,mBAAV,CAA8B,WAA9B,EAA2C;AAC1CH,cAAI,EAAE,WADoC;AAE1CC,gBAAM,EAAEjD,EAFkC;AAG1CkD,eAAK,EAAE/D,EAHmC;AAI1CiF,eAAK,EAAEF,OAAO,CAACE,KAJ2B;AAK1CsG,eAAK,EAAEA;AALmC,SAA3C;AAOA;AAED,KAXD,MAWO,IAAIrF,MAAM,GAAG,CAAb,EAAgB;AACtB,UAAIrF,EAAE,CAACgC,MAAH,CAAUa,SAAV,CAAoB,YAApB,KAAqC,CAAC3G,MAAM,CAAC4G,QAAjD,EAA2D;AAC1D9C,UAAE,CAACgC,MAAH,CAAUmB,mBAAV,CAA8B,YAA9B,EAA4C;AAC3CH,cAAI,EAAE,YADqC;AAE3CC,gBAAM,EAAEjD,EAFmC;AAG3CkD,eAAK,EAAE/D,EAHoC;AAI3CiF,eAAK,EAAEF,OAAO,CAACE,KAJ4B;AAK3CsG,eAAK,EAAEA;AALoC,SAA5C;AAOA,OATqB,CAWtB;;AACA,KAZM,MAYA,IAAIpF,MAAM,GAAG,CAAb,EAAgB;AACtB,UAAItF,EAAE,CAACgC,MAAH,CAAUa,SAAV,CAAoB,SAApB,KAAkC,CAAC3G,MAAM,CAAC4G,QAA9C,EAAwD;AACvD9C,UAAE,CAACgC,MAAH,CAAUmB,mBAAV,CAA8B,SAA9B,EAAyC;AACxCH,cAAI,EAAE,SADkC;AAExCC,gBAAM,EAAEjD,EAFgC;AAGxCkD,eAAK,EAAE/D,EAHiC;AAIxCiF,eAAK,EAAEF,OAAO,CAACE,KAJyB;AAKxCsG,eAAK,EAAEA;AALiC,SAAzC;AAOA;AAED,KAXM,MAWA,IAAIpF,MAAM,GAAG,CAAb,EAAgB;AACtB,UAAItF,EAAE,CAACgC,MAAH,CAAUa,SAAV,CAAoB,WAApB,KAAoC,CAAC3G,MAAM,CAAC4G,QAAhD,EAA0D;AACzD9C,UAAE,CAACgC,MAAH,CAAUmB,mBAAV,CAA8B,WAA9B,EAA2C;AAC1CH,cAAI,EAAE,WADoC;AAE1CC,gBAAM,EAAEjD,EAFkC;AAG1CkD,eAAK,EAAE/D,EAHmC;AAI1CiF,eAAK,EAAEF,OAAO,CAACE,KAJ2B;AAK1CsG,eAAK,EAAEA;AALmC,SAA3C;AAOA;AACD;AACD,GAjEM;AAmEP;;;;;;;;;;AAQO3L,wCAAP,UAAqBiB,EAArB,EAA4CkE,OAA5C,EAA6D;AAE5D,QAAIlE,EAAE,CAACkB,SAAH,IAAgBlB,EAAE,CAACiI,YAAH,CAAgBlD,MAAhB,KAA2B,CAA/C,EAAkD;AACjD,WAAK4F,iBAAL,CAAuB3K,EAAvB,EAA2BkE,OAA3B;AACA;;AAED,QAAIlE,EAAE,CAACoB,SAAH,IAAgBpB,EAAE,CAACiI,YAAH,CAAgBlD,MAAhB,GAAyB,CAA7C,EAAgD;AAC/C,WAAK6F,mBAAL,CAAyB5K,EAAzB,EAA6BkE,OAA7B;AACA;AAED,GAVM;AAYP;;;;;;;;;;AAQOnF,4CAAP,UAAyBiB,EAAzB,EAAgDkE,OAAhD,EAAiE;AAChE,QAAI2G,WAAW,GAAG7K,EAAlB;AACA,QAAIgD,IAAI,GAAW,MAAnB;AACA,QAAIoB,KAAK,GAAG;AACX,WAAKF,OAAO,CAACE,KAAR,CAAcuE,CADR;AAEX,WAAKzE,OAAO,CAACE,KAAR,CAAcwE;AAFR,KAAZ;AAIA,QAAI6B,UAAU,GAAG;AAChB,WAAKvG,OAAO,CAACuG,UAAR,CAAmB9B,CADR;AAEhB,WAAKzE,OAAO,CAACuG,UAAR,CAAmB7B;AAFR,KAAjB,CAPgE,CAYhE;;AACA,QAAIkC,OAAO,GAAG,IAAI/O,OAAJ,CAAY8O,WAAZ,EAAyB7H,IAAzB,EAA+BoB,KAA/B,EAAsCqG,UAAtC,CAAd,CAbgE,CAehE;;AACA,QAAIM,GAAG,GAAG,KAAKC,aAAL,CAAmB9G,OAAnB,EAA4BxH,KAAK,CAACyJ,OAAN,KAAkB,KAAK8E,gBAAL,CAAsBjL,EAAtB,EAA0B,MAA1B,EAAkC,MAAlC,CAA9C,CAAV;;AACA,QAAI,OAAO+K,GAAP,KAAe,WAAnB,EAAgC;AAC/B,WAAKnB,eAAL,CAAqB5J,EAArB,EAAyBkE,OAAzB,EAAkCA,OAAO,CAACgH,WAA1C;AACA;AACA,KApB+D,CAsBhE;;;AACA,QAAIC,MAAM,GAAG,KAAKF,gBAAL,CAAsBjL,EAAtB,EAA0B,MAA1B,EAAkC,QAAlC,CAAb;AACA,QAAIoL,gBAAgB,GAAG,CAAC;AACvB,YAAMlH,OAAO,CAACE,KAAR,CAAcuE,CAAd,GAAkB,CAACzE,OAAO,CAACE,KAAR,CAAcuE,CAAd,GAAkBoC,GAAG,CAAC3G,KAAJ,CAAUuE,CAA7B,IAAkCwC,MADnC;AAEvB,kBAAY;AAFW,KAAD,EAGpB;AACF,YAAMjH,OAAO,CAACE,KAAR,CAAcwE,CAAd,GAAkB,CAAC1E,OAAO,CAACE,KAAR,CAAcwE,CAAd,GAAkBmC,GAAG,CAAC3G,KAAJ,CAAUwE,CAA7B,IAAkCuC,MADxD;AAEF,kBAAY;AAFV,KAHoB,CAAvB,CAxBgE,CAgChE;;AACA,QAAIE,SAAS,GAAc,IAAI3P,SAAJ,CAC1BoP,OAD0B,EAE1BM,gBAF0B,EAG1B,KAAKH,gBAAL,CAAsBjL,EAAtB,EAA0B,MAA1B,EAAkC,UAAlC,CAH0B,EAI1B,KAAKiL,gBAAL,CAAsBjL,EAAtB,EAA0B,MAA1B,EAAkC,QAAlC,CAJ0B,EAKzBsL,KALyB,EAA3B;;AAMA,SAAKnO,UAAL,CAAgBC,IAAhB,CAAqBiO,SAAS,CAACrJ,MAAV,CAAiBC,EAAjB,CAAoB,gBAApB,EAAsC,UAAC9C,EAAD,EAAG;AAC7D2L,aAAO,CAACS,IAAR;AACA,KAFoB,CAArB,EAvCgE,CA2ChE;;;AACAvL,MAAE,CAACwL,QAAH,CAAY5M,MAAZ,CAAmB,MAAnB,EAA2BkM,OAA3B;AAEA,GA9CM;AAgDP;;;;;;;;;;;;;AAWO/L,8CAAP,UAA2BiB,EAA3B,EAAkDkE,OAAlD,EAAmE,CAElE;AAEA,GAJM;AAMP;;;;;;;;;;AAQOnF,0CAAP,UAAuBiB,EAAvB,EAA8Cb,EAA9C,EAAyE;AAExE;AACA,QAAIsM,QAAQ,GAA6BzL,EAAE,CAACiI,YAAH,CAAgB8B,QAAhB,CAAyB,CAAzB,CAAzC;AACA,QAAI2B,MAAM,GAAW,IAArB;AACA,QAAIC,WAAW,GAAW,IAA1B;;AAEA,QAAIF,QAAJ,EAAc;AACbC,YAAM,GAAGD,QAAQ,CAACrH,KAAlB;AACAuH,iBAAW,GAAGF,QAAQ,CAAChB,UAAvB;AACA,KAVuE,CAYxE;;;AACA,QAAImB,QAAJ;AACA,QAAIC,MAAJ;AACA,QAAIC,WAAJ,CAfwE,CAiBxE;;AACAD,UAAM,GAAG;AACR,WAAK7L,EAAE,CAAC+L,gBAAH,CAAoBpD,CADjB;AAER,WAAK3I,EAAE,CAAC+L,gBAAH,CAAoBnD;AAFjB,KAAT;AAIAkD,eAAW,GAAGD,MAAd,CAtBwE,CAwBxE;;AACA,QAAIG,WAAW,GAAY,IAA3B;;AACA,SAAK,IAAInH,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG7E,EAAE,CAACiI,YAAH,CAAgBlD,MAApC,EAA4CF,CAAC,EAA7C,EAAiD;AAEhD;AACA,UAAIoH,WAAW,GAAGjM,EAAE,CAACiI,YAAH,CAAgB8B,QAAhB,CAAyBlF,CAAzB,CAAlB,CAHgD,CAKhD;;AACA,UAAI8G,WAAW,CAAChD,CAAZ,IAAiBsD,WAAW,CAACxB,UAAZ,CAAuB9B,CAAxC,IAA6CgD,WAAW,CAAC/C,CAAZ,IAAiBqD,WAAW,CAACxB,UAAZ,CAAuB7B,CAAzF,EAA4F;AAE3F;AACAoD,mBAAW,GAAG,KAAd,CAH2F,CAK3F;;AACAJ,gBAAQ,GAAGK,WAAX;AACAJ,cAAM,GAAGD,QAAQ,CAACxH,KAAlB;AACA0H,mBAAW,GAAGF,QAAQ,CAACnB,UAAvB,CAR2F,CAU3F;;AACA;AACA;AACD,KA7CuE,CA+CxE;;;AACA,QAAIyB,aAAa,GAAGT,QAAQ,IAAI,KAAK9E,KAAL,CAAW8E,QAAX,EAAqB,CAArB,CAAhC,CAhDwE,CAkDxE;;AACA,QAAIzL,EAAE,CAACkB,SAAH,IAAgBuK,QAAhB,IAA4BA,QAAQ,CAACU,eAArC,IAAwDV,QAAQ,CAACU,eAAT,CAAyBpH,MAAjF,IAA2FmH,aAA/F,EAA8G;AAC7G,UAAIlM,EAAE,CAACgC,MAAH,CAAUa,SAAV,CAAoB,WAApB,KAAoC,CAAC3G,MAAM,CAAC4G,QAAhD,EAA0D;AACzD9C,UAAE,CAACgC,MAAH,CAAUmB,mBAAV,CAA8B,WAA9B,EAA2CsI,QAAQ,CAACU,eAAT,CAAyBzB,KAAzB,EAA3C;AACA,OAH4G,CAI7G;;AACA,KAxDuE,CA0DxE;;;AACA,QAAIsB,WAAW,IAAIhM,EAAE,CAACkB,SAAtB,EAAiC;AAEhC;AACA;AACA,WAAKkL,mBAAL,CAAyBpM,EAAzB,EAA6B0L,MAA7B,EAAqCC,WAArC,EAAkDxM,EAAlD,EAAsD+M,aAAtD,EAAqET,QAAQ,CAACnH,KAA9E;;AAEA,UAAI,KAAKmC,kBAAL,CAAwBgF,QAAxB,KAAqC,KAAK9E,KAAL,CAAW8E,QAAX,EAAqB,KAAKrI,YAAL,CAAkBpD,EAAlB,EAAsB,cAAtB,CAArB,CAAzC,EAAsG;AACrG,aAAK4G,eAAL,CAAqBzH,EAArB;AACA;AAED,KAVD,MAWK;AAEJ;AACA,UAAIkN,aAAa,GAAGT,QAAQ,IAAI,KAAKjF,KAAL,CAAWiF,QAAX,EAAqB,CAArB,CAAhC;;AAEA,UACE,KAAKnF,kBAAL,CAAwBgF,QAAxB,KAAqC,KAAK9E,KAAL,CAAW8E,QAAX,EAAqB,KAAKrI,YAAL,CAAkBpD,EAAlB,EAAsB,cAAtB,CAArB,CAAtC,IAEC,KAAKyG,kBAAL,CAAwBmF,QAAxB,KAAqC,KAAKjF,KAAL,CAAWiF,QAAX,EAAqB,KAAKxI,YAAL,CAAkBpD,EAAlB,EAAsB,cAAtB,CAArB,CAHvC,EAIE;AACD,aAAK4G,eAAL,CAAqBzH,EAArB;AACA;;AAED,UAAIa,EAAE,CAACkB,SAAH,IAAgBlB,EAAE,CAACoB,SAAvB,EAAkC;AACjC;AACA,aAAKgL,mBAAL,CAAyBpM,EAAzB,EAA6B0L,MAA7B,EAAqCC,WAArC,EAAkDxM,EAAlD,EAAsD+M,aAAa,IAAIG,aAAvE,EAAsFZ,QAAQ,CAACnH,KAA/F;AACA,aAAKgI,qBAAL,CAA2BtM,EAA3B,EAA+B0L,MAA/B,EAAuCC,WAAvC,EAAoDE,MAApD,EAA4DC,WAA5D,EAAyE3M,EAAzE,EAA6E+M,aAAa,IAAIG,aAA9F,EAA6GZ,QAAQ,CAACnH,KAAtH;AACA,OAJD,MAKK;AAEJ,YAAItE,EAAE,CAACkB,SAAP,EAAkB;AACjB,eAAKkL,mBAAL,CAAyBpM,EAAzB,EAA6B0L,MAA7B,EAAqCC,WAArC,EAAkDxM,EAAlD,EAAsD+M,aAAtD,EAAqET,QAAQ,CAACnH,KAA9E;AACA;;AAED,YAAItE,EAAE,CAACoB,SAAH,KAAiB,CAAC4K,WAAD,IAAgB7M,EAAE,CAACoN,OAApC,CAAJ,EAAkD;AACjD,eAAKD,qBAAL,CAA2BtM,EAA3B,EAA+B0L,MAA/B,EAAuCC,WAAvC,EAAoDE,MAApD,EAA4DC,WAA5D,EAAyE3M,EAAzE,EAA6E+M,aAAa,IAAIG,aAA9F,EAA6GZ,QAAQ,CAACnH,KAAtH;AACA;AAED;AAED;AAED,GAtGM;AAwGP;;;;;;;;;;;;AAUOvF,8CAAP,UAA2BiB,EAA3B,EAAkDoE,KAAlD,EAAiEqG,UAAjE,EAAqFtL,EAArF,EAAkIqN,YAAlI,EAAyJlI,KAAzJ,EAAuK;AAEtK,QAAIkI,YAAJ,EAAkB;AACjB,UAAIxM,EAAE,CAACgC,MAAH,CAAUa,SAAV,CAAoB,MAApB,KAA+B,CAAC3G,MAAM,CAAC4G,QAAvC,KAAoD,CAAC9C,EAAE,CAACsB,gBAAJ,IAAwB,CAACgD,KAA7E,CAAJ,EAAyF;AACxF,YAAIvB,IAAI,GAAiE;AACxEC,cAAI,EAAE,MADkE;AAExEC,gBAAM,EAAEjD,EAFgE;AAGxEkD,eAAK,EAAE/D,EAHiE;AAIxEuL,eAAK,EAAE;AACN,iBAAKtG,KAAK,CAACuE,CAAN,GAAU8B,UAAU,CAAC9B,CADpB;AAEN,iBAAKvE,KAAK,CAACwE,CAAN,GAAU6B,UAAU,CAAC7B;AAFpB,WAJiE;AAQxE6B,oBAAU,EAAEA,UAR4D;AASxErG,eAAK,EAAEA,KATiE;AAUxEE,eAAK,EAAEA;AAViE,SAAzE;AAYAtE,UAAE,CAACgC,MAAH,CAAUmB,mBAAV,CAA8B,MAA9B,EAAsCJ,IAAtC;AACA;AAED;AAED,GArBM;AAuBP;;;;;;;;;;;;;;AAYOhE,gDAAP,UAA6BiB,EAA7B,EAAoD0L,MAApD,EAAoEC,WAApE,EAAyFE,MAAzF,EAAyGC,WAAzG,EAA8H3M,EAA9H,EAA2JqN,YAA3J,EAAkLlI,KAAlL,EAAgM;AAC/L,QAAItE,EAAE,CAACgC,MAAH,CAAUa,SAAV,CAAoB,QAApB,KAAiC,CAAC3G,MAAM,CAAC4G,QAAzC,KAAsD,CAAC9C,EAAE,CAACsB,gBAAJ,IAAwB,CAACgD,KAA/E,CAAJ,EAA2F;AAC1F,UAAIvB,IAAI,GAAmE;AAC1EC,YAAI,EAAE,QADoE;AAE1EC,cAAM,EAAEjD,EAFkE;AAG1EkD,aAAK,EAAE/D,EAHmE;AAI1EsN,aAAK,EAAEpQ,KAAK,CAACqQ,QAAN,CAAehB,MAAf,EAAuBC,WAAvB,EAAoCE,MAApC,EAA4CC,WAA5C,CAJmE;AAK1EH,mBAAW,EAAEA,WAL6D;AAM1ED,cAAM,EAAEA,MANkE;AAO1EI,mBAAW,EAAEA,WAP6D;AAQ1ED,cAAM,EAAEA,MARkE;AAS1EvH,aAAK,EAAEA;AATmE,OAA3E;AAWAtE,QAAE,CAACgC,MAAH,CAAUmB,mBAAV,CAA8B,QAA9B,EAAwCJ,IAAxC;AACA;AAED,GAhBM;AAkBP;;;;;;;;;;AAQOhE,2CAAP,UAAwBiB,EAAxB,EAA+CkE,OAA/C,EAAmE/E,EAAnE,EAA+F;AAE9F;AACA,SAAKkL,kBAAL,CAAwB1I,SAAxB,CAAkC3B,EAAlC;;AAEA,QAAI,KAAKyG,kBAAL,CAAwBvC,OAAxB,CAAJ,EAAsC;AACrC,WAAK0C,eAAL,CAAqBzH,EAArB;AACA,KAP6F,CAS9F;;;AACA,QAAI4D,IAAI,GAAsE;AAC7EC,UAAI,EAAE,WADuE;AAE7EC,YAAM,EAAEjD,EAFqE;AAG7EkD,WAAK,EAAE/D,EAHsE;AAI7EmF,WAAK,EAAEJ,OAAO,GAAGA,OAAO,CAACI,KAAX,GAAmB;AAJ4C,KAA9E,CAV8F,CAiB9F;AACA;;AACA,QAAIJ,OAAJ,EAAa;AACZA,aAAO,CAACyI,UAAR,GAAqB3M,EAArB,CADY,CAEZ;AACA;AAED;;;;;;;AAKA,QAAIkE,OAAO,IAAIA,OAAO,CAACiI,eAAvB,EAAwC;AACvCjI,aAAO,CAACiI,eAAR,CAAwB/O,IAAxB,CAA6B2F,IAA7B;AACA,KAFD,MAGK;AACJ,UAAI,CAAC7G,MAAM,CAAC4G,QAAZ,EAAsB;AACrB9C,UAAE,CAACmD,mBAAH,CAAuB,WAAvB,EAAoCJ,IAApC;AACA;AACD;AACD,GArCM;AAuCP;;;;;;;;;;AAQOhE,0CAAP,UAAuBiB,EAAvB,EAA8CkE,OAA9C,EAAkE/E,EAAlE,EAA8F;AAE7F;AACA,QAAI,CAAC+E,OAAL,EAAc;AACbA,aAAO,GAAG,KAAK0I,cAAL,CAAoB5M,EAApB,CAAV;AACA,KAL4F,CAO7F;;;AACA,QAAIkE,OAAJ,EAAa;AACZA,aAAO,CAACyI,UAAR,GAAqBtG,SAArB;AACA,KAV4F,CAY7F;;;AACA,SAAKgE,kBAAL,CAAwBzI,WAAxB,CAAoC5B,EAApC,EAb6F,CAe7F;AACA;AAEA;;AACA,QAAI,CAACkE,OAAD,IAAY,KAAKyC,KAAL,CAAWzC,OAAX,EAAoB,CAApB,CAAhB,EAAwC;AACvC,UAAIlE,EAAE,CAACgC,MAAH,CAAUa,SAAV,CAAoB,UAApB,KAAmC,CAAC3G,MAAM,CAAC4G,QAA/C,EAAyD;AACxD,YAAIC,IAAI,GAAqE;AAC5EC,cAAI,EAAE,UADsE;AAE5EC,gBAAM,EAAEjD,EAFoE;AAG5EsE,eAAK,EAAEJ,OAAO,GAAGA,OAAO,CAACI,KAAX,GAAmB;AAH2C,SAA7E;AAKAtE,UAAE,CAACgC,MAAH,CAAUmB,mBAAV,CAA8B,UAA9B,EAA0CJ,IAA1C;AACA;AACD;AACD,GA7BM;AA+BP;;;;;;;;;;AAQOhE,6CAAP,UAA0BiB,EAA1B,EAAiDkE,OAAjD,EAAqE/E,EAArE,EAAiG;AAEhG;AACA,SAAKkL,kBAAL,CAAwB1I,SAAxB,CAAkC3B,EAAlC;AAEA,GALM;AAOP;;;;;;;;;;AAQOjB,4CAAP,UAAyBiB,EAAzB,EAAgDkE,OAAhD,EAAoE/E,EAApE,EAAgG;AAE/F;AACA,SAAKkL,kBAAL,CAAwBzI,WAAxB,CAAoC5B,EAApC;AAEA,GALM;AAQP;;;;;;;AAOA;;;;;;;;;;;;;;AAYOjB,oCAAP,UAAiBiB,EAAjB,EAAwCkE,OAAxC,EAA0D;AACzD,QAAI,CAACA,OAAL,EAAc;AACbA,aAAO,GAAG,KAAK0I,cAAL,CAAoB5M,EAApB,CAAV;AACA;;AAED,QAAIkE,OAAJ,EAAa;AACZ,WAAKgB,UAAL,CAAgBlF,EAAhB,EAAoBkE,OAApB,EAA6BA,OAAO,CAAC2I,aAArC;AACA;AACD,GARM;AAUP;;;;;;;;AAMO9N,mCAAP,UAAgBiB,EAAhB,EAAuCkE,OAAvC,EAA2DS,SAA3D,EAA8E;AAC7E,QAAI,CAACT,OAAL,EAAc;AACbA,aAAO,GAAG,KAAK0I,cAAL,CAAoB5M,EAApB,CAAV;AACA;;AAED,QAAIkE,OAAO,IAAI,CAACS,SAAhB,EAA2B;AAC1B,WAAKC,cAAL,CAAoBV,OAApB,EAA6BA,OAAO,CAACgH,WAArC,EAAkDvG,SAAlD;AACA;AACD,GARM;AAUP;;;;;;;;;;AAQO5F,yCAAP,UAAsBiB,EAAtB,EAA4C;AAC3C,QAAIA,EAAJ,EAAQ;AACP;AACA;AACA,aAAOA,EAAE,CAACiI,YAAH,CAAgB8B,QAAhB,CAAyB,CAAzB,CAAP;AACA,KAJD,MAKK,IAAI,KAAKM,kBAAL,CAAwBtF,MAA5B,EAAoC;AACxC;AACA,aAAO,KAAK6H,cAAL,CAAoB,KAAKvC,kBAAL,CAAwBN,QAAxB,CAAiC,CAAjC,CAApB,CAAP;AACA,KAHI,MAIA;AACJ,aAAO1D,SAAP;AACA;AACD,GAbM;AAgBP;;;;;;;AAOA;;;;;;;;AAMUtH,uCAAV,UAAuBI,EAAvB,EAA8B;AAC7B,QAAI2N,EAAE,GAAG,EAAT;;AACA,QAAIrQ,KAAK,CAACgC,QAAN,CAAeU,EAAE,CAAC4N,UAAlB,CAAJ,EAAmC;AAClCD,QAAE,GAAG,KAAa3N,EAAE,CAAC4N,UAArB;AACA,KAFD,MAEO,IAAItQ,KAAK,CAACgC,QAAN,CAAeU,EAAE,CAAC6N,SAAlB,CAAJ,EAAkC;AACxCF,QAAE,GAAG,KAAa3N,EAAE,CAAC6N,SAArB;AACA,KAFM,MAEA;AACNF,QAAE,GAAG,GAAL;AACA;;AACD,WAAOA,EAAE,CAACG,OAAH,CAAW,GAAX,EAAgB,EAAhB,CAAP;AACA,GAVS;AAYV;;;;;;;;AAMUlO,0CAAV,UAA0BI,EAA1B,EAAgD;AAC/C,WAAO;AACN,WAAKA,EAAE,CAAC+N,OADF;AAEN,WAAK/N,EAAE,CAACgO;AAFF,KAAP;AAIA,GALS;AAOV;;;;;;;;;;AAQUpO,qCAAV,UAAqBI,EAArB,EAA2C;AAE1C;AACA,QAAI2N,EAAE,GAAG,KAAKM,YAAL,CAAkBjO,EAAlB,CAAT,CAH0C,CAK1C;;AACA,QAAIiF,KAAK,GAAG,KAAKC,eAAL,CAAqBlF,EAArB,CAAZ,CAN0C,CAQ1C;;AACA,QAAI+E,OAAJ;;AACA,QAAI,KAAKmJ,QAAL,CAAcjN,MAAd,CAAqB0M,EAArB,CAAJ,EAA8B;AAE7B;AACA5I,aAAO,GAAG,KAAKmJ,QAAL,CAAc7M,MAAd,CAAqBsM,EAArB,CAAV,CAH6B,CAK7B;;AACA5I,aAAO,CAACI,KAAR,GAAgB,KAAKgJ,cAAL,CAAoBnO,EAApB,CAAhB,CAN6B,CAQ7B;AACA;AAEA,KAXD,MAYK;AACJ;AACA+E,aAAO,GAAG;AACT,cAAM4I,EADG;AAET;AACA;AACA,iBAAS,KAAKQ,cAAL,CAAoBnO,EAApB,CAJA;AAKT,sBAAciF,KALL;AAMT,qBAAa1H,KAAK,CAACyJ,OAAN,EANJ;AAOT,iBAAS/B,KAPA;AAQT,iBAAS,EARA;AAST,yBAAiB,KATR;AAUT,2BAAmB;AAVV,OAAV,CAFI,CAeJ;;AACA,WAAKG,aAAL,CAAmBL,OAAnB,EAA4BE,KAA5B,EAhBI,CAkBJ;;AACA,WAAKiJ,QAAL,CAAczO,MAAd,CAAqBkO,EAArB,EAAyB5I,OAAzB;AACA,KA1CyC,CA4C1C;;;AACAA,WAAO,CAACiG,SAAR,GAAoBhL,EAApB;AAEA,SAAKoO,WAAL,GAAmBrJ,OAAnB;AAEA,WAAOA,OAAP;AACA,GAlDS;AAoDV;;;;;;;;AAMUnF,yCAAV,UAAyBI,EAAzB,EAA+C;AAC9C,QAAI,OAAOqO,KAAP,KAAiB,WAAjB,IAAgCrO,EAAE,YAAYqO,KAAlD,EAAyD;AACxD,aAAO,IAAP;AACA,KAFD,MAGK,IAAI,OAAOC,YAAP,KAAwB,WAAxB,IAAuCtO,EAAE,YAAYsO,YAArD,IAAqEhR,KAAK,CAACgC,QAAN,CAAqBU,EAAG,CAACuO,WAAzB,CAAzE,EAAgH;AACpH,cAAcvO,EAAG,CAACuO,WAAlB;AACC,aAAK,OAAL;AACA,aAAK,KAAL;AACA,aAAK,CAAL;AACC,iBAAO,IAAP;;AACD,aAAK,OAAL;AACA,aAAK,CAAL;AACC,iBAAO,KAAP;;AACD;AACC,iBAAO,EAAEvO,EAAE,YAAYwO,UAAhB,CAAP;AATF;AAWA,KAZI,MAaA,IAAIlR,KAAK,CAACgC,QAAN,CAAqBU,EAAG,CAAC6D,IAAzB,CAAJ,EAAoC;AACxC,UAAU7D,EAAG,CAAC6D,IAAJ,CAAS5E,KAAT,CAAe,QAAf,CAAV,EAAoC;AACnC,eAAO,KAAP;AACA;AACD;;AACD,WAAO,IAAP;AACA,GAvBS;AAyBV;;;;;;;;AAMUW,uCAAV,UAAuBmF,OAAvB,EAA0C/E,EAA1C,EAA+E;AAC9E;AACA,QAAIiF,KAAK,GAAG,KAAKC,eAAL,CAAqBlF,EAArB,CAAZ;AAAqC;AACrC+E,WAAO,CAAC0J,SAAR,GAAoBlR,KAAK,CAACyJ,OAAN,EAApB;AACAjC,WAAO,CAACuG,UAAR,GAAqB;AAAE9B,OAAC,EAAEvE,KAAK,CAACuE,CAAX;AAAcC,OAAC,EAAExE,KAAK,CAACwE;AAAvB,KAArB;AACA1E,WAAO,CAACE,KAAR,GAAgB;AAAEuE,OAAC,EAAEvE,KAAK,CAACuE,CAAX;AAAcC,OAAC,EAAExE,KAAK,CAACwE;AAAvB,KAAhB;AACA1E,WAAO,CAAC2J,KAAR,GAAgB,EAAhB;AACA3J,WAAO,CAAC4J,aAAR,GAAwB,KAAxB,CAP8E,CAQ9E;AACA;AACA,GAVS;AAYV;;;;;;;;AAMU/O,wCAAV,UAAwBmF,OAAxB,EAA2CE,KAA3C,EAAwD;AACvDF,WAAO,CAAC2J,KAAR,CAAczQ,IAAd,CAAmB;AAClB,mBAAaV,KAAK,CAACyJ,OAAN,EADK;AAElB,eAAS/B;AAFS,KAAnB;AAIA,GALS;AAOV;;;;;;;AAKOrF,uCAAP;AACC,SAAKwC,WAAL,CAAiB,KAAKvE,IAAtB;AACA,GAFM;AAIP;;;;;;;AAKO+B,yCAAP;AACC,QAAI,KAAKsL,kBAAL,CAAwBtF,MAAxB,IAAkC,CAAtC,EAAyC;AACxC,WAAKgJ,gBAAL,CAAsB,KAAK/Q,IAA3B;AACA;AACD,GAJM;AAMP;;;;;;;AAKO+B,sCAAP,UAAmBiB,EAAnB,EAAwC;AACvC,SAAKuB,WAAL,CAAiBvB,EAAjB;AACA,GAFM;AAIP;;;;;;;AAKOjB,wCAAP,UAAqBiB,EAArB,EAA0C;AACzC,SAAK+N,gBAAL,CAAsB/N,EAAtB;AACA,GAFM;AAIP;;;;;;;AAKOjB,oCAAP;AACC1B,UAAM,CAACrB,gBAAP,CACC,KAAKuB,cAAL,CAAoBiB,KADrB,EAEC,KAAKwP,cAFN,EAGC,KAAKlP,iBAAL,GAAyB;AAAEiD,aAAO,EAAE;AAAX,KAAzB,GAA8C,KAH/C;AAKA,GANM;AAQP;;;;;;;AAKOhD,sCAAP;AACC1B,UAAM,CAAC4Q,mBAAP,CACC,KAAK1Q,cAAL,CAAoBiB,KADrB,EAEC,KAAKwP,cAFN;AAIA,GALM;AAOP;;;;;;;;;;;AASOjP,yCAAP,UAAsBmF,OAAtB,EAAyCgK,GAAzC,EAA6DpB,EAA7D,EAAuE;AACtE,QAAMqB,MAAM,GAAG,KAAKC,QAAL,CAAc,mBAAmBlK,OAAO,CAAC4I,EAAzC,CAAf;;AACA,QAAIrQ,KAAK,CAACgC,QAAN,CAAe0P,MAAf,CAAJ,EAA4B;AAC3B,aAAOA,MAAP;AACA;;AACD,QAAME,GAAG,GAAI9R,IAAI,CAAC+R,OAAL,CAAaJ,GAAb,KAAqBhR,QAAlC;;AACA,QAAImR,GAAG,CAACE,gBAAR,EAA0B;AACzB,UAAMtL,MAAM,GAAGoL,GAAG,CAACE,gBAAJ,CAAqBrK,OAAO,CAACE,KAAR,CAAcuE,CAAnC,EAAsCzE,OAAO,CAACE,KAAR,CAAcwE,CAApD,CAAf;AACA,UAAM4F,KAAK,GAAGvL,MAAM,IAAI1G,IAAI,CAAC4M,QAAL,CAAc+E,GAAd,EAAgCjL,MAAhC,CAAxB;AACA,WAAKwL,QAAL,CAAc,mBAAmBvK,OAAO,CAAC4I,EAA3B,GAAgC,GAAhC,GAAsCA,EAApD,EAAwD0B,KAAxD,EAA+D,GAA/D;AACA,aAAOA,KAAP;AACA;;AACD,WAAO,KAAP;AACA,GAbM;AAeP;;;;;;;;;AAOUzP,yCAAV,UAAyBI,EAAzB,EAAkC;AACjCA,MAAE,CAACoB,cAAH;AACA,WAAO,KAAP;AACA,GAHS;AAKV;;;;;;;;;AAOOxB,sCAAP,UAAmBiB,EAAnB,EAAwC;AAEvC,QAAI0O,EAAE,GAAG1O,EAAE,CAACK,OAAZ;;AAEA,QAAIqO,EAAJ,EAAQ;AAEP;AACA,UAAIC,KAAK,GAAG,CACX,aADW,EACI,mBADJ,EACyB,gBADzB,EAC2C,eAD3C,EAC4D,eAD5D,EAC6E,cAD7E,EAEX,YAFW,EAEG,kBAFH,EAEuB,eAFvB,EAEwC,cAFxC,EAEwD,cAFxD,EAEwE,aAFxE,EAGX,aAHW,EAGI,mBAHJ,EAGyB,gBAHzB,EAG2C,eAH3C,EAG4D,eAH5D,EAG6E,cAH7E,EAIX,cAJW,EAIK,oBAJL,EAI2B,iBAJ3B,EAI8C,gBAJ9C,EAIgE,gBAJhE,EAIkF,eAJlF,EAKX,gBALW,EAKO,sBALP,EAK+B,mBAL/B,EAKoD,kBALpD,EAKwE,kBALxE,EAK4F,iBAL5F,EAMX,UANW,EAMC,gBAND,EAMmB,aANnB,EAMkC,YANlC,EAMgD,YANhD,EAM8D,WAN9D,CAAZ;;AAQA,WAAK,IAAI9J,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG8J,KAAK,CAAC5J,MAA1B,EAAkCF,CAAC,EAAnC,EAAuC;AACtC,YAAI8J,KAAK,CAAC9J,CAAD,CAAL,IAAY6J,EAAE,CAACE,KAAnB,EAA0B;AACzB,eAAKC,iBAAL,CAAuB7O,EAAvB,EAA2B2O,KAAK,CAAC9J,CAAD,CAAhC,EAAqC,MAArC;AACA;AACD,OAfM,CAiBP;;;AACA,WAAKgK,iBAAL,CAAuB7O,EAAvB,EAA2B,mBAA3B,EAAgD,kBAAhD,EAlBO,CAmBP;AACA;AAED,GA1BM;AA4BP;;;;;;;;AAMOjB,wCAAP,UAAqBiB,EAArB,EAA0C;AAEzC,QAAI0O,EAAE,GAAG1O,EAAE,CAACK,OAAZ;;AAEA,QAAIqO,EAAJ,EAAQ;AAEP;AACA,UAAIC,KAAK,GAAG,CACX,aADW,EACI,mBADJ,EACyB,gBADzB,EAC2C,eAD3C,EAC4D,eAD5D,EAC6E,cAD7E,EAEX,YAFW,EAEG,kBAFH,EAEuB,eAFvB,EAEwC,cAFxC,EAEwD,cAFxD,EAEwE,aAFxE,EAGX,aAHW,EAGI,mBAHJ,EAGyB,gBAHzB,EAG2C,eAH3C,EAG4D,eAH5D,EAG6E,cAH7E,EAIX,cAJW,EAIK,oBAJL,EAI2B,iBAJ3B,EAI8C,gBAJ9C,EAIgE,gBAJhE,EAIkF,eAJlF,EAKX,gBALW,EAKO,sBALP,EAK+B,mBAL/B,EAKoD,kBALpD,EAKwE,kBALxE,EAK4F,iBAL5F,EAMX,UANW,EAMC,gBAND,EAMmB,aANnB,EAMkC,YANlC,EAMgD,YANhD,EAM8D,WAN9D,CAAZ;;AAQA,WAAK,IAAI9J,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG8J,KAAK,CAAC5J,MAA1B,EAAkCF,CAAC,EAAnC,EAAuC;AACtC,YAAI8J,KAAK,CAAC9J,CAAD,CAAL,IAAY6J,EAAE,CAACE,KAAnB,EAA0B;AACzB,eAAKE,YAAL,CAAkB9O,EAAlB,EAAsB2O,KAAK,CAAC9J,CAAD,CAA3B;AACA;AACD,OAfM,CAiBP;;;AACA,WAAKiK,YAAL,CAAkB9O,EAAlB,EAAsB,mBAAtB,EAlBO,CAmBP;AACA;AAED,GA1BM;AA4BP;;;;;;;;;;AAQOjB,uCAAP,UAAoBiB,EAApB,EAA2C+O,MAA3C,EAAoE;AACnE,QAAIC,GAAG,GAAGhP,EAAE,CAACiP,UAAH,CAAcF,MAAd,CAAV;;AACA,QAAI,OAAOC,GAAP,KAAe,WAAnB,EAAgC;AAC/BA,SAAG,GAAG,KAAKC,UAAL,CAAgBF,MAAhB,CAAN;AACA;;AACD,WAAOC,GAAP;AACA,GANM;AAQP;;;;;;;;;;AAQOjQ,yCAAP,UAAsBiB,EAAtB,EAA6C+O,MAA7C,EAAwE;AACvE,QAAIC,GAAG,GAAGhP,EAAE,CAACkP,YAAH,CAAgBH,MAAhB,CAAV;;AACA,QAAI,OAAOC,GAAP,KAAe,WAAnB,EAAgC;AAC/BA,SAAG,GAAG,KAAKE,YAAL,CAAkBH,MAAlB,CAAN;AACA;;AACD,WAAOC,GAAP;AACA,GANM;AAQP;;;;;;;;;;AAQOjQ,yCAAP,UAAsBiB,EAAtB,EAA6C+O,MAA7C,EAAwE;AACvE,QAAIC,GAAG,GAAGhP,EAAE,CAACmP,YAAH,CAAgBJ,MAAhB,CAAV;;AACA,QAAI,OAAOC,GAAP,KAAe,WAAnB,EAAgC;AAC/BA,SAAG,GAAG,KAAKG,YAAL,CAAkBJ,MAAlB,CAAN;AACA;;AACD,WAAOC,GAAP;AACA,GANM;AAQP;;;;;;;;;;AAQOjQ,4CAAP,UAAyBiB,EAAzB,EAAgD+O,MAAhD,EAA8E;AAC7E,QAAIC,GAAG,GAAGhP,EAAE,CAACoP,eAAH,CAAmBL,MAAnB,CAAV;;AACA,QAAI,OAAOC,GAAP,KAAe,WAAnB,EAAgC;AAC/BA,SAAG,GAAG,KAAKI,eAAL,CAAqBL,MAArB,CAAN;AACA;;AACD,WAAOC,GAAP;AACA,GANM;AAQP;;;;;;;;;;AAQOjQ,yCAAP,UAAsBiB,EAAtB,EAA6C+O,MAA7C,EAAwE;AACvE,QAAIC,GAAG,GAAGhP,EAAE,CAACqP,YAAH,CAAgBN,MAAhB,CAAV;;AACA,QAAI,OAAOC,GAAP,KAAe,WAAnB,EAAgC;AAC/BA,SAAG,GAAG,KAAKK,YAAL,CAAkBN,MAAlB,CAAN;AACA;;AACD,WAAOC,GAAP;AACA,GANM;AAQP;;;;;;;;;;;AASOjQ,2CAAP,UAAwBiB,EAAxB,EAA+CgD,IAA/C,EAAmE+L,MAAnE,EAAgG;AAC/F,QAAI5S,OAAO,GAAQ6D,EAAE,CAACrB,cAAH,CAAkB6B,MAAlB,CAAyBwC,IAAzB,CAAnB;AACA,QAAIgM,GAAJ;;AACA,QAAI7S,OAAO,IAAIM,KAAK,CAACgC,QAAN,CAAetC,OAAO,CAAC4S,MAAD,CAAtB,CAAf,EAAgD;AAC/CC,SAAG,GAAG7S,OAAO,CAAC4S,MAAD,CAAb;AACA,KAFD,MAGK;AACJC,SAAG,GAAS,KAAKrQ,cAAL,CAAoB6B,MAApB,CAA2BwC,IAA3B,EAAkC+L,MAAlC,CAAZ;AACA;;AACD,WAAOC,GAAP;AACA,GAVM;AAYP;;;;;;;;AAMUjQ,sCAAV,UAAsBiB,EAAtB,EAA2C;AAC1C,QAAI2I,CAAJ;AACA,QAAI6C,QAAQ,GAAwB,CAAC,MAAD,EAAS,QAAT,CAApC;;AACA,SAAK,IAAI3G,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG2G,QAAQ,CAACzG,MAA7B,EAAqCF,CAAC,EAAtC,EAA0C;AACzC8D,OAAC,GAAG6C,QAAQ,CAAC3G,CAAD,CAAZ;;AACA,UAAI7E,EAAE,CAACwL,QAAH,CAAYpL,MAAZ,CAAmBuI,CAAnB,CAAJ,EAA2B;AAC1B,YAAImC,OAAO,GAA4B9K,EAAE,CAACwL,QAAH,CAAYhL,MAAZ,CAAmBmI,CAAnB,CAAvC;;AACA,YAAImC,OAAJ,EAAa;AACZA,iBAAO,CAACrK,OAAR,GADY,CAEZ;AACA;;AACA;AACA;AACD;AACD;AACD,GAfS;AAiBV;;;;;;;;;AAOO1B,kCAAP,UAAeiB,EAAf,EAAsCkE,OAAtC,EAAuD;AACtD,QAAIgC,GAAG,GAAGxJ,KAAK,CAACyJ,OAAN,EAAV;;AAEA,QAAIjC,OAAO,CAAC4J,aAAR,IAAyB,CAAC9N,EAAE,CAACmB,SAAjC,EAA4C;AAC3C,aAAO,KAAP;AACA,KAFD,MAGK,IACHwE,IAAI,CAAC2J,GAAL,CAASpL,OAAO,CAACuG,UAAR,CAAmB7B,CAAnB,GAAuB1E,OAAO,CAACE,KAAR,CAAcwE,CAA9C,IAAmD,KAAK2G,cAAL,CAAoBvP,EAApB,EAAwB,mBAAxB,CAApD,IACCkE,OAAO,CAAC0J,SAAR,GAAqB1H,GAAG,GAAG,KAAKqJ,cAAL,CAAoBvP,EAApB,EAAwB,MAAxB,CAFxB,EAGH;AACD,aAAO,IAAP;AACA,KALI,MAMA;AACJ,aAAO,KAAP;AACA;AACD,GAfM;AAiBP;;;;;;;;;AAOOjB,iCAAP,UAAciB,EAAd,EAAqCkE,OAArC,EAAsD;AACrD,QAAIgC,GAAG,GAAGxJ,KAAK,CAACyJ,OAAN,EAAV;;AACA,QAAIjC,OAAO,CAAC4J,aAAZ,EAA2B;AAC1B,aAAO,KAAP;AACA,KAFD,MAGK,IACHnI,IAAI,CAAC2J,GAAL,CAASpL,OAAO,CAACuG,UAAR,CAAmB9B,CAAnB,GAAuBzE,OAAO,CAACE,KAAR,CAAcuE,CAA9C,IAAmD,KAAK4G,cAAL,CAAoBvP,EAApB,EAAwB,qBAAxB,CAApD,IACC2F,IAAI,CAAC2J,GAAL,CAASpL,OAAO,CAACuG,UAAR,CAAmB7B,CAAnB,GAAuB1E,OAAO,CAACE,KAAR,CAAcwE,CAA9C,IAAmD,KAAK2G,cAAL,CAAoBvP,EAApB,EAAwB,mBAAxB,CADpD,IAECkE,OAAO,CAAC0J,SAAR,GAAqB1H,GAAG,GAAG,KAAKqJ,cAAL,CAAoBvP,EAApB,EAAwB,MAAxB,CAHxB,EAIH;AACD,aAAO,IAAP;AACA,KANI,MAOA;AACJ,aAAO,KAAP;AACA;AACD,GAfM;AAiBP;;;;;;;;;AAOOjB,+CAAP,UAA4BiB,EAA5B,EAAiD;AAEhD;AACA,QAAI7D,OAAO,GAAG6D,EAAE,CAACwP,aAAjB;;AAEA,QAAI,CAAC/S,KAAK,CAACgC,QAAN,CAAetC,OAAO,CAACsT,SAAvB,CAAL,EAAwC;AACvC;AACA,KAP+C,CAShD;;;AACA,SAAK,IAAI5K,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG1I,OAAO,CAACsT,SAAR,CAAkB1K,MAAtC,EAA8CF,CAAC,EAA/C,EAAmD;AAClDtI,UAAI,CAACmT,QAAL,CAAc1P,EAAE,CAACK,OAAjB,EAA0BlE,OAAO,CAACsT,SAAR,CAAkB5K,CAAlB,EAAqB8K,QAA/C,EAAyDxT,OAAO,CAACsT,SAAR,CAAkB5K,CAAlB,EAAqB+K,KAA9E;AACA;AAED,GAdM;AAgBP;;;;;;;;;;AAQO7Q,+CAAP,UAA4BiB,EAA5B,EAAmDkE,OAAnD,EAAoE;AAEnE;AACA,QAAIA,OAAO,IAAIA,OAAO,CAACI,KAAvB,EAA8B;AAC7B;AACA;;AAED,QAAMuL,SAAS,GAAG7P,EAAE,CAACwP,aAAH,CAAiBK,SAAnC,CAPmE,CAQnE;;AACA,QAAI7P,EAAE,CAACiI,YAAH,CAAgBkB,QAAhB,CAAyBjF,OAAzB,KAAqCzH,KAAK,CAACgC,QAAN,CAAeoR,SAAf,CAAzC,EAAoE;AACnE;AACA,WAAK,IAAIhL,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGgL,SAAS,CAAC9K,MAA9B,EAAsCF,CAAC,EAAvC,EAA2C;AAC1C,aAAKgK,iBAAL,CAAuB,KAAK7R,IAA5B,EAAkC6S,SAAS,CAAChL,CAAD,CAAT,CAAa8K,QAA/C,EAAyDE,SAAS,CAAChL,CAAD,CAAT,CAAa+K,KAAtE;AACA,aAAKf,iBAAL,CAAuB7O,EAAvB,EAA2B6P,SAAS,CAAChL,CAAD,CAAT,CAAa8K,QAAxC,EAAkDE,SAAS,CAAChL,CAAD,CAAT,CAAa+K,KAA/D;AACA;AACD;AACD,GAhBM;AAkBP;;;;;;;;;AAOO7Q,iDAAP,UAA8BiB,EAA9B,EAAqDkE,OAArD,EAAsE;AAErE;AACA,QAAIA,OAAO,IAAIA,OAAO,CAACI,KAAvB,EAA8B;AAC7B;AACA;;AAED,QAAMuL,SAAS,GAAG7P,EAAE,CAACwP,aAAH,CAAiBK,SAAnC,CAPqE,CASrE;;AACA,QAAI7P,EAAE,CAACiI,YAAH,CAAgBkB,QAAhB,CAAyBjF,OAAzB,KAAqCzH,KAAK,CAACgC,QAAN,CAAeoR,SAAf,CAAzC,EAAoE;AACnE;AACA,WAAK,IAAIhL,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGgL,SAAS,CAAC9K,MAA9B,EAAsCF,CAAC,EAAvC,EAA2C;AAC1C,aAAKiK,YAAL,CAAkB,KAAK9R,IAAvB,EAA6B6S,SAAS,CAAChL,CAAD,CAAT,CAAa8K,QAA1C;AACA,aAAKb,YAAL,CAAkB9O,EAAlB,EAAsB6P,SAAS,CAAChL,CAAD,CAAT,CAAa8K,QAAnC;AACA;AACD;AACD,GAjBM;AAmBP;;;;;;;;AAMO5Q,yCAAP,UAAsB6P,KAAtB,EAAmE;AAClE,QAAI5R,IAAI,GAAGC,cAAc,GAAGD,IAA5B;AACA,QAAI8S,MAAM,GAA2BrT,KAAK,CAACsT,OAAN,CAAcnB,KAAd,IAAuBA,KAAvB,GAA+B,CAACA,KAAD,CAApE;;AACA,SAAK,IAAI/J,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGiL,MAAM,CAAC/K,MAA3B,EAAmCF,CAAC,EAApC,EAAwC;AACvC,WAAKgK,iBAAL,CAAuB7R,IAAvB,EAA6B8S,MAAM,CAACjL,CAAD,CAAN,CAAU8K,QAAvC,EAAiDG,MAAM,CAACjL,CAAD,CAAN,CAAU+K,KAA3D;AACA;AACD,GANM;AAQP;;;;;;;;AAMO7Q,6CAAP,UAA0B6P,KAA1B,EAAuE;AACtE,QAAI5R,IAAI,GAAGC,cAAc,GAAGD,IAA5B;AACA,QAAI8S,MAAM,GAA2BrT,KAAK,CAACsT,OAAN,CAAcnB,KAAd,IAAuBA,KAAvB,GAA+B,CAACA,KAAD,CAApE;;AACA,SAAK,IAAI/J,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGiL,MAAM,CAAC/K,MAA3B,EAAmCF,CAAC,EAApC,EAAwC;AACvC,WAAKiK,YAAL,CAAkB9R,IAAlB,EAAwB8S,MAAM,CAACjL,CAAD,CAAN,CAAU8K,QAAlC;AACA;AACD,GANM;AAQP;;;;;;;;AAMU5Q,0CAAV,UAA0BiB,EAA1B,EAA+C;AAC9C,WAAO9C,QAAQ,CAACF,IAAT,KAAkBgD,EAAE,CAACK,OAA5B;AACA,GAFS;AAIV;;;;;;;;;;AAQOtB,gCAAP,UAAamF,OAAb,EAAgC8L,SAAhC,EAAmDC,OAAnD,EAAwE;AAEvE;;;;;AAFkD;AAAAA;AAAqB,MAQvE;;;AACA,QAAIvF,KAAK,GAAG,KAAKwF,QAAL,CAAchM,OAAd,CAAZ;AAEA,WAAQyB,IAAI,CAAC2J,GAAL,CAAS5E,KAAK,CAAC/B,CAAf,IAAoBqH,SAArB,IAAoCrK,IAAI,CAAC2J,GAAL,CAAS5E,KAAK,CAAC9B,CAAf,IAAoBoH,SAA/D;AACA,GAZM;AAcP;;;;;;;;;;;AASOjR,8BAAP,UAAWmF,OAAX,EAA8B+L,OAA9B,EAAmD;AAArB;AAAAA;AAAqB;;AAClD,WAAOvT,KAAK,CAACyJ,OAAN,KAAkBjC,OAAO,CAAC0J,SAA1B,GAAsCqC,OAA7C;AACA,GAFM;AAIP;;;;;;;;;AAOOlR,mCAAP,UAAgBmF,OAAhB,EAAiC;AAChC,WAAO;AACN,WAAKA,OAAO,CAACuG,UAAR,CAAmB9B,CAAnB,GAAuBzE,OAAO,CAACE,KAAR,CAAcuE,CADpC;AAEN,WAAKzE,OAAO,CAACuG,UAAR,CAAmB7B,CAAnB,GAAuB1E,OAAO,CAACE,KAAR,CAAcwE;AAFpC,KAAP;AAIA,GALM;AAOP;;;;;;;;;AAOO7J,wCAAP,UAAqBmF,OAArB,EAAwCiM,SAAxC,EAAyD;AACxD,QAAInB,GAAJ;;AACA,SAAK,IAAInK,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGX,OAAO,CAAC2J,KAAR,CAAc9I,MAAlC,EAA0CF,CAAC,EAA3C,EAA+C;AAC9C,UAAIX,OAAO,CAAC2J,KAAR,CAAchJ,CAAd,EAAiBsL,SAAjB,IAA8BA,SAAlC,EAA6C;AAC5CnB,WAAG,GAAG9K,OAAO,CAAC2J,KAAR,CAAchJ,CAAd,CAAN;AACA;AACA;AACD;;AACD,WAAOmK,GAAP;AACA,GATM;AAWP;;;;;;;;;AAOUjQ,wCAAV,UAAwBqR,IAAxB,EAA8ClM,OAA9C,EAA+D;AAC9D,QAAImM,MAAM,GAAG,KAAb;AACAD,QAAI,CAAClH,IAAL,CAAU,UAACoH,IAAD,EAAK;AACd,UAAIA,IAAI,IAAIpM,OAAZ,EAAqB;AACpB;AACA;;AACDmM,YAAM,GAAGC,IAAI,CAAClM,KAAL,CAAWuE,CAAX,IAAgBzE,OAAO,CAACE,KAAR,CAAcuE,CAA9B,IAAmC2H,IAAI,CAAClM,KAAL,CAAWwE,CAAX,IAAgB1E,OAAO,CAACE,KAAR,CAAcwE,CAA1E;AACA,KALD;AAMA,WAAOyH,MAAP;AACA,GATS;AAWV;;;;;;;;;;;AASOtR,yCAAP,UAAsBsB,OAAtB,EAA0D;AACzD,WAAO,IAAIzE,iBAAJ,CAAsByE,OAAtB,CAAP;AACA,GAFM;AAIP;;;;;;;;;;;AASOtB,4CAAP,UAAyBiB,EAAzB,EAAgD2P,QAAhD,EAAkEC,KAAlE,EAA+E;AAE9E;AACA;AACA,QAAIlB,EAAE,GAAG1O,EAAE,CAACK,OAAZ,CAJ8E,CAM9E;;AACA,QAAI5D,KAAK,CAACgC,QAAN,CAAqBiQ,EAAE,CAACE,KAAH,CAAUe,QAAV,CAArB,KAA6C,CAAC3P,EAAE,CAACuQ,cAAH,CAAkBnQ,MAAlB,CAAyBuP,QAAzB,CAAlD,EAAsF;AACrF3P,QAAE,CAACuQ,cAAH,CAAkB3R,MAAlB,CAAyB+Q,QAAzB,EAAyCjB,EAAE,CAACE,KAAH,CAAUe,QAAV,CAAzC;AACA,KAT6E,CAW9E;;;AACApT,QAAI,CAACmT,QAAL,CAAchB,EAAd,EAAkBiB,QAAlB,EAA4BC,KAA5B;AAEA,GAdM;AAgBP;;;;;;;;AAMO7Q,uCAAP,UAAoBiB,EAApB,EAA2C2P,QAA3C,EAA2D;AAE1D;AACA,QAAI3P,EAAE,CAACuQ,cAAH,CAAkBnQ,MAAlB,CAAyBuP,QAAzB,CAAJ,EAAwC;AACjC3P,QAAE,CAACK,OAAH,CAAWuO,KAAX,CAAkBe,QAAlB,IAA8B3P,EAAE,CAACuQ,cAAH,CAAkB/P,MAAlB,CAAyBmP,QAAzB,CAA9B;AACN3P,QAAE,CAACuQ,cAAH,CAAkBtP,SAAlB,CAA4B0O,QAA5B;AACA,KAHD,MAIK;AACJ,aAAa3P,EAAE,CAACK,OAAH,CAAWuO,KAAX,CAAkBe,QAAlB,CAAb;AACA;AACD,GAVM;AAYP;;;;;;;AAKO5Q,2CAAP,UAAwBiB,EAAxB,EAA6C;AAC5CxD,SAAK,CAAC0M,IAAN,CAAWlJ,EAAE,CAACuQ,cAAH,CAAkBjH,QAAlB,EAAX,EAAyC,UAACkH,CAAD,EAAE;AAC1C,UAAMC,GAAG,GAAGD,CAAC,CAAC,CAAD,CAAb;AACA,UAAMZ,KAAK,GAAGY,CAAC,CAAC,CAAD,CAAf;AACMxQ,QAAE,CAACK,OAAH,CAAWuO,KAAX,CAAkB6B,GAAlB,IAAyBb,KAAzB;AACN5P,QAAE,CAACuQ,cAAH,CAAkBtP,SAAlB,CAA4BwP,GAA5B;AACA,KALD;AAMA,GAPM;AASP;;;;;AAGO1R,kCAAP;AACC,QAAI,CAAC,KAAK4I,UAAL,EAAL,EAAwB;AACvB/K,uBAAM6D,OAAN,CAAaiQ,IAAb,CAAa,IAAb;;AACA,WAAK3C,gBAAL,CAAsB,KAAK/Q,IAA3B;AACA,WAAKkF,WAAL;AACA;AACD,GANM,CAtlGR,CA8lGC;;;AACQnD,8BAAR,UAAY4R,IAAZ,EAA0BxR,EAA1B,EAAsEa,EAAtE,EAA4F;AAC3F,QAAI4Q,IAAI,GAAG,IAAX;;AACA,QAAIA,IAAJ,EAAU;AACT;AACA,UAAUzR,EAAG,CAAC2F,cAAd,EAA8B;AAC7B,aAAK,IAAID,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAS1F,EAAG,CAAC2F,cAAJ,CAAmBC,MAA7C,EAAqDF,CAAC,EAAtD,EAA0D;AACzD,eAAKgM,QAAL,CAAcF,IAAd,EAAoBxR,EAAE,CAAC6D,IAAvB,EAAmC7D,EAAG,CAAC2F,cAAJ,CAAmBD,CAAnB,CAAnC;AACA;;AACD;AACA,OAPQ,CAST;;;AACA,UAAI7B,IAAI,GAAG,EAAX;;AACA,UAAU7D,EAAG,CAACuO,WAAd,EAA2B;AAC1B,gBAAcvO,EAAG,CAACuO,WAAlB;AACC,eAAK,CAAL;AACC1K,gBAAI,GAAG,OAAP;AACA;;AACD,eAAK,CAAL;AACCA,gBAAI,GAAG,OAAP;AACA;;AACD;AACCA,gBAAI,GAAS7D,EAAG,CAACuO,WAAjB;AACA;AATF;AAWA,OAZD,MAaK,IAAI,OAAOoD,UAAP,IAAqB,WAArB,IAAoC3R,EAAE,YAAY2R,UAAtD,EAAkE;AACtE9N,YAAI,GAAG,OAAP;AACA,OAFI,MAGA,IAAI7D,EAAE,CAAC6D,IAAH,CAAQ5E,KAAR,CAAc,QAAd,CAAJ,EAA6B;AACjC4E,YAAI,GAAG,OAAP;AACA,OAFI,MAGA;AACJA,YAAI,GAAG,KAAP;AACA,OAhCQ,CAkCT;;;AACA,UAAI8J,EAAE,GAAG,EAAT;;AACA,UAAIrQ,KAAK,CAACgC,QAAN,CAAqBU,EAAG,CAAC4N,UAAzB,CAAJ,EAA0C;AACzCD,UAAE,GAAiB3N,EAAG,CAAC4N,UAAvB;AACA,OAFD,MAEO,IAAItQ,KAAK,CAACgC,QAAN,CAAqBU,EAAG,CAAC6N,SAAzB,CAAJ,EAAyC;AAC/CF,UAAE,GAAiB3N,EAAG,CAAC6N,SAAvB;AACA,OAFM,MAEA;AACNF,UAAE,GAAG,KAAL;AACA;;AAED,UAAI9M,EAAJ,EAAQ;AACP+Q,eAAO,CAACC,GAAR,CAAYL,IAAI,GAAG,IAAP,GAAc3Q,EAAE,CAACiR,GAAjB,GAAuB,KAAvB,GAA+B9R,EAAE,CAAC6D,IAAlC,GAAyC,IAAzC,GAAgDA,IAAhD,GAAuD,IAAvD,GAA8D8J,EAA1E;AACA,OAFD,MAGK;AACJiE,eAAO,CAACC,GAAR,CAAYL,IAAI,GAAG,IAAP,GAAcxR,EAAE,CAAC6D,IAAjB,GAAwB,IAAxB,GAA+BA,IAA/B,GAAsC,IAAtC,GAA6C8J,EAAzD;AACA;AACD;AAED,GAtDO;AAwDR;;;;;;;;;;;;AAUO/N,yCAAP,UAAsBmS,MAAtB,EAAsE;AACrE,QAAIC,KAAK,GAAG,KAAK9G,kBAAL,CAAwBtF,MAApC;;AACA,QAAImM,MAAJ,EAAY;AACX,UAAME,EAAE,GAAG3U,KAAK,CAACsT,OAAN,CAAcmB,MAAd,IAAwBA,MAAxB,GAAiC,CAACA,MAAD,CAA5C;;AACA,WAAK,IAAIrM,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGuM,EAAE,CAACrM,MAAvB,EAA+BF,CAAC,EAAhC,EAAoC;AACnC,YAAI,KAAKwF,kBAAL,CAAwBlB,QAAxB,CAAiCiI,EAAE,CAACvM,CAAD,CAAnC,CAAJ,EAA6C;AAC5CsM,eAAK;AACL;AACD;AACD;;AACD,WAAOA,KAAK,GAAG,CAAf;AACA,GAXM;AAaP;;;;;AAGQpS,mCAAR,UAAiB4R,IAAjB,EAA+B3N,IAA/B,EAA6C7D,EAA7C,EAAsD;AACrD4R,WAAO,CAACC,GAAR,CAAYL,IAAI,GAAG,IAAP,GAAc3N,IAAd,GAAqB,IAArB,GAA4B,OAA5B,GAAsC,IAAtC,GAA6C7D,EAAE,CAAC4N,UAA5D;AACA,GAFO;;AAYRsE,wBAAWtS,WAAX,EAAW,kBAAX,EAA2B;AAH3B;;;SAGA;AAAA;;AAEC,UAAI,KAAKD,iBAAL,IAA0B,IAA9B,EAAoC;AAEnC;AACA,YAAI;AACH,cAAIwS,SAAO,GAAGD,MAAM,CAACE,cAAP,CAAsB,EAAtB,EAA0B,SAA1B,EAAqC;AAClDC,eAAG,EAAE;AACJ3U,mBAAI,CAACiC,iBAAL,GAAyB,IAAzB;AACA;AAHiD,WAArC,CAAd;AAKAzB,gBAAM,CAACrB,gBAAP,CAAwB,MAAxB,EAAgCsV,SAAhC,EAAyCA,SAAzC;AACAjU,gBAAM,CAAC4Q,mBAAP,CAA2B,MAA3B,EAAmCqD,SAAnC,EAA4CA,SAA5C;AACA,SARD,CAQE,OAAOG,GAAP,EAAY;AACb,eAAK3S,iBAAL,GAAyB,KAAzB;AACA;AACD;;AAED,aAAO,KAAKA,iBAAZ;AACA,KAnB0B;oBAAA;;AAAA,GAA3B;AAqBD;AAltGA,EAAiCtD,gBAAjC;;;AAqtGA,IAAIqP,WAAW,GAAuB,IAAtC;AAEA;;;;;;;AAMA,OAAM,SAAU5N,cAAV,GAAwB;AAC7B,MAAI4N,WAAW,IAAI,IAAnB,EAAyB;AACxBA,eAAW,GAAG,IAAI9L,WAAJ,EAAd;AACA;;AAED,SAAO8L,WAAP;AACA","names":["BaseObjectEvents","List","Animation","MultiDisposer","InteractionObject","InteractionKeyboardObject","Dictionary","Inertia","addEventListener","keyboard","system","options","$ease","$math","$array","$dom","$iter","$type","$time","__extends","_super","_this","out","className","body","getInteraction","document","_disposers","push","window","hasOwnProperty","_pointerEvents","pointerdown","pointerup","pointermove","pointercancel","pointerover","pointerout","matchMedia","matches","_addHoverEvents","_useTouchEventsOnly","navigator","userAgent","match","_usePointerEventsOnly","fullFF","createElement","wheel","hasValue","onmousewheel","inertiaOptions","setKey","polyOut3","_passiveSupported","Interaction","passiveSupported","applyTheme","_globalEventsAdded","ev","handleGlobalPointerDown","handleGlobalPointerMove","handleGlobalPointerUp","relatedTarget","buttons","which","handleDocumentLeave","handleGlobalTouchStart","handleGlobalTouchMove","handleGlobalTouchEnd","handleGlobalKeyDown","handleGlobalKeyUp","io","processTouchable","contextMenuDisabled","eventDisposers","hasKey","element","e","preventDefault","getKey","dispose","hoverable","trackable","addGlobalEvents","applyCursorOverStyle","handlePointerOut","handlePointerOver","disposer","removeKey","draggable","swipeable","resizable","isGlobalElement","isTouchProtected","prepElement","processHoverable","processMovable","trackedObjects","moveValue","removeValue","wheelable","handleMouseWheel","passive","events","on","unlockWheel","lockWheel","focusable","tabindex","handleFocus","handleBlur","handleFocusBlur","clickable","handlePointerDown","handleTouchDown","isFocused","isEnabled","isPaused","imev","type","target","event","dispatchImmediately","getHitOption","once","disableType","blur","sprite","enableType","focusedObject","isKey","disposerKey","ko","getEventKey","directionY","directionX","showTooltipOn","pointer","getPointer","point","getPointerPoint","touch","addBreadCrumb","handleGlobalMove","processDelayed","defaultPrevented","cancelled","handleGlobalUp","i","changedTouches","length","button","resetPointer","handleDown","handleOver","handleOut","deltaX","deltaY","mod","deltaMode","getMouseOption","WheelEvent","Math","round","wheelDeltaX","wheelDeltaY","Error","handleWheel","maybePreventDefault","now","getTime","lastHit","undefined","lastHitPointer","soft","hoversPaused","shouldCancelHovers","areTransformed","moved","cancelAllHovers","overPointers","isRealHover","isHover","overObjects","handleTrack","force","hasDelayedOut","old","behavior","getHoverOption","_delayedEvents","keepUntil","timeout","setTimeout","isDisposed","clear","delayedEvent","pop","inert","stopInertia","downPointers","applyCursorDownStyle","isDown","downObjects","processDragStart","processResizeStart","sorted","values","slice","sort","x","y","pos","compareDocumentPosition","Node","DOCUMENT_POSITION_CONTAINED_BY","DOCUMENT_POSITION_CONTAINS","each","contains","handleUp","backwards","iterator","restoreCursorDownStyle","swiped","handleSwipe","handleHit","handleInertia","processDragStop","processResizeStop","cancelable","getIndex","disableHoverOnTransform","target_1","eventTarget","lastEvent","reset","transformedObjects","swiping","handleTransform","skipCheck","startPoint","shift","handleMoveInertia","handleResizeInertia","interaction","inertia","ref","getTrailPoint","getInertiaOption","lastUpEvent","factor","animationOptions","animation","start","done","inertias","pointer1","point1","startPoint1","pointer2","point2","startPoint2","originalPosition","singlePoint","nextPointer","pointer1Moved","dragStartEvents","handleTransformMove","pointer2Moved","handleTransformResize","ctrlKey","pointerMoved","scale","getScale","dragTarget","getDragPointer","lastDownEvent","id","identifier","pointerId","replace","clientX","clientY","getPointerId","pointers","isPointerTouch","lastPointer","Touch","PointerEvent","pointerType","MouseEvent","startTime","track","swipeCanceled","restoreAllStyles","wheelLockEvent","removeEventListener","svg","cached","getCache","doc","getRoot","elementFromPoint","local","setCache","el","props","style","setTemporaryStyle","restoreStyle","option","res","hitOptions","hoverOptions","swipeOptions","keyboardOptions","mouseOptions","abs","getSwipeOption","cursorOptions","overStyle","setStyle","property","value","downStyle","styles","isArray","tolerance","minTime","getShift","timestamp","list","exists","item","replacedStyles","a","key","call","text","show","logTouch","TouchEvent","console","log","uid","except","count","ex","Object","options_1","defineProperty","get","err"],"sourceRoot":"","sources":["../../../../../src/.internal/core/interaction/Interaction.ts"],"sourcesContent":["/**\r\n * Interaction manages all aspects of user interaction - mouse move,\r\n * click, hover, drag events, touch gestures.\r\n *\r\n * [[InteractionObject]] elements that want to use certain events, must attach event\r\n * listeners to Interaction instance.\r\n *\r\n * Interaction itself will not modify [[InteractionObject]] elements, it will be up to\r\n * those elements to handle interaction information received via event triggers.\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { BaseObjectEvents, IBaseObjectEvents } from \"../Base\";\r\nimport { List } from \"../utils/List\";\r\nimport { AMEvent } from \"../utils/EventDispatcher\";\r\nimport { Animation } from \"../utils/Animation\";\r\nimport { IInertiaOptions, ISwipeOptions, IHitOptions, IHoverOptions, IKeyboardOptions, IMouseOptions } from \"./InteractionOptions\";\r\nimport { MultiDisposer, IDisposer } from \"../utils/Disposer\";\r\nimport { InteractionObject, IInteractionObjectEvents } from \"./InteractionObject\";\r\nimport { InteractionKeyboardObject } from \"./InteractionKeyboardObject\";\r\nimport { Dictionary } from \"../utils/Dictionary\";\r\nimport { Inertia, InertiaTypes } from \"./Inertia\";\r\nimport { IPointer, IBreadcrumb } from \"./Pointer\";\r\nimport { addEventListener } from \"../utils/DOM\";\r\nimport { IPoint } from \"../defs/IPoint\";\r\nimport { IStyleProperty } from \"../defs/IStyleProperty\";\r\nimport { keyboard } from \"../utils/Keyboard\";\r\nimport { system } from \"./../System\";\r\nimport { options } from \"./../Options\";\r\nimport * as $ease from \"../utils/Ease\";\r\nimport * as $math from \"../utils/Math\";\r\nimport * as $array from \"../utils/Array\";\r\nimport * as $dom from \"../utils/DOM\";\r\nimport * as $iter from \"../utils/Iterator\";\r\nimport * as $type from \"../utils/Type\";\r\nimport * as $time from \"../utils/Time\";\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * REQUISITES\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Represents an Event object that comes from [[Interaction]]\r\n */\r\nexport interface IInteractionEvents extends IBaseObjectEvents {\r\n\r\n\ttrack: {\r\n\t\tpointer: IPointer;\r\n\t\ttouch: boolean;\r\n\t\tevent: MouseEvent | TouchEvent;\r\n\t};\r\n\r\n\tdown: {\r\n\t\tpointer: IPointer;\r\n\t\ttouch: boolean;\r\n\t\tevent: MouseEvent | TouchEvent;\r\n\t};\r\n\r\n\tup: {\r\n\t\tpointer: IPointer;\r\n\t\ttouch: boolean;\r\n\t\tevent: MouseEvent | TouchEvent;\r\n\t};\r\n\r\n\tfocus: {\r\n\t\tevent: FocusEvent;\r\n\t}\r\n}\r\n\r\n/**\r\n * Interface representing a delayed event\r\n *\r\n * @ignore Exclude from docs\r\n */\r\nexport interface IDelayedEvent {\r\n\ttype: keyof IInteractionObjectEvents;\r\n\tio: InteractionObject;\r\n\tpointer: IPointer;\r\n\tevent: MouseEvent | TouchEvent;\r\n\tkeepUntil?: number;\r\n\ttimeout?: IDisposer;\r\n}\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n\r\n/**\r\n* Interaction manages all aspects of user interaction - mouse move,\r\n* click, hover, drag events, touch gestures.\r\n*\r\n* [[InteractionObject]] elements that want to use certain events, must attach event\r\n* listeners to Interaction instance.\r\n*\r\n* Interaction itself will not modify [[InteractionObject]] elements, it will be up to\r\n* those elements to handle interaction information received via event triggers.\r\n*\r\n* @see {@link IInteractionEvents} for a list of available events\r\n*/\r\nexport class Interaction extends BaseObjectEvents {\r\n\r\n\t/**\r\n\t * Defines available events.\r\n\t *\r\n\t * @deprecated Use inetraction.body.events instead\r\n\t */\r\n\tpublic _events!: IInteractionEvents;\r\n\r\n\t/**\r\n\t * A reference to an [[Interaction]] object for document's body.\r\n\t *\r\n\t * Users can use it to add global, non-chart related events, that will be\r\n\t * applicable to the whole document.\r\n\t */\r\n\tpublic body: InteractionObject;\r\n\r\n\t/**\r\n\t * An indicator of global events were already initialized.\r\n\t */\r\n\tprotected _globalEventsAdded: boolean = false;\r\n\r\n\t/**\r\n\t * Holds which mouse event listeners to use.\r\n\t */\r\n\tprotected _pointerEvents = {\r\n\t\t\"pointerdown\": \"mousedown\",\r\n\t\t\"pointerup\": \"mouseup\",\r\n\t\t\"pointermove\": \"mousemove\",\r\n\t\t\"pointercancel\": \"mouseup\",\r\n\t\t\"pointerover\": \"mouseover\",\r\n\t\t\"pointerout\": \"mouseout\",\r\n\t\t\"wheel\": \"wheel\"\r\n\t};\r\n\r\n\t/**\r\n\t * Indicates if Interaction should use only \"pointer\" type events, like\r\n\t * \"pointermove\", available in all modern browsers, ignoring \"legacy\"\r\n\t * events, like \"touchmove\".\r\n\t */\r\n\tprotected _usePointerEventsOnly: boolean = false;\r\n\r\n\t/**\r\n\t * Use only touch events (for touch only devices such as tablets and phones)\r\n\t */\r\n\tprotected _useTouchEventsOnly: boolean = false;\r\n\r\n\t/**\r\n\t * Add special hover events. Normally, touch device tap will also simulate\r\n\t * hover event. On some devices (ahem iOS) we want to prevent that so that\r\n\t * over/out events are not duplicated.\r\n\t */\r\n\tprotected _addHoverEvents: boolean = true;\r\n\r\n\t/**\r\n\t * Indicates if passive mode options is supported by this browser.\r\n\t */\r\n\tprotected _passiveSupported: boolean = false;\r\n\r\n\t/**\r\n\t * Holds list of delayed events\r\n\t */\r\n\tprotected _delayedEvents: { out: IDelayedEvent[] } = { out: [] };\r\n\r\n\t/**\r\n\t * List of objects that current have a pointer hovered over them.\r\n\t */\r\n\tpublic overObjects: List<InteractionObject> = new List<InteractionObject>();\r\n\r\n\t/**\r\n\t * List of objects that currently has a pressed pointer.\r\n\t */\r\n\tpublic downObjects: List<InteractionObject> = new List<InteractionObject>();\r\n\r\n\t/**\r\n\t * List of objects that need mouse position to be reported to them.\r\n\t */\r\n\tpublic trackedObjects: List<InteractionObject> = new List<InteractionObject>();\r\n\r\n\t/**\r\n\t * List of objects that are currently being dragged.\r\n\t */\r\n\tpublic transformedObjects: List<InteractionObject> = new List<InteractionObject>();\r\n\r\n\t/**\r\n\t * An object that currently has focus. Usually set automatically via\r\n\t * [[InteractionObject]] `isFocus` method.\r\n\t */\r\n\tpublic focusedObject: $type.Optional<InteractionObject>;\r\n\r\n\t/**\r\n\t * Holds all known pointers.\r\n\t */\r\n\tpublic pointers = new Dictionary<string, IPointer>();\r\n\r\n\t/**\r\n\t * Last pointer that generate some kind of action.\r\n\t *\r\n\t * @since 4.9.5\r\n\t * @ignore\r\n\t */\r\n\tpublic lastPointer: $type.Optional<IPointer>;\r\n\r\n\t/**\r\n\t * Inertia options that need to be applied to after element drag, if it's\r\n\t * `inert = true`.\r\n\t *\r\n\t * This is just a default, which can and probably will be overridden by\r\n\t * actual elements.\r\n\t */\r\n\tpublic inertiaOptions = new Dictionary<InertiaTypes, IInertiaOptions>();\r\n\r\n\t/**\r\n\t * Default options for click events. These can be overridden in\r\n\t * [[InteractionObject]].\r\n\t */\r\n\tpublic hitOptions: IHitOptions = {\r\n\t\t\"doubleHitTime\": 300,\r\n\t\t//\"delayFirstHit\": false,\r\n\t\t\"hitTolerance\": 10,\r\n\t\t\"noFocus\": true\r\n\t};\r\n\r\n\t/**\r\n\t * Default options for hover events. These can be overridden in\r\n\t * [[InteractionObject]].\r\n\t */\r\n\tpublic hoverOptions: IHoverOptions = {\r\n\t\t\"touchOutBehavior\": \"leave\",\r\n\t\t\"touchOutDelay\": 1000\r\n\t};\r\n\r\n\t/**\r\n\t * Default options for detecting a swipe gesture. These can be overridden in\r\n\t * [[InteractionObject]].\r\n\t */\r\n\tpublic swipeOptions: ISwipeOptions = {\r\n\t\t\"time\": 500,\r\n\t\t\"verticalThreshold\": 75,\r\n\t\t\"horizontalThreshold\": 30\r\n\t};\r\n\r\n\t/**\r\n\t * Default options for keyboard operations. These can be overridden in\r\n\t * [[InteractionObject]].\r\n\t */\r\n\tpublic keyboardOptions: IKeyboardOptions = {\r\n\t\t\"speed\": 0.1,\r\n\t\t\"accelleration\": 1.2,\r\n\t\t\"accellerationDelay\": 2000\r\n\t};\r\n\r\n\t/**\r\n\t * Default options for keyboard operations. These can be overridden in\r\n\t * [[InteractionObject]].\r\n\t *\r\n\t * @since 4.5.14\r\n\t */\r\n\tpublic mouseOptions: IMouseOptions = {\r\n\t\t\"sensitivity\": 1\r\n\t};\r\n\r\n\r\n\t/**\r\n\t * Constructor. Sets up universal document-wide move events to handle stuff\r\n\t * outside particular chart container.\r\n\t */\r\n\tconstructor() {\r\n\r\n\t\t// Call super\r\n\t\tsuper();\r\n\r\n\t\t// Set class name\r\n\t\tthis.className = \"Interaction\";\r\n\r\n\t\t// Create InteractionObject for <body>\r\n\t\tthis.body = this.getInteraction(document.body);\r\n\r\n\t\tthis._disposers.push(this.body);\r\n\r\n\t\t// Detect browser capabilities and determine what event listeners to use\r\n\t\tif (window.hasOwnProperty(\"PointerEvent\")) {\r\n\t\t\t// IE10+/Edge without touch controls enabled\r\n\t\t\tthis._pointerEvents.pointerdown = \"pointerdown\";\r\n\t\t\tthis._pointerEvents.pointerup = \"pointerup\";\r\n\t\t\tthis._pointerEvents.pointermove = \"pointermove\";\r\n\t\t\tthis._pointerEvents.pointercancel = \"pointercancel\";\r\n\t\t\tthis._pointerEvents.pointerover = \"pointerover\";\r\n\t\t\tthis._pointerEvents.pointerout = \"pointerout\";\r\n\t\t\t//this._usePointerEventsOnly = true;\r\n\t\t} else if (window.hasOwnProperty(\"MSPointerEvent\")) {\r\n\t\t\t// IE9\r\n\t\t\tthis._pointerEvents.pointerdown = \"MSPointerDown\";\r\n\t\t\tthis._pointerEvents.pointerup = \"MSPointerUp\";\r\n\t\t\tthis._pointerEvents.pointermove = \"MSPointerMove\";\r\n\t\t\tthis._pointerEvents.pointercancel = \"MSPointerUp\";\r\n\t\t\tthis._pointerEvents.pointerover = \"MSPointerOver\";\r\n\t\t\tthis._pointerEvents.pointerout = \"MSPointerOut\";\r\n\t\t\t//this._usePointerEventsOnly = true;\r\n\t\t}\r\n\t\telse if ((typeof matchMedia !== \"undefined\") && matchMedia('(pointer:fine)').matches) {\r\n\t\t\t// This is only for Safari as it does not support PointerEvent\r\n\t\t\t// Do nothing and let it use regular `mouse*` events\r\n\t\t\t// Hi Apple ;)\r\n\r\n\t\t\t// Additionally disable hover events for iOS devices\r\n\t\t\tif ('ontouchstart' in window) {\r\n\t\t\t\tthis._addHoverEvents = false;\r\n\t\t\t\tthis._useTouchEventsOnly = true;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if (window.navigator.userAgent.match(/MSIE /)) {\r\n\t\t\t// Oh looky, an MSIE that does not support PointerEvent. Hi granpa IE9!\r\n\t\t\tthis._usePointerEventsOnly = true;\r\n\t\t}\r\n\t\telse if (this.fullFF()) {\r\n\t\t\t// Old FF, let's use regular events.\r\n\t\t\t// (Newer FFs would be detected by the PointerEvent availability check)\r\n\t\t\tthis._usePointerEventsOnly = true;\r\n\t\t}\r\n\t\telse {\r\n\t\t\t// Uses defaults for normal browsers\r\n\t\t\t// We also assume that this must be a touch device that does not have\r\n\t\t\t// any pointer events\r\n\t\t\tthis._useTouchEventsOnly = true;\r\n\t\t}\r\n\r\n\t\t// Detect if device has a mouse\r\n\t\t// This is turning out to be not reliable\r\n\t\t// @todo remove\r\n\t\t/*if (!window.navigator.msPointerEnabled && (typeof matchMedia !== \"undefined\") && !matchMedia('(pointer:fine)').matches && !this.fullFF()) {\r\n\t\t\tthis._useTouchEventsOnly = true;\r\n\t\t}*/\r\n\r\n\t\t// Detect proper mouse wheel events\r\n\t\tif (\"onwheel\" in document.createElement(\"div\")) {\r\n\t\t\t// Modern browsers\r\n\t\t\tthis._pointerEvents.wheel = \"wheel\";\r\n\t\t}\r\n\t\telse if ($type.hasValue((<any>document).onmousewheel)) {\r\n\t\t\t// Webkit and IE support at least \"mousewheel\"\r\n\t\t\tthis._pointerEvents.wheel = \"mousewheel\";\r\n\t\t}\r\n\r\n\t\t// Set up default inertia options\r\n\t\tthis.inertiaOptions.setKey(\"move\", {\r\n\t\t\t\"time\": 100,\r\n\t\t\t\"duration\": 500,\r\n\t\t\t\"factor\": 1,\r\n\t\t\t\"easing\": $ease.polyOut3\r\n\t\t});\r\n\t\tthis.inertiaOptions.setKey(\"resize\", {\r\n\t\t\t\"time\": 100,\r\n\t\t\t\"duration\": 500,\r\n\t\t\t\"factor\": 1,\r\n\t\t\t\"easing\": $ease.polyOut3\r\n\t\t});\r\n\r\n\t\t// Set the passive mode support\r\n\t\tthis._passiveSupported = Interaction.passiveSupported;\r\n\r\n\t\t// Apply theme\r\n\t\tthis.applyTheme();\r\n\t}\r\n\r\n\t/**\r\n\t * This is a nasty detection for Firefox. The reason why we have is that\r\n\t * Firefox ESR version does not support matchMedia correctly.\r\n\t *\r\n\t * On iOS, Firefox uses different userAgent, so we don't have to detect iOS.\r\n\t *\r\n\t * @return Full Firefox?\r\n\t */\r\n\tprotected fullFF(): boolean {\r\n\t\treturn (window.navigator.userAgent.match(/Firefox/)) && !(window.navigator.userAgent.match(/Android/));\r\n\t}\r\n\r\n\tprotected debug(): void { }\r\n\r\n\r\n\t/**\r\n\t * ==========================================================================\r\n\t * Processing\r\n\t * ==========================================================================\r\n\t * @hidden\r\n\t */\r\n\r\n\t/**\r\n\t * Sets up global events.\r\n\t *\r\n\t * We need this so that we can track drag movement beyond chart's container.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic addGlobalEvents(): void {\r\n\t\tif (!this._globalEventsAdded) {\r\n\r\n\t\t\tif (!this._useTouchEventsOnly) {\r\n\t\t\t\tthis._disposers.push(addEventListener<MouseEvent | PointerEvent>(\r\n\t\t\t\t\tdocument,\r\n\t\t\t\t\tthis._pointerEvents.pointerdown,\r\n\t\t\t\t\t(ev: MouseEvent) => { this.handleGlobalPointerDown(ev) }\r\n\t\t\t\t));\r\n\r\n\t\t\t\tthis._disposers.push(addEventListener<MouseEvent | PointerEvent>(\r\n\t\t\t\t\tdocument,\r\n\t\t\t\t\tthis._pointerEvents.pointermove,\r\n\t\t\t\t\t(ev: MouseEvent) => { this.handleGlobalPointerMove(ev) }\r\n\t\t\t\t));\r\n\r\n\t\t\t\tthis._disposers.push(addEventListener<MouseEvent | PointerEvent>(\r\n\t\t\t\t\tdocument,\r\n\t\t\t\t\tthis._pointerEvents.pointerup,\r\n\t\t\t\t\t(ev: MouseEvent) => { this.handleGlobalPointerUp(ev) }\r\n\t\t\t\t));\r\n\r\n\t\t\t\tthis._disposers.push(addEventListener<MouseEvent | PointerEvent>(\r\n\t\t\t\t\tdocument,\r\n\t\t\t\t\tthis._pointerEvents.pointercancel,\r\n\t\t\t\t\t(ev: MouseEvent) => { this.handleGlobalPointerUp(ev, true) }\r\n\t\t\t\t));\r\n\r\n\t\t\t\tthis._disposers.push(addEventListener<MouseEvent | PointerEvent>(\r\n\t\t\t\t\tdocument,\r\n\t\t\t\t\t\"mouseenter\",\r\n\t\t\t\t\t(ev: MouseEvent) => {\r\n\t\t\t\t\t\tif (!$type.hasValue(ev.relatedTarget) && (ev.buttons == 0 || ev.which == 0)) {\r\n\t\t\t\t\t\t\tthis.handleDocumentLeave(ev);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t));\r\n\t\t\t}\r\n\r\n\t\t\t// No need to duplicate events for hubrid systems that support both\r\n\t\t\t// pointer events and touch events. Touch events are need only for\r\n\t\t\t// some touch-only systems, like Mobile Safari.\r\n\t\t\tif (!this._usePointerEventsOnly) {\r\n\t\t\t\tthis._disposers.push(addEventListener(\r\n\t\t\t\t\tdocument,\r\n\t\t\t\t\t\"touchstart\",\r\n\t\t\t\t\t(ev: TouchEvent) => { this.handleGlobalTouchStart(ev) }\r\n\t\t\t\t));\r\n\r\n\t\t\t\tthis._disposers.push(addEventListener(\r\n\t\t\t\t\tdocument,\r\n\t\t\t\t\t\"touchmove\",\r\n\t\t\t\t\t(ev: TouchEvent) => { this.handleGlobalTouchMove(ev) }\r\n\t\t\t\t));\r\n\r\n\t\t\t\tthis._disposers.push(addEventListener(\r\n\t\t\t\t\tdocument,\r\n\t\t\t\t\t\"touchend\",\r\n\t\t\t\t\t(ev: TouchEvent) => { this.handleGlobalTouchEnd(ev) }\r\n\t\t\t\t));\r\n\t\t\t}\r\n\r\n\t\t\tthis._disposers.push(addEventListener(\r\n\t\t\t\tdocument,\r\n\t\t\t\t\"keydown\",\r\n\t\t\t\t(ev: KeyboardEvent) => { this.handleGlobalKeyDown(ev) }\r\n\t\t\t));\r\n\r\n\t\t\tthis._disposers.push(addEventListener(\r\n\t\t\t\tdocument,\r\n\t\t\t\t\"keyup\",\r\n\t\t\t\t(ev: KeyboardEvent) => { this.handleGlobalKeyUp(ev) }\r\n\t\t\t));\r\n\r\n\t\t\tthis._globalEventsAdded = true;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Sets if [[InteractionObject]] is clickable.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param io [[InteractionObject]] instance\r\n\t */\r\n\tpublic processClickable(io: InteractionObject): void {\r\n\t\t// Add or remove touch events\r\n\t\tthis.processTouchable(io);\r\n\t}\r\n\r\n\t/**\r\n\t * Sets if [[InteractionObject]] will display context menu when right-clicked.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param io [[InteractionObject]] instance\r\n\t */\r\n\tpublic processContextMenu(io: InteractionObject): void {\r\n\t\tif (io.contextMenuDisabled) {\r\n\t\t\tif (!io.eventDisposers.hasKey(\"contextMenuDisabled\")) {\r\n\t\t\t\tio.eventDisposers.setKey(\"contextMenuDisabled\",\r\n\t\t\t\t\taddEventListener<MouseEvent | PointerEvent>(io.element, \"contextmenu\", (e) => {\r\n\t\t\t\t\t\te.preventDefault();\r\n\t\t\t\t\t})\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\tif (io.eventDisposers.hasKey(\"contextMenuDisabled\")) {\r\n\t\t\t\tio.eventDisposers.getKey(\"contextMenuDisabled\").dispose();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Sets if [[InteractionObject]] is hoverable.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param io [[InteractionObject]] instance\r\n\t */\r\n\tpublic processHoverable(io: InteractionObject): void {\r\n\t\tif (io.hoverable || io.trackable) {\r\n\r\n\t\t\t// Add global events\r\n\t\t\tthis.addGlobalEvents();\r\n\r\n\t\t\t// Add hover styles\r\n\t\t\tthis.applyCursorOverStyle(io);\r\n\r\n\t\t\t// Add local events\r\n\t\t\tif (!io.eventDisposers.hasKey(\"hoverable\") && this._addHoverEvents) {\r\n\t\t\t\tio.eventDisposers.setKey(\"hoverable\", new MultiDisposer([\r\n\t\t\t\t\taddEventListener<MouseEvent | PointerEvent>(io.element, this._pointerEvents.pointerout, (e) => this.handlePointerOut(io, e)),\r\n\t\t\t\t\taddEventListener<MouseEvent | PointerEvent>(io.element, this._pointerEvents.pointerover, (e) => this.handlePointerOver(io, e))\r\n\t\t\t\t]));\r\n\t\t\t}\r\n\r\n\t\t\tif (io.trackable) {\r\n\t\t\t\t//sprite.addEventListener(\"touchmove\", this.handleTouchMove, false, this);\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\t\t\tconst disposer = io.eventDisposers.getKey(\"hoverable\");\r\n\r\n\t\t\tif (disposer != null) {\r\n\t\t\t\tdisposer.dispose();\r\n\t\t\t\tio.eventDisposers.removeKey(\"hoverable\");\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Add or remove touch events\r\n\t\tthis.processTouchable(io);\r\n\t}\r\n\r\n\t/**\r\n\t * Sets up [[InteractionObject]] as movable. Movable can be any\r\n\t * transformation, e.g. drag, swipe, resize, track.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param io  Element\r\n\t */\r\n\tpublic processMovable(io: InteractionObject) {\r\n\r\n\t\t// Add unified events\r\n\t\tif (io.draggable || io.swipeable || io.trackable || io.resizable) {\r\n\r\n\t\t\t// Prep the element\r\n\t\t\tif (!this.isGlobalElement(io) && !io.isTouchProtected) {\r\n\t\t\t\tthis.prepElement(io);\r\n\t\t\t}\r\n\r\n\t\t\t// Add hover styles\r\n\t\t\tthis.applyCursorOverStyle(io);\r\n\r\n\t\t}\r\n\r\n\t\t// Add or remove touch events\r\n\t\tthis.processTouchable(io);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if [[InteractionObject]] is trackable and sets relative events.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param io  Element\r\n\t */\r\n\tpublic processTrackable(io: InteractionObject): void {\r\n\t\tthis.processHoverable(io);\r\n\t\tthis.processMovable(io);\r\n\t\tif (io.trackable) {\r\n\t\t\tthis.trackedObjects.moveValue(io);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tthis.trackedObjects.removeValue(io);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if [[InteractionObject]] is draggable.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param io  Element\r\n\t */\r\n\tpublic processDraggable(io: InteractionObject): void {\r\n\t\tthis.processMovable(io);\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if [[InteractionObject]] is swipeable and sets relative events.\r\n\t *\r\n\t * A swipe event is triggered when a horizontal drag of 75px or more (and\r\n\t * less than 30px vertically) occurs within 700 milliseconds. This can be\r\n\t * overridden in sprites [[swipeOptions]].\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param io  Element\r\n\t */\r\n\tpublic processSwipeable(io: InteractionObject): void {\r\n\t\tthis.processMovable(io);\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if [[InteractionObject]] is resizable and attaches required events\r\n\t * to it.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param io  Element\r\n\t */\r\n\tpublic processResizable(io: InteractionObject): void {\r\n\t\tthis.processMovable(io);\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if [[InteractionObject]] is supposed to capture mouse wheel events\r\n\t * and prepares it to catch those events.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param io  Element\r\n\t */\r\n\tpublic processWheelable(io: InteractionObject): void {\r\n\t\tif (io.wheelable) {\r\n\t\t\t//io.hoverable = true;\r\n\t\t\tif (!io.eventDisposers.hasKey(\"wheelable\")) {\r\n\t\t\t\tio.eventDisposers.setKey(\"wheelable\", new MultiDisposer([\r\n\t\t\t\t\taddEventListener<WheelEvent>(\r\n\t\t\t\t\t\tio.element,\r\n\t\t\t\t\t\tthis._pointerEvents.wheel,\r\n\t\t\t\t\t\t(e) => this.handleMouseWheel(io, e),\r\n\t\t\t\t\t\tthis._passiveSupported ? { passive: false } : false\r\n\t\t\t\t\t),\r\n\t\t\t\t\tio.events.on(\"out\", (e) => {\r\n\t\t\t\t\t\tif (io.wheelable) {\r\n\t\t\t\t\t\t\tthis.unlockWheel();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}),\r\n\t\t\t\t\tio.events.on(\"over\", (e) => {\r\n\t\t\t\t//console.log(\"whelab over\")\r\n\t\t\t\t\t\tif (io.wheelable) {\r\n\t\t\t\t\t\t\tthis.lockWheel();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t})\r\n\t\t\t\t]));\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\t\t\tconst disposer = io.eventDisposers.getKey(\"wheelable\");\r\n\r\n\t\t\tif (disposer != null) {\r\n\t\t\t\tdisposer.dispose();\r\n\t\t\t\tio.eventDisposers.removeKey(\"wheelable\");\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if [[InteractionObject]] is focusable. A focusable element is an\r\n\t * element that will be highlighted when users presses TAB key. If the\r\n\t * element is focusable, this function will attach relative focus/blur\r\n\t * events to it.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param io  Element\r\n\t */\r\n\tpublic processFocusable(io: InteractionObject): void {\r\n\t\tif (io.focusable === true && (io.tabindex > -1) && !this._useTouchEventsOnly) {\r\n\t\t\tif (!io.eventDisposers.hasKey(\"focusable\")) {\r\n\t\t\t\tio.eventDisposers.setKey(\"focusable\", new MultiDisposer([\r\n\t\t\t\t\taddEventListener<FocusEvent>(io.element, \"focus\", (e) => this.handleFocus(io, e)),\r\n\t\t\t\t\taddEventListener<FocusEvent>(io.element, \"blur\", (e) => this.handleBlur(io, e)),\r\n\t\t\t\t\taddEventListener<MouseEvent>(\r\n\t\t\t\t\t\tio.element,\r\n\t\t\t\t\t\tthis._pointerEvents.pointerdown,\r\n\t\t\t\t\t\t(e) => this.handleFocusBlur(io, e)\r\n\t\t\t\t\t),\r\n\r\n\t\t\t\t\taddEventListener<TouchEvent>(\r\n\t\t\t\t\t\tio.element,\r\n\t\t\t\t\t\t\"touchstart\",\r\n\t\t\t\t\t\t(e) => this.handleFocusBlur(io, e),\r\n\t\t\t\t\t\tthis._passiveSupported ? { passive: false } : false\r\n\t\t\t\t\t)\r\n\t\t\t\t]));\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\tconst disposer = io.eventDisposers.getKey(\"focusable\");\r\n\r\n\t\t\tif (disposer != null) {\r\n\t\t\t\tdisposer.dispose();\r\n\t\t\t\tio.eventDisposers.removeKey(\"focusable\");\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if [[InteractionObject]] is \"touchable\". It means any interaction\r\n\t * whatsoever: mouse click, touch screen tap, swipe, drag, resize, etc.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param io  Element\r\n\t */\r\n\tpublic processTouchable(io: InteractionObject): void {\r\n\r\n\t\t// Add unified events\r\n\t\tif (io.clickable || io.hoverable || io.trackable || io.draggable || io.swipeable || io.resizable) {\r\n\r\n\t\t\t// Add global events\r\n\t\t\tthis.addGlobalEvents();\r\n\r\n\t\t\t// Add local events\r\n\t\t\tif (!io.eventDisposers.hasKey(\"touchable\")) {\r\n\t\t\t\tif (!this._useTouchEventsOnly && !this._usePointerEventsOnly) {\r\n\t\t\t\t\tio.eventDisposers.setKey(\"touchable\", new MultiDisposer([\r\n\r\n\t\t\t\t\t\taddEventListener<MouseEvent>(\r\n\t\t\t\t\t\t\tio.element,\r\n\t\t\t\t\t\t\tthis._pointerEvents.pointerdown,\r\n\t\t\t\t\t\t\t(e) => this.handlePointerDown(io, e)\r\n\t\t\t\t\t\t),\r\n\r\n\t\t\t\t\t\taddEventListener<TouchEvent>(\r\n\t\t\t\t\t\t\tio.element,\r\n\t\t\t\t\t\t\t\"touchstart\",\r\n\t\t\t\t\t\t\t(e) => this.handleTouchDown(io, e),\r\n\t\t\t\t\t\t\tthis._passiveSupported ? { passive: false } : false\r\n\t\t\t\t\t\t)\r\n\r\n\t\t\t\t\t]));\r\n\t\t\t\t}\r\n\t\t\t\telse if (!this._useTouchEventsOnly) {\r\n\t\t\t\t\tio.eventDisposers.setKey(\"touchable\",\r\n\t\t\t\t\t\taddEventListener<MouseEvent>(\r\n\t\t\t\t\t\t\tio.element,\r\n\t\t\t\t\t\t\tthis._pointerEvents.pointerdown,\r\n\t\t\t\t\t\t\t(e) => this.handlePointerDown(io, e)\r\n\t\t\t\t\t\t)\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\t\t\t\telse if (!this._usePointerEventsOnly) {\r\n\t\t\t\t\tio.eventDisposers.setKey(\"touchable\",\r\n\t\t\t\t\t\taddEventListener<TouchEvent>(\r\n\t\t\t\t\t\t\tio.element,\r\n\t\t\t\t\t\t\t\"touchstart\",\r\n\t\t\t\t\t\t\t(e) => this.handleTouchDown(io, e),\r\n\t\t\t\t\t\t\tthis._passiveSupported ? { passive: false } : false\r\n\t\t\t\t\t\t)\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\t\t\tconst disposer = io.eventDisposers.getKey(\"touchable\");\r\n\r\n\t\t\tif (disposer != null) {\r\n\t\t\t\tdisposer.dispose();\r\n\t\t\t\tio.eventDisposers.removeKey(\"touchable\");\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * ==========================================================================\r\n\t * Non-pointer events\r\n\t * ==========================================================================\r\n\t * @hidden\r\n\t */\r\n\r\n\t/**\r\n\t * Dispatches \"focus\" event when element gains focus.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param io  Element\r\n\t * @param ev  Original event\r\n\t */\r\n\tpublic handleFocus(io: InteractionObject, ev: FocusEvent): void {\r\n\t\tif (!io.focusable) {\r\n\t\t\tev.preventDefault();\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tio.isFocused = true;\r\n\t\tif (io.events.isEnabled(\"focus\") && !system.isPaused) {\r\n\t\t\tlet imev: AMEvent<InteractionObject, IInteractionObjectEvents>[\"focus\"] = {\r\n\t\t\t\ttype: \"focus\",\r\n\t\t\t\ttarget: io,\r\n\t\t\t\tevent: ev\r\n\t\t\t};\r\n\t\t\tio.events.dispatchImmediately(\"focus\", imev);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Used by regular click events to prevent focus if \"noFocus\" is set.\r\n\t *\r\n\t * This should not be called by \"focus\" handlers.\r\n\t *\r\n\t * @param io  Element\r\n\t * @param ev  Original event\r\n\t */\r\n\tprivate handleFocusBlur(io: InteractionObject, ev: MouseEvent | TouchEvent): void {\r\n\t\tif (io.focusable !== false && this.getHitOption(io, \"noFocus\")) {\r\n\t\t\tio.events.once(\"focus\", () => {\r\n\t\t\t\tio.events.disableType(\"blur\");\r\n\t\t\t\t$dom.blur();\r\n\t\t\t\tif (io.sprite) {\r\n\t\t\t\t\tio.sprite.handleBlur();\r\n\t\t\t\t}\r\n\t\t\t\tio.events.enableType(\"blur\");\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Dispatches \"blur\" event when element loses focus.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param io  Element\r\n\t * @param ev  Original event\r\n\t */\r\n\tpublic handleBlur(io: InteractionObject, ev: FocusEvent): void {\r\n\t\tif (!io.focusable) {\r\n\t\t\tev.preventDefault();\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tio.isFocused = false;\r\n\t\tif (io.events.isEnabled(\"blur\") && !system.isPaused) {\r\n\t\t\tlet imev: AMEvent<InteractionObject, IInteractionObjectEvents>[\"blur\"] = {\r\n\t\t\t\ttype: \"blur\",\r\n\t\t\t\ttarget: io,\r\n\t\t\t\tevent: ev\r\n\t\t\t};\r\n\t\t\tio.events.dispatchImmediately(\"blur\", imev);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * ==========================================================================\r\n\t * Global keyboard-related even handlers\r\n\t * ==========================================================================\r\n\t * @hidden\r\n\t */\r\n\r\n\t/**\r\n\t * Checks if there is an item that has currently focus and that they key is\r\n\t * one of the directional keys. If both of the conditions are true, it\r\n\t * creates an object to simulate movement of dragable element with keyboard.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param ev An original keyboard event\r\n\t */\r\n\tpublic handleGlobalKeyDown(ev: KeyboardEvent): void {\r\n\r\n\t\tif (this.focusedObject) {\r\n\t\t\tif (keyboard.isKey(ev, \"esc\")) {\r\n\t\t\t\t// ESC removes focus\r\n\t\t\t\t$dom.blur();\r\n\t\t\t}\r\n\t\t\telse if (this.focusedObject.draggable && keyboard.isKey(ev, [\"up\", \"down\", \"left\", \"right\"])) {\r\n\r\n\t\t\t\t// Prevent scrolling of the document\r\n\t\t\t\tev.preventDefault();\r\n\r\n\t\t\t\t// Get focused object\r\n\t\t\t\tlet io = this.focusedObject;\r\n\r\n\t\t\t\t// Get particular key\r\n\t\t\t\tlet disposerKey = \"interactionKeyboardObject\";\r\n\r\n\t\t\t\t// If such disposer already exists we know the event is going on so we\r\n\t\t\t\t// just move on\r\n\t\t\t\tif (io.eventDisposers.hasKey(disposerKey)) {\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Create a keyboard mover\r\n\t\t\t\tlet ko = new InteractionKeyboardObject(io, ev);\r\n\t\t\t\tio.eventDisposers.setKey(disposerKey, ko);\r\n\t\t\t\tswitch (keyboard.getEventKey(ev)) {\r\n\t\t\t\t\tcase \"up\":\r\n\t\t\t\t\t\tko.directionY = -1;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase \"down\":\r\n\t\t\t\t\t\tko.directionY = 1;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase \"left\":\r\n\t\t\t\t\t\tko.directionX = -1;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase \"right\":\r\n\t\t\t\t\t\tko.directionX = 1;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Dispatches related events when the keyboard key is realeasd.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param ev An original keyboard event\r\n\t */\r\n\tpublic handleGlobalKeyUp(ev: KeyboardEvent): void {\r\n\t\tlet disposerKey = \"interactionKeyboardObject\";\r\n\t\tif (this.focusedObject) {\r\n\t\t\tconst disposer = this.focusedObject.eventDisposers.getKey(disposerKey);\r\n\r\n\t\t\tif (disposer != null) {\r\n\t\t\t\t// Prevent scrolling of the document\r\n\t\t\t\tev.preventDefault();\r\n\r\n\t\t\t\t// Dispose stuff\r\n\t\t\t\tdisposer.dispose();\r\n\t\t\t\tthis.focusedObject.eventDisposers.removeKey(disposerKey);\r\n\t\t\t}\r\n\r\n\t\t\t// Does focused object have \"hit\" event?\r\n\t\t\tif (keyboard.isKey(ev, \"enter\")\r\n\t\t\t\t&& this.focusedObject.sprite\r\n\t\t\t\t&& !this.focusedObject.sprite.events.isEnabled(\"toggled\")\r\n\t\t\t) {\r\n\t\t\t\tif (this.focusedObject.sprite.events.isEnabled(\"hit\")) {\r\n\t\t\t\t\tthis.focusedObject.dispatchImmediately(\"hit\");\r\n\t\t\t\t}\r\n\t\t\t\telse if (this.focusedObject.sprite.showTooltipOn == \"hit\") {\r\n\t\t\t\t\tthis.focusedObject.dispatchImmediately(\"up\");\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * ==========================================================================\r\n\t * Global pointer-related even handlers\r\n\t * ==========================================================================\r\n\t * @hidden\r\n\t */\r\n\r\n\t/**\r\n\t * Handler for a global \"pointermove\" event.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param ev Event object\r\n\t */\r\n\tpublic handleGlobalPointerMove(ev: MouseEvent): void {\r\n\t\t// Get pointer\r\n\t\tlet pointer: IPointer = this.getPointer(ev);\r\n\r\n\t\t// Update current point position\r\n\t\tpointer.point = this.getPointerPoint(ev);\r\n\r\n\t\t// Prepare and fire global event\r\n\t\tif (this.events.isEnabled(\"track\") && !system.isPaused) {\r\n\t\t\tlet imev: AMEvent<this, IInteractionEvents>[\"track\"] = {\r\n\t\t\t\ttype: \"track\",\r\n\t\t\t\ttarget: this,\r\n\t\t\t\tevent: ev,\r\n\t\t\t\tpointer: pointer,\r\n\t\t\t\ttouch: pointer.touch\r\n\t\t\t};\r\n\t\t\tthis.events.dispatchImmediately(\"track\", imev);\r\n\t\t}\r\n\r\n\t\t// Track\r\n\t\tthis.addBreadCrumb(pointer, pointer.point);\r\n\r\n\t\t// Process further\r\n\t\tthis.handleGlobalMove(pointer, ev);\r\n\t}\r\n\r\n\t/**\r\n\t * Handler for a global \"pointerdown\" event.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param ev Event object\r\n\t */\r\n\tpublic handleGlobalPointerDown(ev: MouseEvent): void {\r\n\r\n\t\t// Remove delayed hovers\r\n\t\tthis.processDelayed();\r\n\r\n\t\t// Get pointer\r\n\t\tlet pointer: IPointer = this.getPointer(ev);\r\n\r\n\t\t// Prepare and fire global event\r\n\t\tif (this.events.isEnabled(\"down\") && !system.isPaused) {\r\n\t\t\tlet imev: AMEvent<this, IInteractionEvents>[\"down\"] = {\r\n\t\t\t\ttype: \"down\",\r\n\t\t\t\ttarget: this,\r\n\t\t\t\tevent: ev,\r\n\t\t\t\tpointer: pointer,\r\n\t\t\t\ttouch: pointer.touch\r\n\t\t\t};\r\n\t\t\tthis.events.dispatchImmediately(\"down\", imev);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Prevents touch action from firing.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param ev Event\r\n\t */\r\n\tpublic preventTouchAction(ev: TouchEvent): void {\r\n\t\tif (!ev.defaultPrevented) {\r\n\t\t\tev.preventDefault();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Handler for a global \"pointerup\" event.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param ev Event object\r\n\t */\r\n\tpublic handleGlobalPointerUp(ev: MouseEvent, cancelled: boolean = false): void {\r\n\r\n\t\t// Get pointer\r\n\t\tlet pointer: IPointer = this.getPointer(ev);\r\n\r\n\t\t// Prepare and fire global event\r\n\t\tif (this.events.isEnabled(\"up\") && !system.isPaused) {\r\n\t\t\tlet imev: AMEvent<this, IInteractionEvents>[\"up\"] = {\r\n\t\t\t\ttype: \"up\",\r\n\t\t\t\ttarget: this,\r\n\t\t\t\tevent: ev,\r\n\t\t\t\tpointer: pointer,\r\n\t\t\t\ttouch: pointer.touch\r\n\t\t\t};\r\n\t\t\tthis.events.dispatchImmediately(\"up\", imev);\r\n\t\t}\r\n\r\n\t\t// Process further\r\n\t\tthis.handleGlobalUp(pointer, ev, cancelled);\r\n\r\n\t}\r\n\r\n\t/**\r\n * ==========================================================================\r\n * Global touch-related even handlers\r\n * ==========================================================================\r\n */\r\n\r\n\t/**\r\n\t * Handler for a global \"touchmove\" event.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param ev Event object\r\n\t */\r\n\tpublic handleGlobalTouchMove(ev: TouchEvent): void {\r\n\r\n\t\t// Process each changed touch point\r\n\t\tfor (let i = 0; i < ev.changedTouches.length; i++) {\r\n\t\t\t// Get pointer\r\n\t\t\tlet pointer: IPointer = this.getPointer(ev.changedTouches[i]);\r\n\r\n\t\t\t// Update current point position\r\n\t\t\tpointer.point = this.getPointerPoint(ev.changedTouches[i]);\r\n\r\n\t\t\t// Prepare and fire global event\r\n\t\t\tif (this.events.isEnabled(\"track\") && !system.isPaused) {\r\n\t\t\t\tlet imev: AMEvent<this, IInteractionEvents>[\"track\"] = {\r\n\t\t\t\t\ttype: \"track\",\r\n\t\t\t\t\ttarget: this,\r\n\t\t\t\t\tevent: ev,\r\n\t\t\t\t\tpointer: pointer,\r\n\t\t\t\t\ttouch: pointer.touch\r\n\t\t\t\t};\r\n\t\t\t\tthis.events.dispatchImmediately(\"track\", imev);\r\n\t\t\t}\r\n\r\n\t\t\t// Track\r\n\t\t\tthis.addBreadCrumb(pointer, pointer.point);\r\n\r\n\t\t\t// Process further\r\n\t\t\tthis.handleGlobalMove(pointer, ev);\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Handler for a global \"touchstart\" event.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param ev Event object\r\n\t */\r\n\tpublic handleGlobalTouchStart(ev: TouchEvent): void {\r\n\r\n\t\t// Remove delayed hovers\r\n\t\tthis.processDelayed();\r\n\r\n\t\t// Process each changed touch point\r\n\t\tfor (let i = 0; i < ev.changedTouches.length; i++) {\r\n\r\n\t\t\t// Get pointer\r\n\t\t\tlet pointer: IPointer = this.getPointer(ev.changedTouches[i]);\r\n\r\n\t\t\t// Prepare and fire global event\r\n\t\t\tif (!this._usePointerEventsOnly && this.events.isEnabled(\"down\") && !system.isPaused) {\r\n\t\t\t\tlet imev: AMEvent<this, IInteractionEvents>[\"down\"] = {\r\n\t\t\t\t\ttype: \"down\",\r\n\t\t\t\t\ttarget: this,\r\n\t\t\t\t\tevent: ev,\r\n\t\t\t\t\tpointer: pointer,\r\n\t\t\t\t\ttouch: pointer.touch\r\n\t\t\t\t};\r\n\t\t\t\tthis.events.dispatchImmediately(\"down\", imev);\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Handler for a global \"touchend\" event.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param ev Event object\r\n\t */\r\n\tpublic handleGlobalTouchEnd(ev: TouchEvent): void {\r\n\r\n\t\t// Process each changed touch point\r\n\t\tfor (let i = 0; i < ev.changedTouches.length; i++) {\r\n\r\n\t\t\t// Get pointer\r\n\t\t\tlet pointer: IPointer = this.getPointer(ev.changedTouches[i]);\r\n\r\n\t\t\t// Prepare and fire global event\r\n\t\t\tif (this.events.isEnabled(\"up\") && !system.isPaused) {\r\n\t\t\t\tlet imev: AMEvent<this, IInteractionEvents>[\"up\"] = {\r\n\t\t\t\t\ttype: \"up\",\r\n\t\t\t\t\ttarget: this,\r\n\t\t\t\t\tevent: ev,\r\n\t\t\t\t\tpointer: pointer,\r\n\t\t\t\t\ttouch: pointer.touch\r\n\t\t\t\t};\r\n\t\t\t\tthis.events.dispatchImmediately(\"up\", imev);\r\n\t\t\t}\r\n\r\n\t\t\t// Handle element-related events\r\n\t\t\tthis.handleGlobalUp(pointer, ev);\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * ==========================================================================\r\n\t * Element-specific pointer-related even handlers\r\n\t * ==========================================================================\r\n\t * @hidden\r\n\t */\r\n\r\n\t/**\r\n\t * Handles event when pointer is over [[InteractionObject]] and button is\r\n\t * pressed.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param io  Element\r\n\t * @param ev  Original event\r\n\t */\r\n\tpublic handlePointerDown(io: InteractionObject, ev: MouseEvent | PointerEvent): void {\r\n\r\n\t\t// Stop further propagation so we don't get multiple triggers on hybrid\r\n\t\t// devices (both mouse and touch capabilities)\r\n\t\t//ev.preventDefault();\r\n\t\t//ev.stopPropagation();\r\n\t\t//if (ev.defaultPrevented) {\r\n\t\t//}\r\n\r\n\t\t// Get pointer\r\n\t\tlet pointer = this.getPointer(ev);\r\n\r\n\t\t// Ignore if it's anything but mouse's primary button\r\n\t\tif (!pointer.touch && ev.which != 1 && ev.which != 3) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// Set mouse button\r\n\t\tpointer.button = ev.which;\r\n\r\n\t\t// Reset pointer\r\n\t\tthis.resetPointer(pointer, ev);\r\n\r\n\t\t// Process down\r\n\t\tthis.handleDown(io, pointer, ev);\r\n\t}\r\n\r\n\t/**\r\n\t * Handles event when [[InteractionObject]] is hovered by a mouse pointer.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param io  Element\r\n\t * @param ev  Original event\r\n\t */\r\n\tpublic handlePointerOver(io: InteractionObject, ev: MouseEvent | PointerEvent): void {\r\n\t\t// Get pointer\r\n\t\tlet pointer = this.getPointer(ev);\r\n\r\n\t\t// Process down\r\n\t\tthis.handleOver(io, pointer, ev);\r\n\t}\r\n\r\n\t/**\r\n\t * Handles event when [[InteractionObject]] loses hover from a mouse pointer.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param io  Element\r\n\t * @param ev  Original event\r\n\t */\r\n\tpublic handlePointerOut(io: InteractionObject, ev: MouseEvent | PointerEvent): void {\r\n\r\n\t\t// Get pointer\r\n\t\tlet pointer = this.getPointer(ev);\r\n\r\n\t\t// Process down\r\n\t\tthis.handleOut(io, pointer, ev);\r\n\t}\r\n\r\n\t/**\r\n\t * Handles event when mouse wheel is crolled over the [[InteractionObject]].\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param io  Element\r\n\t * @param ev  Original event\r\n\t * @todo Investigate more-cross browser stuff https://developer.mozilla.org/en-US/docs/Web/Events/wheel\r\n\t */\r\n\tpublic handleMouseWheel(io: InteractionObject, ev: WheelEvent): void {\r\n\r\n\t\t// Get pointer\r\n\t\tlet pointer = this.getPointer(ev);\r\n\r\n\t\t// Update current point position\r\n\t\tpointer.point = this.getPointerPoint(ev);\r\n\r\n\t\t// Init delta values\r\n\t\tlet deltaX: number = 0, deltaY: number = 0;\r\n\r\n\t\t// Set up modifier\r\n\t\t// This is needed because FireFox reports wheel deltas in \"lines\" instead\r\n\t\t// of pixels so we have to approximate pixel value\r\n\t\tlet mod = 1;\r\n\t\tif (ev.deltaMode == 1) {\r\n\t\t\tmod = 50;\r\n\t\t}\r\n\r\n\t\t// Adjust configurable sensitivity\r\n\t\tmod *= this.getMouseOption(io, \"sensitivity\");\r\n\r\n\t\t// Calculate deltas\r\n\t\tif (ev instanceof WheelEvent) {\r\n\t\t\tdeltaX = Math.round((-1 * (<any>ev).wheelDeltaX) || (ev.deltaX * mod));\r\n\t\t\tdeltaY = Math.round((-1 * (<any>ev).wheelDeltaY) || (ev.deltaY * mod));\r\n\t\t} else {\r\n\t\t\tthrow new Error(\"Invalid event type\");\r\n\t\t}\r\n\r\n\t\t// Handle the event\r\n\t\tthis.handleWheel(io, pointer, deltaX, deltaY, ev);\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * ==========================================================================\r\n\t * Element-specific touch-related even handlers\r\n\t * ==========================================================================\r\n\t * @hidden\r\n\t */\r\n\r\n\t/**\r\n\t  * Handles an event when an [[InteractionObject]] is touched on a touch\r\n\t  * device.\r\n\t  *\r\n\t  * @ignore Exclude from docs\r\n\t  * @param io  Element\r\n\t  * @param ev  Original event\r\n\t  */\r\n\tpublic handleTouchDown(io: InteractionObject, ev: TouchEvent): void {\r\n\r\n\t\t// Stop further propagation so we don't get multiple triggers on hybrid\r\n\t\t// devices (both mouse and touch capabilities)\r\n\t\t//this.maybePreventDefault(io, ev);\r\n\t\t//return;\r\n\r\n\t\t// Process each changed touch point\r\n\t\tfor (let i = 0; i < ev.changedTouches.length; i++) {\r\n\r\n\t\t\t// Get pointer\r\n\t\t\tlet pointer = this.getPointer(ev.changedTouches[i]);\r\n\t\t\tthis.maybePreventDefault(io, ev, pointer);\r\n\r\n\t\t\t// Reset pointer\r\n\t\t\tthis.resetPointer(pointer, ev.changedTouches[i]);\r\n\r\n\t\t\t// Process down\r\n\t\t\tthis.handleDown(io, pointer, ev);\r\n\t\t}\r\n\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * ==========================================================================\r\n\t * Universal handlers\r\n\t * ==========================================================================\r\n\t * @hidden\r\n\t */\r\n\r\n\t/**\r\n\t * Handles click/tap. Checks for doublehit.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param io       Interaction object\r\n\t * @param pointer  Pointer\r\n\t * @param ev       Original event\r\n\t */\r\n\tpublic handleHit(io: InteractionObject, pointer: IPointer, ev: MouseEvent | TouchEvent): void {\r\n\r\n\t\t// Check if this is a double-hit\r\n\t\tlet now = $time.getTime();\r\n\t\tif (io.lastHit && (io.lastHit >= (now - this.getHitOption(io, \"doubleHitTime\")))) {\r\n\r\n\t\t\t// Yup - it's a double-hit\r\n\r\n\t\t\t// Cancel the hit\r\n\t\t\t//clearTimeout(io.lastHitPointer.hitTimeout);\r\n\r\n\t\t\t// If it happened too fast it probably means that hybrid device just\r\n\t\t\t// generated two events for the same tap\r\n\t\t\tif ((now - io.lastHit) < 100) {\r\n\t\t\t\t// Ignore\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\t// Clear last hit\r\n\t\t\tio.lastHit = undefined;\r\n\t\t\tio.lastHitPointer = undefined;\r\n\r\n\t\t\t// Dispatch event\r\n\t\t\tif (io.events.isEnabled(\"doublehit\") && !system.isPaused) {\r\n\t\t\t\tlet imev: AMEvent<InteractionObject, IInteractionObjectEvents>[\"doublehit\"] = {\r\n\t\t\t\t\ttype: \"doublehit\",\r\n\t\t\t\t\ttarget: io,\r\n\t\t\t\t\tpoint: pointer.point,\r\n\t\t\t\t\tevent: ev,\r\n\t\t\t\t\ttouch: pointer.touch\r\n\t\t\t\t};\r\n\t\t\t\tio.events.dispatchImmediately(\"doublehit\", imev);\r\n\t\t\t}\r\n\r\n\t\t}\r\n\t\telse {\r\n\r\n\t\t\t// Log last hit\r\n\t\t\tio.lastHit = now;\r\n\t\t\tio.lastHitPointer = pointer;\r\n\r\n\t\t\tif (pointer.button === 3) {\r\n\t\t\t\t// Execute HIT now\r\n\t\t\t\tif (io.events.isEnabled(\"rightclick\") && !system.isPaused) {\r\n\t\t\t\t\tlet imev: AMEvent<InteractionObject, IInteractionObjectEvents>[\"rightclick\"] = {\r\n\t\t\t\t\t\ttype: \"rightclick\",\r\n\t\t\t\t\t\ttarget: io,\r\n\t\t\t\t\t\tevent: ev\r\n\t\t\t\t\t}\r\n\t\t\t\t\tio.events.dispatchImmediately(\"rightclick\", imev);\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tif (io.events.isEnabled(\"hit\") && !system.isPaused) {\r\n\t\t\t\t\tlet imev: AMEvent<InteractionObject, IInteractionObjectEvents>[\"hit\"] = {\r\n\t\t\t\t\t\ttype: \"hit\",\r\n\t\t\t\t\t\ttarget: io,\r\n\t\t\t\t\t\tevent: ev,\r\n\t\t\t\t\t\tpoint: pointer.point,\r\n\t\t\t\t\t\ttouch: pointer.touch\r\n\t\t\t\t\t};\r\n\t\t\t\t\tio.events.dispatchImmediately(\"hit\", imev);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Handles pointer hovering over [[InteractionObject]].\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param io       Interaction object\r\n\t * @param pointer  Pointer\r\n\t * @param ev       Original event\r\n\t * @param soft     Invoked by helper function\r\n\t */\r\n\tpublic handleOver(io: InteractionObject, pointer: IPointer, ev: MouseEvent | TouchEvent, soft: boolean = false): void {\r\n\r\n\t\tif (!io.hoverable) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tlet hoversPaused = false;\r\n\t\tif (this.shouldCancelHovers(pointer) && this.areTransformed() && this.moved(pointer, this.getHitOption(io, \"hitTolerance\"))) {\r\n\t\t\thoversPaused = true;\r\n\t\t\tthis.cancelAllHovers(ev);\r\n\t\t}\r\n\r\n\t\t// Remove any delayed outs\r\n\t\tthis.processDelayed();\r\n\r\n\t\t// Add pointer\r\n\t\tio.overPointers.moveValue(pointer);\r\n\r\n\t\t// Check if object is not yet hovered\r\n\t\tif (!io.isRealHover) {\r\n\r\n\t\t\t// Set element as hovered\r\n\t\t\tif (!hoversPaused) {\r\n\t\t\t\tio.isHover = true;\r\n\t\t\t\tio.isRealHover = true;\r\n\t\t\t\tthis.overObjects.moveValue(io);\r\n\t\t\t}\r\n\r\n\t\t\t// Generate body track event. This is needed so that if element loads\r\n\t\t\t// under unmoved mouse cursor, we still need all the actions that are\r\n\t\t\t// required to happen to kick in.\r\n\t\t\tthis.handleTrack(this.body, pointer, ev, true);\r\n\r\n\t\t\t// Event\r\n\t\t\tif (io.events.isEnabled(\"over\") && !system.isPaused && !hoversPaused) {\r\n\t\t\t\tlet imev: AMEvent<InteractionObject, IInteractionObjectEvents>[\"over\"] = {\r\n\t\t\t\t\ttype: \"over\",\r\n\t\t\t\t\ttarget: io,\r\n\t\t\t\t\tevent: ev,\r\n\t\t\t\t\tpointer: pointer,\r\n\t\t\t\t\ttouch: pointer.touch\r\n\t\t\t\t};\r\n\t\t\t\tio.events.dispatchImmediately(\"over\", imev);\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Handles when [[InteractionObject]] is no longer hovered.\r\n\t *\r\n\t * If `soft = true`, this means that method is being invoked by some other\r\n\t * code, not hard \"out\" function, like `handleUp` which implies we need to\r\n\t * run additional checks before unhovering the object.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param io       Interaction object\r\n\t * @param pointer  Pointer\r\n\t * @param ev       Original event\r\n\t * @param soft     Invoked by helper function\r\n\t * @param force    Force imediate out\r\n\t */\r\n\tpublic handleOut(io: InteractionObject, pointer: IPointer, ev: MouseEvent | TouchEvent, soft: boolean = false, force: boolean = false): void {\r\n\r\n\t\tif (!io.hoverable) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// Remove pointer\r\n\t\tio.overPointers.removeValue(pointer);\r\n\r\n\t\t// Check if element is still hovered\r\n\t\tif (io.isHover && (!io.hasDelayedOut || force)) {\r\n\r\n\r\n\t\t\t// Should we run additional checks?\r\n\t\t\tif (soft && io.overPointers.length) {\r\n\t\t\t\t// There are still pointers hovering - don't do anything else and\r\n\t\t\t\t// wait until either no over pointers are there or we get a hard out\r\n\t\t\t\t// event.\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\t// Should we delay \"out\" if this is happening on a touch device?\r\n\t\t\tif (pointer && pointer.touch && !force && !this.old(pointer)) {\r\n\r\n\t\t\t\t// This is a touch pointer, and it hasn't moved, let's pretend\r\n\t\t\t\t// the object is still hovered, and act as per \"behavior\" setting\r\n\t\t\t\tlet behavior = this.getHoverOption(io, \"touchOutBehavior\");\r\n\t\t\t\tif (behavior == \"leave\") {\r\n\t\t\t\t\t// Set to \"leave\", so we do not execute any \"out\" event.\r\n\t\t\t\t\t// It will be handled by any other interaction that happens\r\n\t\t\t\t\t// afterwards.\r\n\t\t\t\t\tthis._delayedEvents.out.push({\r\n\t\t\t\t\t\ttype: \"out\",\r\n\t\t\t\t\t\tio: io,\r\n\t\t\t\t\t\tpointer: pointer,\r\n\t\t\t\t\t\tevent: ev,\r\n\t\t\t\t\t\tkeepUntil: $time.getTime() + 500\r\n\t\t\t\t\t});\r\n\t\t\t\t\tio.hasDelayedOut = true;\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\telse if (behavior == \"delay\" && this.getHoverOption(io, \"touchOutDelay\")) {\r\n\t\t\t\t\tthis._delayedEvents.out.push({\r\n\t\t\t\t\t\ttype: \"out\",\r\n\t\t\t\t\t\tio: io,\r\n\t\t\t\t\t\tpointer: pointer,\r\n\t\t\t\t\t\tevent: ev,\r\n\t\t\t\t\t\tkeepUntil: $time.getTime() + 500,\r\n\t\t\t\t\t\ttimeout: this.setTimeout(() => {\r\n\t\t\t\t\t\t\tthis.handleOut(io, pointer, ev, true);\r\n\t\t\t\t\t\t}, this.getHoverOption(io, \"touchOutDelay\"))\r\n\t\t\t\t\t});\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\t// Nothing for \"remove\" - that's how it works \"out-of-the-box\"\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Set element as not hovered\r\n\t\t\tio.isHover = false;\r\n\t\t\tthis.overObjects.removeValue(io);\r\n\r\n\t\t\t// Invoke event\r\n\t\t\tif (!io.isDisposed() && io.events.isEnabled(\"out\") && !system.isPaused) {\r\n\t\t\t\tlet imev: AMEvent<InteractionObject, IInteractionObjectEvents>[\"out\"] = {\r\n\t\t\t\t\ttype: \"out\",\r\n\t\t\t\t\ttarget: io,\r\n\t\t\t\t\tevent: ev,\r\n\t\t\t\t\tpointer: pointer,\r\n\t\t\t\t\ttouch: pointer.touch\r\n\t\t\t\t};\r\n\t\t\t\tio.events.dispatchImmediately(\"out\", imev);\r\n\t\t\t}\r\n\r\n\t\t\t// Reset object from lefover delayed outs, pointers\r\n\t\t\tio.overPointers.clear();\r\n\t\t\tio.hasDelayedOut = false;\r\n\t\t\t// @todo (clean delayed)\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Processes dalyed events, such as \"out\" event that was initiated for\r\n\t * elements by touch.\r\n\t */\r\n\tprivate processDelayed(): void {\r\n\t\tlet delayedEvent;\r\n\r\n\t\twhile (true) {\r\n\t\t\tdelayedEvent = this._delayedEvents.out.pop();\r\n\r\n\t\t\tif (!delayedEvent) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\tif (delayedEvent.timeout) {\r\n\t\t\t\tdelayedEvent.timeout.dispose();\r\n\t\t\t}\r\n\r\n\t\t\tthis.handleOut(delayedEvent.io, delayedEvent.pointer, delayedEvent.event, false, true);\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Performs tasks on pointer down.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param io       Element\r\n\t * @param pointer  Pointer\r\n\t * @param ev       Original event\r\n\t */\r\n\tpublic handleDown(io: InteractionObject, pointer: IPointer, ev: MouseEvent | TouchEvent | undefined): void {\r\n\r\n\t\t// Need to prevent default event from happening on transformable objects\r\n\t\tthis.maybePreventDefault(io, ev, pointer);\r\n\r\n\t\t// Stop inertia animations if they're currently being played out\r\n\t\tif (io.inert) {\r\n\t\t\tthis.stopInertia(io);\r\n\t\t}\r\n\r\n\t\t// Trigger hover because some touch devices won't trigger over events\r\n\t\t// on their own\r\n\t\tthis.handleOver(io, pointer, ev, true);\r\n\r\n\t\t// Add pointer to list\r\n\t\tio.downPointers.moveValue(pointer);\r\n\r\n\t\t// Apply styles if necessary\r\n\t\tthis.applyCursorDownStyle(io, pointer);\r\n\r\n\t\t// Check if object is already down\r\n\t\tif (!io.isDown) {\r\n\r\n\t\t\t// Lose focus if needed\r\n\t\t\tif (io.focusable !== false && this.getHitOption(io, \"noFocus\") && this.focusedObject) {\r\n\t\t\t\t$dom.blur();\r\n\t\t\t}\r\n\r\n\t\t\t// Set object as hovered\r\n\t\t\tio.isDown = true;\r\n\t\t\tthis.downObjects.moveValue(io);\r\n\r\n\t\t\t// Prep object for dragging and/or resizing\r\n\t\t\tif (io.draggable) {\r\n\t\t\t\tthis.processDragStart(io, pointer, ev);\r\n\t\t\t}\r\n\t\t\tif (io.resizable) {\r\n\t\t\t\tthis.processResizeStart(io, pointer, ev);\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// Dispatch \"down\" event\r\n\t\tif (io.events.isEnabled(\"down\") && !system.isPaused) {\r\n\t\t\tlet imev: AMEvent<InteractionObject, IInteractionObjectEvents>[\"down\"] = {\r\n\t\t\t\ttype: \"down\",\r\n\t\t\t\ttarget: io,\r\n\t\t\t\tevent: ev,\r\n\t\t\t\tpointer: pointer,\r\n\t\t\t\ttouch: pointer.touch\r\n\t\t\t};\r\n\t\t\tio.events.dispatchImmediately(\"down\", imev);\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Performs tasks on pointer up.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param pointer  Pointer\r\n\t * @param ev       Original event\r\n\t */\r\n\tpublic handleGlobalUp(pointer: IPointer, ev: MouseEvent | TouchEvent | undefined, cancelled: boolean = false): void {\r\n\t\tconst sorted = this.downObjects.values.slice();\r\n\r\n\t\tsorted.sort((x, y) => {\r\n\t\t\tif (x && y) {\r\n\t\t\t\tconst pos = x.element.compareDocumentPosition(y.element);\r\n\r\n\t\t\t\tif (pos & Node.DOCUMENT_POSITION_CONTAINED_BY) {\r\n\t\t\t\t\treturn 1;\r\n\r\n\t\t\t\t} else if (pos & Node.DOCUMENT_POSITION_CONTAINS) {\r\n\t\t\t\t\treturn -1;\r\n\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn 0;\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\t\t\t\treturn 0;\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\t// Process all down objects\r\n\t\t$array.each(sorted, (io) => {\r\n\t\t\t// Check if this particular pointer is pressing down\r\n\t\t\t// on object\r\n\t\t\tif (io && io.downPointers.contains(pointer)) {\r\n\t\t\t\tthis.handleUp(io, pointer, ev, cancelled);\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Simulates all pointers being up once mouse leaves document area.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param ev       Original event\r\n\t */\r\n\tpublic handleDocumentLeave(ev: MouseEvent): void {\r\n\r\n\t\t// Process all down objects\r\n\t\t$iter.each(this.downObjects.backwards().iterator(), (io) => {\r\n\t\t\tio.downPointers.each((pointer) => {\r\n\t\t\t\tthis.handleUp(io, pointer, ev);\r\n\t\t\t})\r\n\t\t});\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Handles when [[InteractionObject]] is no longer hovered.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param io       Interaction object\r\n\t * @param pointer  Pointer\r\n\t * @param ev       Original event\r\n\t */\r\n\tpublic handleUp(io: InteractionObject, pointer: IPointer, ev: MouseEvent | TouchEvent, cancelled: boolean = false): void {\r\n\r\n\t\t// Restore cursor style\r\n\t\tthis.restoreCursorDownStyle(io, pointer);\r\n\r\n\t\t// Remove pointer from the list\r\n\t\tio.downPointers.removeValue(pointer);\r\n\r\n\t\t// Trigger out because some touch devices won't trigger out events\r\n\t\t// on their own\r\n\t\tif (pointer.touch || this._useTouchEventsOnly) {\r\n\t\t\tthis.handleOut(io, pointer, ev, true);\r\n\t\t}\r\n\r\n\t\t// Check if object still down\r\n\t\tif (io.isDown) {\r\n\r\n\t\t\t// Check if there are no other pointers hovering this element\r\n\t\t\tif (io.downPointers.length == 0) {\r\n\t\t\t\t// Set element as no longer down\r\n\t\t\t\tio.isDown = false;\r\n\t\t\t\tthis.downObjects.removeValue(io);\r\n\t\t\t}\r\n\r\n\t\t\t// Dispatch \"up\" event\r\n\t\t\tif (io.events.isEnabled(\"up\") && !system.isPaused) {\r\n\t\t\t\tlet imev: AMEvent<InteractionObject, IInteractionObjectEvents>[\"up\"] = {\r\n\t\t\t\t\ttype: \"up\",\r\n\t\t\t\t\ttarget: io,\r\n\t\t\t\t\tevent: ev,\r\n\t\t\t\t\tpointer: pointer,\r\n\t\t\t\t\ttouch: pointer.touch\r\n\t\t\t\t};\r\n\t\t\t\tio.events.dispatchImmediately(\"up\", imev);\r\n\t\t\t}\r\n\r\n\t\t\t// Check if this was not a cancelled event.\r\n\t\t\t// If event was canelled (which might happen if gesture resulted in\r\n\t\t\t// navigation or page scroll) there's no point in triggering hit and\r\n\t\t\t// other actions.\r\n\t\t\tif (!cancelled) {\r\n\r\n\t\t\t\t// Handle swiping-related stuff\r\n\t\t\t\tif (io.swipeable && this.swiped(io, pointer)) {\r\n\t\t\t\t\t// Swiped - nothing else should happen\r\n\t\t\t\t\tthis.handleSwipe(io, pointer, ev);\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// Check if it maybe a click\r\n\t\t\t\t\tif (io.clickable && !this.moved(pointer, this.getHitOption(io, \"hitTolerance\"))) {\r\n\t\t\t\t\t\tthis.handleHit(io, pointer, ev);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Handle inertia\r\n\t\t\t\t\tif (io.inert && this.moved(pointer, this.getHitOption(io, \"hitTolerance\"))) {\r\n\t\t\t\t\t\tthis.handleInertia(io, pointer);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (io.draggable) {\r\n\t\t\t\t\t\tthis.processDragStop(io, pointer, ev);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (io.resizable) {\r\n\t\t\t\t\t\tthis.processResizeStop(io, pointer, ev);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if event needs to be prevented on draggable and such items, so that\r\n\t * touch gestures like navigation and scroll do not kick in.\r\n\t *\r\n\t * @param io  Object\r\n\t * @param ev  Event\r\n\t */\r\n\tprivate maybePreventDefault(io: InteractionObject, ev: MouseEvent | TouchEvent | undefined, pointer?: IPointer): void {\r\n\t\tif (\r\n\t\t\t$type.hasValue(ev)\r\n\t\t\t&& (io.draggable || io.swipeable || io.trackable || io.resizable)\r\n\t\t\t&& !this.isGlobalElement(io)\r\n\t\t\t&& ev.cancelable !== false\r\n\t\t\t&& (!io.isTouchProtected || !pointer || !pointer.touch)\r\n\t\t) {\r\n\t\t\tev.preventDefault();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Cancels all hovers on all currently hovered objects.\r\n\t *\r\n\t * @param  pointer  Pointer\r\n\t * @param  ev       Event\r\n\t */\r\n\tprivate cancelAllHovers(ev?: MouseEvent | TouchEvent): void {\r\n\t\t//this.overObjects.each((io) => {\r\n\t\t$iter.each(this.overObjects.backwards().iterator(), (io) => {\r\n\t\t\tif (io) {\r\n\t\t\t\tconst pointer = io.overPointers.getIndex(0);\r\n\t\t\t\tthis.handleOut(io, pointer, ev, true, true);\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if hovers should be cancelled on transform as per global options.\r\n\t * @param   pointer  Pointer\r\n\t * @return           Cancel?\r\n\t */\r\n\tprivate shouldCancelHovers(pointer: IPointer): boolean {\r\n\t\treturn options.disableHoverOnTransform == \"always\" || (options.disableHoverOnTransform == \"touch\" && pointer.touch);\r\n\t}\r\n\r\n\t/**\r\n\t * Handles pointer move.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param pointer  Pointer\r\n\t * @param ev       Original event\r\n\t */\r\n\tpublic handleGlobalMove(pointer: IPointer, ev: MouseEvent | TouchEvent): void {\r\n\r\n\t\t// Process hovered elements\r\n\t\t// We check if the element became unhovered without reporting the mouseout\r\n\t\t// event. (it happens in some cases)\r\n\t\tif (!pointer.touch) {\r\n\t\t\tconst target = <HTMLElement>$dom.eventTarget(<Event>pointer.lastEvent);\r\n\r\n\t\t\t$iter.each(this.overObjects.backwards().iterator(), (io) => {\r\n\t\t\t\t// Is this pointer relevant to element?\r\n\t\t\t\tif (io && io.overPointers.contains(pointer) && io.hoverable) {\r\n\t\t\t\t\t// Check if the element is still hovered\r\n\t\t\t\t\tlet reset = false;\r\n\t\t\t\t\tif (io.element && pointer.lastEvent) {\r\n\t\t\t\t\t\tif (!$dom.contains(io.element, target)) {\r\n\t\t\t\t\t\t\treset = true;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\treset = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (reset) {\r\n\t\t\t\t\t\tthis.handleOut(io, pointer, ev, true);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\r\n\r\n\t\t// Process down elements\r\n\t\t$iter.each(this.transformedObjects.backwards().iterator(), (io) => {\r\n\t\t\t// Is this pointer relevant to element?\r\n\t\t\tif (io.downPointers.contains(pointer) &&\r\n\t\t\t\t// Swipe still happening?\r\n\t\t\t\t!(io.swipeable && this.swiping(io, pointer)) &&\r\n\t\t\t\t(io.draggable || io.resizable)) {\r\n\t\t\t\tthis.handleTransform(io, ev);\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\t// Process tracked elements\r\n\t\t$iter.each(this.trackedObjects.backwards().iterator(), (io) => {\r\n\t\t\t// Is this pointer relevant to element?\r\n\t\t\tif (!io.overPointers.contains(pointer)) {\r\n\t\t\t\tthis.handleTrack(io, pointer, ev);\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Handles reporting of pointer movement.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param io        Element\r\n\t * @param pointer    Pointer\r\n\t * @param ev         Original event\r\n\t * @param skipCheck  Sould we skip check if cursor actually moved\r\n\t */\r\n\tpublic handleTrack(io: InteractionObject, pointer: IPointer, ev: MouseEvent | TouchEvent, skipCheck = false): void {\r\n\r\n\t\t// Do nothing if the cursor did not actually move\r\n\t\tif (!skipCheck && !this.moved(pointer, 0)) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// Initiate TRACK event\r\n\t\tif (io.events.isEnabled(\"track\") && !system.isPaused) {\r\n\t\t\tlet imev: AMEvent<InteractionObject, IInteractionObjectEvents>[\"track\"] = {\r\n\t\t\t\ttype: \"track\",\r\n\t\t\t\ttarget: io,\r\n\t\t\t\tevent: ev,\r\n\t\t\t\tpoint: pointer.point,\r\n\t\t\t\tpointer: pointer,\r\n\t\t\t\ttouch: pointer.touch\r\n\t\t\t};\r\n\t\t\tio.events.dispatchImmediately(\"track\", imev);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Handles swipe action.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param io       Element\r\n\t * @param pointer  Pointer\r\n\t * @param ev       Original event\r\n\t */\r\n\tpublic handleSwipe(io: InteractionObject, pointer: IPointer, ev: MouseEvent | TouchEvent): void {\r\n\r\n\t\t// We pass in InteractionEvent with shift in mouse coordinates\r\n\t\t// between when the drag started and ended\r\n\t\tif (io.events.isEnabled(\"swipe\") && !system.isPaused) {\r\n\t\t\tlet imev: AMEvent<InteractionObject, IInteractionObjectEvents>[\"swipe\"] = {\r\n\t\t\t\ttype: \"swipe\",\r\n\t\t\t\ttarget: io,\r\n\t\t\t\tevent: ev,\r\n\t\t\t\ttouch: pointer.touch\r\n\t\t\t};\r\n\t\t\tio.events.dispatchImmediately(\"swipe\", imev);\r\n\t\t}\r\n\r\n\t\tif (pointer.startPoint.x < pointer.point.x) {\r\n\t\t\tif (io.events.isEnabled(\"swiperight\") && !system.isPaused) {\r\n\t\t\t\tlet imev: AMEvent<InteractionObject, IInteractionObjectEvents>[\"swiperight\"] = {\r\n\t\t\t\t\ttype: \"swiperight\",\r\n\t\t\t\t\ttarget: io,\r\n\t\t\t\t\tevent: ev,\r\n\t\t\t\t\ttouch: pointer.touch\r\n\t\t\t\t};\r\n\t\t\t\tio.events.dispatchImmediately(\"swiperight\", imev);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\tif (io.events.isEnabled(\"swipeleft\") && !system.isPaused) {\r\n\t\t\t\tlet imev: AMEvent<InteractionObject, IInteractionObjectEvents>[\"swipeleft\"] = {\r\n\t\t\t\t\ttype: \"swipeleft\",\r\n\t\t\t\t\ttarget: io,\r\n\t\t\t\t\tevent: ev,\r\n\t\t\t\t\ttouch: pointer.touch\r\n\t\t\t\t};\r\n\t\t\t\tio.events.dispatchImmediately(\"swipeleft\", imev);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Handles event triggering for wheel rotation.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param io       Element\r\n\t * @param pointer  Pointer\r\n\t * @param deltaX   Horizontal shift\r\n\t * @param deltaY   Vertical shift\r\n\t * @param ev       Original event\r\n\t */\r\n\tpublic handleWheel(io: InteractionObject, pointer: IPointer, deltaX: number, deltaY: number, ev: WheelEvent): void {\r\n\t\tconst shift: IPoint = {\r\n\t\t\tx: deltaX,\r\n\t\t\ty: deltaY\r\n\t\t};\r\n\r\n\t\t// Trigger generic WHEEL event\r\n\t\tif (io.events.isEnabled(\"wheel\") && !system.isPaused) {\r\n\t\t\tio.events.dispatchImmediately(\"wheel\", {\r\n\t\t\t\ttype: \"wheel\",\r\n\t\t\t\ttarget: io,\r\n\t\t\t\tevent: ev,\r\n\t\t\t\tpoint: pointer.point,\r\n\t\t\t\tshift: shift\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\t// Trigger direction-specific events\r\n\r\n\t\t// Horizontal\r\n\t\tif (deltaX < 0) {\r\n\t\t\tif (io.events.isEnabled(\"wheelleft\") && !system.isPaused) {\r\n\t\t\t\tio.events.dispatchImmediately(\"wheelleft\", {\r\n\t\t\t\t\ttype: \"wheelleft\",\r\n\t\t\t\t\ttarget: io,\r\n\t\t\t\t\tevent: ev,\r\n\t\t\t\t\tpoint: pointer.point,\r\n\t\t\t\t\tshift: shift\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t} else if (deltaX > 0) {\r\n\t\t\tif (io.events.isEnabled(\"swiperight\") && !system.isPaused) {\r\n\t\t\t\tio.events.dispatchImmediately(\"wheelright\", {\r\n\t\t\t\t\ttype: \"wheelright\",\r\n\t\t\t\t\ttarget: io,\r\n\t\t\t\t\tevent: ev,\r\n\t\t\t\t\tpoint: pointer.point,\r\n\t\t\t\t\tshift: shift\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\t// Vertical\r\n\t\t} else if (deltaY < 0) {\r\n\t\t\tif (io.events.isEnabled(\"wheelup\") && !system.isPaused) {\r\n\t\t\t\tio.events.dispatchImmediately(\"wheelup\", {\r\n\t\t\t\t\ttype: \"wheelup\",\r\n\t\t\t\t\ttarget: io,\r\n\t\t\t\t\tevent: ev,\r\n\t\t\t\t\tpoint: pointer.point,\r\n\t\t\t\t\tshift: shift\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t} else if (deltaY > 0) {\r\n\t\t\tif (io.events.isEnabled(\"wheeldown\") && !system.isPaused) {\r\n\t\t\t\tio.events.dispatchImmediately(\"wheeldown\", {\r\n\t\t\t\t\ttype: \"wheeldown\",\r\n\t\t\t\t\ttarget: io,\r\n\t\t\t\t\tevent: ev,\r\n\t\t\t\t\tpoint: pointer.point,\r\n\t\t\t\t\tshift: shift\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Initiates inertia checking sub-routines for different movement types:\r\n\t * drag, resize.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param sprite\r\n\t * @param pointer\r\n\t */\r\n\tpublic handleInertia(io: InteractionObject, pointer: IPointer): void {\r\n\r\n\t\tif (io.draggable && io.downPointers.length === 0) {\r\n\t\t\tthis.handleMoveInertia(io, pointer);\r\n\t\t}\r\n\r\n\t\tif (io.resizable && io.downPointers.length > 1) {\r\n\t\t\tthis.handleResizeInertia(io, pointer);\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Continues moving the element to simulate the effect of inertia. Happens\r\n\t * when `inert` and `draggable` object is dragged and then released.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param io       Element\r\n\t * @param pointer  Pointer\r\n\t */\r\n\tpublic handleMoveInertia(io: InteractionObject, pointer: IPointer): void {\r\n\t\tlet interaction = io;\r\n\t\tlet type: \"move\" = \"move\";\r\n\t\tlet point = {\r\n\t\t\t\"x\": pointer.point.x,\r\n\t\t\t\"y\": pointer.point.y\r\n\t\t};\r\n\t\tlet startPoint = {\r\n\t\t\t\"x\": pointer.startPoint.x,\r\n\t\t\t\"y\": pointer.startPoint.y\r\n\t\t};\r\n\r\n\t\t// Init inertia object\r\n\t\tlet inertia = new Inertia(interaction, type, point, startPoint);\r\n\r\n\t\t// Get inertia data\r\n\t\tlet ref = this.getTrailPoint(pointer, $time.getTime() - this.getInertiaOption(io, \"move\", \"time\"));\r\n\t\tif (typeof ref === \"undefined\") {\r\n\t\t\tthis.processDragStop(io, pointer, pointer.lastUpEvent);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// Init animation options\r\n\t\tlet factor = this.getInertiaOption(io, \"move\", \"factor\");\r\n\t\tlet animationOptions = [{\r\n\t\t\t\"to\": pointer.point.x + (pointer.point.x - ref.point.x) * factor,\r\n\t\t\t\"property\": \"x\"\r\n\t\t}, {\r\n\t\t\t\"to\": pointer.point.y + (pointer.point.y - ref.point.y) * factor,\r\n\t\t\t\"property\": \"y\"\r\n\t\t}];\r\n\r\n\t\t// Start animation\r\n\t\tlet animation: Animation = new Animation(\r\n\t\t\tinertia,\r\n\t\t\tanimationOptions,\r\n\t\t\tthis.getInertiaOption(io, \"move\", \"duration\"),\r\n\t\t\tthis.getInertiaOption(io, \"move\", \"easing\")\r\n\t\t).start();\r\n\t\tthis._disposers.push(animation.events.on(\"animationended\", (ev) => {\r\n\t\t\tinertia.done();\r\n\t\t}));\r\n\r\n\t\t// Add inertia object\r\n\t\tio.inertias.setKey(\"move\", inertia);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Continues resizing of a `resizable` element after it is resized and\r\n\t * released.\r\n\t *\r\n\t * **NOTE:** this is is just a placeholder function. No actual fucntionality\r\n\t * is implemented, yet.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param io       Element\r\n\t * @param pointer  Pointer\r\n\t */\r\n\tpublic handleResizeInertia(io: InteractionObject, pointer: IPointer): void {\r\n\r\n\t\t// Some day, folks. Some day...\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Recalculates element's position and size based on position of\r\n\t * all its related pointers.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param io  Element\r\n\t * @param ev  Original event\r\n\t */\r\n\tpublic handleTransform(io: InteractionObject, ev: MouseEvent | TouchEvent): void {\r\n\r\n\t\t// Get primary pointer and its respective points\r\n\t\tlet pointer1: $type.Optional<IPointer> = io.downPointers.getIndex(0);\r\n\t\tlet point1: IPoint = null;\r\n\t\tlet startPoint1: IPoint = null;\r\n\r\n\t\tif (pointer1) {\r\n\t\t\tpoint1 = pointer1.point;\r\n\t\t\tstartPoint1 = pointer1.startPoint;\r\n\t\t}\r\n\r\n\t\t// Init secondary pointer\r\n\t\tlet pointer2: $type.Optional<IPointer>;\r\n\t\tlet point2: IPoint;\r\n\t\tlet startPoint2: IPoint;\r\n\r\n\t\t// Use center of the sprite to simulate \"second\" point of touch\r\n\t\tpoint2 = {\r\n\t\t\t\"x\": io.originalPosition.x,\r\n\t\t\t\"y\": io.originalPosition.y\r\n\t\t};\r\n\t\tstartPoint2 = point2;\r\n\r\n\t\t// Determine if it's a sinngle pointer or multi\r\n\t\tlet singlePoint: boolean = true;\r\n\t\tfor (let i = 1; i < io.downPointers.length; i++) {\r\n\r\n\t\t\t// Get pointer\r\n\t\t\tlet nextPointer = io.downPointers.getIndex(i);\r\n\r\n\t\t\t// Doublecheck if it's not the same pointer by comparing original position\r\n\t\t\tif (startPoint1.x != nextPointer.startPoint.x && startPoint1.y != nextPointer.startPoint.y) {\r\n\r\n\t\t\t\t// Several pointers down\r\n\t\t\t\tsinglePoint = false;\r\n\r\n\t\t\t\t// Get second pointer\r\n\t\t\t\tpointer2 = nextPointer;\r\n\t\t\t\tpoint2 = pointer2.point;\r\n\t\t\t\tstartPoint2 = pointer2.startPoint;\r\n\r\n\t\t\t\t// Stop looking\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Primary touch point moved?\r\n\t\tlet pointer1Moved = pointer1 && this.moved(pointer1, 0);\r\n\r\n\t\t// Report DRAG_START if necessary\r\n\t\tif (io.draggable && pointer1 && pointer1.dragStartEvents && pointer1.dragStartEvents.length && pointer1Moved) {\r\n\t\t\tif (io.events.isEnabled(\"dragstart\") && !system.isPaused) {\r\n\t\t\t\tio.events.dispatchImmediately(\"dragstart\", pointer1.dragStartEvents.shift());\r\n\t\t\t}\r\n\t\t\t//delete pointer1.dragStartEvents;\r\n\t\t}\r\n\r\n\t\t// Determine what we do in order of superiority\r\n\t\tif (singlePoint && io.draggable) {\r\n\r\n\t\t\t// We have only one pointer and the Sprite is draggable\r\n\t\t\t// There's nothing else to be done - just move it\r\n\t\t\tthis.handleTransformMove(io, point1, startPoint1, ev, pointer1Moved, pointer1.touch);\r\n\r\n\t\t\tif (this.shouldCancelHovers(pointer1) && this.moved(pointer1, this.getHitOption(io, \"hitTolerance\"))) {\r\n\t\t\t\tthis.cancelAllHovers(ev);\r\n\t\t\t}\r\n\r\n\t\t}\r\n\t\telse {\r\n\r\n\t\t\t// Check if second touch point moved\r\n\t\t\tlet pointer2Moved = pointer2 && this.moved(pointer2, 0);\r\n\r\n\t\t\tif (\r\n\t\t\t\t(this.shouldCancelHovers(pointer1) && this.moved(pointer1, this.getHitOption(io, \"hitTolerance\")))\r\n\t\t\t\t||\r\n\t\t\t\t(this.shouldCancelHovers(pointer2) && this.moved(pointer2, this.getHitOption(io, \"hitTolerance\")))\r\n\t\t\t) {\r\n\t\t\t\tthis.cancelAllHovers(ev);\r\n\t\t\t}\r\n\r\n\t\t\tif (io.draggable && io.resizable) {\r\n\t\t\t\t//this.handleTransformAll(io, point1, startPoint1, point2, startPoint2, ev, pointer1Moved && pointer2Moved);\r\n\t\t\t\tthis.handleTransformMove(io, point1, startPoint1, ev, pointer1Moved && pointer2Moved, pointer1.touch);\r\n\t\t\t\tthis.handleTransformResize(io, point1, startPoint1, point2, startPoint2, ev, pointer1Moved && pointer2Moved, pointer1.touch);\r\n\t\t\t}\r\n\t\t\telse {\r\n\r\n\t\t\t\tif (io.draggable) {\r\n\t\t\t\t\tthis.handleTransformMove(io, point1, startPoint1, ev, pointer1Moved, pointer1.touch);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (io.resizable && (!singlePoint || ev.ctrlKey)) {\r\n\t\t\t\t\tthis.handleTransformResize(io, point1, startPoint1, point2, startPoint2, ev, pointer1Moved && pointer2Moved, pointer1.touch);\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Handles movement of the dragged element.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param io            Element\r\n\t * @param point         Current point of the pointer\r\n\t * @param startPoint    Starting point of the pointer\r\n\t * @param ev            Original event\r\n\t * @param pointerMoved  Did pointer move?\r\n\t */\r\n\tpublic handleTransformMove(io: InteractionObject, point: IPoint, startPoint: IPoint, ev: MouseEvent | TouchEvent | KeyboardEvent, pointerMoved: boolean, touch: boolean): void {\r\n\r\n\t\tif (pointerMoved) {\r\n\t\t\tif (io.events.isEnabled(\"drag\") && !system.isPaused && (!io.isTouchProtected || !touch)) {\r\n\t\t\t\tlet imev: AMEvent<InteractionObject, IInteractionObjectEvents>[\"drag\"] = {\r\n\t\t\t\t\ttype: \"drag\",\r\n\t\t\t\t\ttarget: io,\r\n\t\t\t\t\tevent: ev,\r\n\t\t\t\t\tshift: {\r\n\t\t\t\t\t\t\"x\": point.x - startPoint.x,\r\n\t\t\t\t\t\t\"y\": point.y - startPoint.y\r\n\t\t\t\t\t},\r\n\t\t\t\t\tstartPoint: startPoint,\r\n\t\t\t\t\tpoint: point,\r\n\t\t\t\t\ttouch: touch\r\n\t\t\t\t};\r\n\t\t\t\tio.events.dispatchImmediately(\"drag\", imev);\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Handles resizing of the element.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param io            Element\r\n\t * @param point1        Current position of reference point #1\r\n\t * @param startPoint1   Original position of reference point #1\r\n\t * @param point2        Current position of reference point #2\r\n\t * @param startPoint2   Original position of reference point #2\r\n\t * @param ev            Original event\r\n\t * @param pointerMoved  Did pointer move?\r\n\t */\r\n\tpublic handleTransformResize(io: InteractionObject, point1: IPoint, startPoint1: IPoint, point2: IPoint, startPoint2: IPoint, ev: MouseEvent | TouchEvent, pointerMoved: boolean, touch: boolean): void {\r\n\t\tif (io.events.isEnabled(\"resize\") && !system.isPaused && (!io.isTouchProtected || !touch)) {\r\n\t\t\tlet imev: AMEvent<InteractionObject, IInteractionObjectEvents>[\"resize\"] = {\r\n\t\t\t\ttype: \"resize\",\r\n\t\t\t\ttarget: io,\r\n\t\t\t\tevent: ev,\r\n\t\t\t\tscale: $math.getScale(point1, startPoint1, point2, startPoint2),\r\n\t\t\t\tstartPoint1: startPoint1,\r\n\t\t\t\tpoint1: point1,\r\n\t\t\t\tstartPoint2: startPoint2,\r\n\t\t\t\tpoint2: point2,\r\n\t\t\t\ttouch: touch\r\n\t\t\t};\r\n\t\t\tio.events.dispatchImmediately(\"resize\", imev);\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Handles all the preparations of the element when it starts to be dragged.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param io       Element\r\n\t * @param pointer  Pointer\r\n\t * @param ev       Original event\r\n\t */\r\n\tpublic processDragStart(io: InteractionObject, pointer?: IPointer, ev?: MouseEvent | TouchEvent): void {\r\n\r\n\t\t// Add to draggedObjects\r\n\t\tthis.transformedObjects.moveValue(io);\r\n\r\n\t\tif (this.shouldCancelHovers(pointer)) {\r\n\t\t\tthis.cancelAllHovers(ev);\r\n\t\t}\r\n\r\n\t\t// Report \"dragstart\"\r\n\t\tlet imev: AMEvent<InteractionObject, IInteractionObjectEvents>[\"dragstart\"] = {\r\n\t\t\ttype: \"dragstart\",\r\n\t\t\ttarget: io,\r\n\t\t\tevent: ev,\r\n\t\t\ttouch: pointer ? pointer.touch : false\r\n\t\t};\r\n\r\n\t\t// Log object that we are starting to drag, so we can check against and\r\n\t\t// avoid hovers on other objects that might be in the path of movement.\r\n\t\tif (pointer) {\r\n\t\t\tpointer.dragTarget = io;\r\n\t\t\t//pointer.startPoint = pointer.point;\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * If pointer is set we will not fire the event until the pointer has\r\n\t\t * actually moved. If it's not set we don't have to wait for anything, so we\r\n\t\t * just fire off the event right away.\r\n\t\t */\r\n\t\tif (pointer && pointer.dragStartEvents) {\r\n\t\t\tpointer.dragStartEvents.push(imev);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tif (!system.isPaused) {\r\n\t\t\t\tio.dispatchImmediately(\"dragstart\", imev);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Finishes up element drag operation.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param io       Element\r\n\t * @param pointer  Pointer\r\n\t * @param ev       Original event\r\n\t */\r\n\tpublic processDragStop(io: InteractionObject, pointer?: IPointer, ev?: MouseEvent | TouchEvent): void {\r\n\r\n\t\t// Pointer set?\r\n\t\tif (!pointer) {\r\n\t\t\tpointer = this.getDragPointer(io);\r\n\t\t}\r\n\r\n\t\t// Unset drag object\r\n\t\tif (pointer) {\r\n\t\t\tpointer.dragTarget = undefined;\r\n\t\t}\r\n\r\n\t\t// Removed from transformedObjects\r\n\t\tthis.transformedObjects.removeValue(io);\r\n\r\n\t\t// Unlock document\r\n\t\t//this.unlockDocument();\r\n\r\n\t\t// Report dragstop\r\n\t\tif (!pointer || this.moved(pointer, 0)) {\r\n\t\t\tif (io.events.isEnabled(\"dragstop\") && !system.isPaused) {\r\n\t\t\t\tlet imev: AMEvent<InteractionObject, IInteractionObjectEvents>[\"dragstop\"] = {\r\n\t\t\t\t\ttype: \"dragstop\",\r\n\t\t\t\t\ttarget: io,\r\n\t\t\t\t\ttouch: pointer ? pointer.touch : false\r\n\t\t\t\t};\r\n\t\t\t\tio.events.dispatchImmediately(\"dragstop\", imev);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Handles all the preparations of the element when it starts to be resized.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param io       Element\r\n\t * @param pointer  Pointer\r\n\t * @param ev       Original event\r\n\t */\r\n\tpublic processResizeStart(io: InteractionObject, pointer?: IPointer, ev?: MouseEvent | TouchEvent): void {\r\n\r\n\t\t// Add to draggedObjects\r\n\t\tthis.transformedObjects.moveValue(io);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Finishes up element drag operation.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param io       Element\r\n\t * @param pointer  Pointer\r\n\t * @param ev       Original event\r\n\t */\r\n\tpublic processResizeStop(io: InteractionObject, pointer?: IPointer, ev?: MouseEvent | TouchEvent): void {\r\n\r\n\t\t// Removed from transformedObjects\r\n\t\tthis.transformedObjects.removeValue(io);\r\n\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * ==========================================================================\r\n\t * Controls for InteractionObjects initiating directly\r\n\t * ==========================================================================\r\n\t * @hidden\r\n\t */\r\n\r\n\t/**\r\n\t * Manually triggers drag start on the element. Could be useful in cases\r\n\t * where tracking or dragging one element can also influence dragging another\r\n\t * element.\r\n\t *\r\n\t * Passing in `pointer` reference is advisable. If not passed in it will try\r\n\t * to determine which pointer to attach to. However, it's better to specify\r\n\t * it explicitly.\r\n\t *\r\n\t * @param io       Element\r\n\t * @param pointer  Pointer\r\n\t */\r\n\tpublic dragStart(io: InteractionObject, pointer?: IPointer): void {\r\n\t\tif (!pointer) {\r\n\t\t\tpointer = this.getDragPointer(io);\r\n\t\t}\r\n\r\n\t\tif (pointer) {\r\n\t\t\tthis.handleDown(io, pointer, pointer.lastDownEvent);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Manually ends drag on the element.\r\n\t *\r\n\t * @param io       Element\r\n\t * @param pointer  Pointer\r\n\t */\r\n\tpublic dragStop(io: InteractionObject, pointer?: IPointer, cancelled?: boolean): void {\r\n\t\tif (!pointer) {\r\n\t\t\tpointer = this.getDragPointer(io);\r\n\t\t}\r\n\r\n\t\tif (pointer && !cancelled) {\r\n\t\t\tthis.handleGlobalUp(pointer, pointer.lastUpEvent, cancelled);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * This method uses a fuzzy logic to find the pointer to be used for dragging.\r\n\t * Beware that this is not a rock-solid solution. If there are a few objects\r\n\t * being dragged at the same time, you may get unexepected results.\r\n\t *\r\n\t * @param io  InteractionObject to get pointers from\r\n\t * @return Pointer currently being used for dragging\r\n\t */\r\n\tpublic getDragPointer(io?: InteractionObject): $type.Optional<IPointer> {\r\n\t\tif (io) {\r\n\t\t\t// InteractionObject is supplied\r\n\t\t\t// Use it's first down pointer\r\n\t\t\treturn io.downPointers.getIndex(0);\r\n\t\t}\r\n\t\telse if (this.transformedObjects.length) {\r\n\t\t\t// Use first dragged object\r\n\t\t\treturn this.getDragPointer(this.transformedObjects.getIndex(0));\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn undefined;\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * ==========================================================================\r\n\t * Utils\r\n\t * ==========================================================================\r\n\t * @hidden\r\n\t */\r\n\r\n\t/**\r\n\t * Returns pointer id for the given event object.\r\n\t *\r\n\t * @param ev  Event\r\n\t * @return Pointer ID\r\n\t */\r\n\tprotected getPointerId(ev: any): string {\r\n\t\tlet id = \"\";\r\n\t\tif ($type.hasValue(ev.identifier)) {\r\n\t\t\tid = \"\" + <string>ev.identifier;\r\n\t\t} else if ($type.hasValue(ev.pointerId)) {\r\n\t\t\tid = \"\" + <string>ev.pointerId;\r\n\t\t} else {\r\n\t\t\tid = \"m\";\r\n\t\t}\r\n\t\treturn id.replace(\"-\", \"\");\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a cursor position of the event.\r\n\t *\r\n\t * @param ev  Original event\r\n\t * @return Event point\r\n\t */\r\n\tprotected getPointerPoint(ev: MouseEvent | Touch): IPoint {\r\n\t\treturn {\r\n\t\t\t\"x\": ev.clientX,\r\n\t\t\t\"y\": ev.clientY\r\n\t\t};\r\n\t}\r\n\r\n\t/**\r\n\t * Returns [[Pointer]] object that is associated with the Event.\r\n\t *\r\n\t * If no such [[Pointer]] object exists, it is created.\r\n\t *\r\n\t * @param ev  Event\r\n\t * @return Pointer\r\n\t */\r\n\tprotected getPointer(ev: MouseEvent | Touch): IPointer {\r\n\r\n\t\t// Get pointer id\r\n\t\tlet id = this.getPointerId(ev);\r\n\r\n\t\t// Get current coordinates\r\n\t\tlet point = this.getPointerPoint(ev);\r\n\r\n\t\t// Look for the pointer in the Dictionary if it maybe already exists\r\n\t\tlet pointer: IPointer;\r\n\t\tif (this.pointers.hasKey(id)) {\r\n\r\n\t\t\t// We already have such pointer\r\n\t\t\tpointer = this.pointers.getKey(id)!;\r\n\r\n\t\t\t// We need this, because Edge reuses pointer ids across touch and mouse\r\n\t\t\tpointer.touch = this.isPointerTouch(ev);\r\n\r\n\t\t\t// Reset pointer\r\n\t\t\t//pointer.point = point;\r\n\r\n\t\t}\r\n\t\telse {\r\n\t\t\t// Init pointer\r\n\t\t\tpointer = {\r\n\t\t\t\t\"id\": id,\r\n\t\t\t\t//\"touch\": !(ev instanceof MouseEvent) || ((<any>ev).pointerType && (<any>ev).pointerType != \"pointer\"),\r\n\t\t\t\t//\"touch\": !(ev instanceof MouseEvent) || ((<any>ev).pointerType && (<any>ev).pointerType != \"mouse\"),\r\n\t\t\t\t\"touch\": this.isPointerTouch(ev),\r\n\t\t\t\t\"startPoint\": point,\r\n\t\t\t\t\"startTime\": $time.getTime(),\r\n\t\t\t\t\"point\": point,\r\n\t\t\t\t\"track\": [],\r\n\t\t\t\t\"swipeCanceled\": false,\r\n\t\t\t\t\"dragStartEvents\": []\r\n\t\t\t};\r\n\r\n\t\t\t// Add first breadcrumb\r\n\t\t\tthis.addBreadCrumb(pointer, point);\r\n\r\n\t\t\t// Add for re-use later\r\n\t\t\tthis.pointers.setKey(id, pointer);\r\n\t\t}\r\n\r\n\t\t// Log last event\r\n\t\tpointer.lastEvent = ev;\r\n\r\n\t\tthis.lastPointer = pointer;\r\n\r\n\t\treturn pointer;\r\n\t}\r\n\r\n\t/**\r\n\t * Determines if pointer event originated from a touch pointer or mouse.\r\n\t *\r\n\t * @param ev  Original event\r\n\t * @return Touch pointer?\r\n\t */\r\n\tprotected isPointerTouch(ev: MouseEvent | Touch): boolean {\r\n\t\tif (typeof Touch !== \"undefined\" && ev instanceof Touch) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\telse if (typeof PointerEvent !== \"undefined\" && ev instanceof PointerEvent && $type.hasValue((<any>ev).pointerType)) {\r\n\t\t\tswitch ((<any>ev).pointerType) {\r\n\t\t\t\tcase \"touch\":\r\n\t\t\t\tcase \"pen\":\r\n\t\t\t\tcase 2:\r\n\t\t\t\t\treturn true;\r\n\t\t\t\tcase \"mouse\":\r\n\t\t\t\tcase 4:\r\n\t\t\t\t\treturn false;\r\n\t\t\t\tdefault:\r\n\t\t\t\t\treturn !(ev instanceof MouseEvent);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if ($type.hasValue((<any>ev).type)) {\r\n\t\t\tif ((<any>ev).type.match(/^mouse/)) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * Resets the poiner to original state, i.e. cleans movement information,\r\n\t * starting point, etc.\r\n\t *\r\n\t * @param pointer Pointer\r\n\t */\r\n\tprotected resetPointer(pointer: IPointer, ev: MouseEvent | PointerEvent | Touch): void {\r\n\t\t// Get current coordinates\r\n\t\tlet point = this.getPointerPoint(ev);;\r\n\t\tpointer.startTime = $time.getTime();\r\n\t\tpointer.startPoint = { x: point.x, y: point.y };\r\n\t\tpointer.point = { x: point.x, y: point.y };\r\n\t\tpointer.track = [];\r\n\t\tpointer.swipeCanceled = false;\r\n\t\t//clearTimeout(pointer.swipeTimeout);\r\n\t\t//clearTimeout(pointer.holdTimeout);\r\n\t}\r\n\r\n\t/**\r\n\t * Adds a \"breadcrumb\" point to the [[Pointer]] to log its movement path.\r\n\t *\r\n\t * @param pointer  Pointer\r\n\t * @param point    Point coordinates\r\n\t */\r\n\tprotected addBreadCrumb(pointer: IPointer, point: IPoint): void {\r\n\t\tpointer.track.push({\r\n\t\t\t\"timestamp\": $time.getTime(),\r\n\t\t\t\"point\": point\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Prepares the document for various touch-related operations.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic lockDocument(): void {\r\n\t\tthis.prepElement(this.body);\r\n\t}\r\n\r\n\t/**\r\n\t * Restores document functionality.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic unlockDocument(): void {\r\n\t\tif (this.transformedObjects.length == 0) {\r\n\t\t\tthis.restoreAllStyles(this.body);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Lock element (disable all touch)\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic lockElement(io: InteractionObject): void {\r\n\t\tthis.prepElement(io);\r\n\t}\r\n\r\n\t/**\r\n\t * Restores element's functionality.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic unlockElement(io: InteractionObject): void {\r\n\t\tthis.restoreAllStyles(io);\r\n\t}\r\n\r\n\t/**\r\n\t * Locks document's wheel scroll.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic lockWheel(): void {\r\n\t\twindow.addEventListener(\r\n\t\t\tthis._pointerEvents.wheel,\r\n\t\t\tthis.wheelLockEvent,\r\n\t\t\tthis._passiveSupported ? { passive: false } : false\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * Unlocks document's wheel scroll.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic unlockWheel(): void {\r\n\t\twindow.removeEventListener(\r\n\t\t\tthis._pointerEvents.wheel,\r\n\t\t\tthis.wheelLockEvent\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if top element at pointer's position belongs to the SVG.\r\n\t *\r\n\t * @ignore Exlude from docs\r\n\t * @param pointer  Pointer\r\n\t * @param svg      The <svg> element\r\n\t * @param id       A unique identifier of the object that is checking for locality\r\n\t * @return Belongs to SVG\r\n\t */\r\n\tpublic isLocalElement(pointer: IPointer, svg: SVGSVGElement, id: string): boolean {\r\n\t\tconst cached = this.getCache(\"local_pointer_\" + pointer.id);\r\n\t\tif ($type.hasValue(cached)) {\r\n\t\t\treturn cached;\r\n\t\t}\r\n\t\tconst doc = ($dom.getRoot(svg) || document);\r\n\t\tif (doc.elementFromPoint) {\r\n\t\t\tconst target = doc.elementFromPoint(pointer.point.x, pointer.point.y);\r\n\t\t\tconst local = target && $dom.contains(svg, <HTMLElement>target);\r\n\t\t\tthis.setCache(\"local_pointer_\" + pointer.id + \"_\" + id, local, 100);\r\n\t\t\treturn local;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/**\r\n\t * A function that cancels mouse wheel scroll.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param ev  Event object\r\n\t * @return Returns `false` to cancel\r\n\t */\r\n\tprotected wheelLockEvent(ev: Event): boolean {\r\n\t\tev.preventDefault();\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/**\r\n\t * Applies a set of styles to an element. Stores the original styles so they\r\n\t * can be restored later.\r\n\t *\r\n\t * @ignore\r\n\t * @param io      Element\r\n\t */\r\n\tpublic prepElement(io: InteractionObject): void {\r\n\r\n\t\tlet el = io.element;\r\n\r\n\t\tif (el) {\r\n\r\n\t\t\t// Define possible props\r\n\t\t\tlet props = [\r\n\t\t\t\t\"touchAction\", \"webkitTouchAction\", \"MozTouchAction\", \"MSTouchAction\", \"msTouchAction\", \"oTouchAction\",\r\n\t\t\t\t\"userSelect\", \"webkitUserSelect\", \"MozUserSelect\", \"MSUserSelect\", \"msUserSelect\", \"oUserSelect\",\r\n\t\t\t\t\"touchSelect\", \"webkitTouchSelect\", \"MozTouchSelect\", \"MSTouchSelect\", \"msTouchSelect\", \"oTouchSelect\",\r\n\t\t\t\t\"touchCallout\", \"webkitTouchCallout\", \"MozTouchCallout\", \"MSTouchCallout\", \"msTouchCallout\", \"oTouchCallout\",\r\n\t\t\t\t\"contentZooming\", \"webkitContentZooming\", \"MozContentZooming\", \"MSContentZooming\", \"msContentZooming\", \"oContentZooming\",\r\n\t\t\t\t\"userDrag\", \"webkitUserDrag\", \"MozUserDrag\", \"MSUserDrag\", \"msUserDrag\", \"oUserDrag\"\r\n\t\t\t];\r\n\t\t\tfor (let i = 0; i < props.length; i++) {\r\n\t\t\t\tif (props[i] in el.style) {\r\n\t\t\t\t\tthis.setTemporaryStyle(io, props[i], \"none\");\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Remove iOS-specific selection;\r\n\t\t\tthis.setTemporaryStyle(io, \"tapHighlightColor\", \"rgba(0, 0, 0, 0)\");\r\n\t\t\t//this.setTemporaryStyle(io, \"webkitOverflowScrolling\", \"none\");\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Restores replaced styles\r\n\t *\r\n\t * @ignore\r\n\t * @param  io  Element\r\n\t */\r\n\tpublic unprepElement(io: InteractionObject): void {\r\n\r\n\t\tlet el = io.element;\r\n\r\n\t\tif (el) {\r\n\r\n\t\t\t// Define possible props\r\n\t\t\tlet props = [\r\n\t\t\t\t\"touchAction\", \"webkitTouchAction\", \"MozTouchAction\", \"MSTouchAction\", \"msTouchAction\", \"oTouchAction\",\r\n\t\t\t\t\"userSelect\", \"webkitUserSelect\", \"MozUserSelect\", \"MSUserSelect\", \"msUserSelect\", \"oUserSelect\",\r\n\t\t\t\t\"touchSelect\", \"webkitTouchSelect\", \"MozTouchSelect\", \"MSTouchSelect\", \"msTouchSelect\", \"oTouchSelect\",\r\n\t\t\t\t\"touchCallout\", \"webkitTouchCallout\", \"MozTouchCallout\", \"MSTouchCallout\", \"msTouchCallout\", \"oTouchCallout\",\r\n\t\t\t\t\"contentZooming\", \"webkitContentZooming\", \"MozContentZooming\", \"MSContentZooming\", \"msContentZooming\", \"oContentZooming\",\r\n\t\t\t\t\"userDrag\", \"webkitUserDrag\", \"MozUserDrag\", \"MSUserDrag\", \"msUserDrag\", \"oUserDrag\"\r\n\t\t\t];\r\n\t\t\tfor (let i = 0; i < props.length; i++) {\r\n\t\t\t\tif (props[i] in el.style) {\r\n\t\t\t\t\tthis.restoreStyle(io, props[i]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Remove iOS-specific selection;\r\n\t\t\tthis.restoreStyle(io, \"tapHighlightColor\");\r\n\t\t\t//this.restoreStyle(io, \"webkitOverflowScrolling\");\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Returns an option associated with hit events.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param io      Element\r\n\t * @param option  Option key\r\n\t * @return Option value\r\n\t */\r\n\tpublic getHitOption(io: InteractionObject, option: keyof IHitOptions): any {\r\n\t\tlet res = io.hitOptions[option];\r\n\t\tif (typeof res === \"undefined\") {\r\n\t\t\tres = this.hitOptions[option];\r\n\t\t}\r\n\t\treturn res;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns an option associated with hover events.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param io      Element\r\n\t * @param option  Option key\r\n\t * @return Option value\r\n\t */\r\n\tpublic getHoverOption(io: InteractionObject, option: keyof IHoverOptions): any {\r\n\t\tlet res = io.hoverOptions[option];\r\n\t\tif (typeof res === \"undefined\") {\r\n\t\t\tres = this.hoverOptions[option];\r\n\t\t}\r\n\t\treturn res;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns an option associated with swipe events.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param io      Element\r\n\t * @param option  Option key\r\n\t * @return Option value\r\n\t */\r\n\tpublic getSwipeOption(io: InteractionObject, option: keyof ISwipeOptions): any {\r\n\t\tlet res = io.swipeOptions[option];\r\n\t\tif (typeof res === \"undefined\") {\r\n\t\t\tres = this.swipeOptions[option];\r\n\t\t}\r\n\t\treturn res;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns an option for keyboard.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param io      Element\r\n\t * @param option  Option key\r\n\t * @return Option value\r\n\t */\r\n\tpublic getKeyboardOption(io: InteractionObject, option: keyof IKeyboardOptions): any {\r\n\t\tlet res = io.keyboardOptions[option];\r\n\t\tif (typeof res === \"undefined\") {\r\n\t\t\tres = this.keyboardOptions[option];\r\n\t\t}\r\n\t\treturn res;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns an option for mouse.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param io      Element\r\n\t * @param option  Option key\r\n\t * @return Option value\r\n\t */\r\n\tpublic getMouseOption(io: InteractionObject, option: keyof IMouseOptions): any {\r\n\t\tlet res = io.mouseOptions[option];\r\n\t\tif (typeof res === \"undefined\") {\r\n\t\t\tres = this.mouseOptions[option];\r\n\t\t}\r\n\t\treturn res;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns an option associated with inertia.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param io      Element\r\n\t * @param type    Inertia type\r\n\t * @param option  Option key\r\n\t * @return Option value\r\n\t */\r\n\tpublic getInertiaOption(io: InteractionObject, type: InertiaTypes, option: keyof IInertiaOptions): any {\r\n\t\tlet options: any = io.inertiaOptions.getKey(type);\r\n\t\tlet res: IInertiaOptions;\r\n\t\tif (options && $type.hasValue(options[option])) {\r\n\t\t\tres = options[option];\r\n\t\t}\r\n\t\telse {\r\n\t\t\tres = (<any>this.inertiaOptions.getKey(type))[option];\r\n\t\t}\r\n\t\treturn res;\r\n\t}\r\n\r\n\t/**\r\n\t * Stops currently going on inertia. Useful if inertia is currently being\r\n\t * animated and the object is being interacted with.\r\n\t *\r\n\t * @param io Element\r\n\t */\r\n\tprotected stopInertia(io: InteractionObject): void {\r\n\t\tlet x: InertiaTypes;\r\n\t\tlet inertias: Array<InertiaTypes> = [\"move\", \"resize\"];\r\n\t\tfor (let i = 0; i < inertias.length; i++) {\r\n\t\t\tx = inertias[i];\r\n\t\t\tif (io.inertias.hasKey(x)) {\r\n\t\t\t\tlet inertia: $type.Optional<Inertia> = io.inertias.getKey(x);\r\n\t\t\t\tif (inertia) {\r\n\t\t\t\t\tinertia.dispose();\r\n\t\t\t\t\t//io.inertiaAnimations.removeKey(x);\r\n\t\t\t\t\t//this.processDragStop(io);\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Check if swiping is currently being performed on an object.\r\n\t *\r\n\t * @param io       Element\r\n\t * @param pointer  Pointer to check\r\n\t * @return `true` if swiping\r\n\t */\r\n\tpublic swiping(io: InteractionObject, pointer: IPointer): boolean {\r\n\t\tlet now = $time.getTime();\r\n\r\n\t\tif (pointer.swipeCanceled || !io.swipeable) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\telse if (\r\n\t\t\t(Math.abs(pointer.startPoint.y - pointer.point.y) < this.getSwipeOption(io, \"verticalThreshold\")) &&\r\n\t\t\t(pointer.startTime > (now - this.getSwipeOption(io, \"time\")))\r\n\t\t) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Returns `true` if a successfull swipe action was performed on an element.\r\n\t *\r\n\t * @param io       Element\r\n\t * @param pointer  Pointer\r\n\t * @return Swiped?\r\n\t */\r\n\tpublic swiped(io: InteractionObject, pointer: IPointer): boolean {\r\n\t\tlet now = $time.getTime();\r\n\t\tif (pointer.swipeCanceled) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\telse if (\r\n\t\t\t(Math.abs(pointer.startPoint.x - pointer.point.x) > this.getSwipeOption(io, \"horizontalThreshold\")) &&\r\n\t\t\t(Math.abs(pointer.startPoint.y - pointer.point.y) < this.getSwipeOption(io, \"verticalThreshold\")) &&\r\n\t\t\t(pointer.startTime > (now - this.getSwipeOption(io, \"time\")))\r\n\t\t) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Applies style to mouse cursor based on its stage in relation to\r\n\t * [[InteractionObject]].\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param Element\r\n\t */\r\n\tpublic applyCursorOverStyle(io: InteractionObject): void {\r\n\r\n\t\t// Get sprite's cursor ooptions\r\n\t\tlet options = io.cursorOptions;\r\n\r\n\t\tif (!$type.hasValue(options.overStyle)) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// Apply cursor down styles\r\n\t\tfor (let i = 0; i < options.overStyle.length; i++) {\r\n\t\t\t$dom.setStyle(io.element, options.overStyle[i].property, options.overStyle[i].value);\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Applies style to mouse cursor based on its stage in relation to\r\n\t * [[InteractionObject]].\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param io       Element\r\n\t * @param pointer  Pointer\r\n\t */\r\n\tpublic applyCursorDownStyle(io: InteractionObject, pointer: IPointer): void {\r\n\r\n\t\t// Not applicable for touch pointers since they don't display a cursor\r\n\t\tif (pointer && pointer.touch) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tconst downStyle = io.cursorOptions.downStyle;\r\n\t\t// Is down?\r\n\t\tif (io.downPointers.contains(pointer) && $type.hasValue(downStyle)) {\r\n\t\t\t// Apply cursor down styles\r\n\t\t\tfor (let i = 0; i < downStyle.length; i++) {\r\n\t\t\t\tthis.setTemporaryStyle(this.body, downStyle[i].property, downStyle[i].value);\r\n\t\t\t\tthis.setTemporaryStyle(io, downStyle[i].property, downStyle[i].value);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Restores original cursor style for the element.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param io       Element\r\n\t * @param pointer  Pointer\r\n\t */\r\n\tpublic restoreCursorDownStyle(io: InteractionObject, pointer: IPointer): void {\r\n\r\n\t\t// Not applicable for touch pointers since they don't display a cursor\r\n\t\tif (pointer && pointer.touch) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tconst downStyle = io.cursorOptions.downStyle;\r\n\r\n\t\t// Is down?\r\n\t\tif (io.downPointers.contains(pointer) && $type.hasValue(downStyle)) {\r\n\t\t\t// Apply cursor down styles\r\n\t\t\tfor (let i = 0; i < downStyle.length; i++) {\r\n\t\t\t\tthis.restoreStyle(this.body, downStyle[i].property);\r\n\t\t\t\tthis.restoreStyle(io, downStyle[i].property);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Sets style on the body of the document.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param style  Style definitions\r\n\t */\r\n\tpublic setGlobalStyle(style: Array<IStyleProperty> | IStyleProperty): void {\r\n\t\tlet body = getInteraction().body;\r\n\t\tlet styles = <Array<IStyleProperty>>($type.isArray(style) ? style : [style]);\r\n\t\tfor (let i = 0; i < styles.length; i++) {\r\n\t\t\tthis.setTemporaryStyle(body, styles[i].property, styles[i].value);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Restores style on the body of the document.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param style  Style definitions\r\n\t */\r\n\tpublic restoreGlobalStyle(style: Array<IStyleProperty> | IStyleProperty): void {\r\n\t\tlet body = getInteraction().body;\r\n\t\tlet styles = <Array<IStyleProperty>>($type.isArray(style) ? style : [style]);\r\n\t\tfor (let i = 0; i < styles.length; i++) {\r\n\t\t\tthis.restoreStyle(body, styles[i].property);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if element is a non-cahrt element.\r\n\t *\r\n\t * @param io  InteractionObject\r\n\t * @return Global element?\r\n\t */\r\n\tprotected isGlobalElement(io: InteractionObject): boolean {\r\n\t\treturn document.body === io.element;\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if pointer has moved since it was created.\r\n\t *\r\n\t * @param pointer    Pointer\r\n\t * @param tolerance  Tolerance in pixels\r\n\t * @param minTime    Minimum time required for the pointer to be down to be considered moved\r\n\t * @return `true` if the pointer has moved\r\n\t */\r\n\tpublic moved(pointer: IPointer, tolerance: number, minTime: number = 300): boolean {\r\n\r\n\t\t/*// If there was more time, we don't care if cursor actually moved\r\n\t\tlet duration = $time.getTime() - pointer.startTime;\r\n\t\tif ($type.hasValue(minTime) && (minTime > duration)) {\r\n\t\t\treturn false;\r\n\t\t}*/\r\n\r\n\t\t// That was quick measure shift\r\n\t\tlet shift = this.getShift(pointer);\r\n\r\n\t\treturn (Math.abs(shift.x) > tolerance) || (Math.abs(shift.y) > tolerance);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns if pointer is \"old\", meaning it has been pressing for more than\r\n\t * X milliseconds.\r\n\t *\r\n\t * @ignore\r\n\t * @param pointer  Pointer\r\n\t * @param minTime  Minimum time to consider pointer old\r\n\t * @return {boolean}\r\n\t */\r\n\tpublic old(pointer: IPointer, minTime: number = 300): boolean {\r\n\t\treturn $time.getTime() - pointer.startTime > minTime;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns total a shift in pointers coordinates between its original\r\n\t * position and now.\r\n\t *\r\n\t * @param pointer  Pointer\r\n\t * @return Shift in coordinates (x/y)\r\n\t */\r\n\tpublic getShift(pointer: IPointer): IPoint {\r\n\t\treturn {\r\n\t\t\t\"x\": pointer.startPoint.x - pointer.point.x,\r\n\t\t\t\"y\": pointer.startPoint.y - pointer.point.y\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a point from [[Pointer]]'s move history at a certain timetamp.\r\n\t *\r\n\t * @param pointer    Pointer\r\n\t * @param timestamp  Timestamp\r\n\t * @return Point\r\n\t */\r\n\tpublic getTrailPoint(pointer: IPointer, timestamp: number): $type.Optional<IBreadcrumb> {\r\n\t\tlet res: $type.Optional<IBreadcrumb>;\r\n\t\tfor (let i = 0; i < pointer.track.length; i++) {\r\n\t\t\tif (pointer.track[i].timestamp >= timestamp) {\r\n\t\t\t\tres = pointer.track[i];\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn res;\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if same pointer already exists in the list.\r\n\t *\r\n\t * @param list     List to check agains\r\n\t * @param pointer  Pointer\r\n\t * @return Exists?\r\n\t */\r\n\tprotected pointerExists(list: List<IPointer>, pointer: IPointer): boolean {\r\n\t\tlet exists = false;\r\n\t\tlist.each((item) => {\r\n\t\t\tif (item == pointer) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\texists = item.point.x == pointer.point.x && item.point.y == pointer.point.y;\r\n\t\t});\r\n\t\treturn exists;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns an [[InteractionObject]] representation of a DOM element.\r\n\t *\r\n\t * You can use this on any HTML or SVG element, to add interactive features\r\n\t * to it.\r\n\t *\r\n\t * @param element  Element\r\n\t * @return InteractionObject\r\n\t */\r\n\tpublic getInteraction(element: HTMLElement | SVGSVGElement): InteractionObject {\r\n\t\treturn new InteractionObject(element);\r\n\t}\r\n\r\n\t/**\r\n\t * Sets a style property on an element. Stores original value to be restored\r\n\t * later with [[restoreStyle]].\r\n\t *\r\n\t * @see {@link restoreStyle}\r\n\t * @param io        Element\r\n\t * @param property  Property\r\n\t * @param value     Value\r\n\t */\r\n\tpublic setTemporaryStyle(io: InteractionObject, property: string, value: string): void {\r\n\r\n\t\t// Get element\r\n\t\t//let el = io.element.tagName == \"g\" ? <SVGSVGElement>io.element.parentNode : io.element;\r\n\t\tlet el = io.element;\r\n\r\n\t\t// Save original property if it is set and hasn't been saved before already\r\n\t\tif ($type.hasValue((<any>el.style)[property]) && !io.replacedStyles.hasKey(property)) {\r\n\t\t\tio.replacedStyles.setKey(property, (<any>el.style)[property]);\r\n\t\t}\r\n\r\n\t\t// Replace with the new one\r\n\t\t$dom.setStyle(el, property, value);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Restores specific style on an element.\r\n\t *\r\n\t * @param io        Element\r\n\t * @param property  Style property\r\n\t */\r\n\tpublic restoreStyle(io: InteractionObject, property: string): void {\r\n\r\n\t\t// Reset style\r\n\t\tif (io.replacedStyles.hasKey(property)) {\r\n\t\t\t(<any>io.element.style)[property] = io.replacedStyles.getKey(property);\r\n\t\t\tio.replacedStyles.removeKey(property);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tdelete (<any>io.element.style)[property];\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Restore temporarily reset styles on an element.\r\n\t *\r\n\t * @param io Element\r\n\t */\r\n\tpublic restoreAllStyles(io: InteractionObject): void {\r\n\t\t$iter.each(io.replacedStyles.iterator(), (a) => {\r\n\t\t\tconst key = a[0];\r\n\t\t\tconst value = a[1];\r\n\t\t\t(<any>io.element.style)[key] = value;\r\n\t\t\tio.replacedStyles.removeKey(key);\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Disposes this object and cleans up after itself.\r\n\t */\r\n\tpublic dispose(): void {\r\n\t\tif (!this.isDisposed()) {\r\n\t\t\tsuper.dispose();\r\n\t\t\tthis.restoreAllStyles(this.body);\r\n\t\t\tthis.unlockWheel();\r\n\t\t}\r\n\t}\r\n\r\n\t// @ts-ignore Used for debugging\r\n\tprivate log(text: string, ev: MouseEvent | TouchEvent | PointerEvent, io?: InteractionObject): void {\r\n\t\tlet show = true;\r\n\t\tif (show) {\r\n\t\t\t// Touchlist?\r\n\t\t\tif ((<any>ev).changedTouches) {\r\n\t\t\t\tfor (let i = 0; i < (<any>ev).changedTouches.length; i++) {\r\n\t\t\t\t\tthis.logTouch(text, ev.type, (<any>ev).changedTouches[i])\r\n\t\t\t\t}\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\t// Get type\r\n\t\t\tlet type = \"\";\r\n\t\t\tif ((<any>ev).pointerType) {\r\n\t\t\t\tswitch ((<any>ev).pointerType) {\r\n\t\t\t\t\tcase 2:\r\n\t\t\t\t\t\ttype = \"touch\";\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 4:\r\n\t\t\t\t\t\ttype = \"mouse\";\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\ttype = (<any>ev).pointerType;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse if (typeof TouchEvent != \"undefined\" && ev instanceof TouchEvent) {\r\n\t\t\t\ttype = \"touch\";\r\n\t\t\t}\r\n\t\t\telse if (ev.type.match(/^mouse/)) {\r\n\t\t\t\ttype = \"mouse\";\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\ttype = \"???\";\r\n\t\t\t}\r\n\r\n\t\t\t// Get ID\r\n\t\t\tlet id = \"\";\r\n\t\t\tif ($type.hasValue((<any>ev).identifier)) {\r\n\t\t\t\tid = <string>(<any>ev).identifier;\r\n\t\t\t} else if ($type.hasValue((<any>ev).pointerId)) {\r\n\t\t\t\tid = <string>(<any>ev).pointerId;\r\n\t\t\t} else {\r\n\t\t\t\tid = \"???\";\r\n\t\t\t}\r\n\r\n\t\t\tif (io) {\r\n\t\t\t\tconsole.log(text + \" (\" + io.uid + \")  \" + ev.type + \"  \" + type + \"  \" + id);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tconsole.log(text + \"  \" + ev.type + \"  \" + type + \"  \" + id);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Checks whether there are currently any objects being transformed (dragged\r\n\t * or resized).\r\n\t *\r\n\t * If `except` is set, that object will be ignored.\r\n\t *\r\n\t * @since 4.9.3\r\n\t * @param   except  Ignore this object(s)\r\n\t * @return          Objects are being transformed\r\n\t */\r\n\tpublic areTransformed(except?: InteractionObject | InteractionObject[]): boolean {\r\n\t\tlet count = this.transformedObjects.length;\r\n\t\tif (except) {\r\n\t\t\tconst ex = $type.isArray(except) ? except : [except];\r\n\t\t\tfor (let i = 0; i < ex.length; i++) {\r\n\t\t\t\tif (this.transformedObjects.contains(ex[i])) {\r\n\t\t\t\t\tcount--;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn count > 0;\r\n\t}\r\n\r\n\t/**\r\n\t * Log.\r\n\t */\r\n\tprivate logTouch(text: string, type: string, ev: Touch): void {\r\n\t\tconsole.log(text + \"  \" + type + \"  \" + \"touch\" + \"  \" + ev.identifier);\r\n\t}\r\n\r\n\t/**\r\n\t * Indicates if passive mode options is supported by this browser.\r\n\t */\r\n\tprivate static _passiveSupported: boolean;\r\n\r\n\t/**\r\n\t * Indicates if passive mode options is supported by this browser.\r\n\t */\r\n\tstatic get passiveSupported() {\r\n\r\n\t\tif (this._passiveSupported == null) {\r\n\r\n\t\t\t// Check for passive mode support\r\n\t\t\ttry {\r\n\t\t\t\tlet options = Object.defineProperty({}, \"passive\", {\r\n\t\t\t\t\tget: () => {\r\n\t\t\t\t\t\tthis._passiveSupported = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t\twindow.addEventListener(\"test\", options, options);\r\n\t\t\t\twindow.removeEventListener(\"test\", options, options);\r\n\t\t\t} catch (err) {\r\n\t\t\t\tthis._passiveSupported = false;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn this._passiveSupported;\r\n\t}\r\n\r\n}\r\n\r\n\r\nlet interaction: Interaction | null = null;\r\n\r\n/**\r\n * Returns a single unified global instance of [[Interaction]].\r\n *\r\n * All code should use this function, rather than create their own instances\r\n * of [[Interaction]].\r\n */\r\nexport function getInteraction(): Interaction {\r\n\tif (interaction == null) {\r\n\t\tinteraction = new Interaction();\r\n\t}\r\n\r\n\treturn interaction;\r\n}\r\n"]},"metadata":{},"sourceType":"module"}