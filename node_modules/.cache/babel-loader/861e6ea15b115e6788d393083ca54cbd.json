{"ast":null,"code":"/**\r\n * DateAxis module\r\n */\nimport { __assign, __extends } from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\nimport { ValueAxis, ValueAxisDataItem } from \"./ValueAxis\";\nimport { List } from \"../../core/utils/List\";\nimport { Dictionary } from \"../../core/utils/Dictionary\";\nimport { DateAxisBreak } from \"./DateAxisBreak\";\nimport { registry } from \"../../core/Registry\";\nimport * as $time from \"../../core/utils/Time\";\nimport * as $type from \"../../core/utils/Type\";\nimport * as $iter from \"../../core/utils/Iterator\";\nimport * as $math from \"../../core/utils/Math\";\nimport * as $array from \"../../core/utils/Array\";\nimport * as $object from \"../../core/utils/Object\";\nimport * as $utils from \"../../core/utils/Utils\";\nimport { OrderedListTemplate } from \"../../core/utils/SortedList\";\n/**\r\n * ============================================================================\r\n * DATA ITEM\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * Defines data item for [[DateAxis]].\r\n *\r\n * @see {@link DataItem}\r\n */\n\nvar DateAxisDataItem =\n/** @class */\nfunction (_super) {\n  __extends(DateAxisDataItem, _super);\n  /**\r\n   * Constructor\r\n   */\n\n\n  function DateAxisDataItem() {\n    var _this = _super.call(this) || this;\n\n    _this.className = \"DateAxisDataItem\";\n\n    _this.applyTheme();\n\n    _this.values.date = {};\n    _this.values.endDate = {};\n    return _this;\n  }\n\n  Object.defineProperty(DateAxisDataItem.prototype, \"date\", {\n    /**\r\n     * @return Date\r\n     */\n    get: function get() {\n      return this.dates[\"date\"];\n    },\n\n    /**\r\n     * Date position of the data item.\r\n     *\r\n     * @param date  Date\r\n     */\n    set: function set(date) {\n      this.setDate(\"date\", date);\n      this.value = date.getTime();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DateAxisDataItem.prototype, \"endDate\", {\n    /**\r\n     * @return End date\r\n     */\n    get: function get() {\n      return this.dates[\"endDate\"];\n    },\n\n    /**\r\n     * End date for data item.\r\n     *\r\n     * @param date End date\r\n     */\n    set: function set(date) {\n      this.setDate(\"endDate\", date);\n      this.endValue = date.getTime();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return DateAxisDataItem;\n}(ValueAxisDataItem);\n\nexport { DateAxisDataItem };\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * Used to create a date/time-based axis for the chart.\r\n *\r\n * ```TypeScript\r\n * // Create the axis\r\n * let xAxis = chart.xAxes.push(new am4charts.DateAxis());\r\n *\r\n * // Set settings\r\n * xAxis.title.text = \"Time\";\r\n * ```\r\n * ```JavaScript\r\n * // Create the axis\r\n * var valueAxis = chart.xAxes.push(new am4charts.DateAxis());\r\n *\r\n * // Set settings\r\n * valueAxis.title.text = \"Time\";\r\n * ```\r\n * ```JSON\r\n * \"xAxes\": [{\r\n *   \"type\": \"DateAxis\",\r\n *   \"title\": {\r\n *     \"text\": \"Time\"\r\n *   }\r\n * }]\r\n * ```\r\n *\r\n * @see {@link IDateAxisEvents} for a list of available Events\r\n * @see {@link IDateAxisAdapters} for a list of available Adapters\r\n * @see {@link https://www.amcharts.com/docs/v4/concepts/axes/date-axis/} got `DateAxis` documention\r\n * @important\r\n */\n\nvar DateAxis =\n/** @class */\nfunction (_super) {\n  __extends(DateAxis, _super);\n  /**\r\n   * Constructor\r\n   */\n\n\n  function DateAxis() {\n    var _this = // Init\n    _super.call(this) || this;\n\n    _this._gapBreaks = false;\n    /**\r\n     * A list of date/time intervals for Date axis.\r\n     *\r\n     * This define various granularities available for the axis. For example\r\n     * if you have an axis spanning an hour, and space for 6 grid lines / labels\r\n     * the axis will choose the granularity of 10 minutes, displaying a label\r\n     * every 10 minutes.\r\n     *\r\n     * Default intervals:\r\n     *\r\n     * ```JSON\r\n     * [\r\n     *  { timeUnit: \"millisecond\", count: 1 },\r\n     *  { timeUnit: \"millisecond\", count: 5 },\r\n     *  { timeUnit: \"millisecond\", count: 10 },\r\n     *  { timeUnit: \"millisecond\", count: 50 },\r\n     *  { timeUnit: \"millisecond\", count: 100 },\r\n     *  { timeUnit: \"millisecond\", count: 500 },\r\n     *  { timeUnit: \"second\", count: 1 },\r\n     *  { timeUnit: \"second\", count: 5 },\r\n     *  { timeUnit: \"second\", count: 10 },\r\n     *  { timeUnit: \"second\", count: 30 },\r\n     *  { timeUnit: \"minute\", count: 1 },\r\n     *  { timeUnit: \"minute\", count: 5 },\r\n     *  { timeUnit: \"minute\", count: 10 },\r\n     *  { timeUnit: \"minute\", count: 30 },\r\n     *  { timeUnit: \"hour\", count: 1 },\r\n     *  { timeUnit: \"hour\", count: 3 },\r\n     *  { timeUnit: \"hour\", count: 6 },\r\n     *  { timeUnit: \"hour\", count: 12 },\r\n     *  { timeUnit: \"day\", count: 1 },\r\n     *  { timeUnit: \"day\", count: 2 },\r\n     *  { timeUnit: \"day\", count: 3 },\r\n     *  { timeUnit: \"day\", count: 4 },\r\n     *  { timeUnit: \"day\", count: 5 },\r\n     *  { timeUnit: \"week\", count: 1 },\r\n     *  { timeUnit: \"month\", count: 1 },\r\n     *  { timeUnit: \"month\", count: 2 },\r\n     *  { timeUnit: \"month\", count: 3 },\r\n     *  { timeUnit: \"month\", count: 6 },\r\n     *  { timeUnit: \"year\", count: 1 },\r\n     *  { timeUnit: \"year\", count: 2 },\r\n     *  { timeUnit: \"year\", count: 5 },\r\n     *  { timeUnit: \"year\", count: 10 },\r\n     *  { timeUnit: \"year\", count: 50 },\r\n     *  { timeUnit: \"year\", count: 100 }\r\n     * ]\r\n     * ```\r\n     */\n\n    _this.gridIntervals = new List();\n    /**\r\n     * If data aggregation is enabled by setting Axis' `groupData = true`, the\r\n     * chart will try to aggregate data items into grouped data items.\r\n     *\r\n     * If there are more data items in selected period than `groupCount`, it will\r\n     * group data items into bigger period.\r\n     *\r\n     * For example seconds might be grouped into 10-second aggregate data items.\r\n     *\r\n     * This setting indicates what group intervals can the chart group to.\r\n     *\r\n     * Default intervals:\r\n     *\r\n     * ```JSON\r\n     * [\r\n     *   { timeUnit: \"millisecond\", count: 1},\r\n     *   { timeUnit: \"millisecond\", count: 10 },\r\n     *   { timeUnit: \"millisecond\", count: 100 },\r\n     *   { timeUnit: \"second\", count: 1 },\r\n     *   { timeUnit: \"second\", count: 10 },\r\n     *   { timeUnit: \"minute\", count: 1 },\r\n     *   { timeUnit: \"minute\", count: 10 },\r\n     *   { timeUnit: \"hour\", count: 1 },\r\n     *   { timeUnit: \"day\", count: 1 },\r\n     *   { timeUnit: \"week\", count: 1 },\r\n     *   { timeUnit: \"month\", count: 1 },\r\n     *   { timeUnit: \"year\", count: 1 }\r\n     * ]\r\n     * ```\r\n     * `groupData = true` does not work in combination with `skipEmptyPeriods = true`.\r\n     *\r\n     * @since 4.7.0\r\n     * @see {@link https://www.amcharts.com/docs/v4/concepts/axes/date-axis/#Dynamic_data_item_grouping} for more information about dynamic data item grouping.\r\n     */\n\n    _this.groupIntervals = new List();\n    /**\r\n     * A collection of date formats to use when formatting different time units\r\n     * on Date/time axis.\r\n     *\r\n     * Actual defaults will depend on the language locale set for the chart.\r\n     *\r\n     * To override format for a specific time unit, say days, you need to set\r\n     * the appropriate key to a format string. E.g.:\r\n     *\r\n     * ```TypeScript\r\n     * axis.dateFormats.setKey(\"day\", \"MMMM d, yyyy\");\r\n     * ```\r\n     * ```JavaScript\r\n     * axis.dateFormats.setKey(\"day\", \"MMMM d, yyyy\");\r\n     * ```\r\n     * ```JSON\r\n     * \"xAxes\": [{\r\n     *   \"type\": \"DateAxis\",\r\n     *   \"dateFormats\": {\r\n     *     \"day\": \"MMMM d, yyyy\"\r\n     *   }\r\n     * }]\r\n     * ```\r\n     *\r\n     * @see {@link DateFormatter}\r\n     */\n\n    _this.dateFormats = new Dictionary();\n    /**\r\n     * These formats are applied to labels that are first in a larger unit.\r\n     *\r\n     * For example, if we have a DateAxis with days on it, the first day of month\r\n     * indicates a break in month - a start of the bigger period.\r\n     *\r\n     * For those labels, `periodChangeDateFormats` are applied instead of\r\n     * `dateFormats`.\r\n     *\r\n     * This allows us implement convenient structures, like instead of:\r\n     *\r\n     * `Jan 1 - Jan 2 - Jan 3 - ...`\r\n     *\r\n     * We can have:\r\n     *\r\n     * `Jan - 1 - 2 - 3 - ...`\r\n     *\r\n     * This can be disabled by setting `markUnitChange = false`.\r\n     */\n\n    _this.periodChangeDateFormats = new Dictionary();\n    /**\r\n     * Actual interval (granularity) derived from the actual data.\r\n     */\n\n    _this._baseIntervalReal = {\n      timeUnit: \"day\",\n      count: 1\n    };\n    /**\r\n     */\n\n    _this._prevSeriesTime = {};\n    /**\r\n     * [_minDifference description]\r\n     *\r\n     * @todo Description\r\n     */\n\n    _this._minDifference = {};\n    /**\r\n     * @ignore\r\n     */\n\n    _this._firstWeekDay = 1;\n    /**\r\n     * A collection of start timestamps to use as axis' min timestamp for\r\n     * particular data item item periods.\r\n     *\r\n     * @since 4.7.0\r\n     * @readonly\r\n     */\n\n    _this.groupMin = {};\n    /**\r\n     * A collection of start timestamps to use as axis' max timestamp for\r\n     * particular data item item periods.\r\n     *\r\n     * @since 4.7.0\r\n     * @readonly\r\n     */\n\n    _this.groupMax = {};\n    _this.className = \"DateAxis\";\n\n    _this.setPropertyValue(\"markUnitChange\", true);\n\n    _this.snapTooltip = true;\n    _this.tooltipPosition = \"pointer\";\n\n    _this.setPropertyValue(\"groupData\", false);\n\n    _this.groupCount = 200;\n\n    _this.events.on(\"parentset\", _this.getDFFormatter, _this, false); // Translatable defaults are applied in `applyInternalDefaults()`\n    // ...\n    // Define default intervals\n\n\n    _this.gridIntervals.pushAll([{\n      timeUnit: \"millisecond\",\n      count: 1\n    }, {\n      timeUnit: \"millisecond\",\n      count: 5\n    }, {\n      timeUnit: \"millisecond\",\n      count: 10\n    }, {\n      timeUnit: \"millisecond\",\n      count: 50\n    }, {\n      timeUnit: \"millisecond\",\n      count: 100\n    }, {\n      timeUnit: \"millisecond\",\n      count: 500\n    }, {\n      timeUnit: \"second\",\n      count: 1\n    }, {\n      timeUnit: \"second\",\n      count: 5\n    }, {\n      timeUnit: \"second\",\n      count: 10\n    }, {\n      timeUnit: \"second\",\n      count: 30\n    }, {\n      timeUnit: \"minute\",\n      count: 1\n    }, {\n      timeUnit: \"minute\",\n      count: 5\n    }, {\n      timeUnit: \"minute\",\n      count: 10\n    }, {\n      timeUnit: \"minute\",\n      count: 15\n    }, {\n      timeUnit: \"minute\",\n      count: 30\n    }, {\n      timeUnit: \"hour\",\n      count: 1\n    }, {\n      timeUnit: \"hour\",\n      count: 3\n    }, {\n      timeUnit: \"hour\",\n      count: 6\n    }, {\n      timeUnit: \"hour\",\n      count: 12\n    }, {\n      timeUnit: \"day\",\n      count: 1\n    }, {\n      timeUnit: \"day\",\n      count: 2\n    }, {\n      timeUnit: \"day\",\n      count: 3\n    }, {\n      timeUnit: \"day\",\n      count: 4\n    }, {\n      timeUnit: \"day\",\n      count: 5\n    }, {\n      timeUnit: \"week\",\n      count: 1\n    }, {\n      timeUnit: \"month\",\n      count: 1\n    }, {\n      timeUnit: \"month\",\n      count: 2\n    }, {\n      timeUnit: \"month\",\n      count: 3\n    }, {\n      timeUnit: \"month\",\n      count: 6\n    }, {\n      timeUnit: \"year\",\n      count: 1\n    }, {\n      timeUnit: \"year\",\n      count: 2\n    }, {\n      timeUnit: \"year\",\n      count: 5\n    }, {\n      timeUnit: \"year\",\n      count: 10\n    }, {\n      timeUnit: \"year\",\n      count: 50\n    }, {\n      timeUnit: \"year\",\n      count: 100\n    }, {\n      timeUnit: \"year\",\n      count: 200\n    }, {\n      timeUnit: \"year\",\n      count: 500\n    }, {\n      timeUnit: \"year\",\n      count: 1000\n    }, {\n      timeUnit: \"year\",\n      count: 2000\n    }, {\n      timeUnit: \"year\",\n      count: 5000\n    }, {\n      timeUnit: \"year\",\n      count: 10000\n    }, {\n      timeUnit: \"year\",\n      count: 100000\n    }]);\n\n    _this.groupIntervals.pushAll([{\n      timeUnit: \"millisecond\",\n      count: 1\n    }, {\n      timeUnit: \"millisecond\",\n      count: 10\n    }, {\n      timeUnit: \"millisecond\",\n      count: 100\n    }, {\n      timeUnit: \"second\",\n      count: 1\n    }, {\n      timeUnit: \"second\",\n      count: 10\n    }, {\n      timeUnit: \"minute\",\n      count: 1\n    }, {\n      timeUnit: \"minute\",\n      count: 10\n    }, {\n      timeUnit: \"hour\",\n      count: 1\n    }, {\n      timeUnit: \"day\",\n      count: 1\n    }, {\n      timeUnit: \"week\",\n      count: 1\n    }, {\n      timeUnit: \"month\",\n      count: 1\n    }, {\n      timeUnit: \"year\",\n      count: 1\n    }]); // Set field name\n\n\n    _this.axisFieldName = \"date\"; // Apply theme\n\n    _this.applyTheme();\n\n    return _this;\n  }\n  /**\r\n   * A function which applies fills to axis cells.\r\n   *\r\n   * Default function fills every second fill. You can set this to a function\r\n   * that follows some other logic.\r\n   *\r\n   * Function should accept a [[DateAxisDataItem]] and modify its `axisFill`\r\n   * property accordingly.\r\n   */\n\n\n  DateAxis.prototype.fillRule = function (dataItem) {\n    var value = dataItem.value;\n    var axis = dataItem.component;\n    var gridInterval = axis._gridInterval;\n    var gridDuration = $time.getDuration(gridInterval.timeUnit, gridInterval.count);\n\n    if (Math.round((value - axis.min) / gridDuration) / 2 == Math.round(Math.round((value - axis.min) / gridDuration) / 2)) {\n      dataItem.axisFill.__disabled = true;\n    } else {\n      dataItem.axisFill.__disabled = false;\n    }\n  };\n  /**\r\n   * Sets defaults that instantiate some objects that rely on parent, so they\r\n   * cannot be set in constructor.\r\n   */\n\n\n  DateAxis.prototype.applyInternalDefaults = function () {\n    _super.prototype.applyInternalDefaults.call(this); // Set default date formats\n\n\n    if (!this.dateFormats.hasKey(\"millisecond\")) {\n      this.dateFormats.setKey(\"millisecond\", this.language.translate(\"_date_millisecond\"));\n    }\n\n    if (!this.dateFormats.hasKey(\"second\")) {\n      this.dateFormats.setKey(\"second\", this.language.translate(\"_date_second\"));\n    }\n\n    if (!this.dateFormats.hasKey(\"minute\")) {\n      this.dateFormats.setKey(\"minute\", this.language.translate(\"_date_minute\"));\n    }\n\n    if (!this.dateFormats.hasKey(\"hour\")) {\n      this.dateFormats.setKey(\"hour\", this.language.translate(\"_date_hour\"));\n    }\n\n    if (!this.dateFormats.hasKey(\"day\")) {\n      this.dateFormats.setKey(\"day\", this.language.translate(\"_date_day\"));\n    }\n\n    if (!this.dateFormats.hasKey(\"week\")) {\n      this.dateFormats.setKey(\"week\", this.language.translate(\"_date_day\")); // not a mistake\n    }\n\n    if (!this.dateFormats.hasKey(\"month\")) {\n      this.dateFormats.setKey(\"month\", this.language.translate(\"_date_month\"));\n    }\n\n    if (!this.dateFormats.hasKey(\"year\")) {\n      this.dateFormats.setKey(\"year\", this.language.translate(\"_date_year\"));\n    }\n\n    if (!this.periodChangeDateFormats.hasKey(\"millisecond\")) {\n      this.periodChangeDateFormats.setKey(\"millisecond\", this.language.translate(\"_date_millisecond\"));\n    }\n\n    if (!this.periodChangeDateFormats.hasKey(\"second\")) {\n      this.periodChangeDateFormats.setKey(\"second\", this.language.translate(\"_date_second\"));\n    }\n\n    if (!this.periodChangeDateFormats.hasKey(\"minute\")) {\n      this.periodChangeDateFormats.setKey(\"minute\", this.language.translate(\"_date_minute\"));\n    }\n\n    if (!this.periodChangeDateFormats.hasKey(\"hour\")) {\n      this.periodChangeDateFormats.setKey(\"hour\", this.language.translate(\"_date_day\"));\n    }\n\n    if (!this.periodChangeDateFormats.hasKey(\"day\")) {\n      this.periodChangeDateFormats.setKey(\"day\", this.language.translate(\"_date_day\"));\n    }\n\n    if (!this.periodChangeDateFormats.hasKey(\"week\")) {\n      this.periodChangeDateFormats.setKey(\"week\", this.language.translate(\"_date_day\"));\n    }\n\n    if (!this.periodChangeDateFormats.hasKey(\"month\")) {\n      this.periodChangeDateFormats.setKey(\"month\", this.language.translate(\"_date_month\") + \" \" + this.language.translate(\"_date_year\"));\n    }\n  };\n  /**\r\n   * Returns a new/empty [[DataItem]] of the type appropriate for this object.\r\n   *\r\n   * @see {@link DataItem}\r\n   * @return Data Item\r\n   */\n\n\n  DateAxis.prototype.createDataItem = function () {\n    return new DateAxisDataItem();\n  };\n  /**\r\n   * Returns a new/empty [[AxisBreak]] of the appropriate type.\r\n   *\r\n   * @return Axis break\r\n   */\n\n\n  DateAxis.prototype.createAxisBreak = function () {\n    return new DateAxisBreak();\n  };\n  /**\r\n   * Validates Axis' data items.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  DateAxis.prototype.validateDataItems = function () {\n    // allows to keep selection of the same size\n    var start = this.start;\n    var end = this.end;\n    var baseDuration = this.baseDuration;\n    var periodCount = (this.max - this.min) / baseDuration;\n    this._firstWeekDay = this.getFirstWeekDay();\n    this.getDFFormatter();\n\n    _super.prototype.validateDataItems.call(this);\n\n    var mainBaseDuration = $time.getDuration(this.mainBaseInterval.timeUnit, this.mainBaseInterval.count);\n    this.maxZoomFactor = Math.max(1, (this.max - this.min) / mainBaseDuration);\n    this._deltaMinMax = this.baseDuration / 2; // allows to keep selection of the same size\n\n    var newPeriodCount = (this.max - this.min) / baseDuration;\n    start = start + (end - start) * (1 - periodCount / newPeriodCount);\n    this.zoom({\n      start: start,\n      end: end\n    }, false, true); // added instantlyto solve zoomout problem when we have axes gaps. @todo: check how this affects maxZoomFactor\n  };\n  /**\r\n   * Handles process after zoom.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Does nothing?\r\n   */\n\n\n  DateAxis.prototype.handleSelectionExtremesChange = function () {};\n  /**\r\n   * Calculates all positions, related to axis as per current zoom.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  DateAxis.prototype.calculateZoom = function () {\n    var _this = this;\n\n    _super.prototype.calculateZoom.call(this);\n\n    var difference = this.adjustDifference(this._minZoomed, this._maxZoomed);\n    var dataSetChanged = false; // if data has to be grouped, choose interval and set dataset\n\n    if (this.groupData && $type.hasValue(difference)) {\n      var mainBaseInterval = this.mainBaseInterval;\n      var modifiedDifference = difference + (this.startLocation + (1 - this.endLocation)) * this.baseDuration;\n      var groupInterval = void 0;\n\n      if (this.groupInterval) {\n        groupInterval = __assign({}, this.groupInterval);\n      } else {\n        groupInterval = this.chooseInterval(0, modifiedDifference, this.groupCount, this.groupIntervals);\n\n        if ($time.getDuration(groupInterval.timeUnit, groupInterval.count) < $time.getDuration(mainBaseInterval.timeUnit, mainBaseInterval.count)) {\n          groupInterval = __assign({}, mainBaseInterval);\n        }\n      }\n\n      this._groupInterval = groupInterval;\n      var newId = groupInterval.timeUnit + groupInterval.count;\n\n      if (this._currentDataSetId != newId) {\n        this._currentDataSetId = newId;\n        this.dispatch(\"groupperiodchanged\");\n      }\n\n      this.series.each(function (series) {\n        if (series.baseAxis == _this) {\n          if (series.setDataSet(_this._currentDataSetId)) {\n            dataSetChanged = true;\n          }\n        }\n      });\n    }\n\n    var gridInterval = this.chooseInterval(0, difference, this._gridCount);\n\n    if ($time.getDuration(gridInterval.timeUnit, gridInterval.count) < this.baseDuration) {\n      gridInterval = __assign({}, this.baseInterval);\n    }\n\n    this._gridInterval = gridInterval;\n    this._nextGridUnit = $time.getNextUnit(gridInterval.timeUnit); // the following is needed to avoid grid flickering while scrolling\n\n    this._intervalDuration = $time.getDuration(gridInterval.timeUnit, gridInterval.count);\n    this._gridDate = $time.round(new Date(this.minZoomed - $time.getDuration(gridInterval.timeUnit, gridInterval.count)), gridInterval.timeUnit, gridInterval.count, this._firstWeekDay, this._df.utc, new Date(this.min), this._df.timezoneMinutes, this._df.timezone); // tell series start/end\n\n    $iter.each(this.series.iterator(), function (series) {\n      if (series.baseAxis == _this) {\n        var field_1 = series.getAxisField(_this);\n        var minZoomed = $time.round(new Date(_this._minZoomed + _this.baseDuration * 0.05), _this.baseInterval.timeUnit, _this.baseInterval.count, _this._firstWeekDay, _this._df.utc, undefined, _this._df.timezoneMinutes, _this._df.timezone).getTime();\n        var minZoomedStr = minZoomed.toString();\n        var startDataItem = series.dataItemsByAxis.getKey(_this.uid).getKey(minZoomedStr + series.currentDataSetId);\n        var startIndex = 0;\n\n        if (_this.start != 0) {\n          if (startDataItem) {\n            startDataItem = _this.findFirst(startDataItem, minZoomed, field_1);\n            startIndex = startDataItem.index;\n          } else {\n            startIndex = series.dataItems.findClosestIndex(_this._minZoomed, function (x) {\n              return x[field_1];\n            }, \"left\");\n          }\n        } // 1 millisecond is removed so that if only first item is selected, it would not count in the second.\n\n\n        var baseInterval = _this.baseInterval;\n        var maxZoomed = $time.add($time.round(new Date(_this._maxZoomed), baseInterval.timeUnit, baseInterval.count, _this._firstWeekDay, _this._df.utc, undefined, _this._df.timezoneMinutes, _this._df.timezone), baseInterval.timeUnit, baseInterval.count, _this._df.utc).getTime();\n        var maxZoomedStr = maxZoomed.toString();\n        var endDataItem = series.dataItemsByAxis.getKey(_this.uid).getKey(maxZoomedStr + series.currentDataSetId);\n        var endIndex = series.dataItems.length;\n\n        if (_this.end != 1) {\n          if (endDataItem) {\n            endIndex = endDataItem.index;\n          } else {\n            maxZoomed -= 1;\n            endIndex = series.dataItems.findClosestIndex(maxZoomed, function (x) {\n              return x[field_1];\n            }, \"right\"); // not good - if end is in the gap, indexes go like 5,4,3,4,2,1\n            //if (endIndex < series.dataItems.length) {\n\n            endIndex++; //}\n          }\n        }\n\n        if (series.max(_this) < minZoomed) {\n          series.startIndex = series.dataItems.length;\n          series.endIndex = series.dataItems.length;\n          series.outOfRange = true;\n        } else if (series.min(_this) > maxZoomed) {\n          series.startIndex = 0;\n          series.endIndex = 0;\n          series.outOfRange = true;\n        } else {\n          series.outOfRange = false;\n          series.startIndex = startIndex;\n          series.endIndex = endIndex;\n        } //\tconsole.log(series.name, startIndex, endIndex);\n\n\n        if (!dataSetChanged && series.dataRangeInvalid) {\n          series.validateDataRange();\n        }\n      }\n    });\n  };\n\n  DateAxis.prototype.findFirst = function (dataItem, time, key) {\n    var index = dataItem.index;\n\n    if (index > 0) {\n      var series = dataItem.component;\n      var previousDataItem = series.dataItems.getIndex(index - 1);\n      var previousDate = previousDataItem[key];\n\n      if (!previousDate || previousDate.getTime() < time) {\n        return dataItem;\n      } else {\n        return this.findFirst(previousDataItem, time, key);\n      }\n    } else {\n      return dataItem;\n    }\n  };\n  /**\r\n   * (Re)validates data.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  DateAxis.prototype.validateData = function () {\n    _super.prototype.validateData.call(this);\n\n    if (!$type.isNumber(this.baseInterval.count)) {\n      this.baseInterval.count = 1;\n    }\n  };\n\n  Object.defineProperty(DateAxis.prototype, \"minDifference\", {\n    /**\r\n     * @ignore\r\n     */\n    get: function get() {\n      var _this = this;\n\n      var minDifference = Number.MAX_VALUE;\n      this.series.each(function (series) {\n        if (minDifference > _this._minDifference[series.uid]) {\n          minDifference = _this._minDifference[series.uid];\n        }\n      });\n\n      if (minDifference == Number.MAX_VALUE || minDifference == 0) {\n        minDifference = $time.getDuration(\"day\");\n      }\n\n      return minDifference;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * [dataChangeUpdate description]\r\n   *\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description\r\n   */\n\n  DateAxis.prototype.seriesDataChangeUpdate = function (series) {\n    this._minDifference[series.uid] = Number.MAX_VALUE;\n  };\n  /**\r\n   * [postProcessSeriesDataItems description]\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description\r\n   */\n\n\n  DateAxis.prototype.postProcessSeriesDataItems = function (series) {\n    var _this = this;\n\n    this._firstWeekDay = this.getFirstWeekDay();\n\n    if (series) {\n      this.seriesGroupUpdate(series);\n    } else {\n      this.series.each(function (series) {\n        _this.seriesGroupUpdate(series);\n      });\n    }\n\n    this.addEmptyUnitsBreaks();\n  };\n\n  DateAxis.prototype.seriesGroupUpdate = function (series) {\n    var _this = this;\n\n    if (JSON.stringify(series._baseInterval[this.uid]) != JSON.stringify(this.mainBaseInterval)) {\n      series._baseInterval[this.uid] = this.mainBaseInterval;\n      series.mainDataSet.each(function (dataItem) {\n        _this.postProcessSeriesDataItem(dataItem);\n      });\n\n      if (this.groupData) {\n        this.groupSeriesData(series);\n      }\n    }\n  };\n  /**\r\n   * Calculates series group data.\r\n   *\r\n   * @param  series  Series\r\n   * @ignore\r\n   */\n\n\n  DateAxis.prototype.groupSeriesData = function (series) {\n    var _this = this;\n\n    if (series.baseAxis == this && series.dataItems.length > 0 && !series.dataGrouped) {\n      series.bulletsContainer.removeChildren(); // make array of intervals which will be used;\n\n      var intervals_1 = [];\n      var mainBaseInterval = this.mainBaseInterval;\n      var mainIntervalDuration_1 = $time.getDuration(mainBaseInterval.timeUnit, mainBaseInterval.count);\n      this.groupIntervals.each(function (interval) {\n        var intervalDuration = $time.getDuration(interval.timeUnit, interval.count);\n\n        if (intervalDuration > mainIntervalDuration_1 && intervalDuration < _this.max - _this.min || _this.groupInterval) {\n          intervals_1.push(interval);\n        }\n      });\n\n      if (series._dataSets) {\n        series._dataSets.each(function (key, dataItems) {\n          dataItems.each(function (dataItem) {\n            dataItem.dispose();\n          });\n          dataItems.clear();\n        });\n\n        series._dataSets.clear();\n      }\n\n      series.dataGrouped = true;\n      $array.each(intervals_1, function (interval) {\n        //let mainBaseInterval = this._mainBaseInterval;\n        var key = \"date\" + _this.axisLetter; // create data set\n\n        var dataSetId = interval.timeUnit + interval.count; // todo: check where this clone goes\n\n        var dataSet = new OrderedListTemplate(series.mainDataSet.template.clone());\n        series.dataSets.setKey(dataSetId, dataSet);\n        var dataItems = series.mainDataSet;\n        var previousTime = Number.NEGATIVE_INFINITY;\n        var i = 0;\n        var newDataItem;\n        var dataFields = [];\n        $object.each(series.dataFields, function (dfkey, df) {\n          var dfk = dfkey;\n\n          if (dfk != key && dfk.indexOf(\"Show\") == -1) {\n            dataFields.push(dfk);\n          }\n        });\n        var roundedDate;\n        dataItems.each(function (dataItem) {\n          var date = dataItem.getDate(key);\n\n          if (date) {\n            var time = date.getTime();\n            roundedDate = $time.round(new Date(time), interval.timeUnit, interval.count, _this._df.firstDayOfWeek, _this._df.utc, undefined, _this._df.timezoneMinutes, _this._df.timezone);\n            var currentTime = roundedDate.getTime(); // changed period\t\t\t\t\t\t\t\t\n\n            if (previousTime < currentTime) {\n              if (newDataItem && series._adapterO) {\n                $array.each(dataFields, function (vkey) {\n                  newDataItem.values[vkey].value = series._adapterO.apply(\"groupDataItem\", {\n                    dataItem: newDataItem,\n                    interval: interval,\n                    dataField: vkey,\n                    date: roundedDate,\n                    value: newDataItem.values[vkey].value\n                  }).value;\n                  newDataItem.values[vkey].workingValue = newDataItem.values[vkey].value;\n                });\n              }\n\n              newDataItem = dataSet.create();\n              newDataItem.dataContext = {};\n              newDataItem.setWorkingLocation(\"dateX\", series.dataItems.template.locations.dateX, 0);\n              newDataItem.setWorkingLocation(\"openDateX\", series.dataItems.template.locations.openDateX, 0);\n              newDataItem.setWorkingLocation(\"dateY\", series.dataItems.template.locations.dateY, 0);\n              newDataItem.setWorkingLocation(\"openDateY\", series.dataItems.template.locations.openDateY, 0);\n              newDataItem.component = series; // other Dates?\n\n              newDataItem.setDate(key, roundedDate);\n              newDataItem._index = i;\n              i++;\n              $array.each(dataFields, function (vkey) {\n                //let groupFieldName = vkey + \"Group\";\n                var dvalues = dataItem.values[vkey];\n\n                if (dvalues) {\n                  var value = dvalues.value;\n\n                  if (series._adapterO) {\n                    value = series._adapterO.apply(\"groupValue\", {\n                      dataItem: dataItem,\n                      interval: interval,\n                      dataField: vkey,\n                      date: roundedDate,\n                      value: value\n                    }).value;\n                  }\n\n                  var values = newDataItem.values[vkey];\n\n                  if ($type.isNumber(value)) {\n                    values.value = value;\n                    values.workingValue = value;\n                    values.open = value;\n                    values.close = value;\n                    values.low = value;\n                    values.high = value;\n                    values.sum = value;\n                    values.average = value;\n                    values.count = 1;\n                  } else {\n                    values.count = 0;\n                  }\n                }\n              });\n\n              _this.postProcessSeriesDataItem(newDataItem, interval);\n\n              $object.each(series.propertyFields, function (key, fieldValue) {\n                var f = key;\n                var value = dataItem.properties[key];\n\n                if ($type.hasValue(value)) {\n                  newDataItem.hasProperties = true;\n                  newDataItem.setProperty(f, value);\n                }\n              });\n              newDataItem.groupDataItems = [dataItem];\n              previousTime = currentTime;\n            } else {\n              if (newDataItem) {\n                $array.each(dataFields, function (vkey) {\n                  var groupFieldName = series.groupFields[vkey];\n                  var dvalues = dataItem.values[vkey];\n\n                  if (dvalues) {\n                    var value = dvalues.value;\n\n                    if (series._adapterO) {\n                      value = series._adapterO.apply(\"groupValue\", {\n                        dataItem: dataItem,\n                        interval: interval,\n                        dataField: vkey,\n                        date: roundedDate,\n                        value: value\n                      }).value;\n                    }\n\n                    if ($type.isNumber(value)) {\n                      var values = newDataItem.values[vkey];\n\n                      if (!$type.isNumber(values.open)) {\n                        values.open = value;\n                      }\n\n                      values.close = value;\n\n                      if (values.low > value || !$type.isNumber(values.low)) {\n                        values.low = value;\n                      }\n\n                      if (values.high < value || !$type.isNumber(values.high)) {\n                        values.high = value;\n                      }\n\n                      if ($type.isNumber(values.sum)) {\n                        values.sum += value;\n                      } else {\n                        values.sum = value;\n                      }\n\n                      values.count++;\n                      values.average = values.sum / values.count;\n\n                      if ($type.isNumber(values[groupFieldName])) {\n                        values.value = values[groupFieldName];\n                        values.workingValue = values.value;\n                      }\n                    }\n                  }\n                });\n                $utils.copyProperties(dataItem.properties, newDataItem.properties);\n                $object.each(series.propertyFields, function (key, fieldValue) {\n                  var f = key;\n                  var value = dataItem.properties[key];\n\n                  if ($type.hasValue(value)) {\n                    newDataItem.hasProperties = true;\n                    newDataItem.setProperty(f, value);\n                  }\n                });\n                newDataItem.groupDataItems.push(dataItem);\n              }\n            }\n          }\n\n          if (newDataItem) {\n            $utils.copyProperties(dataItem.dataContext, newDataItem.dataContext);\n          }\n        });\n\n        if (newDataItem && series._adapterO) {\n          $array.each(dataFields, function (vkey) {\n            newDataItem.values[vkey].value = series._adapterO.apply(\"groupDataItem\", {\n              dataItem: newDataItem,\n              interval: interval,\n              dataField: vkey,\n              date: roundedDate,\n              value: newDataItem.values[vkey].value\n            }).value;\n            newDataItem.values[vkey].workingValue = newDataItem.values[vkey].value;\n          });\n        }\n      });\n      this.calculateZoom();\n    }\n  };\n  /**\r\n   * @ignore\r\n   */\n\n\n  DateAxis.prototype.getDFFormatter = function () {\n    this._df = this.dateFormatter;\n  };\n  /**\r\n   * [postProcessSeriesDataItem description]\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description\r\n   * @param dataItem Data item\r\n   */\n\n\n  DateAxis.prototype.postProcessSeriesDataItem = function (dataItem, interval) {\n    var _this = this; // we need to do this for all series data items not only added recently, as baseInterval might change\n\n\n    var intervalID = \"\";\n\n    if (interval) {\n      intervalID = interval.timeUnit + interval.count;\n    } else {\n      interval = this.mainBaseInterval;\n    }\n\n    var series = dataItem.component;\n    var dataItemsByAxis = series.dataItemsByAxis.getKey(this.uid);\n    $object.each(dataItem.dates, function (key) {\n      var date = dataItem.getDate(key);\n      var time = date.getTime();\n      var startDate = $time.round(new Date(time), interval.timeUnit, interval.count, _this._firstWeekDay, _this._df.utc, undefined, _this._df.timezoneMinutes, _this._df.timezone);\n      var startTime = startDate.getTime();\n      var endDate = $time.add(new Date(startTime), interval.timeUnit, interval.count, _this._df.utc);\n      dataItem.setCalculatedValue(key, startTime, \"open\");\n      dataItem.setCalculatedValue(key, endDate.getTime(), \"close\");\n      dataItemsByAxis.setKey(startTime + intervalID, dataItem);\n    });\n  };\n  /**\r\n   * Collapses empty stretches of date/time scale by creating [[AxisBreak]]\r\n   * elements for them.\r\n   *\r\n   * Can be used to automatically remove strethes without data, like weekends.\r\n   *\r\n   * No, need to call this manually. It will automatically be done if\r\n   * `skipEmptyPeriods = true`.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  DateAxis.prototype.addEmptyUnitsBreaks = function () {\n    var _this = this;\n\n    if (this.skipEmptyPeriods && $type.isNumber(this.min) && $type.isNumber(this.max)) {\n      var timeUnit = this.baseInterval.timeUnit;\n      var count = this.baseInterval.count;\n\n      if (this._axisBreaks) {\n        this._axisBreaks.clear(); // TODO: what about breaks added by user?\n\n      }\n\n      var date = $time.round(new Date(this.min), timeUnit, count, this._firstWeekDay, this._df.utc, undefined, this._df.timezoneMinutes, this._df.timezone);\n      var axisBreak = void 0;\n\n      var _loop_1 = function _loop_1() {\n        $time.add(date, timeUnit, count, this_1._df.utc);\n        var startTime = date.getTime();\n        var startTimeStr = startTime.toString();\n        var hasData = $iter.contains(this_1.series.iterator(), function (series) {\n          return !!series.dataItemsByAxis.getKey(_this.uid).getKey(startTimeStr + series.currentDataSetId);\n        }); // open break if not yet opened\n\n        if (!hasData) {\n          if (!axisBreak) {\n            axisBreak = this_1.axisBreaks.create();\n            axisBreak.startDate = new Date(startTime);\n            this_1._gapBreaks = true;\n          }\n        } else {\n          // close if already opened\n          if (axisBreak) {\n            // close at end time minus one millisecond\n            axisBreak.endDate = new Date(startTime - 1);\n            axisBreak = undefined;\n          }\n        }\n      };\n\n      var this_1 = this;\n\n      while (date.getTime() < this.max - this.baseDuration) {\n        _loop_1();\n      }\n    }\n  };\n  /**\r\n   * Updates positioning of Axis breaks after something changes.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  DateAxis.prototype.fixAxisBreaks = function () {\n    var _this = this;\n\n    _super.prototype.fixAxisBreaks.call(this);\n\n    var axisBreaks = this._axisBreaks;\n\n    if (axisBreaks) {\n      if (axisBreaks.length > 0) {\n        // process breaks\n        axisBreaks.each(function (axisBreak) {\n          var breakGridCount = Math.ceil(_this._gridCount * (Math.min(_this.end, axisBreak.endPosition) - Math.max(_this.start, axisBreak.startPosition)) / (_this.end - _this.start));\n          axisBreak.gridInterval = _this.chooseInterval(0, axisBreak.adjustedEndValue - axisBreak.adjustedStartValue, breakGridCount);\n          var gridDate = $time.round(new Date(axisBreak.adjustedStartValue), axisBreak.gridInterval.timeUnit, axisBreak.gridInterval.count, _this._firstWeekDay, _this._df.utc, undefined, _this._df.timezoneMinutes, _this._df.timezone);\n\n          if (gridDate.getTime() > axisBreak.startDate.getTime()) {\n            $time.add(gridDate, axisBreak.gridInterval.timeUnit, axisBreak.gridInterval.count, _this._df.utc);\n          }\n\n          axisBreak.gridDate = gridDate;\n        });\n      }\n    }\n  };\n  /**\r\n   * @ignore\r\n   */\n\n\n  DateAxis.prototype.getFirstWeekDay = function () {\n    if (this._df) {\n      return this._df.firstDayOfWeek;\n    }\n\n    return 1;\n  };\n  /**\r\n   * [getGridDate description]\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description\r\n   * @param date           [description]\r\n   * @param intervalCount  [description]\r\n   * @return [description]\r\n   */\n\n\n  DateAxis.prototype.getGridDate = function (date, intervalCount) {\n    var timeUnit = this._gridInterval.timeUnit;\n    var realIntervalCount = this._gridInterval.count; // round date\n\n    $time.round(date, timeUnit, 1, this._firstWeekDay, this._df.utc, undefined, this._df.timezoneMinutes, this._df.timezone);\n    var prevTimestamp = date.getTime();\n    var newDate = $time.copy(date); // modify date by adding intervalcount\n\n    var timestamp = $time.add(newDate, timeUnit, intervalCount, this._df.utc).getTime(); // if it's axis break, get first rounded date which is not in a break\n\n    var axisBreak = this.isInBreak(timestamp);\n\n    if (axisBreak && axisBreak.endDate) {\n      newDate = new Date(axisBreak.endDate.getTime());\n      $time.round(newDate, timeUnit, realIntervalCount, this._firstWeekDay, this._df.utc, undefined, this._df.timezoneMinutes, this._df.timezone);\n\n      if (newDate.getTime() < axisBreak.endDate.getTime()) {\n        $time.add(newDate, timeUnit, realIntervalCount, this._df.utc);\n      }\n\n      timestamp = newDate.getTime();\n    } // get duration between grid lines with break duration removed\n\n\n    var durationBreaksRemoved = this.adjustDifference(prevTimestamp, timestamp); // calculate how many time units fit to this duration\n\n    var countBreaksRemoved = Math.round(durationBreaksRemoved / $time.getDuration(timeUnit)); // if less units fit, add one and repeat\n\n    if (countBreaksRemoved < realIntervalCount) {\n      return this.getGridDate(date, intervalCount + realIntervalCount);\n    }\n\n    return newDate;\n  };\n  /**\r\n   * [getBreaklessDate description]\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description\r\n   * @param axisBreak  [description]\r\n   * @param timeUnit   [description]\r\n   * @param count      [description]\r\n   * @return [description]\r\n   */\n\n\n  DateAxis.prototype.getBreaklessDate = function (axisBreak, timeUnit, count) {\n    var date = new Date(axisBreak.endValue);\n    $time.round(date, timeUnit, count, this._firstWeekDay, this._df.utc, undefined, this._df.timezoneMinutes, this._df.timezone);\n    $time.add(date, timeUnit, count, this._df.utc);\n    var timestamp = date.getTime();\n    axisBreak = this.isInBreak(timestamp);\n\n    if (axisBreak) {\n      return this.getBreaklessDate(axisBreak, timeUnit, count);\n    }\n\n    return date;\n  };\n  /**\r\n   * (Re)validates all Axis elements.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description (review)\r\n   */\n\n\n  DateAxis.prototype.validateAxisElements = function () {\n    var _this = this;\n\n    if ($type.isNumber(this.max) && $type.isNumber(this.min)) {\n      this.calculateZoom(); // first regular items\n\n      var timestamp = this._gridDate.getTime();\n\n      var timeUnit = this._gridInterval.timeUnit;\n      var intervalCount = this._gridInterval.count;\n      var prevGridDate = $time.copy(this._gridDate);\n      var dataItemsIterator_1 = this._dataItemsIterator;\n      this.resetIterators();\n\n      var _loop_2 = function _loop_2() {\n        var date = this_2.getGridDate($time.copy(prevGridDate), intervalCount);\n        timestamp = date.getTime();\n        var endDate = $time.copy(date); // you might think it's easier to add intervalduration to timestamp, however it won't work for months or years which are not of the same length\n\n        endDate = $time.add(endDate, timeUnit, intervalCount, this_2._df.utc);\n        var format = this_2.dateFormats.getKey(timeUnit);\n\n        if (this_2.markUnitChange && prevGridDate) {\n          if ($time.checkChange(date, prevGridDate, this_2._nextGridUnit, this_2._df.utc)) {\n            if (timeUnit !== \"year\") {\n              format = this_2.periodChangeDateFormats.getKey(timeUnit);\n            }\n          }\n        }\n\n        var text = this_2._df.format(date, format);\n\n        var dataItem = dataItemsIterator_1.find(function (x) {\n          return x.text === text;\n        });\n\n        if (dataItem.__disabled) {\n          dataItem.__disabled = false;\n        }\n\n        this_2.appendDataItem(dataItem);\n        dataItem.axisBreak = undefined;\n        dataItem.date = date;\n        dataItem.endDate = endDate;\n        dataItem.text = text;\n        this_2.validateDataElement(dataItem);\n        prevGridDate = date;\n      };\n\n      var this_2 = this;\n\n      while (timestamp <= this._maxZoomed) {\n        _loop_2();\n      } // breaks later\n\n\n      var renderer_1 = this.renderer;\n\n      if (this._axisBreaks) {\n        $iter.each(this._axisBreaks.iterator(), function (axisBreak) {\n          if (axisBreak.breakSize > 0) {\n            var timeUnit_1 = axisBreak.gridInterval.timeUnit;\n            var intervalCount_1 = axisBreak.gridInterval.count; // only add grid if gap is bigger then minGridDistance\n\n            if ($math.getDistance(axisBreak.startPoint, axisBreak.endPoint) > renderer_1.minGridDistance * 4) {\n              var timestamp_1 = axisBreak.gridDate.getTime();\n              var prevGridDate_1;\n              var count = 0;\n\n              var _loop_3 = function _loop_3() {\n                var date = $time.copy(axisBreak.gridDate);\n                timestamp_1 = $time.add(date, timeUnit_1, intervalCount_1 * count, _this._df.utc).getTime();\n                count++;\n\n                if (timestamp_1 > axisBreak.adjustedStartValue && timestamp_1 < axisBreak.adjustedEndValue) {\n                  var endDate = $time.copy(date); // you might think it's easier to add intervalduration to timestamp, however it won't work for months or years which are not of the same length\n\n                  endDate = $time.add(endDate, timeUnit_1, intervalCount_1, _this._df.utc);\n\n                  var format = _this.dateFormats.getKey(timeUnit_1);\n\n                  if (_this.markUnitChange && prevGridDate_1) {\n                    if ($time.checkChange(date, prevGridDate_1, _this._nextGridUnit, _this._df.utc)) {\n                      if (timeUnit_1 !== \"year\") {\n                        format = _this.periodChangeDateFormats.getKey(timeUnit_1);\n                      }\n                    }\n                  }\n\n                  var text_1 = _this._df.format(date, format);\n\n                  var dataItem = dataItemsIterator_1.find(function (x) {\n                    return x.text === text_1;\n                  });\n\n                  if (dataItem.__disabled) {\n                    dataItem.__disabled = false;\n                  } //this.processDataItem(dataItem);\n\n\n                  _this.appendDataItem(dataItem);\n\n                  dataItem.axisBreak = axisBreak;\n                  axisBreak.dataItems.moveValue(dataItem);\n                  dataItem.date = date;\n                  dataItem.endDate = endDate;\n                  dataItem.text = text_1;\n                  prevGridDate_1 = date;\n\n                  _this.validateDataElement(dataItem);\n                }\n              };\n\n              while (timestamp_1 <= axisBreak.adjustedMax) {\n                _loop_3();\n              }\n            }\n          }\n        });\n      }\n    }\n  };\n  /**\r\n   * Validates Axis data item.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param dataItem Data item\r\n   */\n\n\n  DateAxis.prototype.validateDataElement = function (dataItem) {\n    dataItem.itemIndex = this._axisItemCount;\n    this._axisItemCount++;\n\n    if ($type.isNumber(this.max) && $type.isNumber(this.min)) {\n      var renderer = this.renderer;\n      var timestamp = dataItem.value;\n      var endTimestamp = dataItem.endValue;\n\n      if (!$type.isNumber(endTimestamp)) {\n        endTimestamp = timestamp;\n      }\n\n      var position = this.valueToPosition(timestamp);\n      var endPosition = this.valueToPosition(endTimestamp);\n      var fillEndPosition = endPosition;\n\n      if (!dataItem.isRange && this._gridInterval.count > this.baseInterval.count) {\n        endPosition = position + (endPosition - position) / (this._gridInterval.count / this.baseInterval.count);\n      }\n\n      dataItem.position = position;\n      var tick = dataItem.tick;\n\n      if (tick && !tick.disabled) {\n        renderer.updateTickElement(tick, position, endPosition);\n      }\n\n      var grid = dataItem.grid;\n\n      if (grid && !grid.disabled) {\n        renderer.updateGridElement(grid, position, endPosition);\n      }\n\n      var fill = dataItem.axisFill;\n\n      if (fill && !fill.disabled) {\n        renderer.updateFillElement(fill, position, fillEndPosition);\n\n        if (!dataItem.isRange) {\n          this.fillRule(dataItem);\n        }\n      }\n\n      var mask = dataItem.mask;\n\n      if (mask) {\n        renderer.updateFillElement(mask, position, endPosition);\n      }\n\n      if (dataItem.bullet) {\n        renderer.updateBullet(dataItem.bullet, position, endPosition);\n      }\n\n      var label = dataItem.label;\n\n      if (label && !label.disabled) {\n        var location_1 = label.location;\n\n        if (location_1 == 0) {\n          if (this._gridInterval.count == 1 && this._gridInterval.timeUnit != \"week\" && !dataItem.isRange) {\n            location_1 = 0.5;\n          } else {\n            location_1 = 0;\n          }\n        }\n\n        renderer.updateLabelElement(label, position, endPosition, location_1);\n      }\n    }\n  };\n\n  Object.defineProperty(DateAxis.prototype, \"baseDuration\", {\n    /**\r\n     * A duration in milliseconds of the `baseInterval`.\r\n     *\r\n     * @return Duration (ms)\r\n     */\n    get: function get() {\n      return $time.getDuration(this.baseInterval.timeUnit, this.baseInterval.count);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Adjusts min/max values.\r\n   *\r\n   * @ignore Exclude from docs.\r\n   * @todo Description (review)\r\n   * @param min  Min timestamp\r\n   * @param max  Max timestamp\r\n   * @return Adjusted min/max step\r\n   */\n\n  DateAxis.prototype.adjustMinMax = function (min, max) {\n    return {\n      min: min,\n      max: max,\n      step: this.baseDuration\n    };\n  };\n  /**\r\n   * Adjusts the minimum timestamp as per cell start location.\r\n   *\r\n   * @param value  Value\r\n   * @return Adjusted value\r\n   */\n\n\n  DateAxis.prototype.fixMin = function (value) {\n    // like this because months are not equal\n    var interval = this.baseInterval;\n    var startTime = $time.round(new Date(value), interval.timeUnit, interval.count, this._firstWeekDay, this._df.utc, undefined, this._df.timezoneMinutes, this._df.timezone).getTime();\n    var endTime = $time.add(new Date(startTime), interval.timeUnit, interval.count, this._df.utc).getTime();\n    return startTime + (endTime - startTime) * this.startLocation;\n  };\n  /**\r\n   * Adjusts the maximum timestamp as per cell start location.\r\n   *\r\n   * @param value  Value\r\n   * @return Adjusted value\r\n   */\n\n\n  DateAxis.prototype.fixMax = function (value) {\n    // like this because months are not equal\n    var interval = this.baseInterval;\n    var startTime = $time.round(new Date(value), interval.timeUnit, interval.count, this._firstWeekDay, this._df.utc, undefined, this._df.timezoneMinutes, this._df.timezone).getTime();\n    var endTime = $time.add(new Date(startTime), interval.timeUnit, interval.count, this._df.utc).getTime();\n    return startTime + (endTime - startTime) * this.endLocation;\n  };\n  /**\r\n   * [chooseInterval description]\r\n   *\r\n   * @ignore Exclude from docs.\r\n   * @todo Description\r\n   * @param index      [description]\r\n   * @param duration   [description]\r\n   * @param gridCount  [description]\r\n   * @return [description]\r\n   */\n\n\n  DateAxis.prototype.chooseInterval = function (index, duration, gridCount, intervals) {\n    if (!intervals) {\n      intervals = this.gridIntervals;\n    }\n\n    var gridInterval = intervals.getIndex(index);\n    var intervalDuration = $time.getDuration(gridInterval.timeUnit, gridInterval.count);\n    var lastIndex = intervals.length - 1;\n\n    if (index >= lastIndex) {\n      return __assign({}, intervals.getIndex(lastIndex));\n    }\n\n    var count = Math.ceil(duration / intervalDuration);\n\n    if (duration < intervalDuration && index > 0) {\n      return __assign({}, intervals.getIndex(index - 1));\n    }\n\n    if (count <= gridCount) {\n      return __assign({}, intervals.getIndex(index));\n    } else {\n      if (index + 1 < intervals.length) {\n        return this.chooseInterval(index + 1, duration, gridCount, intervals);\n      } else {\n        return __assign({}, intervals.getIndex(index));\n      }\n    }\n  };\n  /**\r\n   * Formats the value according to axis' own [[DateFormatter]].\r\n   *\r\n   * @param value  Source value\r\n   * @return Formatted value\r\n   */\n\n\n  DateAxis.prototype.formatLabel = function (value) {\n    return this._df.format(value);\n  };\n  /**\r\n   * Converts a Date to an asbolute pixel position within Axis.\r\n   *\r\n   * @param date  Date\r\n   * @return Position (px)\r\n   */\n\n\n  DateAxis.prototype.dateToPosition = function (date) {\n    return this.valueToPosition(date.getTime());\n  };\n  /**\r\n   * Converts a numeric timestamp or a `Date` to a relative position on axis.\r\n   *\r\n   * @param date  Date or a timestamp\r\n   * @return Relative position\r\n   */\n\n\n  DateAxis.prototype.anyToPosition = function (date) {\n    if (date instanceof Date) {\n      return this.dateToPosition(date);\n    } else {\n      return this.valueToPosition(date);\n    }\n  };\n  /**\r\n   * Converts date to orientation point (x, y, angle) on axis\r\n   *\r\n   * @param date Date\r\n   * @return IOrientationPoint\r\n   */\n\n\n  DateAxis.prototype.dateToPoint = function (date) {\n    var position = this.dateToPosition(date);\n    var point = this.renderer.positionToPoint(position);\n    var angle = this.renderer.positionToAngle(position);\n    return {\n      x: point.x,\n      y: point.y,\n      angle: angle\n    };\n  };\n  /**\r\n   * Converts a numeric value to orientation (x, y, angle) point on axis\r\n   *\r\n   * @param value  Value\r\n   * @return Orientation point\r\n   */\n\n\n  DateAxis.prototype.anyToPoint = function (date) {\n    if (date instanceof Date) {\n      return this.dateToPoint(date);\n    } else {\n      return this.valueToPoint(date);\n    }\n  };\n  /**\r\n   * Converts pixel position within Axis to a corresponding Date.\r\n   *\r\n   * @param position  Position (px)\r\n   * @return Date\r\n   */\n\n\n  DateAxis.prototype.positionToDate = function (position) {\n    return new Date(this.positionToValue(position));\n  };\n  /**\r\n   * Returns the relative position on axis for series' data item's value.\r\n   *\r\n   * @since 4.5.14\r\n   * @param  dataItem  Data item\r\n   * @param  key       Data field to get value from\r\n   * @param  location  Location (0-1)\r\n   * @return           Relative position\r\n   */\n\n\n  DateAxis.prototype.getPositionX = function (dataItem, key, location, stackKey, range) {\n    var value = this.getTimeByLocation(dataItem, key, location); //let stack: number = dataItem.getValue(\"valueX\", \"stack\");\n\n    if (!$type.isNumber(value)) {\n      value = this.baseValue;\n    }\n\n    var position = this.valueToPosition(value);\n\n    if (range) {\n      position = $math.fitToRange(position, range.start, range.end);\n    }\n\n    return position;\n  };\n  /**\r\n   * Returns relative position on axis for series' data item's value.\r\n   *\r\n   * @since 4.5.14\r\n   * @param  dataItem  Data item\r\n   * @param  key       Data field to get value from\r\n   * @param  location  Location (0-1)\r\n   * @return           Relative position\r\n   */\n\n\n  DateAxis.prototype.getPositionY = function (dataItem, key, location, stackKey, range) {\n    var value = this.getTimeByLocation(dataItem, key, location);\n    var stack = dataItem.getValue(\"valueX\", \"stack\");\n\n    if (!$type.isNumber(value)) {\n      value = this.baseValue;\n    }\n\n    var position = this.valueToPosition(value + stack);\n\n    if (range) {\n      position = $math.fitToRange(position, range.start, range.end);\n    }\n\n    return position;\n  };\n  /**\r\n   * Returns an angle for series data item.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description (review)\r\n   * @param dataItem  Data item\r\n   * @param key       Data field to get value from\r\n   * @param location  Location (0-1)\r\n   * @param stackKey  Stack ID\r\n   * @param range Range to fit in\r\n   * @return Angle\r\n   */\n\n\n  DateAxis.prototype.getAngle = function (dataItem, key, location, stackKey, range) {\n    var value = this.getTimeByLocation(dataItem, key, location);\n    var stack = dataItem.getValue(stackKey, \"stack\");\n\n    if (!$type.isNumber(value)) {\n      value = this.baseValue;\n    }\n\n    var position = this.valueToPosition(value + stack);\n\n    if (range) {\n      position = $math.fitToRange(position, range.start, range.end);\n    }\n\n    return this.positionToAngle(position);\n  };\n  /**\r\n   * [getTimeByLocation description]\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description\r\n   * @param dataItem  [description]\r\n   * @param key       [description]\r\n   * @param location  [description]\r\n   * @return [description]\r\n   */\n\n\n  DateAxis.prototype.getTimeByLocation = function (dataItem, key, location) {\n    if (!$type.hasValue(key)) {\n      return;\n    }\n\n    if (!$type.isNumber(location)) {\n      location = dataItem.workingLocations[key];\n\n      if (!$type.isNumber(location)) {\n        location = 0;\n      }\n    }\n\n    var startTime = dataItem.values[key][\"open\"];\n    var endTime = dataItem.values[key][\"close\"];\n    var workingValue = dataItem.values[key].workingValue;\n    var value = dataItem.values[key].value;\n    var difference = value - workingValue;\n    startTime -= difference;\n    endTime -= difference;\n\n    if ($type.isNumber(startTime) && $type.isNumber(endTime)) {\n      return startTime + (endTime - startTime) * location;\n    }\n  };\n  /**\r\n   * Processes a related series' data item.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description\r\n   * @param dataItem  Data item\r\n   */\n\n\n  DateAxis.prototype.processSeriesDataItem = function (dataItem, axisLetter) {\n    var series = dataItem.component;\n    var time;\n    var date = dataItem[\"date\" + axisLetter];\n\n    if ($type.isNumber(this.timezoneOffset)) {\n      date.setTime(date.getTime() + (date.getTimezoneOffset() - this.timezoneOffset) * 60000);\n      dataItem.setValue(\"date\" + axisLetter, date.getTime(), 0);\n    } else if ($type.hasValue(this.timezone)) {\n      date = $time.setTimezone(date, this.timezone);\n      dataItem.setValue(\"date\" + axisLetter, date.getTime(), 0);\n      dataItem[\"date\" + axisLetter] = date;\n    }\n\n    if (date) {\n      time = date.getTime();\n    } else {\n      return;\n    }\n\n    var openDate = dataItem[\"openDate\" + axisLetter];\n    var prevSeriesTime = this._prevSeriesTime[series.uid];\n    var openTime;\n\n    if (openDate) {\n      openTime = openDate.getTime();\n    }\n\n    if ($type.isNumber(openTime)) {\n      var difference = Math.abs(time - openTime);\n\n      if (this._minDifference[series.uid] > difference) {\n        this._minDifference[series.uid] = difference;\n      }\n    }\n\n    var differece = time - prevSeriesTime;\n\n    if (differece > 0) {\n      if (this._minDifference[series.uid] > differece) {\n        this._minDifference[series.uid] = differece;\n      }\n    }\n\n    this._prevSeriesTime[series.uid] = time;\n\n    if (series._baseInterval[this.uid]) {\n      this.postProcessSeriesDataItem(dataItem);\n    }\n  };\n  /**\r\n   * [updateAxisBySeries description]\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description\r\n   */\n\n\n  DateAxis.prototype.updateAxisBySeries = function () {\n    _super.prototype.updateAxisBySeries.call(this);\n\n    var baseInterval = this.chooseInterval(0, this.minDifference, 1); // handle short months\n\n    if (this.minDifference >= $time.getDuration(\"day\", 27) && baseInterval.timeUnit == \"week\") {\n      baseInterval.timeUnit = \"month\";\n      baseInterval.count = 1;\n    }\n\n    if (baseInterval.timeUnit == \"month\") {\n      if (this.minDifference >= $time.getDuration(\"day\", 29 * 2) && baseInterval.count == 1) {\n        baseInterval.count = 2;\n      }\n\n      if (this.minDifference >= $time.getDuration(\"day\", 29 * 3) && baseInterval.count == 2) {\n        baseInterval.count = 3;\n      }\n\n      if (this.minDifference >= $time.getDuration(\"day\", 29 * 6) && baseInterval.count == 5) {\n        baseInterval.count = 6;\n      }\n    } // handle daylight saving\n\n\n    if (this.minDifference >= $time.getDuration(\"hour\", 23) && baseInterval.timeUnit == \"hour\") {\n      baseInterval.timeUnit = \"day\";\n      baseInterval.count = 1;\n    }\n\n    if (this.minDifference >= $time.getDuration(\"week\", 1) - $time.getDuration(\"hour\", 1) && baseInterval.timeUnit == \"day\") {\n      baseInterval.timeUnit = \"week\";\n      baseInterval.count = 1;\n    }\n\n    if (this.minDifference >= $time.getDuration(\"year\", 1) - $time.getDuration(\"day\", 1.01) && baseInterval.timeUnit == \"month\") {\n      baseInterval.timeUnit = \"year\";\n      baseInterval.count = 1;\n    }\n\n    this._baseIntervalReal = baseInterval;\n    this._mainBaseInterval = baseInterval; // no need to invalidate\n  };\n\n  Object.defineProperty(DateAxis.prototype, \"baseInterval\", {\n    /**\r\n     * @return Base interval\r\n     */\n    get: function get() {\n      if (this._groupInterval) {\n        return this._groupInterval;\n      } else if (this._baseInterval) {\n        return this._baseInterval;\n      } else {\n        return this._baseIntervalReal;\n      }\n    },\n\n    /**\r\n     * A base interval (granularity) of data.\r\n     *\r\n     * Used to indicate what are the base units of your data.\r\n     *\r\n     * For example, if you have a data set that has a data point every 5 minutes,\r\n     * you may want to set this to `{ timeUnit: \"minute\", count: 5 }`.\r\n     *\r\n     * If not set, the Axis will try to determine the setting by its own, looking\r\n     * at actual data.\r\n     *\r\n     * For best results, try to follow these values for `count`:\r\n     *\r\n     * When unit is \"month\", use 12 / count = round number\r\n     * When unit is \"hour\", use 24 / count = round number\r\n     * When unit is \"second\" and \"minute\", use 60 / count = round number\r\n     *\r\n     * @param timeInterval base interval\r\n     */\n    set: function set(timeInterval) {\n      if (JSON.stringify(this._baseInterval) != JSON.stringify(timeInterval)) {\n        this._baseInterval = timeInterval;\n        this._mainBaseInterval = timeInterval;\n\n        if (!$type.isNumber(timeInterval.count)) {\n          timeInterval.count = 1;\n        }\n\n        this.invalidate();\n        this.postProcessSeriesDataItems();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DateAxis.prototype, \"mainBaseInterval\", {\n    /**\r\n     * Indicates granularity of the data of source (unaggregated) data.\r\n     *\r\n     * @since 4.7.0\r\n     * @return Granularity of the main data set\r\n     */\n    get: function get() {\n      if (this._baseInterval) {\n        return this._baseInterval;\n      } else if (this._mainBaseInterval) {\n        return this._mainBaseInterval;\n      } else {\n        return this._baseIntervalReal;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DateAxis.prototype, \"skipEmptyPeriods\", {\n    /**\r\n     * @return Remove empty stretches of time?\r\n     */\n    get: function get() {\n      return this.getPropertyValue(\"skipEmptyPeriods\");\n    },\n\n    /**\r\n     * If enabled, axis will automatically collapse empty (without data points)\r\n     * periods of time, i.e. weekends.\r\n     *\r\n     * An \"empty\" period is considered a stretch of time in the length of current\r\n     * `baseInterval` without a single data point in it.\r\n     *\r\n     * For each such empty period, axis will automatically create an\r\n     * [[AxisBreak]]. By default they will be invisible. You can still configure\r\n     * them by accessing `axis.breaks.template`.\r\n     *\r\n     * [More info about breaks](https://www.amcharts.com/docs/v4/concepts/axes/#Breaks).\r\n     *\r\n     * Important notes:\r\n     * * If you set this property to `true`, you can not add your custom axis breaks to this axis anymore.\r\n     * * Using this feature affects performance. Use only if you need it.\r\n     * * Setting this to `true` will reset appearance of breaks. If you want to modify appearance, do it *after* you set `skipEmptyPeriods`.\r\n     * * Some axis label overlapping might happen.\r\n     * * This setting is not compatible with `groupData = true`.\r\n     *\r\n     * @default false\r\n     * @param value  Remove empty stretches of time?\r\n     */\n    set: function set(value) {\n      if (value) {\n        var breakTemplate = this.axisBreaks.template;\n        breakTemplate.startLine.disabled = true;\n        breakTemplate.endLine.disabled = true;\n        breakTemplate.fillShape.disabled = true;\n        breakTemplate.breakSize = 0;\n      } else {\n        if (this._gapBreaks) {\n          this.axisBreaks.clear();\n          this._gapBreaks = false;\n        }\n      }\n\n      if (this.setPropertyValue(\"skipEmptyPeriods\", value)) {\n        this.invalidate();\n        this.postProcessSeriesDataItems();\n        this.invalidateSeries();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DateAxis.prototype, \"tooltipDateFormat\", {\n    /**\r\n     * @return Date format\r\n     */\n    get: function get() {\n      return this.getPropertyValue(\"tooltipDateFormat\");\n    },\n\n    /**\r\n     * A special date format to apply axis tooltips.\r\n     *\r\n     * Will use same format as for labels, if not set.\r\n     *\r\n     * @param value  Date format\r\n     */\n    set: function set(value) {\n      this.setPropertyValue(\"tooltipDateFormat\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DateAxis.prototype, \"markUnitChange\", {\n    /**\r\n     * @return Use different format for period beginning?\r\n     */\n    get: function get() {\n      return this.getPropertyValue(\"markUnitChange\");\n    },\n\n    /**\r\n     * Use `periodChangeDateFormats` to apply different formats to the first\r\n     * label in bigger time unit.\r\n     *\r\n     * @default true\r\n     * @param value  Use different format for period beginning?\r\n     */\n    set: function set(value) {\n      if (this.setPropertyValue(\"markUnitChange\", value)) {\n        this.invalidateData();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Returns text to show in a tooltip, based on specific relative position\r\n   * within axis.\r\n   *\r\n   * The label will be formatted as per [[DateFormatter]] set for the whole\r\n   * chart, or explicitly for this Axis.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param position  Position\r\n   * @return Label (formatted date)\r\n   */\n\n  DateAxis.prototype.getTooltipText = function (position) {\n    var text;\n    var date = this.positionToDate(position);\n    date = $time.round(date, this.baseInterval.timeUnit, this.baseInterval.count, this._firstWeekDay, this._df.utc, new Date(this.min), this._df.timezoneMinutes, this._df.timezone);\n    this.tooltipDate = date;\n\n    if ($type.hasValue(this.tooltipDateFormat)) {\n      text = this._df.format(date, this.tooltipDateFormat, [\"day\", \"month\", \"week\", \"year\"].indexOf(this.baseInterval.timeUnit) == -1);\n    } else {\n      var dateFormat = this.dateFormats.getKey(this.baseInterval.timeUnit);\n\n      if (dateFormat) {\n        text = this._df.format(date, dateFormat);\n      } else {\n        text = this.getPositionLabel(position);\n      }\n    }\n\n    if (!this._adapterO) {\n      return text;\n    } else {\n      return this._adapterO.apply(\"getTooltipText\", text);\n    }\n  };\n  /**\r\n   * Takes an absolute position within axis and adjust it to a specific position within base interval. (cell)\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param position Source position\r\n   * @param location  Location in the cell\r\n   * @return Adjusted position\r\n   */\n\n\n  DateAxis.prototype.roundPosition = function (position, location, axisLocation) {\n    var baseInterval = this.baseInterval;\n    var timeUnit = baseInterval.timeUnit;\n    var count = baseInterval.count;\n    var date = this.positionToDate(position);\n    $time.round(date, timeUnit, count, this._firstWeekDay, this._df.utc, undefined, this._df.timezoneMinutes, this._df.timezone);\n\n    if (location > 0) {\n      $time.add(date, timeUnit, location * count, this._df.utc);\n    }\n\n    if (axisLocation > 0 && axisLocation < 1) {\n      date.setTime(date.getTime() + this.baseDuration * axisLocation);\n    }\n\n    if (this.isInBreak(date.getTime())) {\n      while (date.getTime() < this.max) {\n        $time.add(date, timeUnit, count, this._df.utc);\n\n        if (!this.isInBreak(date.getTime())) {\n          break;\n        }\n      }\n    }\n\n    return this.dateToPosition(date);\n  };\n  /**\r\n   * Returns an relative position of the start of the cell (period), that specific position value falls into.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description (review)\r\n   * @param position  Relative position\r\n   * @return Cell start relative position\r\n   */\n\n\n  DateAxis.prototype.getCellStartPosition = function (position) {\n    return this.roundPosition(position, 0);\n  };\n  /**\r\n   * Returns an relative position of the end of the cell (period), that specific position value falls into.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description (review)\r\n   * @param position  Relative position\r\n   * @return Cell end relative position\r\n   */\n\n\n  DateAxis.prototype.getCellEndPosition = function (position) {\n    return this.roundPosition(position, 1); //return this.dateToPosition($time.add(this.positionToDate(this.roundPosition(position, 1)), this.baseInterval.timeUnit, this.baseInterval.count));\n  };\n  /**\r\n   * Returns a Series data item that corresponds to the specific pixel position\r\n   * of the Axis.\r\n   *\r\n   * If `findNearest` (third parameter) is set to `true`, the method will try\r\n   * to locate nearest available data item if none is found directly under\r\n   * `position`.\r\n   *\r\n   * @param series       Series\r\n   * @param position     Position (px)\r\n   * @param findNearest  Should axis try to find nearest tooltip if there is no data item at exact position\r\n   * @return Data item\r\n   */\n\n\n  DateAxis.prototype.getSeriesDataItem = function (series, position, findNearest) {\n    var value = this.positionToValue(position);\n    var location = 0.5;\n\n    if (this.axisLetter == \"Y\") {\n      location = series.dataItems.template.locations.dateY;\n    } else {\n      location = series.dataItems.template.locations.dateX;\n    }\n\n    var deltaValue = value - location * this.baseDuration;\n    var date = $time.round(new Date(value), this.baseInterval.timeUnit, this.baseInterval.count, this._firstWeekDay, this._df.utc, undefined, this._df.timezoneMinutes, this._df.timezone);\n    var nextDate = $time.round(new Date(value + this.baseDuration), this.baseInterval.timeUnit, this.baseInterval.count, this._firstWeekDay, this._df.utc, undefined, this._df.timezoneMinutes, this._df.timezone);\n\n    if (nextDate.getTime() > date.getTime()) {\n      if (Math.abs(nextDate.getTime() - deltaValue) < Math.abs(deltaValue - date.getTime())) {\n        date = nextDate;\n      }\n    }\n\n    var dataItemsByAxis = series.dataItemsByAxis.getKey(this.uid);\n    var dataItem = dataItemsByAxis.getKey(date.getTime() + series.currentDataSetId); // todo:  alternatively we can find closiest here\n\n    if (!dataItem && findNearest) {\n      var key_1;\n\n      if (this.axisLetter == \"Y\") {\n        key_1 = \"dateY\";\n      } else {\n        key_1 = \"dateX\";\n      }\n\n      dataItem = series.dataItems.getIndex(series.dataItems.findClosestIndex(date.getTime(), function (x) {\n        if (x[key_1]) {\n          return x[key_1].getTime();\n        } else {\n          return -Infinity;\n        }\n      }, \"any\"));\n    }\n\n    return dataItem;\n  };\n  /**\r\n   * Returns a formatted date based on position in axis scale.\r\n   *\r\n   * Please note that `position` represents position within axis which may be\r\n   * zoomed and not correspond to Cursor's `position`.\r\n   *\r\n   * To convert Cursor's `position` to Axis' `position` use `toAxisPosition()` method.\r\n   *\r\n   * @see {@link https://www.amcharts.com/docs/v4/tutorials/tracking-cursors-position-via-api/#Tracking_Cursor_s_position} For more information about cursor tracking.\r\n   * @param position  Relative position on axis (0-1)\r\n   * @return Position label\r\n   */\n\n\n  DateAxis.prototype.getPositionLabel = function (position) {\n    // @todo Better format recognition\n    var date = this.positionToDate(position);\n    return this._df.format(date, this.getCurrentLabelFormat());\n  };\n  /**\r\n   * Returns label date format based on currently used time units\r\n   *\r\n   * @return Format\r\n   */\n\n\n  DateAxis.prototype.getCurrentLabelFormat = function () {\n    return this.dateFormats.getKey(this._gridInterval ? this._gridInterval.timeUnit : \"day\");\n  };\n  /**\r\n   * Initializes an Axis renderer.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  DateAxis.prototype.initRenderer = function () {\n    _super.prototype.initRenderer.call(this);\n\n    var renderer = this.renderer;\n\n    if (renderer) {\n      // Set defaults\n      renderer.ticks.template.location = 0;\n      renderer.grid.template.location = 0;\n      renderer.labels.template.location = 0;\n      renderer.baseGrid.disabled = true;\n    }\n  };\n\n  Object.defineProperty(DateAxis.prototype, \"basePoint\", {\n    /**\r\n     * Coordinates of the actual axis start.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @return Base point\r\n     */\n    get: function get() {\n      return {\n        x: 0,\n        y: 0\n      };\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * @ignore\r\n   */\n\n  DateAxis.prototype.animateMinMax = function (min, max) {\n    var _this = this;\n\n    var animation = this.animate([{\n      property: \"_minAdjusted\",\n      from: this._minAdjusted,\n      to: min\n    }, {\n      property: \"_maxAdjusted\",\n      from: this._maxAdjusted,\n      to: max\n    }], this.rangeChangeDuration, this.rangeChangeEasing);\n    animation.events.on(\"animationprogress\", function () {\n      _this.dispatch(\"extremeschanged\");\n    });\n    return animation;\n  };\n  /**\r\n   * Invalidates axis data items when series extremes change\r\n   */\n\n\n  DateAxis.prototype.handleExtremesChange = function () {\n    _super.prototype.handleExtremesChange.call(this);\n\n    if (this.groupData) {\n      var id = this.baseInterval.timeUnit + this.baseInterval.count;\n      this.groupMin[id] = this._finalMin;\n      this.groupMax[id] = this._finalMax;\n    }\n  };\n  /**\r\n   * Zooms axis to specific Dates.\r\n   *\r\n   * @param startDate       Start date\r\n   * @param endValue        End date\r\n   * @param skipRangeEvent  Do not invoke events\r\n   * @param instantly       Do not play zoom animations\r\n   */\n\n\n  DateAxis.prototype.zoomToDates = function (startDate, endDate, skipRangeEvent, instantly, adjust) {\n    startDate = this._df.parse(startDate);\n    endDate = this._df.parse(endDate);\n    this.zoomToValues(startDate.getTime(), endDate.getTime(), skipRangeEvent, instantly, adjust);\n  };\n  /**\r\n   * Zooms axis to specific values.\r\n   *\r\n   * @param startValue      Start value\r\n   * @param endValue        End value\r\n   * @param skipRangeEvent  Do not invoke events\r\n   * @param instantly       Do not play zoom animations\r\n   */\n\n\n  DateAxis.prototype.zoomToValues = function (startValue, endValue, skipRangeEvent, instantly, adjust) {\n    var _this = this;\n\n    if (!this.groupData) {\n      //let start: number = (startValue - this.min) / (this.max - this.min);\n      //let end: number = (endValue - this.min) / (this.max - this.min);\n      var start = this.valueToPosition(startValue);\n      var end = this.valueToPosition(endValue);\n      this.zoom({\n        start: start,\n        end: end\n      }, skipRangeEvent, instantly);\n    } else {\n      var difference = this.adjustDifference(startValue, endValue);\n      var isEnd = false;\n\n      if (endValue == this.max) {\n        isEnd = true;\n      }\n\n      var isStart = false;\n\n      if (startValue == this.min) {\n        isStart = true;\n      }\n\n      if ($type.hasValue(difference)) {\n        var mainBaseInterval = this.mainBaseInterval;\n        var groupInterval_1 = this.chooseInterval(0, difference, this.groupCount, this.groupIntervals);\n\n        if (groupInterval_1.timeUnit == mainBaseInterval.timeUnit && groupInterval_1.count < mainBaseInterval.count || $time.getDuration(groupInterval_1.timeUnit, 1) < $time.getDuration(mainBaseInterval.timeUnit, 1)) {\n          groupInterval_1 = __assign({}, mainBaseInterval);\n        }\n\n        var id = groupInterval_1.timeUnit + groupInterval_1.count;\n        var min_1 = this.groupMin[id];\n        var max_1 = this.groupMax[id];\n\n        if (!$type.isNumber(min_1) || !$type.isNumber(max_1)) {\n          min_1 = Number.POSITIVE_INFINITY;\n          max_1 = Number.NEGATIVE_INFINITY;\n          this.series.each(function (series) {\n            var seriesMin = series.min(_this);\n            var seriesMax = series.max(_this);\n\n            if (series._dataSets) {\n              var ds = series._dataSets.getKey(groupInterval_1.timeUnit + groupInterval_1.count);\n\n              if (ds) {\n                var mindi = ds.getIndex(0);\n                var maxdi = ds.getIndex(ds.length - 1);\n\n                if (mindi) {\n                  if (series.xAxis == _this) {\n                    seriesMin = mindi.dateX.getTime();\n                  } else if (series.yAxis == _this) {\n                    seriesMin = mindi.dateY.getTime();\n                  }\n                }\n\n                if (maxdi) {\n                  if (series.xAxis == _this) {\n                    seriesMax = maxdi.dateX.getTime();\n                  } else if (series.yAxis == _this) {\n                    seriesMax = maxdi.dateY.getTime();\n                  }\n                }\n              }\n            }\n\n            seriesMax = $time.round($time.add(new Date(seriesMax), groupInterval_1.timeUnit, 1, _this._df.utc), groupInterval_1.timeUnit, 1, _this._df.firstDayOfWeek, _this._df.utc, undefined, _this._df.timezoneMinutes, _this._df.timezone).getTime();\n\n            if (seriesMin < min_1) {\n              min_1 = seriesMin;\n            }\n\n            if (seriesMax > max_1) {\n              max_1 = seriesMax;\n            }\n          });\n          this.groupMin[id] = min_1;\n          this.groupMax[id] = max_1;\n        }\n\n        startValue = $math.fitToRange(startValue, min_1, max_1);\n        endValue = $math.fitToRange(endValue, min_1, max_1);\n\n        if (adjust) {\n          if (isEnd) {\n            startValue = endValue - difference;\n            startValue = $math.fitToRange(startValue, min_1, max_1);\n          }\n\n          if (isStart) {\n            endValue = startValue + difference;\n            endValue = $math.fitToRange(endValue, min_1, max_1);\n          }\n        }\n\n        var start = (startValue - min_1) / (max_1 - min_1);\n        var end = (endValue - min_1) / (max_1 - min_1);\n        this.zoom({\n          start: start,\n          end: end\n        }, skipRangeEvent, instantly);\n      }\n    }\n  };\n  /**\r\n   * Adds `baseInterval` to \"as is\" fields.\r\n   *\r\n   * @param field  Field name\r\n   * @return Assign as is?\r\n   */\n\n\n  DateAxis.prototype.asIs = function (field) {\n    return field == \"baseInterval\" || _super.prototype.asIs.call(this, field);\n  };\n  /**\r\n   * Copies all properties and related data from a different instance of Axis.\r\n   *\r\n   * @param source Source Axis\r\n   */\n\n\n  DateAxis.prototype.copyFrom = function (source) {\n    var _this = this;\n\n    _super.prototype.copyFrom.call(this, source);\n\n    this.dateFormats = source.dateFormats;\n    this.periodChangeDateFormats = source.periodChangeDateFormats;\n    this.groupIntervals.clear();\n    source.groupIntervals.each(function (interval) {\n      _this.groupIntervals.push(__assign({}, interval));\n    });\n    this.gridIntervals.clear();\n    source.gridIntervals.each(function (interval) {\n      _this.gridIntervals.push(__assign({}, interval));\n    });\n\n    if (source._baseInterval) {\n      this.baseInterval = source._baseInterval;\n    }\n  };\n  /**\r\n   * Shows Axis tooltip at specific relative position within Axis. (0-1)\r\n   *\r\n   * @param position Position (0-1)\r\n   * @param local or global position\r\n   */\n\n\n  DateAxis.prototype.showTooltipAtPosition = function (position, local) {\n    var _this = this;\n\n    if (!local) {\n      position = this.toAxisPosition(position);\n    }\n\n    if (this.snapTooltip) {\n      // rounding is not good, pen/aac4e7f66f019d36b2447f050c600c13 (no last tootltip shown)\n      var actualDate = this.positionToDate(position); //$time.round(this.positionToDate(position), this.baseInterval.timeUnit, 1, this.getFirstWeekDay(), this.dateFormatter.utc, undefined, this._df.timezoneMinutes, this._df.timezone);\n\n      var actualTime_1 = actualDate.getTime();\n      var closestDate_1;\n      this.series.each(function (series) {\n        if (series.baseAxis == _this) {\n          var dataItem = _this.getSeriesDataItem(series, position, true);\n\n          if (dataItem) {\n            var date = void 0;\n\n            if (series.xAxis == _this) {\n              date = dataItem.dateX;\n            }\n\n            if (series.yAxis == _this) {\n              date = dataItem.dateY;\n            }\n\n            if (!closestDate_1) {\n              closestDate_1 = date;\n            } else {\n              if (Math.abs(closestDate_1.getTime() - actualTime_1) > Math.abs(date.getTime() - actualTime_1)) {\n                closestDate_1 = date;\n              }\n            }\n          }\n        }\n      });\n\n      if (closestDate_1) {\n        var closestTime_1 = closestDate_1.getTime();\n        closestDate_1 = $time.round(new Date(closestTime_1), this.baseInterval.timeUnit, this.baseInterval.count, this._firstWeekDay, this._df.utc, undefined, this._df.timezoneMinutes, this._df.timezone);\n        closestTime_1 = closestDate_1.getTime();\n        var tooltipLocation = this.renderer.tooltipLocation;\n\n        if (tooltipLocation == 0) {\n          tooltipLocation = 0.0001;\n        }\n\n        closestDate_1 = new Date(closestDate_1.getTime() + this.baseDuration * tooltipLocation);\n        position = this.dateToPosition(closestDate_1);\n\n        if (this.chart.cursor && this.chart.cursor.snapToSeries) {//void\n        } else {\n          this.series.each(function (series) {\n            var dataItem = series.dataItemsByAxis.getKey(_this.uid).getKey(closestTime_1 + series.currentDataSetId);\n            var point = series.showTooltipAtDataItem(dataItem);\n\n            if (point) {\n              _this.chart._seriesPoints.push({\n                series: series,\n                point: point\n              });\n            } else {\n              // check, otherwise column tooltip will be hidden\n              if (series.tooltipText || series.tooltipHTML) {\n                series.hideTooltip();\n              }\n            }\n          });\n        } //this.chart.sortSeriesTooltips(seriesPoints);\n\n      }\n    }\n\n    _super.prototype.showTooltipAtPosition.call(this, position, true);\n  };\n\n  Object.defineProperty(DateAxis.prototype, \"snapTooltip\", {\n    /**\r\n     * @return Should snap?\r\n     */\n    get: function get() {\n      return this.getPropertyValue(\"snapTooltip\");\n    },\n\n    /**\r\n     * Should the nearest tooltip be shown if no data item is found on the\r\n     * current cursor position.\r\n     *\r\n     * @default true\r\n     * @param value  Should snap?\r\n     */\n    set: function set(value) {\n      this.setPropertyValue(\"snapTooltip\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DateAxis.prototype, \"groupData\", {\n    /**\r\n     * @return Group data points?\r\n     */\n    get: function get() {\n      return this.getPropertyValue(\"groupData\");\n    },\n\n    /**\r\n     * Indicates if data should be aggregated to composide data items if there\r\n     * are more data items in selected range than `groupCount`.\r\n     *\r\n     * Grouping will occur automatically, based on current selection range, and\r\n     * will change dynamically when user zooms in/out the chart.\r\n     *\r\n     * NOTE: This works only if [[DateAxis]] is base axis of an [[XYSeries]].\r\n     *\r\n     * The related [[XYSeries]] also needs to be set up to take advantage of, by\r\n     * setting its [`groupFields`](https://www.amcharts.com/docs/v4/reference/xyseries/#groupFields_property).\r\n     *\r\n     * The group intervals to aggregate data to is defined by `groupIntervals`\r\n     * property.\r\n     *\r\n     * ```TypeScript\r\n     * let dateAxis = chart.xAxes.push(new am4charts.DateAxis());\r\n     * dateAxis.groupData = true;\r\n     *\r\n     * let valueAxis = chart.xAxes.push(new am4charts.valueAxis());\r\n     *\r\n     * let series = chart.series.push(new am4charts.LineSeries());\r\n     * series.dataFields.dateX = \"date\";\r\n     * series.dataFields.valueY = \"value\";\r\n     * series.groupFields.valueY = \"average\";\r\n     * ```\r\n     * ```JavaScript\r\n     * var dateAxis = chart.xAxes.push(new am4charts.DateAxis());\r\n     * dateAxis.groupData = true;\r\n     *\r\n     * var valueAxis = chart.xAxes.push(new am4charts.valueAxis());\r\n     *\r\n     * var series = chart.series.push(new am4charts.LineSeries());\r\n     * series.dataFields.dateX = \"date\";\r\n     * series.dataFields.valueY = \"value\";\r\n     * series.groupFields.valueY = \"average\";\r\n     * ```\r\n     * ```JSON\r\n     * {\r\n     *   // ...\r\n     *   \"xAxes\": [{\r\n     *     \"type\": \"DateAxis\",\r\n     *     \"groupData\": true\r\n     *   }],\r\n     *   \"yAxes\": [{\r\n     *     \"type\": \"ValueAxis\"\r\n     *   }],\r\n     *   \"series\": [{\r\n     *     \"type\": \"LineSeries\",\r\n     *     \"dataFields\": {\r\n     *       \"dateX\": \"date\",\r\n     *       \"valueY\": \"value\"\r\n     *     },\r\n     *     \"groupFields\": {\r\n     *       \"valueY\": \"average\"\r\n     *     }\r\n     *   }]\r\n     * }\r\n     * ```\r\n     *\r\n     * @default false\r\n     * @see {@link https://www.amcharts.com/docs/v4/concepts/axes/date-axis/#Dynamic_data_item_grouping} for more information about dynamic data item grouping.\r\n     * @since 4.7.0\r\n     * @param  value  Group data points?\r\n     */\n    set: function set(value) {\n      var _this = this;\n\n      if (this.setPropertyValue(\"groupData\", value)) {\n        this.series.each(function (series) {\n          series.setDataSet(\"\");\n\n          if (value && !series.dataGrouped && series.inited) {\n            series._baseInterval[_this.uid] = _this.mainBaseInterval;\n\n            _this.groupSeriesData(series);\n          }\n        });\n        this._currentDataSetId = \"\";\n        this._groupInterval = undefined;\n        this.invalidate();\n        this.invalidateSeries();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DateAxis.prototype, \"groupInterval\", {\n    /**\r\n     * @return Interval\r\n     */\n    get: function get() {\n      return this.getPropertyValue(\"groupInterval\");\n    },\n\n    /**\r\n     * Disables automatic selection of data grouping intervals and always uses\r\n     * `groupInterval` if set. Works only if `groupData = true`.\r\n     *\r\n     * @since 4.9.24\r\n     * @param  value  Interval\r\n     */\n    set: function set(value) {\n      if (this.setPropertyValue(\"groupInterval\", value)) {\n        this.invalidate();\n        this.invalidateSeries();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DateAxis.prototype, \"groupCount\", {\n    /**\r\n     * @return Number of data items\r\n     */\n    get: function get() {\n      return this.getPropertyValue(\"groupCount\");\n    },\n\n    /**\r\n     * Indicates threshold of data items in selected range at which to start\r\n     * aggregating data items if `groupData = true`.\r\n     *\r\n     * @default 200\r\n     * @since 4.7.0\r\n     * @param  value  Number of data items\r\n     */\n    set: function set(value) {\n      this.setPropertyValue(\"groupCount\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DateAxis.prototype, \"timezoneOffset\", {\n    /**\r\n     * @todo Timezone offset in minutes\r\n     */\n    get: function get() {\n      return this.getPropertyValue(\"timezoneOffset\");\n    },\n\n    /**\r\n     * If set will recalculate all timestamps in data by applying specific offset\r\n     * in minutes.\r\n     *\r\n     * IMPORTANT: do not set `timezoneOffset` on both `DateAxis` and `dateFormatter`. It\r\n     * will skew your results by applying offset twice.\r\n     *\r\n     * @since 4.8.5\r\n     * @param  value Time zone offset in minutes\r\n     */\n    set: function set(value) {\n      this.setPropertyValue(\"timezoneOffset\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DateAxis.prototype, \"timezone\", {\n    /**\r\n     * @return Timezone\r\n     */\n    get: function get() {\n      return this.getPropertyValue(\"timezone\");\n    },\n\n    /**\r\n     * If set will recalculate all timestamps in data to specific named timezone,\r\n     * e.g. `\"America/Vancouver\"`, `\"Australia/Sydney\"`, `\"UTC\"`, etc.\r\n     *\r\n     * IMPORTANT: it is no longer recommended to use this setting. Please\r\n     * set`timezone` on `dateFormatter`.\r\n     *\r\n     * @deprecated\r\n     * @since 4.10.1\r\n     * @param  value Time zone\r\n     */\n    set: function set(value) {\n      this.setPropertyValue(\"timezone\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DateAxis.prototype, \"gridInterval\", {\n    /**\r\n     * Current grid interval.\r\n     *\r\n     * @return Grid interval\r\n     */\n    get: function get() {\n      return this._gridInterval;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * @ignore\r\n   */\n\n  DateAxis.prototype.makeGap = function (dataItem, previous) {\n    var series = dataItem.component;\n\n    if (dataItem && previous) {\n      if (!series.connect && $type.isNumber(series.autoGapCount)) {\n        if (series.baseAxis == this) {\n          var date = dataItem.dates[\"date\" + this.axisLetter];\n          var prevDate = previous.dates[\"date\" + this.axisLetter];\n\n          if (date && prevDate) {\n            var time = date.getTime();\n            var prevTime = prevDate.getTime();\n\n            if (time - prevTime > series.autoGapCount * this.baseDuration) {\n              return true;\n            }\n          }\n        }\n      }\n    }\n\n    return false;\n  };\n\n  Object.defineProperty(DateAxis.prototype, \"baseValue\", {\n    /**\r\n     * @return base value\r\n     */\n    get: function get() {\n      return this.min;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return DateAxis;\n}(ValueAxis);\n\nexport { DateAxis };\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\n\nregistry.registeredClasses[\"DateAxis\"] = DateAxis;\nregistry.registeredClasses[\"DateAxisDataItem\"] = DateAxisDataItem;","map":{"version":3,"mappings":"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","names":["ValueAxis","ValueAxisDataItem","List","Dictionary","DateAxisBreak","registry","$time","$type","$iter","$math","$array","$object","$utils","OrderedListTemplate","__extends","_super","_this","className","applyTheme","values","date","endDate","Object","DateAxisDataItem","dates","setDate","value","getTime","endValue","timeUnit","count","setPropertyValue","snapTooltip","tooltipPosition","groupCount","events","on","getDFFormatter","gridIntervals","pushAll","groupIntervals","axisFieldName","DateAxis","dataItem","axis","component","gridInterval","_gridInterval","gridDuration","getDuration","Math","round","min","axisFill","__disabled","applyInternalDefaults","call","dateFormats","hasKey","setKey","language","translate","periodChangeDateFormats","start","end","baseDuration","periodCount","max","_firstWeekDay","getFirstWeekDay","validateDataItems","mainBaseDuration","mainBaseInterval","maxZoomFactor","_deltaMinMax","newPeriodCount","zoom","calculateZoom","difference","adjustDifference","_minZoomed","_maxZoomed","dataSetChanged","groupData","hasValue","modifiedDifference","startLocation","endLocation","groupInterval","chooseInterval","_groupInterval","newId","_currentDataSetId","dispatch","series","each","baseAxis","setDataSet","_gridCount","baseInterval","_nextGridUnit","getNextUnit","_intervalDuration","_gridDate","Date","minZoomed","_df","utc","timezoneMinutes","timezone","iterator","field_1","getAxisField","undefined","minZoomedStr","toString","startDataItem","dataItemsByAxis","getKey","uid","currentDataSetId","startIndex","findFirst","index","dataItems","findClosestIndex","x","maxZoomed","add","maxZoomedStr","endDataItem","endIndex","length","outOfRange","dataRangeInvalid","validateDataRange","time","key","previousDataItem","getIndex","previousDate","validateData","isNumber","minDifference","Number","MAX_VALUE","_minDifference","seriesGroupUpdate","addEmptyUnitsBreaks","JSON","stringify","_baseInterval","mainDataSet","postProcessSeriesDataItem","groupSeriesData","dataGrouped","bulletsContainer","removeChildren","intervals_1","mainIntervalDuration_1","interval","intervalDuration","push","_dataSets","dispose","clear","axisLetter","dataSetId","dataSet","template","clone","dataSets","previousTime","NEGATIVE_INFINITY","i","newDataItem","dataFields","dfkey","df","dfk","indexOf","roundedDate","getDate","firstDayOfWeek","currentTime","_adapterO","vkey","apply","dataField","workingValue","create","dataContext","setWorkingLocation","locations","dateX","openDateX","dateY","openDateY","_index","dvalues","open","close","low","high","sum","average","propertyFields","fieldValue","f","properties","hasProperties","setProperty","groupDataItems","groupFieldName","groupFields","copyProperties","dateFormatter","intervalID","startDate","startTime","setCalculatedValue","skipEmptyPeriods","_axisBreaks","axisBreak","this_1","startTimeStr","hasData","contains","axisBreaks","_gapBreaks","fixAxisBreaks","breakGridCount","ceil","endPosition","startPosition","adjustedEndValue","adjustedStartValue","gridDate","intervalCount","realIntervalCount","prevTimestamp","newDate","copy","timestamp","isInBreak","durationBreaksRemoved","countBreaksRemoved","getGridDate","getBreaklessDate","prevGridDate","dataItemsIterator_1","_dataItemsIterator","resetIterators","this_2","format","markUnitChange","checkChange","text","find","appendDataItem","validateDataElement","renderer_1","renderer","breakSize","timeUnit_1","intervalCount_1","getDistance","startPoint","endPoint","minGridDistance","timestamp_1","prevGridDate_1","text_1","moveValue","adjustedMax","itemIndex","_axisItemCount","endTimestamp","position","valueToPosition","fillEndPosition","isRange","tick","disabled","updateTickElement","grid","updateGridElement","fill","updateFillElement","fillRule","mask","bullet","updateBullet","label","location_1","location","updateLabelElement","step","endTime","duration","gridCount","intervals","lastIndex","dateToPosition","point","positionToPoint","angle","positionToAngle","y","dateToPoint","valueToPoint","positionToValue","stackKey","range","getTimeByLocation","baseValue","fitToRange","stack","getValue","workingLocations","timezoneOffset","setTime","getTimezoneOffset","setValue","setTimezone","openDate","prevSeriesTime","_prevSeriesTime","openTime","abs","differece","updateAxisBySeries","_baseIntervalReal","_mainBaseInterval","timeInterval","invalidate","postProcessSeriesDataItems","getPropertyValue","breakTemplate","startLine","endLine","fillShape","invalidateSeries","invalidateData","positionToDate","tooltipDate","tooltipDateFormat","dateFormat","getPositionLabel","axisLocation","roundPosition","findNearest","deltaValue","nextDate","key_1","Infinity","getCurrentLabelFormat","initRenderer","ticks","labels","baseGrid","animation","animate","property","from","_minAdjusted","to","_maxAdjusted","rangeChangeDuration","rangeChangeEasing","handleExtremesChange","id","groupMin","_finalMin","groupMax","_finalMax","skipRangeEvent","instantly","adjust","parse","zoomToValues","startValue","isEnd","isStart","groupInterval_1","min_1","max_1","POSITIVE_INFINITY","seriesMin","seriesMax","ds","mindi","maxdi","xAxis","yAxis","field","asIs","source","copyFrom","__assign","local","toAxisPosition","actualDate","actualTime_1","closestDate_1","getSeriesDataItem","closestTime_1","tooltipLocation","chart","cursor","snapToSeries","showTooltipAtDataItem","_seriesPoints","tooltipText","tooltipHTML","hideTooltip","showTooltipAtPosition","inited","previous","connect","autoGapCount","prevDate","prevTime","registeredClasses"],"sourceRoot":"","sources":["../../../../../src/.internal/charts/axes/DateAxis.ts"],"sourcesContent":["/**\r\n * DateAxis module\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { ValueAxis, ValueAxisDataItem, IValueAxisProperties, IValueAxisDataFields, IValueAxisAdapters, IValueAxisEvents } from \"./ValueAxis\";\r\nimport { AxisItemLocation } from \"./Axis\";\r\nimport { AxisRenderer } from \"./AxisRenderer\";\r\nimport { AxisTick } from \"./AxisTick\";\r\nimport { AxisLabel } from \"./AxisLabel\";\r\nimport { AxisFill } from \"./AxisFill\";\r\nimport { List } from \"../../core/utils/List\";\r\nimport { Dictionary } from \"../../core/utils/Dictionary\";\r\nimport { IPoint, IOrientationPoint } from \"../../core/defs/IPoint\";\r\nimport { Grid } from \"./Grid\";\r\nimport { XYSeries, XYSeriesDataItem } from \"../series/XYSeries\";\r\nimport { LineSeriesDataItem } from \"../series/LineSeries\";\r\nimport { TimeUnit } from \"../../core/defs/TimeUnit\";\r\nimport { ITimeInterval } from \"../../core/defs/ITimeInterval\";\r\nimport { IMinMaxStep } from \"./ValueAxis\";\r\nimport { DateAxisBreak } from \"./DateAxisBreak\";\r\nimport { registry } from \"../../core/Registry\";\r\nimport * as $time from \"../../core/utils/Time\";\r\nimport * as $type from \"../../core/utils/Type\";\r\nimport * as $iter from \"../../core/utils/Iterator\";\r\nimport * as $math from \"../../core/utils/Math\";\r\nimport * as $array from \"../../core/utils/Array\";\r\nimport * as $object from \"../../core/utils/Object\";\r\nimport * as $utils from \"../../core/utils/Utils\";\r\nimport { IRange } from \"../../core/defs/IRange\";\r\nimport { DateFormatter } from \"../../core/formatters/DateFormatter\";\r\nimport { OrderedListTemplate } from \"../../core/utils/SortedList\";\r\nimport { Animation } from \"../../core/utils/Animation\";\r\n\r\n/**\r\n * ============================================================================\r\n * DATA ITEM\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Defines data item for [[DateAxis]].\r\n *\r\n * @see {@link DataItem}\r\n */\r\nexport class DateAxisDataItem extends ValueAxisDataItem {\r\n\r\n\t/**\r\n\t * Defines a type of [[Component]] this data item is used for.\r\n\t */\r\n\tpublic _component!: DateAxis;\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor() {\r\n\t\tsuper();\r\n\t\tthis.className = \"DateAxisDataItem\";\r\n\t\tthis.applyTheme();\r\n\r\n\t\tthis.values.date = {};\r\n\t\tthis.values.endDate = {};\r\n\t}\r\n\r\n\t/**\r\n\t * Date position of the data item.\r\n\t *\r\n\t * @param date  Date\r\n\t */\r\n\tpublic set date(date: Date) {\r\n\t\tthis.setDate(\"date\", date);\r\n\t\tthis.value = date.getTime();\r\n\t}\r\n\r\n\t/**\r\n\t * @return Date\r\n\t */\r\n\tpublic get date(): Date {\r\n\t\treturn this.dates[\"date\"];\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * End date for data item.\r\n\t *\r\n\t * @param date End date\r\n\t */\r\n\tpublic set endDate(date: Date) {\r\n\t\tthis.setDate(\"endDate\", date);\r\n\t\tthis.endValue = date.getTime();\r\n\t}\r\n\r\n\t/**\r\n\t * @return End date\r\n\t */\r\n\tpublic get endDate(): Date {\r\n\t\treturn this.dates[\"endDate\"];\r\n\t}\r\n\r\n}\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * REQUISITES\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Defines data fields for [[DateAxis]].\r\n */\r\nexport interface IDateAxisDataFields extends IValueAxisDataFields {\r\n\r\n\t/**\r\n\t * Date.\r\n\t */\r\n\tdate?: string;\r\n\r\n}\r\n\r\n/**\r\n * Defines properties for [[DateAxis]].\r\n */\r\nexport interface IDateAxisProperties extends IValueAxisProperties {\r\n\r\n\t/**\r\n\t * If enabled, axis will automatically collapse empty (without data points)\r\n\t * periods of time, i.e. weekends.\r\n\t *\r\n\t * @default false\r\n\t */\r\n\tskipEmptyPeriods?: boolean;\r\n\r\n\t/**\r\n\t * Use `periodChangeDateFormats` to apply different formats to the first\r\n\t * label in bigger time unit.\r\n\t *\r\n\t * @default true\r\n\t * @param value  Use different format for period beginning?\r\n\t */\r\n\tmarkUnitChange?: boolean;\r\n\r\n\t/**\r\n\t * Should the nearest tooltip be shown if no data item is found on the\r\n\t * current cursor position.\r\n\t *\r\n\t * @default true\r\n\t */\r\n\tsnapTooltip?: boolean;\r\n\r\n\t/**\r\n\t * A special date format to apply axis tooltips.\r\n\t *\r\n\t * Will use same format as for labels, if not set.\r\n\t */\r\n\ttooltipDateFormat?: string | Intl.DateTimeFormatOptions;\r\n\r\n\t/**\r\n\t * Indicates if data should be aggregated to composide data items if there\r\n\t * are more data items in selected range than `groupCount`.\r\n\t *\r\n\t * @default false\r\n\t * @since 4.7.0\r\n\t */\r\n\tgroupData?: boolean;\r\n\r\n\t/**\r\n\t * Indicates threshold of data items in selected range at which to start\r\n\t * aggregating data items if `groupData = true`.\r\n\t * \r\n\t * @default 200\r\n\t * @since 4.7.0\r\n\t */\r\n\tgroupCount?: number;\r\n\r\n\t/**\r\n\t * Disables automatic selection of data grouping intervals and always uses\r\n\t * `groupInterval` if set. Works only if `groupData = true`.\r\n\t * \r\n\t * @since 4.9.24\r\n\t */\r\n\tgroupInterval?: ITimeInterval;\r\n\r\n\t/**\r\n\t * If set will recalculate all timestamps in data by applying specific offset\r\n\t * in minutes.\r\n\t *\r\n\t * IMPORTANT: do not set `timezoneOffset` on both `DateAxis` and `dateFormatter`. It\r\n\t * will skew your results by applying offset twice.\r\n\t *\r\n\t * @since 4.8.5\r\n\t */\r\n\ttimezoneOffset?: number;\r\n\r\n\t/**\r\n\t * If set will recalculate all timestamps in data to specific named timezone,\r\n\t * e.g. `\"America/Vancouver\"`, `\"Australia/Sydney\"`, `\"UTC\"`, etc.\r\n\t *\r\n\t * IMPORTANT: do not set `timezone` on both `DateAxis` and `dateFormatter`. It\r\n\t * will skew your results by applying timezone twice.\r\n\t * \r\n\t * @since 4.10.1\r\n\t */\r\n\ttimezone?: string;\r\n\r\n}\r\n\r\n/**\r\n * Defines events for [[DateAxis]].\r\n */\r\nexport interface IDateAxisEvents extends IValueAxisEvents {\r\n\t/**\r\n\t * Invoked when data grouping is on and grouping period is changed. You can find our the period via dateAxis.currentDataSetId property.\r\n\t */\r\n\tgroupperiodchanged: IDateAxisEvents;\r\n}\r\n\r\n/**\r\n * Defines adapters for [[DateAxis]].\r\n *\r\n * @see {@link Adapter}\r\n */\r\nexport interface IDateAxisAdapters extends IValueAxisAdapters, IDateAxisProperties { }\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Used to create a date/time-based axis for the chart.\r\n *\r\n * ```TypeScript\r\n * // Create the axis\r\n * let xAxis = chart.xAxes.push(new am4charts.DateAxis());\r\n *\r\n * // Set settings\r\n * xAxis.title.text = \"Time\";\r\n * ```\r\n * ```JavaScript\r\n * // Create the axis\r\n * var valueAxis = chart.xAxes.push(new am4charts.DateAxis());\r\n *\r\n * // Set settings\r\n * valueAxis.title.text = \"Time\";\r\n * ```\r\n * ```JSON\r\n * \"xAxes\": [{\r\n *   \"type\": \"DateAxis\",\r\n *   \"title\": {\r\n *     \"text\": \"Time\"\r\n *   }\r\n * }]\r\n * ```\r\n *\r\n * @see {@link IDateAxisEvents} for a list of available Events\r\n * @see {@link IDateAxisAdapters} for a list of available Adapters\r\n * @see {@link https://www.amcharts.com/docs/v4/concepts/axes/date-axis/} got `DateAxis` documention\r\n * @important\r\n */\r\nexport class DateAxis<T extends AxisRenderer = AxisRenderer> extends ValueAxis<T> {\r\n\r\n\t/**\r\n\t * Defines data fields.\r\n\t */\r\n\tpublic _dataFields: IDateAxisDataFields;\r\n\r\n\t/**\r\n\t * Defines available properties.\r\n\t */\r\n\tpublic _properties!: IDateAxisProperties;\r\n\r\n\t/**\r\n\t * Defines available adapters.\r\n\t */\r\n\tpublic _adapter!: IDateAxisAdapters;\r\n\r\n\t/**\r\n\t * Defines available events.\r\n\t */\r\n\tpublic _events!: IDateAxisEvents;\r\n\r\n\t/**\r\n\t * Defines the type of the Date Items.\r\n\t */\r\n\tpublic _dataItem: DateAxisDataItem;\r\n\r\n\t/**\r\n\t * Defines the type of the axis breaks.\r\n\t */\r\n\tpublic _axisBreak: DateAxisBreak;\r\n\r\n\tprotected _gapBreaks: boolean = false;\r\n\r\n\t/**\r\n\t * A list of date/time intervals for Date axis.\r\n\t *\r\n\t * This define various granularities available for the axis. For example\r\n\t * if you have an axis spanning an hour, and space for 6 grid lines / labels\r\n\t * the axis will choose the granularity of 10 minutes, displaying a label\r\n\t * every 10 minutes.\r\n\t *\r\n\t * Default intervals:\r\n\t *\r\n\t * ```JSON\r\n\t * [\r\n\t *  { timeUnit: \"millisecond\", count: 1 },\r\n\t *  { timeUnit: \"millisecond\", count: 5 },\r\n\t *  { timeUnit: \"millisecond\", count: 10 },\r\n\t *  { timeUnit: \"millisecond\", count: 50 },\r\n\t *  { timeUnit: \"millisecond\", count: 100 },\r\n\t *  { timeUnit: \"millisecond\", count: 500 },\r\n\t *  { timeUnit: \"second\", count: 1 },\r\n\t *  { timeUnit: \"second\", count: 5 },\r\n\t *  { timeUnit: \"second\", count: 10 },\r\n\t *  { timeUnit: \"second\", count: 30 },\r\n\t *  { timeUnit: \"minute\", count: 1 },\r\n\t *  { timeUnit: \"minute\", count: 5 },\r\n\t *  { timeUnit: \"minute\", count: 10 },\r\n\t *  { timeUnit: \"minute\", count: 30 },\r\n\t *  { timeUnit: \"hour\", count: 1 },\r\n\t *  { timeUnit: \"hour\", count: 3 },\r\n\t *  { timeUnit: \"hour\", count: 6 },\r\n\t *  { timeUnit: \"hour\", count: 12 },\r\n\t *  { timeUnit: \"day\", count: 1 },\r\n\t *  { timeUnit: \"day\", count: 2 },\r\n\t *  { timeUnit: \"day\", count: 3 },\r\n\t *  { timeUnit: \"day\", count: 4 },\r\n\t *  { timeUnit: \"day\", count: 5 },\r\n\t *  { timeUnit: \"week\", count: 1 },\r\n\t *  { timeUnit: \"month\", count: 1 },\r\n\t *  { timeUnit: \"month\", count: 2 },\r\n\t *  { timeUnit: \"month\", count: 3 },\r\n\t *  { timeUnit: \"month\", count: 6 },\r\n\t *  { timeUnit: \"year\", count: 1 },\r\n\t *  { timeUnit: \"year\", count: 2 },\r\n\t *  { timeUnit: \"year\", count: 5 },\r\n\t *  { timeUnit: \"year\", count: 10 },\r\n\t *  { timeUnit: \"year\", count: 50 },\r\n\t *  { timeUnit: \"year\", count: 100 }\r\n\t * ]\r\n\t * ```\r\n\t */\r\n\tpublic gridIntervals: List<ITimeInterval> = new List<ITimeInterval>();\r\n\r\n\t/**\r\n\t * If data aggregation is enabled by setting Axis' `groupData = true`, the\r\n\t * chart will try to aggregate data items into grouped data items.\r\n\t *\r\n\t * If there are more data items in selected period than `groupCount`, it will\r\n\t * group data items into bigger period.\r\n\t *\r\n\t * For example seconds might be grouped into 10-second aggregate data items.\r\n\t *\r\n\t * This setting indicates what group intervals can the chart group to.\r\n\t *\r\n\t * Default intervals:\r\n\t *\r\n\t * ```JSON\r\n\t * [\r\n\t *   { timeUnit: \"millisecond\", count: 1},\r\n\t *   { timeUnit: \"millisecond\", count: 10 },\r\n\t *   { timeUnit: \"millisecond\", count: 100 },\r\n\t *   { timeUnit: \"second\", count: 1 },\r\n\t *   { timeUnit: \"second\", count: 10 },\r\n\t *   { timeUnit: \"minute\", count: 1 },\r\n\t *   { timeUnit: \"minute\", count: 10 },\r\n\t *   { timeUnit: \"hour\", count: 1 },\r\n\t *   { timeUnit: \"day\", count: 1 },\r\n\t *   { timeUnit: \"week\", count: 1 },\r\n\t *   { timeUnit: \"month\", count: 1 },\r\n\t *   { timeUnit: \"year\", count: 1 }\r\n\t * ]\r\n\t * ```\r\n\t * `groupData = true` does not work in combination with `skipEmptyPeriods = true`.\r\n\t * \r\n\t * @since 4.7.0\r\n\t * @see {@link https://www.amcharts.com/docs/v4/concepts/axes/date-axis/#Dynamic_data_item_grouping} for more information about dynamic data item grouping.\r\n\t */\r\n\tpublic groupIntervals: List<ITimeInterval> = new List<ITimeInterval>();\r\n\r\n\t/**\r\n\t * A collection of date formats to use when formatting different time units\r\n\t * on Date/time axis.\r\n\t *\r\n\t * Actual defaults will depend on the language locale set for the chart.\r\n\t *\r\n\t * To override format for a specific time unit, say days, you need to set\r\n\t * the appropriate key to a format string. E.g.:\r\n\t *\r\n\t * ```TypeScript\r\n\t * axis.dateFormats.setKey(\"day\", \"MMMM d, yyyy\");\r\n\t * ```\r\n\t * ```JavaScript\r\n\t * axis.dateFormats.setKey(\"day\", \"MMMM d, yyyy\");\r\n\t * ```\r\n\t * ```JSON\r\n\t * \"xAxes\": [{\r\n\t *   \"type\": \"DateAxis\",\r\n\t *   \"dateFormats\": {\r\n\t *     \"day\": \"MMMM d, yyyy\"\r\n\t *   }\r\n\t * }]\r\n\t * ```\r\n\t *\r\n\t * @see {@link DateFormatter}\r\n\t */\r\n\tpublic dateFormats: Dictionary<TimeUnit, string | Intl.DateTimeFormatOptions> = new Dictionary<TimeUnit, string | Intl.DateTimeFormatOptions>();\r\n\r\n\t/**\r\n\t * These formats are applied to labels that are first in a larger unit.\r\n\t *\r\n\t * For example, if we have a DateAxis with days on it, the first day of month\r\n\t * indicates a break in month - a start of the bigger period.\r\n\t *\r\n\t * For those labels, `periodChangeDateFormats` are applied instead of\r\n\t * `dateFormats`.\r\n\t *\r\n\t * This allows us implement convenient structures, like instead of:\r\n\t *\r\n\t * `Jan 1 - Jan 2 - Jan 3 - ...`\r\n\t *\r\n\t * We can have:\r\n\t *\r\n\t * `Jan - 1 - 2 - 3 - ...`\r\n\t *\r\n\t * This can be disabled by setting `markUnitChange = false`.\r\n\t */\r\n\tpublic periodChangeDateFormats: Dictionary<TimeUnit, string | Intl.DateTimeFormatOptions> = new Dictionary<TimeUnit, string | Intl.DateTimeFormatOptions>();\r\n\r\n\t/**\r\n\t * At which intervals grid elements are displayed.\r\n\t */\r\n\tprotected _gridInterval: ITimeInterval;\r\n\r\n\t/**\r\n\t * [_intervalDuration description]\r\n\t *\r\n\t * @todo Description\r\n\t */\r\n\tprotected _intervalDuration: number;\r\n\r\n\t/**\r\n\t * [_gridDate description]\r\n\t *\r\n\t * @todo Description\r\n\t */\r\n\tprotected _gridDate: Date;\r\n\r\n\t/**\r\n\t * [_nextGridUnit description]\r\n\t *\r\n\t * @todo Description\r\n\t */\r\n\tprotected _nextGridUnit: TimeUnit;\r\n\r\n\t/**\r\n\t * User-defined granularity of data.\r\n\t */\r\n\tprotected _baseInterval: ITimeInterval;\r\n\r\n\t/**\r\n\t * This is base interval of the main data set.\r\n\t */\r\n\tprotected _mainBaseInterval: ITimeInterval;\r\n\r\n\t/**\r\n\t * This is base interval of the currently selected data set.\r\n\t */\r\n\tprotected _groupInterval: ITimeInterval;\r\n\r\n\t/**\r\n\t * Actual interval (granularity) derived from the actual data.\r\n\t */\r\n\tprotected _baseIntervalReal: ITimeInterval = { timeUnit: \"day\", count: 1 };\r\n\r\n\t/**\r\n\t */\r\n\tprotected _prevSeriesTime: { [index: string]: number } = {};\r\n\r\n\t/**\r\n\t * [_minDifference description]\r\n\t *\r\n\t * @todo Description\r\n\t */\r\n\tprotected _minDifference: { [index: string]: number } = {};\r\n\r\n\t/**\r\n\t * A function which applies fills to axis cells.\r\n\t *\r\n\t * Default function fills every second fill. You can set this to a function\r\n\t * that follows some other logic.\r\n\t *\r\n\t * Function should accept a [[DateAxisDataItem]] and modify its `axisFill`\r\n\t * property accordingly.\r\n\t */\r\n\tpublic fillRule(dataItem: this[\"_dataItem\"]): void {\r\n\t\tlet value = dataItem.value;\r\n\t\tlet axis = dataItem.component;\r\n\t\tlet gridInterval = axis._gridInterval;\r\n\t\tlet gridDuration = $time.getDuration(gridInterval.timeUnit, gridInterval.count);\r\n\r\n\t\tif (Math.round((value - axis.min) / gridDuration) / 2 == Math.round(Math.round((value - axis.min) / gridDuration) / 2)) {\r\n\t\t\tdataItem.axisFill.__disabled = true;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tdataItem.axisFill.__disabled = false;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tprotected _firstWeekDay: number = 1;\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tprotected _df: DateFormatter;\r\n\r\n\t/**\r\n\t * A collection of start timestamps to use as axis' min timestamp for\r\n\t * particular data item item periods.\r\n\t *\r\n\t * @since 4.7.0\r\n\t * @readonly\r\n\t */\r\n\tpublic groupMin: { [index: string]: number } = {};\r\n\r\n\t/**\r\n\t * A collection of start timestamps to use as axis' max timestamp for\r\n\t * particular data item item periods.\r\n\t *\r\n\t * @since 4.7.0\r\n\t * @readonly\r\n\t */\r\n\tpublic groupMax: { [index: string]: number } = {};\r\n\r\n\t/**\r\n\t * Date of the last shown axis tooltip.\r\n\t *\r\n\t * @since 4.9.7\r\n\t * @readonly\r\n\t */\r\n\tpublic tooltipDate: Date;\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor() {\r\n\r\n\t\t// Init\r\n\t\tsuper();\r\n\t\tthis.className = \"DateAxis\";\r\n\r\n\t\tthis.setPropertyValue(\"markUnitChange\", true);\r\n\t\tthis.snapTooltip = true;\r\n\t\tthis.tooltipPosition = \"pointer\";\r\n\r\n\t\tthis.setPropertyValue(\"groupData\", false);\r\n\t\tthis.groupCount = 200;\r\n\r\n\t\tthis.events.on(\"parentset\", this.getDFFormatter, this, false);\r\n\r\n\t\t// Translatable defaults are applied in `applyInternalDefaults()`\r\n\t\t// ...\r\n\r\n\t\t// Define default intervals\r\n\t\tthis.gridIntervals.pushAll([\r\n\t\t\t{ timeUnit: \"millisecond\", count: 1 },\r\n\t\t\t{ timeUnit: \"millisecond\", count: 5 },\r\n\t\t\t{ timeUnit: \"millisecond\", count: 10 },\r\n\t\t\t{ timeUnit: \"millisecond\", count: 50 },\r\n\t\t\t{ timeUnit: \"millisecond\", count: 100 },\r\n\t\t\t{ timeUnit: \"millisecond\", count: 500 },\r\n\t\t\t{ timeUnit: \"second\", count: 1 },\r\n\t\t\t{ timeUnit: \"second\", count: 5 },\r\n\t\t\t{ timeUnit: \"second\", count: 10 },\r\n\t\t\t{ timeUnit: \"second\", count: 30 },\r\n\t\t\t{ timeUnit: \"minute\", count: 1 },\r\n\t\t\t{ timeUnit: \"minute\", count: 5 },\r\n\t\t\t{ timeUnit: \"minute\", count: 10 },\r\n\t\t\t{ timeUnit: \"minute\", count: 15 },\r\n\t\t\t{ timeUnit: \"minute\", count: 30 },\r\n\t\t\t{ timeUnit: \"hour\", count: 1 },\r\n\t\t\t{ timeUnit: \"hour\", count: 3 },\r\n\t\t\t{ timeUnit: \"hour\", count: 6 },\r\n\t\t\t{ timeUnit: \"hour\", count: 12 },\r\n\t\t\t{ timeUnit: \"day\", count: 1 },\r\n\t\t\t{ timeUnit: \"day\", count: 2 },\r\n\t\t\t{ timeUnit: \"day\", count: 3 },\r\n\t\t\t{ timeUnit: \"day\", count: 4 },\r\n\t\t\t{ timeUnit: \"day\", count: 5 },\r\n\t\t\t{ timeUnit: \"week\", count: 1 },\r\n\t\t\t{ timeUnit: \"month\", count: 1 },\r\n\t\t\t{ timeUnit: \"month\", count: 2 },\r\n\t\t\t{ timeUnit: \"month\", count: 3 },\r\n\t\t\t{ timeUnit: \"month\", count: 6 },\r\n\t\t\t{ timeUnit: \"year\", count: 1 },\r\n\t\t\t{ timeUnit: \"year\", count: 2 },\r\n\t\t\t{ timeUnit: \"year\", count: 5 },\r\n\t\t\t{ timeUnit: \"year\", count: 10 },\r\n\t\t\t{ timeUnit: \"year\", count: 50 },\r\n\t\t\t{ timeUnit: \"year\", count: 100 },\r\n\t\t\t{ timeUnit: \"year\", count: 200 },\r\n\t\t\t{ timeUnit: \"year\", count: 500 },\r\n\t\t\t{ timeUnit: \"year\", count: 1000 },\r\n\t\t\t{ timeUnit: \"year\", count: 2000 },\r\n\t\t\t{ timeUnit: \"year\", count: 5000 },\r\n\t\t\t{ timeUnit: \"year\", count: 10000 },\r\n\t\t\t{ timeUnit: \"year\", count: 100000 }\r\n\t\t]);\r\n\r\n\t\tthis.groupIntervals.pushAll([\r\n\t\t\t{ timeUnit: \"millisecond\", count: 1 },\r\n\t\t\t{ timeUnit: \"millisecond\", count: 10 },\r\n\t\t\t{ timeUnit: \"millisecond\", count: 100 },\r\n\t\t\t{ timeUnit: \"second\", count: 1 },\r\n\t\t\t{ timeUnit: \"second\", count: 10 },\r\n\t\t\t{ timeUnit: \"minute\", count: 1 },\r\n\t\t\t{ timeUnit: \"minute\", count: 10 },\r\n\t\t\t{ timeUnit: \"hour\", count: 1 },\r\n\t\t\t{ timeUnit: \"day\", count: 1 },\r\n\t\t\t{ timeUnit: \"week\", count: 1 },\r\n\t\t\t{ timeUnit: \"month\", count: 1 },\r\n\t\t\t{ timeUnit: \"year\", count: 1 }\r\n\t\t]);\r\n\r\n\t\t// Set field name\r\n\t\tthis.axisFieldName = \"date\";\r\n\r\n\t\t// Apply theme\r\n\t\tthis.applyTheme();\r\n\t}\r\n\r\n\t/**\r\n\t * Sets defaults that instantiate some objects that rely on parent, so they\r\n\t * cannot be set in constructor.\r\n\t */\r\n\tprotected applyInternalDefaults(): void {\r\n\t\tsuper.applyInternalDefaults();\r\n\r\n\t\t// Set default date formats\r\n\t\tif (!this.dateFormats.hasKey(\"millisecond\")) {\r\n\t\t\tthis.dateFormats.setKey(\"millisecond\", this.language.translate(\"_date_millisecond\"));\r\n\t\t}\r\n\t\tif (!this.dateFormats.hasKey(\"second\")) {\r\n\t\t\tthis.dateFormats.setKey(\"second\", this.language.translate(\"_date_second\"));\r\n\t\t}\r\n\t\tif (!this.dateFormats.hasKey(\"minute\")) {\r\n\t\t\tthis.dateFormats.setKey(\"minute\", this.language.translate(\"_date_minute\"));\r\n\t\t}\r\n\t\tif (!this.dateFormats.hasKey(\"hour\")) {\r\n\t\t\tthis.dateFormats.setKey(\"hour\", this.language.translate(\"_date_hour\"));\r\n\t\t}\r\n\t\tif (!this.dateFormats.hasKey(\"day\")) {\r\n\t\t\tthis.dateFormats.setKey(\"day\", this.language.translate(\"_date_day\"));\r\n\t\t}\r\n\t\tif (!this.dateFormats.hasKey(\"week\")) {\r\n\t\t\tthis.dateFormats.setKey(\"week\", this.language.translate(\"_date_day\"));\t // not a mistake\r\n\t\t}\r\n\t\tif (!this.dateFormats.hasKey(\"month\")) {\r\n\t\t\tthis.dateFormats.setKey(\"month\", this.language.translate(\"_date_month\"));\r\n\t\t}\r\n\t\tif (!this.dateFormats.hasKey(\"year\")) {\r\n\t\t\tthis.dateFormats.setKey(\"year\", this.language.translate(\"_date_year\"));\r\n\t\t}\r\n\r\n\t\tif (!this.periodChangeDateFormats.hasKey(\"millisecond\")) {\r\n\t\t\tthis.periodChangeDateFormats.setKey(\"millisecond\", this.language.translate(\"_date_millisecond\"));\r\n\t\t}\r\n\t\tif (!this.periodChangeDateFormats.hasKey(\"second\")) {\r\n\t\t\tthis.periodChangeDateFormats.setKey(\"second\", this.language.translate(\"_date_second\"));\r\n\t\t}\r\n\t\tif (!this.periodChangeDateFormats.hasKey(\"minute\")) {\r\n\t\t\tthis.periodChangeDateFormats.setKey(\"minute\", this.language.translate(\"_date_minute\"));\r\n\t\t}\r\n\t\tif (!this.periodChangeDateFormats.hasKey(\"hour\")) {\r\n\t\t\tthis.periodChangeDateFormats.setKey(\"hour\", this.language.translate(\"_date_day\"));\r\n\t\t}\r\n\t\tif (!this.periodChangeDateFormats.hasKey(\"day\")) {\r\n\t\t\tthis.periodChangeDateFormats.setKey(\"day\", this.language.translate(\"_date_day\"));\r\n\t\t}\r\n\t\tif (!this.periodChangeDateFormats.hasKey(\"week\")) {\r\n\t\t\tthis.periodChangeDateFormats.setKey(\"week\", this.language.translate(\"_date_day\"));\r\n\t\t}\r\n\t\tif (!this.periodChangeDateFormats.hasKey(\"month\")) {\r\n\t\t\tthis.periodChangeDateFormats.setKey(\"month\", this.language.translate(\"_date_month\") + \" \" + this.language.translate(\"_date_year\"));\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a new/empty [[DataItem]] of the type appropriate for this object.\r\n\t *\r\n\t * @see {@link DataItem}\r\n\t * @return Data Item\r\n\t */\r\n\tprotected createDataItem(): this[\"_dataItem\"] {\r\n\t\treturn new DateAxisDataItem();\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a new/empty [[AxisBreak]] of the appropriate type.\r\n\t *\r\n\t * @return Axis break\r\n\t */\r\n\tprotected createAxisBreak(): this[\"_axisBreak\"] {\r\n\t\treturn new DateAxisBreak();\r\n\t}\r\n\r\n\t/**\r\n\t * Validates Axis' data items.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic validateDataItems(): void {\r\n\t\t// allows to keep selection of the same size\r\n\t\tlet start: number = this.start;\r\n\t\tlet end: number = this.end;\r\n\t\tlet baseDuration = this.baseDuration;\r\n\t\tlet periodCount: number = (this.max - this.min) / baseDuration;\r\n\r\n\t\tthis._firstWeekDay = this.getFirstWeekDay();\r\n\t\tthis.getDFFormatter();\r\n\r\n\t\tsuper.validateDataItems();\r\n\r\n\t\tlet mainBaseDuration = $time.getDuration(this.mainBaseInterval.timeUnit, this.mainBaseInterval.count)\r\n\r\n\t\tthis.maxZoomFactor = Math.max(1, (this.max - this.min) / mainBaseDuration);\r\n\r\n\t\tthis._deltaMinMax = this.baseDuration / 2;\r\n\r\n\t\t// allows to keep selection of the same size\r\n\t\tlet newPeriodCount: number = (this.max - this.min) / baseDuration;\r\n\t\tstart = start + (end - start) * (1 - periodCount / newPeriodCount);\r\n\t\tthis.zoom({ start: start, end: end }, false, true); // added instantlyto solve zoomout problem when we have axes gaps. @todo: check how this affects maxZoomFactor\r\n\t}\r\n\r\n\t/**\r\n\t * Handles process after zoom.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Does nothing?\r\n\t */\r\n\tpublic handleSelectionExtremesChange(): void {\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Calculates all positions, related to axis as per current zoom.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic calculateZoom(): void {\r\n\t\tsuper.calculateZoom();\r\n\r\n\t\tlet difference = this.adjustDifference(this._minZoomed, this._maxZoomed);\r\n\t\tlet dataSetChanged = false;\r\n\r\n\t\t// if data has to be grouped, choose interval and set dataset\r\n\t\tif (this.groupData && $type.hasValue(difference)) {\r\n\t\t\tlet mainBaseInterval = this.mainBaseInterval;\r\n\r\n\t\t\tlet modifiedDifference = difference + (this.startLocation + (1 - this.endLocation)) * this.baseDuration;\r\n\t\t\tlet groupInterval: ITimeInterval;\r\n\t\t\tif (this.groupInterval) {\r\n\t\t\t\tgroupInterval = { ...this.groupInterval }\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tgroupInterval = this.chooseInterval(0, modifiedDifference, this.groupCount, this.groupIntervals);\r\n\t\t\t\tif ($time.getDuration(groupInterval.timeUnit, groupInterval.count) < $time.getDuration(mainBaseInterval.timeUnit, mainBaseInterval.count)) {\r\n\t\t\t\t\tgroupInterval = { ...mainBaseInterval };\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\r\n\t\t\tthis._groupInterval = groupInterval;\r\n\t\t\tlet newId = groupInterval.timeUnit + groupInterval.count;\r\n\t\t\tif (this._currentDataSetId != newId) {\r\n\t\t\t\tthis._currentDataSetId = newId;\r\n\t\t\t\tthis.dispatch(\"groupperiodchanged\");\r\n\t\t\t}\r\n\r\n\t\t\tthis.series.each((series) => {\r\n\t\t\t\tif (series.baseAxis == this) {\r\n\t\t\t\t\tif (series.setDataSet(this._currentDataSetId)) {\r\n\t\t\t\t\t\tdataSetChanged = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t}\r\n\r\n\t\tlet gridInterval: ITimeInterval = this.chooseInterval(0, difference, this._gridCount);\r\n\r\n\t\tif ($time.getDuration(gridInterval.timeUnit, gridInterval.count) < this.baseDuration) {\r\n\t\t\tgridInterval = { ...this.baseInterval };\r\n\t\t}\r\n\r\n\t\tthis._gridInterval = gridInterval;\r\n\t\tthis._nextGridUnit = $time.getNextUnit(gridInterval.timeUnit);\r\n\r\n\t\t// the following is needed to avoid grid flickering while scrolling\r\n\t\tthis._intervalDuration = $time.getDuration(gridInterval.timeUnit, gridInterval.count);\r\n\t\tthis._gridDate = $time.round(\r\n\t\t\tnew Date(this.minZoomed - $time.getDuration(gridInterval.timeUnit, gridInterval.count)),\r\n\t\t\tgridInterval.timeUnit,\r\n\t\t\tgridInterval.count,\r\n\t\t\tthis._firstWeekDay,\r\n\t\t\tthis._df.utc,\r\n\t\t\tnew Date(this.min),\r\n\t\t\tthis._df.timezoneMinutes,\r\n\t\t\tthis._df.timezone\r\n\t\t);\r\n\r\n\t\t// tell series start/end\r\n\t\t$iter.each(this.series.iterator(), (series) => {\r\n\t\t\tif (series.baseAxis == this) {\r\n\t\t\t\tlet field = <keyof XYSeriesDataItem>series.getAxisField(this);\r\n\r\n\t\t\t\tlet minZoomed = $time.round(\r\n\t\t\t\t\tnew Date(this._minZoomed + this.baseDuration * 0.05),\r\n\t\t\t\t\tthis.baseInterval.timeUnit, this.baseInterval.count,\r\n\t\t\t\t\tthis._firstWeekDay,\r\n\t\t\t\t\tthis._df.utc,\r\n\t\t\t\t\tundefined,\r\n\t\t\t\t\tthis._df.timezoneMinutes,\r\n\t\t\t\t\tthis._df.timezone\r\n\t\t\t\t).getTime();\r\n\t\t\t\tlet minZoomedStr = minZoomed.toString();\r\n\t\t\t\tlet startDataItem = series.dataItemsByAxis.getKey(this.uid).getKey(minZoomedStr + series.currentDataSetId);\r\n\r\n\t\t\t\tlet startIndex: number = 0;\r\n\t\t\t\tif (this.start != 0) {\r\n\t\t\t\t\tif (startDataItem) {\r\n\t\t\t\t\t\tstartDataItem = this.findFirst(startDataItem, minZoomed, field);\r\n\t\t\t\t\t\tstartIndex = startDataItem.index;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tstartIndex = series.dataItems.findClosestIndex(this._minZoomed, (x) => <number>x[field], \"left\");\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t// 1 millisecond is removed so that if only first item is selected, it would not count in the second.\r\n\t\t\t\tlet baseInterval = this.baseInterval;\r\n\t\t\t\tlet maxZoomed = $time.add(\r\n\t\t\t\t\t$time.round(\r\n\t\t\t\t\t\tnew Date(this._maxZoomed),\r\n\t\t\t\t\t\tbaseInterval.timeUnit,\r\n\t\t\t\t\t\tbaseInterval.count,\r\n\t\t\t\t\t\tthis._firstWeekDay,\r\n\t\t\t\t\t\tthis._df.utc,\r\n\t\t\t\t\t\tundefined,\r\n\t\t\t\t\t\tthis._df.timezoneMinutes,\r\n\t\t\t\t\t\tthis._df.timezone\r\n\t\t\t\t\t),\r\n\t\t\t\t\tbaseInterval.timeUnit,\r\n\t\t\t\t\tbaseInterval.count,\r\n\t\t\t\t\tthis._df.utc\r\n\t\t\t\t).getTime();\r\n\r\n\t\t\t\tlet maxZoomedStr = maxZoomed.toString();\r\n\t\t\t\tlet endDataItem = series.dataItemsByAxis.getKey(this.uid).getKey(maxZoomedStr + series.currentDataSetId);\r\n\t\t\t\tlet endIndex: number = series.dataItems.length;\r\n\t\t\t\tif (this.end != 1) {\r\n\t\t\t\t\tif (endDataItem) {\r\n\t\t\t\t\t\tendIndex = endDataItem.index;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tmaxZoomed -= 1;\r\n\t\t\t\t\t\tendIndex = series.dataItems.findClosestIndex(maxZoomed, (x) => <number>x[field], \"right\");\r\n\t\t\t\t\t\t// not good - if end is in the gap, indexes go like 5,4,3,4,2,1\r\n\t\t\t\t\t\t//if (endIndex < series.dataItems.length) {\r\n\t\t\t\t\t\tendIndex++;\r\n\t\t\t\t\t\t//}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (series.max(this) < minZoomed) {\r\n\t\t\t\t\tseries.startIndex = series.dataItems.length;\r\n\t\t\t\t\tseries.endIndex = series.dataItems.length;\r\n\t\t\t\t\tseries.outOfRange = true;\r\n\t\t\t\t}\r\n\t\t\t\telse if (series.min(this) > maxZoomed) {\r\n\t\t\t\t\tseries.startIndex = 0;\r\n\t\t\t\t\tseries.endIndex = 0;\r\n\t\t\t\t\tseries.outOfRange = true;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tseries.outOfRange = false;\r\n\t\t\t\t\tseries.startIndex = startIndex;\r\n\t\t\t\t\tseries.endIndex = endIndex;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t//\tconsole.log(series.name, startIndex, endIndex);\r\n\r\n\t\t\t\tif (!dataSetChanged && series.dataRangeInvalid) {\r\n\t\t\t\t\tseries.validateDataRange();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\tprotected findFirst(dataItem: XYSeriesDataItem, time: number, key: string): XYSeriesDataItem {\r\n\t\tlet index = dataItem.index;\r\n\r\n\t\tif (index > 0) {\r\n\t\t\tlet series = dataItem.component;\r\n\t\t\tlet previousDataItem = series.dataItems.getIndex(index - 1);\r\n\r\n\t\t\tlet previousDate = (<any>previousDataItem)[key];\r\n\r\n\t\t\tif (!previousDate || previousDate.getTime() < time) {\r\n\t\t\t\treturn dataItem;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\treturn this.findFirst(previousDataItem, time, key);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn dataItem;\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * (Re)validates data.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic validateData(): void {\r\n\t\tsuper.validateData();\r\n\t\tif (!$type.isNumber(this.baseInterval.count)) {\r\n\t\t\tthis.baseInterval.count = 1;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tpublic get minDifference(): number {\r\n\t\tlet minDifference = Number.MAX_VALUE;\r\n\r\n\t\tthis.series.each((series) => {\r\n\t\t\tif (minDifference > this._minDifference[series.uid]) {\r\n\t\t\t\tminDifference = this._minDifference[series.uid];\r\n\t\t\t}\r\n\t\t})\r\n\r\n\t\tif (minDifference == Number.MAX_VALUE || minDifference == 0) {\r\n\t\t\tminDifference = $time.getDuration(\"day\");\r\n\t\t}\r\n\r\n\t\treturn minDifference;\r\n\t}\r\n\r\n\t/**\r\n\t * [dataChangeUpdate description]\r\n\t *\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description\r\n\t */\r\n\tpublic seriesDataChangeUpdate(series: XYSeries): void {\r\n\t\tthis._minDifference[series.uid] = Number.MAX_VALUE;\r\n\t}\r\n\r\n\t/**\r\n\t * [postProcessSeriesDataItems description]\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description\r\n\t */\r\n\tpublic postProcessSeriesDataItems(series?: XYSeries): void {\r\n\t\tthis._firstWeekDay = this.getFirstWeekDay();\r\n\t\tif (series) {\r\n\t\t\tthis.seriesGroupUpdate(series);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tthis.series.each((series) => {\r\n\t\t\t\tthis.seriesGroupUpdate(series);\r\n\t\t\t})\r\n\t\t}\r\n\r\n\t\tthis.addEmptyUnitsBreaks();\r\n\t}\r\n\r\n\tprotected seriesGroupUpdate(series: XYSeries) {\r\n\t\tif (JSON.stringify(series._baseInterval[this.uid]) != JSON.stringify(this.mainBaseInterval)) {\r\n\r\n\t\t\tseries._baseInterval[this.uid] = this.mainBaseInterval;\r\n\r\n\t\t\tseries.mainDataSet.each((dataItem) => {\r\n\t\t\t\tthis.postProcessSeriesDataItem(dataItem);\r\n\t\t\t});\r\n\r\n\t\t\tif (this.groupData) {\r\n\t\t\t\tthis.groupSeriesData(series);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Calculates series group data.\r\n\t * \r\n\t * @param  series  Series\r\n\t * @ignore\r\n\t */\r\n\tpublic groupSeriesData(series: XYSeries): void {\r\n\t\tif (series.baseAxis == this && series.dataItems.length > 0 && !series.dataGrouped) {\r\n\r\n\t\t\tseries.bulletsContainer.removeChildren();\r\n\r\n\t\t\t// make array of intervals which will be used;\r\n\t\t\tlet intervals: ITimeInterval[] = [];\r\n\t\t\tlet mainBaseInterval = this.mainBaseInterval;\r\n\t\t\tlet mainIntervalDuration = $time.getDuration(mainBaseInterval.timeUnit, mainBaseInterval.count);\r\n\r\n\t\t\tthis.groupIntervals.each((interval) => {\r\n\t\t\t\tlet intervalDuration = $time.getDuration(interval.timeUnit, interval.count);\r\n\t\t\t\tif ((intervalDuration > mainIntervalDuration && intervalDuration < (this.max - this.min)) || this.groupInterval) {\r\n\t\t\t\t\tintervals.push(interval);\r\n\t\t\t\t}\r\n\t\t\t})\r\n\r\n\t\t\tif (series._dataSets) {\r\n\t\t\t\tseries._dataSets.each((key, dataItems) => {\r\n\t\t\t\t\tdataItems.each((dataItem) => {\r\n\t\t\t\t\t\tdataItem.dispose();\r\n\t\t\t\t\t})\r\n\t\t\t\t\tdataItems.clear();\r\n\t\t\t\t})\r\n\t\t\t\tseries._dataSets.clear();\r\n\t\t\t}\r\n\r\n\t\t\tseries.dataGrouped = true;\r\n\r\n\t\t\t$array.each(intervals, (interval) => {\r\n\r\n\t\t\t\t//let mainBaseInterval = this._mainBaseInterval;\r\n\t\t\t\tlet key = \"date\" + this.axisLetter;\r\n\r\n\t\t\t\t// create data set\r\n\t\t\t\tlet dataSetId = interval.timeUnit + interval.count;\r\n\t\t\t\t// todo: check where this clone goes\r\n\t\t\t\tlet dataSet = new OrderedListTemplate(series.mainDataSet.template.clone());\r\n\r\n\t\t\t\tseries.dataSets.setKey(dataSetId, dataSet);\r\n\r\n\t\t\t\tlet dataItems = series.mainDataSet;\r\n\t\t\t\tlet previousTime: number = Number.NEGATIVE_INFINITY;\r\n\t\t\t\tlet i = 0;\r\n\t\t\t\tlet newDataItem: XYSeriesDataItem;\r\n\r\n\t\t\t\tlet dataFields: string[] = [];\r\n\r\n\t\t\t\t$object.each(series.dataFields, (dfkey, df) => {\r\n\t\t\t\t\tlet dfk = <string>dfkey;\r\n\t\t\t\t\tif (dfk != key && dfk.indexOf(\"Show\") == -1) {\r\n\t\t\t\t\t\tdataFields.push(dfk);\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\r\n\t\t\t\tlet roundedDate: Date;\r\n\t\t\t\tdataItems.each((dataItem) => {\r\n\t\t\t\t\tlet date = dataItem.getDate(key);\r\n\t\t\t\t\tif (date) {\r\n\t\t\t\t\t\tlet time = date.getTime();\r\n\t\t\t\t\t\troundedDate = $time.round(\r\n\t\t\t\t\t\t\tnew Date(time),\r\n\t\t\t\t\t\t\tinterval.timeUnit,\r\n\t\t\t\t\t\t\tinterval.count,\r\n\t\t\t\t\t\t\tthis._df.firstDayOfWeek,\r\n\t\t\t\t\t\t\tthis._df.utc,\r\n\t\t\t\t\t\t\tundefined,\r\n\t\t\t\t\t\t\tthis._df.timezoneMinutes,\r\n\t\t\t\t\t\t\tthis._df.timezone\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t\tlet currentTime = roundedDate.getTime();\r\n\t\t\t\t\t\t// changed period\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\tif (previousTime < currentTime) {\r\n\r\n\t\t\t\t\t\t\tif (newDataItem && series._adapterO) {\r\n\t\t\t\t\t\t\t\t$array.each(dataFields, (vkey) => {\r\n\t\t\t\t\t\t\t\t\tnewDataItem.values[vkey].value = series._adapterO.apply(\"groupDataItem\", {\r\n\t\t\t\t\t\t\t\t\t\tdataItem: newDataItem,\r\n\t\t\t\t\t\t\t\t\t\tinterval: interval,\r\n\t\t\t\t\t\t\t\t\t\tdataField: <any>vkey,\r\n\t\t\t\t\t\t\t\t\t\tdate: roundedDate,\r\n\t\t\t\t\t\t\t\t\t\tvalue: newDataItem.values[vkey].value\r\n\t\t\t\t\t\t\t\t\t}).value;\r\n\r\n\t\t\t\t\t\t\t\t\tnewDataItem.values[vkey].workingValue = newDataItem.values[vkey].value\r\n\t\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tnewDataItem = dataSet.create();\r\n\r\n\t\t\t\t\t\t\tnewDataItem.dataContext = {};\r\n\r\n\t\t\t\t\t\t\tnewDataItem.setWorkingLocation(\"dateX\", series.dataItems.template.locations.dateX, 0);\r\n\t\t\t\t\t\t\tnewDataItem.setWorkingLocation(\"openDateX\", series.dataItems.template.locations.openDateX, 0);\r\n\t\t\t\t\t\t\tnewDataItem.setWorkingLocation(\"dateY\", series.dataItems.template.locations.dateY, 0);\r\n\t\t\t\t\t\t\tnewDataItem.setWorkingLocation(\"openDateY\", series.dataItems.template.locations.openDateY, 0);\r\n\r\n\t\t\t\t\t\t\tnewDataItem.component = series;\r\n\t\t\t\t\t\t\t// other Dates?\r\n\t\t\t\t\t\t\tnewDataItem.setDate(key, roundedDate);\r\n\t\t\t\t\t\t\tnewDataItem._index = i;\r\n\t\t\t\t\t\t\ti++;\r\n\r\n\t\t\t\t\t\t\t$array.each(dataFields, (vkey) => {\r\n\t\t\t\t\t\t\t\t//let groupFieldName = vkey + \"Group\";\r\n\t\t\t\t\t\t\t\tlet dvalues = dataItem.values[vkey];\r\n\t\t\t\t\t\t\t\tif (dvalues) {\r\n\t\t\t\t\t\t\t\t\tlet value = dvalues.value;\r\n\r\n\t\t\t\t\t\t\t\t\tif (series._adapterO) {\r\n\t\t\t\t\t\t\t\t\t\tvalue = series._adapterO.apply(\"groupValue\", {\r\n\t\t\t\t\t\t\t\t\t\t\tdataItem: dataItem,\r\n\t\t\t\t\t\t\t\t\t\t\tinterval: interval,\r\n\t\t\t\t\t\t\t\t\t\t\tdataField: <any>vkey,\r\n\t\t\t\t\t\t\t\t\t\t\tdate: roundedDate,\r\n\t\t\t\t\t\t\t\t\t\t\tvalue: value\r\n\t\t\t\t\t\t\t\t\t\t}).value;\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\tlet values = newDataItem.values[vkey];\r\n\t\t\t\t\t\t\t\t\tif ($type.isNumber(value)) {\r\n\r\n\t\t\t\t\t\t\t\t\t\tvalues.value = value;\r\n\t\t\t\t\t\t\t\t\t\tvalues.workingValue = value;\r\n\r\n\t\t\t\t\t\t\t\t\t\tvalues.open = value;\r\n\t\t\t\t\t\t\t\t\t\tvalues.close = value;\r\n\t\t\t\t\t\t\t\t\t\tvalues.low = value;\r\n\t\t\t\t\t\t\t\t\t\tvalues.high = value;\r\n\t\t\t\t\t\t\t\t\t\tvalues.sum = value;\r\n\t\t\t\t\t\t\t\t\t\tvalues.average = value;\r\n\t\t\t\t\t\t\t\t\t\tvalues.count = 1;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\t\t\tvalues.count = 0;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t})\r\n\r\n\t\t\t\t\t\t\tthis.postProcessSeriesDataItem(newDataItem, interval);\r\n\r\n\t\t\t\t\t\t\t$object.each(series.propertyFields, (key, fieldValue) => {\r\n\t\t\t\t\t\t\t\tconst f: string = <string>key;\r\n\t\t\t\t\t\t\t\tlet value: any = (<any>dataItem.properties)[key];\r\n\r\n\t\t\t\t\t\t\t\tif ($type.hasValue(value)) {\r\n\t\t\t\t\t\t\t\t\tnewDataItem.hasProperties = true;\r\n\t\t\t\t\t\t\t\t\tnewDataItem.setProperty(f, value);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\tnewDataItem.groupDataItems = [dataItem];\r\n\t\t\t\t\t\t\tpreviousTime = currentTime;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\tif (newDataItem) {\r\n\t\t\t\t\t\t\t\t$array.each(dataFields, (vkey) => {\r\n\t\t\t\t\t\t\t\t\tlet groupFieldName = (<any>series.groupFields)[vkey];\r\n\t\t\t\t\t\t\t\t\tlet dvalues = dataItem.values[vkey];\r\n\t\t\t\t\t\t\t\t\tif (dvalues) {\r\n\t\t\t\t\t\t\t\t\t\tlet value = dvalues.value;\r\n\r\n\t\t\t\t\t\t\t\t\t\tif (series._adapterO) {\r\n\t\t\t\t\t\t\t\t\t\t\tvalue = series._adapterO.apply(\"groupValue\", {\r\n\t\t\t\t\t\t\t\t\t\t\t\tdataItem: dataItem,\r\n\t\t\t\t\t\t\t\t\t\t\t\tinterval: interval,\r\n\t\t\t\t\t\t\t\t\t\t\t\tdataField: <any>vkey,\r\n\t\t\t\t\t\t\t\t\t\t\t\tdate: roundedDate,\r\n\t\t\t\t\t\t\t\t\t\t\t\tvalue: value\r\n\t\t\t\t\t\t\t\t\t\t\t}).value;\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\tif ($type.isNumber(value)) {\r\n\t\t\t\t\t\t\t\t\t\t\tlet values = newDataItem.values[vkey];\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tif (!$type.isNumber(values.open)) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tvalues.open = value;\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tvalues.close = value;\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tif (values.low > value || !$type.isNumber(values.low)) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tvalues.low = value;\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\tif (values.high < value || !$type.isNumber(values.high)) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tvalues.high = value;\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\tif ($type.isNumber(values.sum)) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tvalues.sum += value;\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\t\t\t\t\tvalues.sum = value;\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\tvalues.count++;\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tvalues.average = values.sum / values.count;\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tif ($type.isNumber(values[groupFieldName])) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tvalues.value = values[groupFieldName];\r\n\t\t\t\t\t\t\t\t\t\t\t\tvalues.workingValue = values.value;\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t})\r\n\t\t\t\t\t\t\t\t$utils.copyProperties(dataItem.properties, newDataItem.properties);\r\n\r\n\t\t\t\t\t\t\t\t$object.each(series.propertyFields, (key, fieldValue) => {\r\n\t\t\t\t\t\t\t\t\tconst f: string = <string>key;\r\n\t\t\t\t\t\t\t\t\tlet value: any = (<any>dataItem.properties)[key];\r\n\t\t\t\t\t\t\t\t\tif ($type.hasValue(value)) {\r\n\t\t\t\t\t\t\t\t\t\tnewDataItem.hasProperties = true;\r\n\t\t\t\t\t\t\t\t\t\tnewDataItem.setProperty(f, value);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t});\r\n\r\n\t\t\t\t\t\t\t\tnewDataItem.groupDataItems.push(dataItem);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (newDataItem) {\r\n\t\t\t\t\t\t$utils.copyProperties(dataItem.dataContext, newDataItem.dataContext);\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t\t\tif (newDataItem && series._adapterO) {\r\n\r\n\t\t\t\t\t$array.each(dataFields, (vkey) => {\r\n\t\t\t\t\t\tnewDataItem.values[vkey].value = series._adapterO.apply(\"groupDataItem\", {\r\n\t\t\t\t\t\t\tdataItem: newDataItem,\r\n\t\t\t\t\t\t\tinterval: interval,\r\n\t\t\t\t\t\t\tdataField: <any>vkey,\r\n\t\t\t\t\t\t\tdate: roundedDate,\r\n\t\t\t\t\t\t\tvalue: newDataItem.values[vkey].value\r\n\t\t\t\t\t\t}).value;\r\n\r\n\t\t\t\t\t\tnewDataItem.values[vkey].workingValue = newDataItem.values[vkey].value;\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t})\r\n\r\n\t\t\tthis.calculateZoom();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tprotected getDFFormatter() {\r\n\t\tthis._df = this.dateFormatter;\r\n\t}\r\n\r\n\t/**\r\n\t * [postProcessSeriesDataItem description]\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description\r\n\t * @param dataItem Data item\r\n\t */\r\n\tpublic postProcessSeriesDataItem(dataItem: XYSeriesDataItem, interval?: ITimeInterval): void {\r\n\t\t// we need to do this for all series data items not only added recently, as baseInterval might change\r\n\t\tlet intervalID = \"\";\r\n\t\tif (interval) {\r\n\t\t\tintervalID = interval.timeUnit + interval.count;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tinterval = this.mainBaseInterval;\r\n\t\t}\r\n\r\n\t\tlet series: XYSeries = dataItem.component;\r\n\t\tlet dataItemsByAxis = series.dataItemsByAxis.getKey(this.uid);\r\n\r\n\t\t$object.each(dataItem.dates, (key) => {\r\n\t\t\tlet date: Date = dataItem.getDate(key);\r\n\t\t\tlet time = date.getTime();\r\n\r\n\t\t\tlet startDate: Date = $time.round(\r\n\t\t\t\tnew Date(time),\r\n\t\t\t\tinterval.timeUnit,\r\n\t\t\t\tinterval.count,\r\n\t\t\t\tthis._firstWeekDay,\r\n\t\t\t\tthis._df.utc,\r\n\t\t\t\tundefined,\r\n\t\t\t\tthis._df.timezoneMinutes,\r\n\t\t\t\tthis._df.timezone\r\n\t\t\t);\r\n\t\t\tlet startTime = startDate.getTime();\r\n\t\t\tlet endDate: Date = $time.add(new Date(startTime), interval.timeUnit, interval.count, this._df.utc);\r\n\r\n\t\t\tdataItem.setCalculatedValue(key, startTime, \"open\");\r\n\t\t\tdataItem.setCalculatedValue(key, endDate.getTime(), \"close\");\r\n\t\t\tdataItemsByAxis.setKey(startTime + intervalID, dataItem);\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Collapses empty stretches of date/time scale by creating [[AxisBreak]]\r\n\t * elements for them.\r\n\t *\r\n\t * Can be used to automatically remove strethes without data, like weekends.\r\n\t *\r\n\t * No, need to call this manually. It will automatically be done if\r\n\t * `skipEmptyPeriods = true`.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tprotected addEmptyUnitsBreaks(): void {\r\n\r\n\t\tif (this.skipEmptyPeriods && $type.isNumber(this.min) && $type.isNumber(this.max)) {\r\n\t\t\tlet timeUnit: TimeUnit = this.baseInterval.timeUnit;\r\n\t\t\tlet count: number = this.baseInterval.count;\r\n\r\n\t\t\tif (this._axisBreaks) {\r\n\t\t\t\tthis._axisBreaks.clear(); // TODO: what about breaks added by user?\r\n\t\t\t}\r\n\r\n\t\t\tlet date: Date = $time.round(\r\n\t\t\t\tnew Date(this.min),\r\n\t\t\t\ttimeUnit,\r\n\t\t\t\tcount,\r\n\t\t\t\tthis._firstWeekDay,\r\n\t\t\t\tthis._df.utc,\r\n\t\t\t\tundefined,\r\n\t\t\t\tthis._df.timezoneMinutes,\r\n\t\t\t\tthis._df.timezone\r\n\t\t\t);\r\n\t\t\tlet axisBreak: DateAxisBreak;\r\n\r\n\t\t\twhile (date.getTime() < this.max - this.baseDuration) {\r\n\t\t\t\t$time.add(date, timeUnit, count, this._df.utc);\r\n\r\n\t\t\t\tlet startTime: number = date.getTime();\r\n\t\t\t\tlet startTimeStr: string = startTime.toString();\r\n\r\n\t\t\t\tlet hasData = $iter.contains(this.series.iterator(), (series) => {\r\n\t\t\t\t\treturn !!series.dataItemsByAxis.getKey(this.uid).getKey(startTimeStr + series.currentDataSetId);\r\n\t\t\t\t});\r\n\r\n\t\t\t\t// open break if not yet opened\r\n\t\t\t\tif (!hasData) {\r\n\t\t\t\t\tif (!axisBreak) {\r\n\t\t\t\t\t\taxisBreak = <DateAxisBreak>this.axisBreaks.create();\r\n\t\t\t\t\t\taxisBreak.startDate = new Date(startTime);\r\n\t\t\t\t\t\tthis._gapBreaks = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\t// close if already opened\r\n\t\t\t\t\tif (axisBreak) {\r\n\t\t\t\t\t\t// close at end time minus one millisecond\r\n\t\t\t\t\t\taxisBreak.endDate = new Date(startTime - 1);\r\n\t\t\t\t\t\taxisBreak = undefined;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Updates positioning of Axis breaks after something changes.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic fixAxisBreaks(): void {\r\n\t\tsuper.fixAxisBreaks();\r\n\t\tlet axisBreaks = this._axisBreaks;\r\n\t\tif (axisBreaks) {\r\n\t\t\tif (axisBreaks.length > 0) {\r\n\t\t\t\t// process breaks\r\n\t\t\t\taxisBreaks.each((axisBreak) => {\r\n\t\t\t\t\tlet breakGridCount: number = Math.ceil(this._gridCount * (Math.min(this.end, axisBreak.endPosition) - Math.max(this.start, axisBreak.startPosition)) / (this.end - this.start));\r\n\t\t\t\t\taxisBreak.gridInterval = this.chooseInterval(0, axisBreak.adjustedEndValue - axisBreak.adjustedStartValue, breakGridCount);\r\n\t\t\t\t\tlet gridDate = $time.round(\r\n\t\t\t\t\t\tnew Date(axisBreak.adjustedStartValue),\r\n\t\t\t\t\t\taxisBreak.gridInterval.timeUnit,\r\n\t\t\t\t\t\taxisBreak.gridInterval.count,\r\n\t\t\t\t\t\tthis._firstWeekDay,\r\n\t\t\t\t\t\tthis._df.utc,\r\n\t\t\t\t\t\tundefined,\r\n\t\t\t\t\t\tthis._df.timezoneMinutes,\r\n\t\t\t\t\t\tthis._df.timezone\r\n\t\t\t\t\t);\r\n\t\t\t\t\tif (gridDate.getTime() > axisBreak.startDate.getTime()) {\r\n\t\t\t\t\t\t$time.add(gridDate, axisBreak.gridInterval.timeUnit, axisBreak.gridInterval.count, this._df.utc);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\taxisBreak.gridDate = gridDate;\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tprotected getFirstWeekDay(): number {\r\n\t\tif (this._df) {\r\n\t\t\treturn this._df.firstDayOfWeek;\r\n\t\t}\r\n\t\treturn 1;\r\n\t}\r\n\r\n\t/**\r\n\t * [getGridDate description]\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description\r\n\t * @param date           [description]\r\n\t * @param intervalCount  [description]\r\n\t * @return [description]\r\n\t */\r\n\tpublic getGridDate(date: Date, intervalCount: number): Date {\r\n\t\tlet timeUnit: TimeUnit = this._gridInterval.timeUnit;\r\n\t\tlet realIntervalCount: number = this._gridInterval.count;\r\n\t\t// round date\r\n\t\t$time.round(\r\n\t\t\tdate,\r\n\t\t\ttimeUnit,\r\n\t\t\t1,\r\n\t\t\tthis._firstWeekDay,\r\n\t\t\tthis._df.utc,\r\n\t\t\tundefined,\r\n\t\t\tthis._df.timezoneMinutes,\r\n\t\t\tthis._df.timezone\r\n\t\t);\r\n\r\n\t\tlet prevTimestamp: number = date.getTime();\r\n\r\n\t\tlet newDate: Date = $time.copy(date);\r\n\t\t// modify date by adding intervalcount\r\n\t\tlet timestamp: number = $time.add(newDate, timeUnit, intervalCount, this._df.utc).getTime();\r\n\r\n\t\t// if it's axis break, get first rounded date which is not in a break\r\n\t\tlet axisBreak: DateAxisBreak = <DateAxisBreak>this.isInBreak(timestamp);\r\n\t\tif (axisBreak && axisBreak.endDate) {\r\n\t\t\tnewDate = new Date(axisBreak.endDate.getTime());\r\n\t\t\t$time.round(\r\n\t\t\t\tnewDate,\r\n\t\t\t\ttimeUnit,\r\n\t\t\t\trealIntervalCount,\r\n\t\t\t\tthis._firstWeekDay,\r\n\t\t\t\tthis._df.utc,\r\n\t\t\t\tundefined,\r\n\t\t\t\tthis._df.timezoneMinutes,\r\n\t\t\t\tthis._df.timezone\r\n\t\t\t);\r\n\t\t\tif (newDate.getTime() < axisBreak.endDate.getTime()) {\r\n\t\t\t\t$time.add(newDate, timeUnit, realIntervalCount, this._df.utc);\r\n\t\t\t}\r\n\t\t\ttimestamp = newDate.getTime();\r\n\t\t}\r\n\r\n\t\t// get duration between grid lines with break duration removed\r\n\t\tlet durationBreaksRemoved: number = this.adjustDifference(prevTimestamp, timestamp);\r\n\t\t// calculate how many time units fit to this duration\r\n\t\tlet countBreaksRemoved: number = Math.round(durationBreaksRemoved / $time.getDuration(timeUnit));\r\n\r\n\t\t// if less units fit, add one and repeat\r\n\t\tif (countBreaksRemoved < realIntervalCount) {\r\n\t\t\treturn this.getGridDate(date, intervalCount + realIntervalCount);\r\n\t\t}\r\n\r\n\t\treturn newDate;\r\n\t}\r\n\r\n\t/**\r\n\t * [getBreaklessDate description]\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description\r\n\t * @param axisBreak  [description]\r\n\t * @param timeUnit   [description]\r\n\t * @param count      [description]\r\n\t * @return [description]\r\n\t */\r\n\tpublic getBreaklessDate(axisBreak: DateAxisBreak, timeUnit: TimeUnit, count: number): Date {\r\n\t\tlet date = new Date(axisBreak.endValue);\r\n\t\t$time.round(\r\n\t\t\tdate,\r\n\t\t\ttimeUnit,\r\n\t\t\tcount,\r\n\t\t\tthis._firstWeekDay,\r\n\t\t\tthis._df.utc,\r\n\t\t\tundefined,\r\n\t\t\tthis._df.timezoneMinutes,\r\n\t\t\tthis._df.timezone\r\n\t\t);\r\n\t\t$time.add(date, timeUnit, count, this._df.utc);\r\n\r\n\t\tlet timestamp = date.getTime();\r\n\r\n\t\taxisBreak = <DateAxisBreak>this.isInBreak(timestamp);\r\n\t\tif (axisBreak) {\r\n\t\t\treturn this.getBreaklessDate(axisBreak, timeUnit, count);\r\n\t\t}\r\n\t\treturn date;\r\n\t}\r\n\r\n\t/**\r\n\t * (Re)validates all Axis elements.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description (review)\r\n\t */\r\n\tpublic validateAxisElements(): void {\r\n\t\tif ($type.isNumber(this.max) && $type.isNumber(this.min)) {\r\n\r\n\t\t\tthis.calculateZoom();\r\n\r\n\t\t\t// first regular items\r\n\t\t\tlet timestamp = this._gridDate.getTime();\r\n\t\t\tlet timeUnit = this._gridInterval.timeUnit;\r\n\t\t\tlet intervalCount = this._gridInterval.count;\r\n\t\t\tlet prevGridDate = $time.copy(this._gridDate);\r\n\r\n\t\t\tlet dataItemsIterator = this._dataItemsIterator;\r\n\t\t\tthis.resetIterators();\r\n\r\n\t\t\twhile (timestamp <= this._maxZoomed) {\r\n\t\t\t\tlet date = this.getGridDate($time.copy(prevGridDate), intervalCount);\r\n\t\t\t\ttimestamp = date.getTime();\r\n\r\n\t\t\t\tlet endDate = $time.copy(date); // you might think it's easier to add intervalduration to timestamp, however it won't work for months or years which are not of the same length\r\n\t\t\t\tendDate = $time.add(endDate, timeUnit, intervalCount, this._df.utc);\r\n\r\n\t\t\t\tlet format = this.dateFormats.getKey(timeUnit);\r\n\r\n\t\t\t\tif (this.markUnitChange && prevGridDate) {\r\n\t\t\t\t\tif ($time.checkChange(date, prevGridDate, this._nextGridUnit, this._df.utc)) {\r\n\t\t\t\t\t\tif (timeUnit !== \"year\") {\r\n\t\t\t\t\t\t\tformat = this.periodChangeDateFormats.getKey(timeUnit);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet text = this._df.format(date, format);\r\n\r\n\t\t\t\tlet dataItem = dataItemsIterator.find((x) => x.text === text);\r\n\t\t\t\tif (dataItem.__disabled) {\r\n\t\t\t\t\tdataItem.__disabled = false;\r\n\t\t\t\t}\r\n\t\t\t\tthis.appendDataItem(dataItem);\r\n\r\n\t\t\t\tdataItem.axisBreak = undefined;\r\n\t\t\t\tdataItem.date = date;\r\n\t\t\t\tdataItem.endDate = endDate;\r\n\r\n\t\t\t\tdataItem.text = text;\r\n\r\n\t\t\t\tthis.validateDataElement(dataItem);\r\n\r\n\t\t\t\tprevGridDate = date;\r\n\t\t\t}\r\n\r\n\t\t\t// breaks later\r\n\t\t\tlet renderer: AxisRenderer = this.renderer;\r\n\r\n\t\t\tif (this._axisBreaks) {\r\n\t\t\t\t$iter.each(this._axisBreaks.iterator(), (axisBreak) => {\r\n\t\t\t\t\tif (axisBreak.breakSize > 0) {\r\n\t\t\t\t\t\tlet timeUnit: TimeUnit = axisBreak.gridInterval.timeUnit;\r\n\t\t\t\t\t\tlet intervalCount: number = axisBreak.gridInterval.count;\r\n\r\n\t\t\t\t\t\t// only add grid if gap is bigger then minGridDistance\r\n\t\t\t\t\t\tif ($math.getDistance(axisBreak.startPoint, axisBreak.endPoint) > renderer.minGridDistance * 4) {\r\n\t\t\t\t\t\t\tlet timestamp: number = axisBreak.gridDate.getTime();\r\n\r\n\t\t\t\t\t\t\tlet prevGridDate;\r\n\t\t\t\t\t\t\tlet count: number = 0;\r\n\t\t\t\t\t\t\twhile (timestamp <= axisBreak.adjustedMax) {\r\n\t\t\t\t\t\t\t\tlet date: Date = $time.copy(axisBreak.gridDate);\r\n\t\t\t\t\t\t\t\ttimestamp = $time.add(date, timeUnit, intervalCount * count, this._df.utc).getTime();\r\n\t\t\t\t\t\t\t\tcount++;\r\n\t\t\t\t\t\t\t\tif (timestamp > axisBreak.adjustedStartValue && timestamp < axisBreak.adjustedEndValue) {\r\n\t\t\t\t\t\t\t\t\tlet endDate = $time.copy(date); // you might think it's easier to add intervalduration to timestamp, however it won't work for months or years which are not of the same length\r\n\t\t\t\t\t\t\t\t\tendDate = $time.add(endDate, timeUnit, intervalCount, this._df.utc);\r\n\r\n\t\t\t\t\t\t\t\t\tlet format = this.dateFormats.getKey(timeUnit);\r\n\r\n\t\t\t\t\t\t\t\t\tif (this.markUnitChange && prevGridDate) {\r\n\t\t\t\t\t\t\t\t\t\tif ($time.checkChange(date, prevGridDate, this._nextGridUnit, this._df.utc)) {\r\n\t\t\t\t\t\t\t\t\t\t\tif (timeUnit !== \"year\") {\r\n\t\t\t\t\t\t\t\t\t\t\t\tformat = this.periodChangeDateFormats.getKey(timeUnit);\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\tlet text: string = this._df.format(date, format);\r\n\r\n\t\t\t\t\t\t\t\t\tlet dataItem: this[\"_dataItem\"] = dataItemsIterator.find((x) => x.text === text);\r\n\t\t\t\t\t\t\t\t\tif (dataItem.__disabled) {\r\n\t\t\t\t\t\t\t\t\t\tdataItem.__disabled = false;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t//this.processDataItem(dataItem);\r\n\t\t\t\t\t\t\t\t\tthis.appendDataItem(dataItem);\r\n\t\t\t\t\t\t\t\t\tdataItem.axisBreak = axisBreak;\r\n\t\t\t\t\t\t\t\t\taxisBreak.dataItems.moveValue(dataItem);\r\n\r\n\t\t\t\t\t\t\t\t\tdataItem.date = date;\r\n\t\t\t\t\t\t\t\t\tdataItem.endDate = endDate;\r\n\t\t\t\t\t\t\t\t\tdataItem.text = text;\r\n\t\t\t\t\t\t\t\t\tprevGridDate = date;\r\n\t\t\t\t\t\t\t\t\tthis.validateDataElement(dataItem);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Validates Axis data item.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param dataItem Data item\r\n\t */\r\n\tpublic validateDataElement(dataItem: this[\"_dataItem\"]): void {\r\n\r\n\t\tdataItem.itemIndex = this._axisItemCount;\r\n\t\tthis._axisItemCount++;\r\n\r\n\t\tif ($type.isNumber(this.max) && $type.isNumber(this.min)) {\r\n\t\t\tlet renderer: AxisRenderer = this.renderer;\r\n\r\n\t\t\tlet timestamp = dataItem.value;\r\n\t\t\tlet endTimestamp = dataItem.endValue;\r\n\r\n\t\t\tif (!$type.isNumber(endTimestamp)) {\r\n\t\t\t\tendTimestamp = timestamp;\r\n\t\t\t}\r\n\r\n\t\t\tlet position: number = this.valueToPosition(timestamp);\r\n\t\t\tlet endPosition: number = this.valueToPosition(endTimestamp);\r\n\t\t\tlet fillEndPosition = endPosition;\r\n\r\n\t\t\tif (!dataItem.isRange && this._gridInterval.count > this.baseInterval.count) {\r\n\t\t\t\tendPosition = position + (endPosition - position) / (this._gridInterval.count / this.baseInterval.count);\r\n\t\t\t}\r\n\r\n\t\t\tdataItem.position = position;\r\n\r\n\t\t\tlet tick: AxisTick = dataItem.tick;\r\n\t\t\tif (tick && !tick.disabled) {\r\n\t\t\t\trenderer.updateTickElement(tick, position, endPosition);\r\n\t\t\t}\r\n\r\n\t\t\tlet grid: Grid = dataItem.grid;\r\n\t\t\tif (grid && !grid.disabled) {\r\n\t\t\t\trenderer.updateGridElement(grid, position, endPosition);\r\n\t\t\t}\r\n\r\n\t\t\tlet fill: AxisFill = dataItem.axisFill;\r\n\t\t\tif (fill && !fill.disabled) {\r\n\t\t\t\trenderer.updateFillElement(fill, position, fillEndPosition);\r\n\t\t\t\tif (!dataItem.isRange) {\r\n\t\t\t\t\tthis.fillRule(dataItem);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tlet mask: AxisFill = dataItem.mask;\r\n\t\t\tif (mask) {\r\n\t\t\t\trenderer.updateFillElement(mask, position, endPosition);\r\n\t\t\t}\r\n\r\n\t\t\tif (dataItem.bullet) {\r\n\t\t\t\trenderer.updateBullet(dataItem.bullet, position, endPosition);\r\n\t\t\t}\r\n\r\n\t\t\tlet label: AxisLabel = dataItem.label;\r\n\t\t\tif (label && !label.disabled) {\r\n\t\t\t\tlet location = label.location;\r\n\r\n\r\n\r\n\t\t\t\tif (location == 0) {\r\n\t\t\t\t\tif (this._gridInterval.count == 1 && this._gridInterval.timeUnit != \"week\" && !dataItem.isRange) {\r\n\t\t\t\t\t\tlocation = 0.5;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tlocation = 0;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\r\n\t\t\t\trenderer.updateLabelElement(label, position, endPosition, location);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * A duration in milliseconds of the `baseInterval`.\r\n\t *\r\n\t * @return Duration (ms)\r\n\t */\r\n\tpublic get baseDuration(): number {\r\n\t\treturn $time.getDuration(this.baseInterval.timeUnit, this.baseInterval.count);\r\n\t}\r\n\r\n\t/**\r\n\t * Adjusts min/max values.\r\n\t *\r\n\t * @ignore Exclude from docs.\r\n\t * @todo Description (review)\r\n\t * @param min  Min timestamp\r\n\t * @param max  Max timestamp\r\n\t * @return Adjusted min/max step\r\n\t */\r\n\tpublic adjustMinMax(min: number, max: number): IMinMaxStep {\r\n\t\treturn { min: min, max: max, step: this.baseDuration };\r\n\t}\r\n\r\n\t/**\r\n\t * Adjusts the minimum timestamp as per cell start location.\r\n\t *\r\n\t * @param value  Value\r\n\t * @return Adjusted value\r\n\t */\r\n\tprotected fixMin(value: number) {\r\n\t\t// like this because months are not equal\r\n\t\tlet interval = this.baseInterval;\r\n\r\n\t\tlet startTime = $time.round(\r\n\t\t\tnew Date(value),\r\n\t\t\tinterval.timeUnit,\r\n\t\t\tinterval.count,\r\n\t\t\tthis._firstWeekDay,\r\n\t\t\tthis._df.utc,\r\n\t\t\tundefined,\r\n\t\t\tthis._df.timezoneMinutes,\r\n\t\t\tthis._df.timezone\r\n\t\t).getTime();\r\n\t\tlet endTime = $time.add(new Date(startTime), interval.timeUnit, interval.count, this._df.utc).getTime();\r\n\r\n\t\treturn startTime + (endTime - startTime) * this.startLocation;\r\n\t}\r\n\r\n\t/**\r\n\t * Adjusts the maximum timestamp as per cell start location.\r\n\t *\r\n\t * @param value  Value\r\n\t * @return Adjusted value\r\n\t */\r\n\tprotected fixMax(value: number) {\r\n\t\t// like this because months are not equal\r\n\t\tlet interval = this.baseInterval;\r\n\r\n\t\tlet startTime = $time.round(\r\n\t\t\tnew Date(value),\r\n\t\t\tinterval.timeUnit,\r\n\t\t\tinterval.count,\r\n\t\t\tthis._firstWeekDay,\r\n\t\t\tthis._df.utc,\r\n\t\t\tundefined,\r\n\t\t\tthis._df.timezoneMinutes,\r\n\t\t\tthis._df.timezone\r\n\t\t).getTime();\r\n\t\tlet endTime = $time.add(new Date(startTime), interval.timeUnit, interval.count, this._df.utc).getTime();\r\n\r\n\t\treturn startTime + (endTime - startTime) * this.endLocation;\r\n\t}\r\n\r\n\t/**\r\n\t * [chooseInterval description]\r\n\t *\r\n\t * @ignore Exclude from docs.\r\n\t * @todo Description\r\n\t * @param index      [description]\r\n\t * @param duration   [description]\r\n\t * @param gridCount  [description]\r\n\t * @return [description]\r\n\t */\r\n\tpublic chooseInterval(index: number, duration: number, gridCount: number, intervals?: List<ITimeInterval>): ITimeInterval {\r\n\t\tif (!intervals) {\r\n\t\t\tintervals = this.gridIntervals;\r\n\t\t}\r\n\r\n\t\tlet gridInterval: ITimeInterval = intervals.getIndex(index);\r\n\r\n\t\tlet intervalDuration: number = $time.getDuration(gridInterval.timeUnit, gridInterval.count);\r\n\r\n\t\tlet lastIndex: number = intervals.length - 1;\r\n\t\tif (index >= lastIndex) {\r\n\t\t\treturn { ...intervals.getIndex(lastIndex) };\r\n\t\t}\r\n\r\n\t\tlet count: number = Math.ceil(duration / intervalDuration);\r\n\r\n\t\tif (duration < intervalDuration && index > 0) {\r\n\t\t\treturn { ...intervals.getIndex(index - 1) };\r\n\t\t}\r\n\t\tif (count <= gridCount) {\r\n\t\t\treturn { ...intervals.getIndex(index) };\r\n\t\t} else {\r\n\t\t\tif (index + 1 < intervals.length) {\r\n\t\t\t\treturn this.chooseInterval(index + 1, duration, gridCount, intervals);\r\n\t\t\t} else {\r\n\t\t\t\treturn { ...intervals.getIndex(index) };\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Formats the value according to axis' own [[DateFormatter]].\r\n\t *\r\n\t * @param value  Source value\r\n\t * @return Formatted value\r\n\t */\r\n\tpublic formatLabel(value: number): string {\r\n\t\treturn this._df.format(value);\r\n\t}\r\n\r\n\t/**\r\n\t * Converts a Date to an asbolute pixel position within Axis.\r\n\t *\r\n\t * @param date  Date\r\n\t * @return Position (px)\r\n\t */\r\n\tpublic dateToPosition(date: Date): number {\r\n\t\treturn this.valueToPosition(date.getTime());\r\n\t}\r\n\r\n\t/**\r\n\t * Converts a numeric timestamp or a `Date` to a relative position on axis.\r\n\t *\r\n\t * @param date  Date or a timestamp\r\n\t * @return Relative position\r\n\t */\r\n\tpublic anyToPosition(date: Date | number): number {\r\n\t\tif (date instanceof Date) {\r\n\t\t\treturn this.dateToPosition(date);\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn this.valueToPosition(date);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Converts date to orientation point (x, y, angle) on axis\r\n\t *\r\n\t * @param date Date\r\n\t * @return IOrientationPoint\r\n\t */\r\n\tpublic dateToPoint(date: Date): IOrientationPoint {\r\n\t\tlet position = this.dateToPosition(date);\r\n\t\tlet point = this.renderer.positionToPoint(position);\r\n\t\tlet angle = this.renderer.positionToAngle(position);\r\n\t\treturn { x: point.x, y: point.y, angle: angle };\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Converts a numeric value to orientation (x, y, angle) point on axis\r\n\t *\r\n\t * @param value  Value\r\n\t * @return Orientation point\r\n\t */\r\n\tpublic anyToPoint(date: Date | number): IOrientationPoint {\r\n\t\tif (date instanceof Date) {\r\n\t\t\treturn this.dateToPoint(date);\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn this.valueToPoint(date);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Converts pixel position within Axis to a corresponding Date.\r\n\t *\r\n\t * @param position  Position (px)\r\n\t * @return Date\r\n\t */\r\n\tpublic positionToDate(position: number): Date {\r\n\t\treturn new Date(this.positionToValue(position));\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the relative position on axis for series' data item's value.\r\n\t *\r\n\t * @since 4.5.14\r\n\t * @param  dataItem  Data item\r\n\t * @param  key       Data field to get value from\r\n\t * @param  location  Location (0-1)\r\n\t * @return           Relative position\r\n\t */\r\n\tpublic getPositionX(dataItem: XYSeriesDataItem, key: string, location?: number, stackKey?: string, range?: IRange): number {\r\n\t\tlet value: number = this.getTimeByLocation(dataItem, key, location);\r\n\t\t//let stack: number = dataItem.getValue(\"valueX\", \"stack\");\r\n\r\n\t\tif (!$type.isNumber(value)) {\r\n\t\t\tvalue = this.baseValue;\r\n\t\t}\r\n\r\n\t\tlet position = this.valueToPosition(value);\r\n\t\tif (range) {\r\n\t\t\tposition = $math.fitToRange(position, range.start, range.end);\r\n\t\t}\r\n\r\n\t\treturn position;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Returns relative position on axis for series' data item's value.\r\n\t *\r\n\t * @since 4.5.14\r\n\t * @param  dataItem  Data item\r\n\t * @param  key       Data field to get value from\r\n\t * @param  location  Location (0-1)\r\n\t * @return           Relative position\r\n\t */\r\n\tpublic getPositionY(dataItem: XYSeriesDataItem, key: string, location?: number, stackKey?: string, range?: IRange): number {\r\n\t\tlet value: number = this.getTimeByLocation(dataItem, key, location);\r\n\t\tlet stack: number = dataItem.getValue(\"valueX\", \"stack\");\r\n\r\n\t\tif (!$type.isNumber(value)) {\r\n\t\t\tvalue = this.baseValue;\r\n\t\t}\r\n\r\n\t\tlet position = this.valueToPosition(value + stack);\r\n\t\tif (range) {\r\n\t\t\tposition = $math.fitToRange(position, range.start, range.end);\r\n\t\t}\r\n\r\n\t\treturn position;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns an angle for series data item.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description (review)\r\n\t * @param dataItem  Data item\r\n\t * @param key       Data field to get value from\r\n\t * @param location  Location (0-1)\r\n\t * @param stackKey  Stack ID\r\n\t * @param range Range to fit in\r\n\t * @return Angle\r\n\t */\r\n\tpublic getAngle(dataItem: XYSeriesDataItem, key: string, location?: number, stackKey?: string, range?: IRange): number {\r\n\t\tlet value: number = this.getTimeByLocation(dataItem, key, location);\r\n\t\tlet stack: number = dataItem.getValue(stackKey, \"stack\");\r\n\r\n\t\tif (!$type.isNumber(value)) {\r\n\t\t\tvalue = this.baseValue;\r\n\t\t}\r\n\r\n\t\tlet position = this.valueToPosition(value + stack);\r\n\t\tif (range) {\r\n\t\t\tposition = $math.fitToRange(position, range.start, range.end);\r\n\t\t}\r\n\r\n\t\treturn this.positionToAngle(position);\r\n\t}\r\n\r\n\t/**\r\n\t * [getTimeByLocation description]\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description\r\n\t * @param dataItem  [description]\r\n\t * @param key       [description]\r\n\t * @param location  [description]\r\n\t * @return [description]\r\n\t */\r\n\tprotected getTimeByLocation(dataItem: XYSeriesDataItem, key: string, location: number): number {\r\n\r\n\t\tif (!$type.hasValue(key)) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tif (!$type.isNumber(location)) {\r\n\t\t\tlocation = dataItem.workingLocations[key];\r\n\r\n\t\t\tif (!$type.isNumber(location)) {\r\n\t\t\t\tlocation = 0;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tlet startTime: number = dataItem.values[key][\"open\"];\r\n\t\tlet endTime: number = dataItem.values[key][\"close\"];\r\n\r\n\t\tlet workingValue = dataItem.values[key].workingValue;\r\n\t\tlet value = dataItem.values[key].value;\r\n\r\n\t\tlet difference = value - workingValue;\r\n\t\tstartTime -= difference;\r\n\t\tendTime -= difference;\r\n\r\n\t\tif ($type.isNumber(startTime) && $type.isNumber(endTime)) {\r\n\t\t\treturn startTime + (endTime - startTime) * location;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Processes a related series' data item.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description\r\n\t * @param dataItem  Data item\r\n\t */\r\n\tpublic processSeriesDataItem(dataItem: XYSeriesDataItem, axisLetter?: string): void {\r\n\t\tlet series = dataItem.component;\r\n\t\tlet time: number;\r\n\r\n\t\tlet date: Date = (<any>dataItem)[\"date\" + axisLetter];\r\n\r\n\t\tif ($type.isNumber(this.timezoneOffset)) {\r\n\t\t\tdate.setTime(date.getTime() + (date.getTimezoneOffset() - this.timezoneOffset) * 60000)\r\n\t\t\tdataItem.setValue(\"date\" + axisLetter, date.getTime(), 0);\r\n\t\t}\r\n\t\telse if ($type.hasValue(this.timezone)) {\r\n\t\t\tdate = $time.setTimezone(date, this.timezone);\r\n\t\t\tdataItem.setValue(\"date\" + axisLetter, date.getTime(), 0);\r\n\t\t\t(<any>dataItem)[\"date\" + axisLetter] = date;\r\n\t\t}\r\n\r\n\t\tif (date) {\r\n\t\t\ttime = date.getTime();\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tlet openDate: Date = (<any>dataItem)[\"openDate\" + axisLetter];\r\n\t\tlet prevSeriesTime: number = this._prevSeriesTime[series.uid];\r\n\r\n\r\n\t\tlet openTime: number;\r\n\t\tif (openDate) {\r\n\t\t\topenTime = openDate.getTime();\r\n\t\t}\r\n\r\n\t\tif ($type.isNumber(openTime)) {\r\n\t\t\tlet difference = Math.abs(time - openTime);\r\n\r\n\t\t\tif (this._minDifference[series.uid] > difference) {\r\n\t\t\t\tthis._minDifference[series.uid] = difference;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tlet differece: number = time - prevSeriesTime;\r\n\r\n\t\tif (differece > 0) {\r\n\t\t\tif (this._minDifference[series.uid] > differece) {\r\n\t\t\t\tthis._minDifference[series.uid] = differece;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis._prevSeriesTime[series.uid] = time;\r\n\r\n\t\tif (series._baseInterval[this.uid]) {\r\n\t\t\tthis.postProcessSeriesDataItem(dataItem);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * [updateAxisBySeries description]\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description\r\n\t */\r\n\tpublic updateAxisBySeries() {\r\n\t\tsuper.updateAxisBySeries();\r\n\r\n\t\tlet baseInterval: ITimeInterval = this.chooseInterval(0, this.minDifference, 1);\r\n\r\n\t\t// handle short months\r\n\r\n\t\tif (this.minDifference >= $time.getDuration(\"day\", 27) && baseInterval.timeUnit == \"week\") {\r\n\t\t\tbaseInterval.timeUnit = \"month\";\r\n\t\t\tbaseInterval.count = 1;\r\n\t\t}\r\n\t\tif (baseInterval.timeUnit == \"month\") {\r\n\t\t\tif (this.minDifference >= $time.getDuration(\"day\", 29 * 2) && baseInterval.count == 1) {\r\n\t\t\t\tbaseInterval.count = 2;\r\n\t\t\t}\r\n\r\n\t\t\tif (this.minDifference >= $time.getDuration(\"day\", 29 * 3) && baseInterval.count == 2) {\r\n\t\t\t\tbaseInterval.count = 3;\r\n\t\t\t}\r\n\r\n\t\t\tif (this.minDifference >= $time.getDuration(\"day\", 29 * 6) && baseInterval.count == 5) {\r\n\t\t\t\tbaseInterval.count = 6;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// handle daylight saving\r\n\t\tif (this.minDifference >= $time.getDuration(\"hour\", 23) && baseInterval.timeUnit == \"hour\") {\r\n\t\t\tbaseInterval.timeUnit = \"day\";\r\n\t\t\tbaseInterval.count = 1;\r\n\t\t}\r\n\r\n\t\tif (this.minDifference >= $time.getDuration(\"week\", 1) - $time.getDuration(\"hour\", 1) && baseInterval.timeUnit == \"day\") {\r\n\t\t\tbaseInterval.timeUnit = \"week\";\r\n\t\t\tbaseInterval.count = 1;\r\n\t\t}\r\n\r\n\t\tif (this.minDifference >= $time.getDuration(\"year\", 1) - $time.getDuration(\"day\", 1.01) && baseInterval.timeUnit == \"month\") {\r\n\t\t\tbaseInterval.timeUnit = \"year\";\r\n\t\t\tbaseInterval.count = 1;\r\n\t\t}\r\n\r\n\t\tthis._baseIntervalReal = baseInterval;\r\n\t\tthis._mainBaseInterval = baseInterval;\r\n\r\n\t\t// no need to invalidate\r\n\t}\r\n\r\n\t/**\r\n\t * A base interval (granularity) of data.\r\n\t *\r\n\t * Used to indicate what are the base units of your data.\r\n\t *\r\n\t * For example, if you have a data set that has a data point every 5 minutes,\r\n\t * you may want to set this to `{ timeUnit: \"minute\", count: 5 }`.\r\n\t *\r\n\t * If not set, the Axis will try to determine the setting by its own, looking\r\n\t * at actual data.\r\n\t *\r\n\t * For best results, try to follow these values for `count`:\r\n\t *\r\n\t * When unit is \"month\", use 12 / count = round number\r\n\t * When unit is \"hour\", use 24 / count = round number\r\n\t * When unit is \"second\" and \"minute\", use 60 / count = round number\r\n\t *\r\n\t * @param timeInterval base interval\r\n\t */\r\n\tpublic set baseInterval(timeInterval: ITimeInterval) {\r\n\t\tif (JSON.stringify(this._baseInterval) != JSON.stringify(timeInterval)) {\r\n\t\t\tthis._baseInterval = timeInterval;\r\n\t\t\tthis._mainBaseInterval = timeInterval;\r\n\t\t\tif (!$type.isNumber(timeInterval.count)) {\r\n\t\t\t\ttimeInterval.count = 1;\r\n\t\t\t}\r\n\t\t\tthis.invalidate();\r\n\t\t\tthis.postProcessSeriesDataItems();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @return Base interval\r\n\t */\r\n\tpublic get baseInterval(): ITimeInterval {\r\n\t\tif (this._groupInterval) {\r\n\t\t\treturn this._groupInterval;\r\n\t\t}\r\n\t\telse if (this._baseInterval) {\r\n\t\t\treturn this._baseInterval;\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn this._baseIntervalReal;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Indicates granularity of the data of source (unaggregated) data.\r\n\t *\r\n\t * @since 4.7.0\r\n\t * @return Granularity of the main data set\r\n\t */\r\n\tpublic get mainBaseInterval(): ITimeInterval {\r\n\t\tif (this._baseInterval) {\r\n\t\t\treturn this._baseInterval;\r\n\t\t}\r\n\t\telse if (this._mainBaseInterval) {\r\n\t\t\treturn this._mainBaseInterval;\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn this._baseIntervalReal;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * If enabled, axis will automatically collapse empty (without data points)\r\n\t * periods of time, i.e. weekends.\r\n\t *\r\n\t * An \"empty\" period is considered a stretch of time in the length of current\r\n\t * `baseInterval` without a single data point in it.\r\n\t *\r\n\t * For each such empty period, axis will automatically create an\r\n\t * [[AxisBreak]]. By default they will be invisible. You can still configure\r\n\t * them by accessing `axis.breaks.template`.\r\n\t *\r\n\t * [More info about breaks](https://www.amcharts.com/docs/v4/concepts/axes/#Breaks).\r\n\t *\r\n\t * Important notes:\r\n\t * * If you set this property to `true`, you can not add your custom axis breaks to this axis anymore.\r\n\t * * Using this feature affects performance. Use only if you need it.\r\n\t * * Setting this to `true` will reset appearance of breaks. If you want to modify appearance, do it *after* you set `skipEmptyPeriods`.\r\n\t * * Some axis label overlapping might happen.\r\n\t * * This setting is not compatible with `groupData = true`.\r\n\t *\r\n\t * @default false\r\n\t * @param value  Remove empty stretches of time?\r\n\t */\r\n\tpublic set skipEmptyPeriods(value: boolean) {\r\n\r\n\t\tif (value) {\r\n\t\t\tlet breakTemplate = this.axisBreaks.template;\r\n\t\t\tbreakTemplate.startLine.disabled = true;\r\n\t\t\tbreakTemplate.endLine.disabled = true;\r\n\t\t\tbreakTemplate.fillShape.disabled = true;\r\n\t\t\tbreakTemplate.breakSize = 0;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tif (this._gapBreaks) {\r\n\t\t\t\tthis.axisBreaks.clear();\r\n\t\t\t\tthis._gapBreaks = false;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (this.setPropertyValue(\"skipEmptyPeriods\", value)) {\r\n\t\t\tthis.invalidate();\r\n\t\t\tthis.postProcessSeriesDataItems();\r\n\t\t\tthis.invalidateSeries();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @return Remove empty stretches of time?\r\n\t */\r\n\tpublic get skipEmptyPeriods(): boolean {\r\n\t\treturn this.getPropertyValue(\"skipEmptyPeriods\");\r\n\t}\r\n\r\n\t/**\r\n\t * A special date format to apply axis tooltips.\r\n\t *\r\n\t * Will use same format as for labels, if not set.\r\n\t *\r\n\t * @param value  Date format\r\n\t */\r\n\tpublic set tooltipDateFormat(value: string | Intl.DateTimeFormatOptions) {\r\n\t\tthis.setPropertyValue(\"tooltipDateFormat\", value);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Date format\r\n\t */\r\n\tpublic get tooltipDateFormat(): string | Intl.DateTimeFormatOptions {\r\n\t\treturn this.getPropertyValue(\"tooltipDateFormat\");\r\n\t}\r\n\r\n\t/**\r\n\t * Use `periodChangeDateFormats` to apply different formats to the first\r\n\t * label in bigger time unit.\r\n\t *\r\n\t * @default true\r\n\t * @param value  Use different format for period beginning?\r\n\t */\r\n\tpublic set markUnitChange(value: boolean) {\r\n\t\tif (this.setPropertyValue(\"markUnitChange\", value)) {\r\n\t\t\tthis.invalidateData();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @return Use different format for period beginning?\r\n\t */\r\n\tpublic get markUnitChange(): boolean {\r\n\t\treturn this.getPropertyValue(\"markUnitChange\");\r\n\t}\r\n\r\n\t/**\r\n\t * Returns text to show in a tooltip, based on specific relative position\r\n\t * within axis.\r\n\t *\r\n\t * The label will be formatted as per [[DateFormatter]] set for the whole\r\n\t * chart, or explicitly for this Axis.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param position  Position\r\n\t * @return Label (formatted date)\r\n\t */\r\n\tpublic getTooltipText(position: number): string {\r\n\t\tlet text: string;\r\n\t\tlet date = this.positionToDate(position);\r\n\t\tdate = $time.round(\r\n\t\t\tdate,\r\n\t\t\tthis.baseInterval.timeUnit,\r\n\t\t\tthis.baseInterval.count,\r\n\t\t\tthis._firstWeekDay,\r\n\t\t\tthis._df.utc,\r\n\t\t\tnew Date(this.min),\r\n\t\t\tthis._df.timezoneMinutes,\r\n\t\t\tthis._df.timezone\r\n\t\t);\r\n\r\n\t\tthis.tooltipDate = date;\r\n\r\n\t\tif ($type.hasValue(this.tooltipDateFormat)) {\r\n\t\t\ttext = this._df.format(date, this.tooltipDateFormat, [\"day\", \"month\", \"week\", \"year\"].indexOf(this.baseInterval.timeUnit) == -1);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tlet dateFormat = this.dateFormats.getKey(this.baseInterval.timeUnit);\r\n\t\t\tif (dateFormat) {\r\n\t\t\t\ttext = this._df.format(date, dateFormat);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\ttext = this.getPositionLabel(position);\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (!this._adapterO) {\r\n\t\t\treturn text;\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn this._adapterO.apply(\"getTooltipText\", text);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Takes an absolute position within axis and adjust it to a specific position within base interval. (cell)\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param position Source position\r\n\t * @param location  Location in the cell\r\n\t * @return Adjusted position\r\n\t */\r\n\tpublic roundPosition(position: number, location?: AxisItemLocation, axisLocation?: number): number {\r\n\t\tlet baseInterval = this.baseInterval;\r\n\t\tlet timeUnit = baseInterval.timeUnit;\r\n\t\tlet count = baseInterval.count;\r\n\r\n\t\tlet date: Date = this.positionToDate(position);\r\n\r\n\t\t$time.round(\r\n\t\t\tdate,\r\n\t\t\ttimeUnit,\r\n\t\t\tcount,\r\n\t\t\tthis._firstWeekDay,\r\n\t\t\tthis._df.utc,\r\n\t\t\tundefined,\r\n\t\t\tthis._df.timezoneMinutes,\r\n\t\t\tthis._df.timezone\r\n\t\t);\r\n\r\n\t\tif (location > 0) {\r\n\t\t\t$time.add(date, timeUnit, location * count, this._df.utc);\r\n\t\t}\r\n\r\n\t\tif (axisLocation > 0 && axisLocation < 1) {\r\n\t\t\tdate.setTime(date.getTime() + this.baseDuration * axisLocation);\r\n\t\t}\r\n\r\n\t\tif (this.isInBreak(date.getTime())) {\r\n\t\t\twhile (date.getTime() < this.max) {\r\n\t\t\t\t$time.add(date, timeUnit, count, this._df.utc);\r\n\t\t\t\tif (!this.isInBreak(date.getTime())) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn this.dateToPosition(date);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns an relative position of the start of the cell (period), that specific position value falls into.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description (review)\r\n\t * @param position  Relative position\r\n\t * @return Cell start relative position\r\n\t */\r\n\tpublic getCellStartPosition(position: number): number {\r\n\t\treturn this.roundPosition(position, 0);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns an relative position of the end of the cell (period), that specific position value falls into.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description (review)\r\n\t * @param position  Relative position\r\n\t * @return Cell end relative position\r\n\t */\r\n\tpublic getCellEndPosition(position: number): number {\r\n\t\treturn this.roundPosition(position, 1);\r\n\t\t//return this.dateToPosition($time.add(this.positionToDate(this.roundPosition(position, 1)), this.baseInterval.timeUnit, this.baseInterval.count));\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a Series data item that corresponds to the specific pixel position\r\n\t * of the Axis.\r\n\t *\r\n\t * If `findNearest` (third parameter) is set to `true`, the method will try\r\n\t * to locate nearest available data item if none is found directly under\r\n\t * `position`.\r\n\t *\r\n\t * @param series       Series\r\n\t * @param position     Position (px)\r\n\t * @param findNearest  Should axis try to find nearest tooltip if there is no data item at exact position\r\n\t * @return Data item\r\n\t */\r\n\tpublic getSeriesDataItem(series: XYSeries, position: number, findNearest?: boolean): XYSeriesDataItem {\r\n\r\n\t\tlet value: number = this.positionToValue(position);\r\n\r\n\t\tlet location = 0.5;\r\n\t\tif (this.axisLetter == \"Y\") {\r\n\t\t\tlocation = series.dataItems.template.locations.dateY;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tlocation = series.dataItems.template.locations.dateX;\r\n\t\t}\r\n\r\n\t\tlet deltaValue = value - location * this.baseDuration;\r\n\r\n\t\tlet date: Date = $time.round(\r\n\t\t\tnew Date(value),\r\n\t\t\tthis.baseInterval.timeUnit,\r\n\t\t\tthis.baseInterval.count,\r\n\t\t\tthis._firstWeekDay,\r\n\t\t\tthis._df.utc,\r\n\t\t\tundefined,\r\n\t\t\tthis._df.timezoneMinutes,\r\n\t\t\tthis._df.timezone\r\n\t\t);\r\n\t\tlet nextDate: Date = $time.round(\r\n\t\t\tnew Date(value + this.baseDuration),\r\n\t\t\tthis.baseInterval.timeUnit,\r\n\t\t\tthis.baseInterval.count,\r\n\t\t\tthis._firstWeekDay,\r\n\t\t\tthis._df.utc,\r\n\t\t\tundefined,\r\n\t\t\tthis._df.timezoneMinutes,\r\n\t\t\tthis._df.timezone\r\n\t\t);\r\n\r\n\t\tif (nextDate.getTime() > date.getTime()) {\r\n\t\t\tif (Math.abs(nextDate.getTime() - deltaValue) < Math.abs(deltaValue - date.getTime())) {\r\n\t\t\t\tdate = nextDate;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tlet dataItemsByAxis = series.dataItemsByAxis.getKey(this.uid);\r\n\r\n\t\tlet dataItem = dataItemsByAxis.getKey(date.getTime() + series.currentDataSetId);\r\n\r\n\t\t// todo:  alternatively we can find closiest here\r\n\t\tif (!dataItem && findNearest) {\r\n\r\n\t\t\tlet key: \"dateX\" | \"dateY\";\r\n\r\n\t\t\tif (this.axisLetter == \"Y\") {\r\n\t\t\t\tkey = \"dateY\";\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tkey = \"dateX\";\r\n\t\t\t}\r\n\r\n\t\t\tdataItem = series.dataItems.getIndex(series.dataItems.findClosestIndex(date.getTime(), (x) => {\r\n\t\t\t\tif (x[key]) {\r\n\t\t\t\t\treturn <number>x[key].getTime();\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\treturn -Infinity;\r\n\t\t\t\t}\r\n\t\t\t}, \"any\"));\r\n\t\t}\r\n\r\n\t\treturn dataItem;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a formatted date based on position in axis scale.\r\n\t *\r\n\t * Please note that `position` represents position within axis which may be\r\n\t * zoomed and not correspond to Cursor's `position`.\r\n\t *\r\n\t * To convert Cursor's `position` to Axis' `position` use `toAxisPosition()` method.\r\n\t *\r\n\t * @see {@link https://www.amcharts.com/docs/v4/tutorials/tracking-cursors-position-via-api/#Tracking_Cursor_s_position} For more information about cursor tracking.\r\n\t * @param position  Relative position on axis (0-1)\r\n\t * @return Position label\r\n\t */\r\n\tpublic getPositionLabel(position: number): string {\r\n\t\t// @todo Better format recognition\r\n\t\tlet date = this.positionToDate(position);\r\n\t\treturn this._df.format(date, this.getCurrentLabelFormat());\r\n\t}\r\n\r\n\t/**\r\n\t * Returns label date format based on currently used time units\r\n\t *\r\n\t * @return Format\r\n\t */\r\n\tprotected getCurrentLabelFormat(): string | Intl.DateTimeFormatOptions {\r\n\t\treturn this.dateFormats.getKey(this._gridInterval ? this._gridInterval.timeUnit : \"day\");\r\n\t}\r\n\r\n\t/**\r\n\t * Initializes an Axis renderer.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic initRenderer(): void {\r\n\t\tsuper.initRenderer();\r\n\t\tlet renderer = this.renderer;\r\n\t\tif (renderer) {\r\n\t\t\t// Set defaults\r\n\t\t\trenderer.ticks.template.location = 0;\r\n\t\t\trenderer.grid.template.location = 0;\r\n\t\t\trenderer.labels.template.location = 0;\r\n\t\t\trenderer.baseGrid.disabled = true;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Coordinates of the actual axis start.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @return Base point\r\n\t */\r\n\tpublic get basePoint(): IPoint {\r\n\t\treturn { x: 0, y: 0 };\r\n\t}\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tprotected animateMinMax(min: number, max: number): Animation {\r\n\t\tlet animation = this.animate([{ property: \"_minAdjusted\", from: this._minAdjusted, to: min }, { property: \"_maxAdjusted\", from: this._maxAdjusted, to: max }], this.rangeChangeDuration, this.rangeChangeEasing);\r\n\t\tanimation.events.on(\"animationprogress\", () => {\r\n\t\t\tthis.dispatch(\"extremeschanged\");\r\n\t\t})\r\n\t\treturn animation;\r\n\t}\r\n\r\n\t/**\r\n\t * Invalidates axis data items when series extremes change\r\n\t */\r\n\tprotected handleExtremesChange() {\r\n\t\tsuper.handleExtremesChange();\r\n\r\n\t\tif (this.groupData) {\r\n\t\t\tlet id = this.baseInterval.timeUnit + this.baseInterval.count;\r\n\t\t\tthis.groupMin[id] = this._finalMin;\r\n\t\t\tthis.groupMax[id] = this._finalMax;\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Zooms axis to specific Dates.\r\n\t *\r\n\t * @param startDate       Start date\r\n\t * @param endValue        End date\r\n\t * @param skipRangeEvent  Do not invoke events\r\n\t * @param instantly       Do not play zoom animations\r\n\t */\r\n\tpublic zoomToDates(startDate: Date, endDate: Date, skipRangeEvent?: boolean, instantly?: boolean, adjust?: boolean): void {\r\n\t\tstartDate = this._df.parse(startDate);\r\n\t\tendDate = this._df.parse(endDate);\r\n\t\tthis.zoomToValues(startDate.getTime(), endDate.getTime(), skipRangeEvent, instantly, adjust);\r\n\t}\r\n\r\n\t/**\r\n\t * Zooms axis to specific values.\r\n\t *\r\n\t * @param startValue      Start value\r\n\t * @param endValue        End value\r\n\t * @param skipRangeEvent  Do not invoke events\r\n\t * @param instantly       Do not play zoom animations\r\n\t */\r\n\tpublic zoomToValues(startValue: number, endValue: number, skipRangeEvent?: boolean, instantly?: boolean, adjust?: boolean): void {\r\n\t\tif (!this.groupData) {\r\n\t\t\t//let start: number = (startValue - this.min) / (this.max - this.min);\r\n\t\t\t//let end: number = (endValue - this.min) / (this.max - this.min);\r\n\r\n\t\t\tlet start = this.valueToPosition(startValue);\r\n\t\t\tlet end = this.valueToPosition(endValue);\r\n\r\n\t\t\tthis.zoom({ start: start, end: end }, skipRangeEvent, instantly);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tlet difference = this.adjustDifference(startValue, endValue);\r\n\t\t\tlet isEnd = false;\r\n\t\t\tif (endValue == this.max) {\r\n\t\t\t\tisEnd = true;\r\n\t\t\t}\r\n\t\t\tlet isStart = false;\r\n\t\t\tif (startValue == this.min) {\r\n\t\t\t\tisStart = true;\r\n\t\t\t}\r\n\r\n\t\t\tif ($type.hasValue(difference)) {\r\n\t\t\t\tlet mainBaseInterval = this.mainBaseInterval;\r\n\t\t\t\tlet groupInterval = this.chooseInterval(0, difference, this.groupCount, this.groupIntervals);\r\n\r\n\t\t\t\tif ((groupInterval.timeUnit == mainBaseInterval.timeUnit && groupInterval.count < mainBaseInterval.count) || $time.getDuration(groupInterval.timeUnit, 1) < $time.getDuration(mainBaseInterval.timeUnit, 1)) {\r\n\t\t\t\t\tgroupInterval = { ...mainBaseInterval };\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet id = groupInterval.timeUnit + groupInterval.count;\r\n\t\t\t\tlet min = this.groupMin[id];\r\n\t\t\t\tlet max = this.groupMax[id];\r\n\r\n\t\t\t\tif (!$type.isNumber(min) || !$type.isNumber(max)) {\r\n\t\t\t\t\tmin = Number.POSITIVE_INFINITY;\r\n\t\t\t\t\tmax = Number.NEGATIVE_INFINITY;\r\n\t\t\t\t\tthis.series.each((series) => {\r\n\t\t\t\t\t\tlet seriesMin = series.min(this);\r\n\t\t\t\t\t\tlet seriesMax = series.max(this);\r\n\r\n\t\t\t\t\t\tif (series._dataSets) {\r\n\t\t\t\t\t\t\tlet ds = series._dataSets.getKey(groupInterval.timeUnit + groupInterval.count);\r\n\r\n\t\t\t\t\t\t\tif (ds) {\r\n\t\t\t\t\t\t\t\tlet mindi = ds.getIndex(0);\r\n\t\t\t\t\t\t\t\tlet maxdi = ds.getIndex(ds.length - 1);\r\n\r\n\t\t\t\t\t\t\t\tif (mindi) {\r\n\t\t\t\t\t\t\t\t\tif (series.xAxis == this) {\r\n\t\t\t\t\t\t\t\t\t\tseriesMin = mindi.dateX.getTime();\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\telse if (series.yAxis == this) {\r\n\t\t\t\t\t\t\t\t\t\tseriesMin = mindi.dateY.getTime();\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tif (maxdi) {\r\n\t\t\t\t\t\t\t\t\tif (series.xAxis == this) {\r\n\t\t\t\t\t\t\t\t\t\tseriesMax = maxdi.dateX.getTime();\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\telse if (series.yAxis == this) {\r\n\t\t\t\t\t\t\t\t\t\tseriesMax = maxdi.dateY.getTime();\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tseriesMax = $time.round(\r\n\t\t\t\t\t\t\t$time.add(new Date(seriesMax), groupInterval.timeUnit, 1, this._df.utc),\r\n\t\t\t\t\t\t\tgroupInterval.timeUnit,\r\n\t\t\t\t\t\t\t1,\r\n\t\t\t\t\t\t\tthis._df.firstDayOfWeek,\r\n\t\t\t\t\t\t\tthis._df.utc,\r\n\t\t\t\t\t\t\tundefined,\r\n\t\t\t\t\t\t\tthis._df.timezoneMinutes,\r\n\t\t\t\t\t\t\tthis._df.timezone\r\n\t\t\t\t\t\t).getTime();\r\n\r\n\t\t\t\t\t\tif (seriesMin < min) {\r\n\t\t\t\t\t\t\tmin = seriesMin;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (seriesMax > max) {\r\n\t\t\t\t\t\t\tmax = seriesMax;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t})\r\n\t\t\t\t\tthis.groupMin[id] = min;\r\n\t\t\t\t\tthis.groupMax[id] = max;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tstartValue = $math.fitToRange(startValue, min, max);\r\n\t\t\t\tendValue = $math.fitToRange(endValue, min, max);\r\n\r\n\t\t\t\tif (adjust) {\r\n\t\t\t\t\tif (isEnd) {\r\n\t\t\t\t\t\tstartValue = endValue - difference;\r\n\t\t\t\t\t\tstartValue = $math.fitToRange(startValue, min, max);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (isStart) {\r\n\t\t\t\t\t\tendValue = startValue + difference;\r\n\t\t\t\t\t\tendValue = $math.fitToRange(endValue, min, max);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet start: number = (startValue - min) / (max - min);\r\n\t\t\t\tlet end: number = (endValue - min) / (max - min);\r\n\r\n\t\t\t\tthis.zoom({ start: start, end: end }, skipRangeEvent, instantly);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Adds `baseInterval` to \"as is\" fields.\r\n\t *\r\n\t * @param field  Field name\r\n\t * @return Assign as is?\r\n\t */\r\n\tprotected asIs(field: string): boolean {\r\n\t\treturn field == \"baseInterval\" || super.asIs(field);\r\n\t}\r\n\r\n\t/**\r\n\t * Copies all properties and related data from a different instance of Axis.\r\n\t *\r\n\t * @param source Source Axis\r\n\t */\r\n\tpublic copyFrom(source: this): void {\r\n\t\tsuper.copyFrom(source);\r\n\t\tthis.dateFormats = source.dateFormats;\r\n\t\tthis.periodChangeDateFormats = source.periodChangeDateFormats;\r\n\t\tthis.groupIntervals.clear();\r\n\t\tsource.groupIntervals.each((interval) => {\r\n\t\t\tthis.groupIntervals.push({ ...interval });\r\n\t\t})\r\n\r\n\t\tthis.gridIntervals.clear();\r\n\t\tsource.gridIntervals.each((interval) => {\r\n\t\t\tthis.gridIntervals.push({ ...interval });\r\n\t\t})\r\n\r\n\t\tif (source._baseInterval) {\r\n\t\t\tthis.baseInterval = source._baseInterval;\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Shows Axis tooltip at specific relative position within Axis. (0-1)\r\n\t *\r\n\t * @param position Position (0-1)\r\n\t * @param local or global position\r\n\t */\r\n\tpublic showTooltipAtPosition(position: number, local?: boolean) {\r\n\r\n\t\tif (!local) {\r\n\t\t\tposition = this.toAxisPosition(position);\r\n\t\t}\r\n\r\n\t\tif (this.snapTooltip) {\r\n\t\t\t// rounding is not good, pen/aac4e7f66f019d36b2447f050c600c13 (no last tootltip shown)\r\n\t\t\tlet actualDate = this.positionToDate(position) //$time.round(this.positionToDate(position), this.baseInterval.timeUnit, 1, this.getFirstWeekDay(), this.dateFormatter.utc, undefined, this._df.timezoneMinutes, this._df.timezone);\r\n\r\n\t\t\tlet actualTime = actualDate.getTime();\r\n\t\t\tlet closestDate: Date;\r\n\r\n\t\t\tthis.series.each((series) => {\r\n\t\t\t\tif (series.baseAxis == this) {\r\n\t\t\t\t\tlet dataItem = this.getSeriesDataItem(series, position, true);\r\n\r\n\t\t\t\t\tif (dataItem) {\r\n\t\t\t\t\t\tlet date: Date;\r\n\t\t\t\t\t\tif (series.xAxis == this) {\r\n\t\t\t\t\t\t\tdate = dataItem.dateX;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (series.yAxis == this) {\r\n\t\t\t\t\t\t\tdate = dataItem.dateY;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif (!closestDate) {\r\n\t\t\t\t\t\t\tclosestDate = date;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\tif (Math.abs(closestDate.getTime() - actualTime) > Math.abs(date.getTime() - actualTime)) {\r\n\t\t\t\t\t\t\t\tclosestDate = date;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t})\r\n\r\n\t\t\tif (closestDate) {\r\n\t\t\t\tlet closestTime = closestDate.getTime();\r\n\t\t\t\tclosestDate = $time.round(\r\n\t\t\t\t\tnew Date(closestTime),\r\n\t\t\t\t\tthis.baseInterval.timeUnit,\r\n\t\t\t\t\tthis.baseInterval.count,\r\n\t\t\t\t\tthis._firstWeekDay,\r\n\t\t\t\t\tthis._df.utc,\r\n\t\t\t\t\tundefined,\r\n\t\t\t\t\tthis._df.timezoneMinutes,\r\n\t\t\t\t\tthis._df.timezone\r\n\t\t\t\t);\r\n\t\t\t\tclosestTime = closestDate.getTime();\r\n\r\n\t\t\t\tlet tooltipLocation = this.renderer.tooltipLocation;\r\n\t\t\t\tif (tooltipLocation == 0) {\r\n\t\t\t\t\ttooltipLocation = 0.0001;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tclosestDate = new Date(closestDate.getTime() + this.baseDuration * tooltipLocation);\r\n\t\t\t\tposition = this.dateToPosition(closestDate);\r\n\r\n\t\t\t\tif (this.chart.cursor && this.chart.cursor.snapToSeries) {\r\n\t\t\t\t\t//void\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tthis.series.each((series) => {\r\n\r\n\t\t\t\t\t\tlet dataItem = series.dataItemsByAxis.getKey(this.uid).getKey(closestTime + series.currentDataSetId);\r\n\t\t\t\t\t\tlet point = series.showTooltipAtDataItem(dataItem);\r\n\t\t\t\t\t\tif (point) {\r\n\t\t\t\t\t\t\tthis.chart._seriesPoints.push({ series: series, point: point });\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t// check, otherwise column tooltip will be hidden\r\n\t\t\t\t\t\t\tif (series.tooltipText || series.tooltipHTML) {\r\n\t\t\t\t\t\t\t\tseries.hideTooltip();\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t})\r\n\t\t\t\t}\r\n\r\n\t\t\t\t//this.chart.sortSeriesTooltips(seriesPoints);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tsuper.showTooltipAtPosition(position, true);\r\n\t}\r\n\r\n\t/**\r\n\t * Should the nearest tooltip be shown if no data item is found on the\r\n\t * current cursor position.\r\n\t *\r\n\t * @default true\r\n\t * @param value  Should snap?\r\n\t */\r\n\tpublic set snapTooltip(value: boolean) {\r\n\t\tthis.setPropertyValue(\"snapTooltip\", value);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Should snap?\r\n\t */\r\n\tpublic get snapTooltip(): boolean {\r\n\t\treturn this.getPropertyValue(\"snapTooltip\");\r\n\t}\r\n\r\n\t/**\r\n\t * Indicates if data should be aggregated to composide data items if there\r\n\t * are more data items in selected range than `groupCount`.\r\n\t *\r\n\t * Grouping will occur automatically, based on current selection range, and\r\n\t * will change dynamically when user zooms in/out the chart.\r\n\t *\r\n\t * NOTE: This works only if [[DateAxis]] is base axis of an [[XYSeries]].\r\n\t *\r\n\t * The related [[XYSeries]] also needs to be set up to take advantage of, by\r\n\t * setting its [`groupFields`](https://www.amcharts.com/docs/v4/reference/xyseries/#groupFields_property).\r\n\t *\r\n\t * The group intervals to aggregate data to is defined by `groupIntervals`\r\n\t * property.\r\n\t *\r\n\t * ```TypeScript\r\n\t * let dateAxis = chart.xAxes.push(new am4charts.DateAxis());\r\n\t * dateAxis.groupData = true;\r\n\t * \r\n\t * let valueAxis = chart.xAxes.push(new am4charts.valueAxis());\r\n\t * \r\n\t * let series = chart.series.push(new am4charts.LineSeries());\r\n\t * series.dataFields.dateX = \"date\";\r\n\t * series.dataFields.valueY = \"value\";\r\n\t * series.groupFields.valueY = \"average\";\r\n\t * ```\r\n\t * ```JavaScript\r\n\t * var dateAxis = chart.xAxes.push(new am4charts.DateAxis());\r\n\t * dateAxis.groupData = true;\r\n\t * \r\n\t * var valueAxis = chart.xAxes.push(new am4charts.valueAxis());\r\n\t * \r\n\t * var series = chart.series.push(new am4charts.LineSeries());\r\n\t * series.dataFields.dateX = \"date\";\r\n\t * series.dataFields.valueY = \"value\";\r\n\t * series.groupFields.valueY = \"average\";\r\n\t * ```\r\n\t * ```JSON\r\n\t * {\r\n\t *   // ...\r\n\t *   \"xAxes\": [{\r\n\t *     \"type\": \"DateAxis\",\r\n\t *     \"groupData\": true\r\n\t *   }],\r\n\t *   \"yAxes\": [{\r\n\t *     \"type\": \"ValueAxis\"\r\n\t *   }],\r\n\t *   \"series\": [{\r\n\t *     \"type\": \"LineSeries\",\r\n\t *     \"dataFields\": {\r\n\t *       \"dateX\": \"date\",\r\n\t *       \"valueY\": \"value\"\r\n\t *     },\r\n\t *     \"groupFields\": {\r\n\t *       \"valueY\": \"average\"\r\n\t *     }\r\n\t *   }]\r\n\t * }\r\n\t * ```\r\n\t *\r\n\t * @default false\r\n\t * @see {@link https://www.amcharts.com/docs/v4/concepts/axes/date-axis/#Dynamic_data_item_grouping} for more information about dynamic data item grouping.\r\n\t * @since 4.7.0\r\n\t * @param  value  Group data points?\r\n\t */\r\n\tpublic set groupData(value: boolean) {\r\n\t\tif (this.setPropertyValue(\"groupData\", value)) {\r\n\t\t\tthis.series.each((series) => {\r\n\t\t\t\tseries.setDataSet(\"\");\r\n\r\n\t\t\t\tif (value && !series.dataGrouped && series.inited) {\r\n\t\t\t\t\tseries._baseInterval[this.uid] = this.mainBaseInterval;\r\n\t\t\t\t\tthis.groupSeriesData(series);\r\n\t\t\t\t}\r\n\t\t\t})\r\n\r\n\t\t\tthis._currentDataSetId = \"\"\r\n\t\t\tthis._groupInterval = undefined;\r\n\t\t\tthis.invalidate();\r\n\t\t\tthis.invalidateSeries();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @return Group data points?\r\n\t */\r\n\tpublic get groupData(): boolean {\r\n\t\treturn this.getPropertyValue(\"groupData\");\r\n\t}\r\n\r\n\t/**\r\n\t * Disables automatic selection of data grouping intervals and always uses\r\n\t * `groupInterval` if set. Works only if `groupData = true`.\r\n\t * \r\n\t * @since 4.9.24\r\n\t * @param  value  Interval\r\n\t */\r\n\tpublic set groupInterval(value: ITimeInterval) {\r\n\t\tif (this.setPropertyValue(\"groupInterval\", value)) {\r\n\t\t\tthis.invalidate();\r\n\t\t\tthis.invalidateSeries();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @return Interval\r\n\t */\r\n\tpublic get groupInterval(): ITimeInterval {\r\n\t\treturn this.getPropertyValue(\"groupInterval\");\r\n\t}\r\n\r\n\t/**\r\n\t * Indicates threshold of data items in selected range at which to start\r\n\t * aggregating data items if `groupData = true`.\r\n\t * \r\n\t * @default 200\r\n\t * @since 4.7.0\r\n\t * @param  value  Number of data items\r\n\t */\r\n\tpublic set groupCount(value: number) {\r\n\t\tthis.setPropertyValue(\"groupCount\", value);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Number of data items\r\n\t */\r\n\tpublic get groupCount(): number {\r\n\t\treturn this.getPropertyValue(\"groupCount\");\r\n\t}\r\n\r\n\t/**\r\n\t * If set will recalculate all timestamps in data by applying specific offset\r\n\t * in minutes.\r\n\t *\r\n\t * IMPORTANT: do not set `timezoneOffset` on both `DateAxis` and `dateFormatter`. It\r\n\t * will skew your results by applying offset twice.\r\n\t * \r\n\t * @since 4.8.5\r\n\t * @param  value Time zone offset in minutes\r\n\t */\r\n\tpublic set timezoneOffset(value: number) {\r\n\t\tthis.setPropertyValue(\"timezoneOffset\", value);\r\n\t}\r\n\r\n\t/**\r\n\t * @todo Timezone offset in minutes\r\n\t */\r\n\tpublic get timezoneOffset(): number {\r\n\t\treturn this.getPropertyValue(\"timezoneOffset\");\r\n\t}\r\n\r\n\t/**\r\n\t * If set will recalculate all timestamps in data to specific named timezone,\r\n\t * e.g. `\"America/Vancouver\"`, `\"Australia/Sydney\"`, `\"UTC\"`, etc.\r\n\t *\r\n\t * IMPORTANT: it is no longer recommended to use this setting. Please \r\n\t * set`timezone` on `dateFormatter`.\r\n\t *\r\n\t * @deprecated\r\n\t * @since 4.10.1\r\n\t * @param  value Time zone\r\n\t */\r\n\tpublic set timezone(value: string) {\r\n\t\tthis.setPropertyValue(\"timezone\", value);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Timezone\r\n\t */\r\n\tpublic get timezone(): string {\r\n\t\treturn this.getPropertyValue(\"timezone\");\r\n\t}\r\n\r\n\t/**\r\n\t * Current grid interval.\r\n\t *\r\n\t * @return Grid interval\r\n\t */\r\n\tpublic get gridInterval(): ITimeInterval {\r\n\t\treturn this._gridInterval;\r\n\t}\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tpublic makeGap(dataItem: LineSeriesDataItem, previous: LineSeriesDataItem): boolean {\r\n\t\tlet series = dataItem.component;\r\n\t\tif (dataItem && previous) {\r\n\t\t\tif (!series.connect && $type.isNumber(series.autoGapCount)) {\r\n\t\t\t\tif (series.baseAxis == this) {\r\n\t\t\t\t\tlet date = dataItem.dates[\"date\" + this.axisLetter];\r\n\t\t\t\t\tlet prevDate = previous.dates[\"date\" + this.axisLetter];\r\n\r\n\t\t\t\t\tif (date && prevDate) {\r\n\t\t\t\t\t\tlet time = date.getTime();\r\n\t\t\t\t\t\tlet prevTime = prevDate.getTime();\r\n\r\n\t\t\t\t\t\tif (time - prevTime > series.autoGapCount * this.baseDuration) {\r\n\t\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/**\r\n\t * @return base value\r\n\t */\r\n\tpublic get baseValue(): number {\r\n\t\treturn this.min;\r\n\t}\r\n}\r\n\r\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\r\nregistry.registeredClasses[\"DateAxis\"] = DateAxis;\r\nregistry.registeredClasses[\"DateAxisDataItem\"] = DateAxisDataItem;\r\n"]},"metadata":{},"sourceType":"module"}