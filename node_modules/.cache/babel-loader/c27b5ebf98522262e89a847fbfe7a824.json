{"ast":null,"code":"/**\r\n * Radar series module.\r\n */\nimport { __extends } from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\nimport { LineSeries, LineSeriesDataItem } from \"./LineSeries\";\nimport { registry } from \"../../core/Registry\";\nimport * as $math from \"../../core/utils/Math\";\nimport * as $path from \"../../core/rendering/Path\"; //import { AxisRendererCircular } from \"../axes/AxisRendererCircular\";\n//import { Sprite } from \"../../core/Sprite\";\n\n/**\r\n * ============================================================================\r\n * DATA ITEM\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * Defines a [[DataItem]] for [[RadarSeries]].\r\n *\r\n * @see {@link DataItem}\r\n */\n\nvar RadarSeriesDataItem =\n/** @class */\nfunction (_super) {\n  __extends(RadarSeriesDataItem, _super);\n  /**\r\n   * Constructor\r\n   */\n\n\n  function RadarSeriesDataItem() {\n    var _this = _super.call(this) || this;\n\n    _this.className = \"RadarSeriesDataItem\";\n\n    _this.setLocation(\"dateX\", 0, 0);\n\n    _this.setLocation(\"dateY\", 0, 0);\n\n    _this.setLocation(\"categoryX\", 0, 0);\n\n    _this.setLocation(\"categoryY\", 0, 0);\n\n    _this.applyTheme();\n\n    return _this;\n  }\n\n  return RadarSeriesDataItem;\n}(LineSeriesDataItem);\n\nexport { RadarSeriesDataItem };\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * Defines [[Series]] for a radar graph.\r\n *\r\n * @see {@link IRadarSeriesEvents} for a list of available Events\r\n * @see {@link IRadarSeriesAdapters} for a list of available Adapters\r\n * @todo Example\r\n * @important\r\n */\n\nvar RadarSeries =\n/** @class */\nfunction (_super) {\n  __extends(RadarSeries, _super);\n  /**\r\n   * Constructor\r\n   */\n\n\n  function RadarSeries() {\n    var _this = _super.call(this) || this;\n\n    _this.className = \"RadarSeries\";\n    _this.connectEnds = true;\n\n    _this.applyTheme();\n\n    return _this;\n  }\n  /**\r\n   * (Re)validates the whole series, effectively causing it to redraw.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  RadarSeries.prototype.validate = function () {\n    // so that radius would be updated\n    if (this.chart.invalid) {\n      this.chart.validate();\n    }\n\n    _super.prototype.validate.call(this);\n  };\n  /**\r\n   * Returns a new/empty DataItem of the type appropriate for this object.\r\n   *\r\n   * @see {@link DataItem}\r\n   * @return Data Item\r\n   */\n\n\n  RadarSeries.prototype.createDataItem = function () {\n    return new RadarSeriesDataItem();\n  };\n  /**\r\n   * Returns an [[IPoint]] coordinates of the specific Serie's data point.\r\n   *\r\n   * @param    dataItem   Data item\r\n   * @param    xKey       Name of X data field\r\n   * @param    yKey       Name of Y data field\r\n   * @param    locationX  X location\r\n   * @param    locationY  Y location\r\n   * @param    stackKeyX  ?\r\n   * @param    stackKeyY  ?\r\n   * @returns             Coordinates\r\n   */\n\n\n  RadarSeries.prototype.getPoint = function (dataItem, xKey, yKey, locationX, locationY, stackKeyX, stackKeyY) {\n    if (!stackKeyX) {\n      stackKeyX = \"valueX\";\n    }\n\n    if (!stackKeyY) {\n      stackKeyY = \"valueY\";\n    }\n\n    var x = this.yAxis.getX(dataItem, yKey, locationY, stackKeyY);\n    var y = this.yAxis.getY(dataItem, yKey, locationY, stackKeyY);\n    var radius = $math.getDistance({\n      x: x,\n      y: y\n    }); // hack to be able to determine angle later\n\n    if (radius == 0) {\n      radius = 0.00001;\n    }\n\n    var angle = this.xAxis.getAngle(dataItem, xKey, locationX, stackKeyX);\n    var startAngle = this.chart.startAngle;\n    var endAngle = this.chart.endAngle; //\t\tangle = $math.fitToRange(angle, startAngle, endAngle);\n\n    if (angle < startAngle || angle > endAngle) {\n      return undefined;\n    } else {\n      return {\n        x: radius * $math.cos(angle),\n        y: radius * $math.sin(angle)\n      };\n    }\n  };\n  /**\r\n   * [addPoints description]\r\n   *\r\n   * @todo Description\r\n   * @param points    [description]\r\n   * @param dataItem  [description]\r\n   * @param xField    [description]\r\n   * @param yField    [description]\r\n   * @param backwards [description]\r\n   */\n\n\n  RadarSeries.prototype.addPoints = function (points, dataItem, xField, yField, backwards) {\n    var point = this.getPoint(dataItem, xField, yField, dataItem.locations[xField], dataItem.locations[yField]);\n\n    if (point) {\n      points.push(point);\n    }\n  };\n  /**\r\n   * Returns an SVG path to be used as a mask for the series.\r\n   *\r\n   * @return SVG path\r\n   */\n\n\n  RadarSeries.prototype.getMaskPath = function () {\n    var renderer = this.yAxis.renderer;\n    return $path.arc(renderer.startAngle, renderer.endAngle - renderer.startAngle, renderer.pixelRadius, renderer.pixelInnerRadius);\n  };\n  /**\r\n   * [drawSegment description]\r\n   *\r\n   * @todo Description\r\n   * @param segment      [description]\r\n   * @param points       [description]\r\n   * @param closePoints  [description]\r\n   */\n\n\n  RadarSeries.prototype.drawSegment = function (segment, points, closePoints) {\n    var axis = this.yAxis;\n    var renderer = axis.renderer;\n\n    if (this.connectEnds && Math.abs(renderer.endAngle - renderer.startAngle) == 360) {\n      // adds one point to the beginning of closePoints array, if needed\n      if (this.dataFields[this._xOpenField] || this.dataFields[this._yOpenField] || this.stacked) {\n        points.push(points[0]);\n\n        if (closePoints.length > 0) {\n          closePoints.unshift(closePoints[closePoints.length - 1]);\n        }\n      }\n    }\n\n    _super.prototype.drawSegment.call(this, segment, points, closePoints);\n  };\n\n  Object.defineProperty(RadarSeries.prototype, \"connectEnds\", {\n    /**\r\n     * @return Connect?\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"connectEnds\");\n    },\n\n    /**\r\n     * Should the last and and first data points be connected, forming a complete\r\n     * closed circle?\r\n     *\r\n     * @default true\r\n     * @param value  Connect?\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"connectEnds\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  RadarSeries.prototype.positionBulletReal = function (bullet, positionX, positionY) {\n    var xAxis = this.xAxis;\n    var yAxis = this.yAxis;\n\n    if (positionX < xAxis.start || positionX > xAxis.end || positionY < yAxis.start || positionY > yAxis.end) {\n      bullet.visible = false;\n    }\n\n    bullet.moveTo(this.xAxis.renderer.positionToPoint(positionX, positionY));\n  };\n\n  RadarSeries.prototype.setXAxis = function (axis) {\n    _super.prototype.setXAxis.call(this, axis);\n\n    this.updateRendererRefs();\n  };\n\n  RadarSeries.prototype.setYAxis = function (axis) {\n    _super.prototype.setYAxis.call(this, axis);\n\n    this.updateRendererRefs();\n  };\n\n  RadarSeries.prototype.updateRendererRefs = function () {\n    var rendererX = this.xAxis.renderer;\n    var rendererY = this.yAxis.renderer;\n    rendererX.axisRendererY = rendererY;\n  };\n\n  return RadarSeries;\n}(LineSeries);\n\nexport { RadarSeries };\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\n\nregistry.registeredClasses[\"RadarSeries\"] = RadarSeries;\nregistry.registeredClasses[\"RadarSeriesDataItem\"] = RadarSeriesDataItem;","map":{"version":3,"mappings":"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","names":["LineSeries","LineSeriesDataItem","registry","$math","$path","__extends","_super","_this","className","setLocation","applyTheme","connectEnds","RadarSeries","chart","invalid","validate","call","RadarSeriesDataItem","dataItem","xKey","yKey","locationX","locationY","stackKeyX","stackKeyY","x","yAxis","getX","y","getY","radius","getDistance","angle","xAxis","getAngle","startAngle","endAngle","undefined","cos","sin","points","xField","yField","backwards","point","getPoint","locations","push","renderer","arc","pixelRadius","pixelInnerRadius","segment","closePoints","axis","Math","abs","dataFields","_xOpenField","_yOpenField","stacked","length","unshift","drawSegment","Object","getPropertyValue","value","setPropertyValue","bullet","positionX","positionY","start","end","visible","moveTo","positionToPoint","setXAxis","updateRendererRefs","setYAxis","rendererX","rendererY","axisRendererY","registeredClasses"],"sourceRoot":"","sources":["../../../../../src/.internal/charts/series/RadarSeries.ts"],"sourcesContent":["/**\r\n * Radar series module.\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { LineSeries, LineSeriesDataItem, ILineSeriesDataFields, ILineSeriesProperties, ILineSeriesAdapters, ILineSeriesEvents } from \"./LineSeries\";\r\nimport { LineSeriesSegment } from \"./LineSeriesSegment\";\r\nimport { IPoint } from \"../../core/defs/IPoint\";\r\nimport { AxisRendererRadial } from \"../axes/AxisRendererRadial\";\r\nimport { AxisRendererCircular } from \"../axes/AxisRendererCircular\";\r\nimport { Axis } from \"../axes/Axis\";\r\nimport { RadarChart } from \"../types/RadarChart\";\r\nimport { registry } from \"../../core/Registry\";\r\nimport { Sprite } from \"../../core/Sprite\";\r\nimport * as $math from \"../../core/utils/Math\";\r\nimport * as $path from \"../../core/rendering/Path\";\r\n//import { AxisRendererCircular } from \"../axes/AxisRendererCircular\";\r\n//import { Sprite } from \"../../core/Sprite\";\r\n\r\n/**\r\n * ============================================================================\r\n * DATA ITEM\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Defines a [[DataItem]] for [[RadarSeries]].\r\n *\r\n * @see {@link DataItem}\r\n */\r\nexport class RadarSeriesDataItem extends LineSeriesDataItem {\r\n\r\n\t/**\r\n\t * Defines a type of [[Component]] this data item is used for.\r\n\t */\r\n\tpublic _component!: RadarSeries;\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor() {\r\n\t\tsuper();\r\n\t\tthis.className = \"RadarSeriesDataItem\";\r\n\r\n\t\tthis.setLocation(\"dateX\", 0, 0);\r\n\t\tthis.setLocation(\"dateY\", 0, 0);\r\n\r\n\t\tthis.setLocation(\"categoryX\", 0, 0);\r\n\t\tthis.setLocation(\"categoryY\", 0, 0);\r\n\r\n\t\tthis.applyTheme();\r\n\t}\r\n\r\n}\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * REQUISITES\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Defines data fields for [[RadarSeries]].\r\n */\r\nexport interface IRadarSeriesDataFields extends ILineSeriesDataFields { }\r\n\r\n/**\r\n * Defines properties for [[RadarSeries]].\r\n */\r\nexport interface IRadarSeriesProperties extends ILineSeriesProperties {\r\n\r\n\t/**\r\n\t * Should the last and and first data points be connected, forming a complete\r\n\t * closed circle?\r\n\t *\r\n\t * @default true\r\n\t */\r\n\tconnectEnds?: boolean;\r\n\r\n}\r\n\r\n/**\r\n * Defines events for [[RadarSeries]].\r\n */\r\nexport interface IRadarSeriesEvents extends ILineSeriesEvents { }\r\n\r\n/**\r\n * Defines adapters for [[RadarSeries]].\r\n *\r\n * @see {@link Adapter}\r\n */\r\nexport interface IRadarSeriesAdapters extends ILineSeriesAdapters, IRadarSeriesProperties { }\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Defines [[Series]] for a radar graph.\r\n *\r\n * @see {@link IRadarSeriesEvents} for a list of available Events\r\n * @see {@link IRadarSeriesAdapters} for a list of available Adapters\r\n * @todo Example\r\n * @important\r\n */\r\nexport class RadarSeries extends LineSeries {\r\n\r\n\t/**\r\n\t * Defines the type of data fields used for the series.\r\n\t */\r\n\tpublic _dataFields: IRadarSeriesDataFields;\r\n\r\n\t/**\r\n\t * Defines available properties.\r\n\t */\r\n\tpublic _properties!: IRadarSeriesProperties;\r\n\r\n\t/**\r\n\t * Defines available adapters.\r\n\t */\r\n\tpublic _adapter!: IRadarSeriesAdapters;\r\n\r\n\t/**\r\n\t * Defines available events.\r\n\t */\r\n\tpublic _events!: IRadarSeriesEvents;\r\n\r\n\t/**\r\n\t * Defines the type of data item.\r\n\t */\r\n\tpublic _dataItem: RadarSeriesDataItem;\r\n\r\n\t/**\r\n\t * A chart series belongs to.\r\n\t */\r\n\tpublic _chart: RadarChart;\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor() {\r\n\t\tsuper();\r\n\t\tthis.className = \"RadarSeries\";\r\n\t\tthis.connectEnds = true;\r\n\t\tthis.applyTheme();\r\n\t}\r\n\r\n\t/**\r\n\t * (Re)validates the whole series, effectively causing it to redraw.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic validate(): void {\r\n\r\n\t\t// so that radius would be updated\r\n\t\tif (this.chart.invalid) {\r\n\t\t\tthis.chart.validate();\r\n\t\t}\r\n\r\n\t\tsuper.validate();\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a new/empty DataItem of the type appropriate for this object.\r\n\t *\r\n\t * @see {@link DataItem}\r\n\t * @return Data Item\r\n\t */\r\n\tprotected createDataItem(): this[\"_dataItem\"] {\r\n\t\treturn new RadarSeriesDataItem();\r\n\t}\r\n\r\n\t/**\r\n\t * Returns an [[IPoint]] coordinates of the specific Serie's data point.\r\n\t *\r\n\t * @param    dataItem   Data item\r\n\t * @param    xKey       Name of X data field\r\n\t * @param    yKey       Name of Y data field\r\n\t * @param    locationX  X location\r\n\t * @param    locationY  Y location\r\n\t * @param    stackKeyX  ?\r\n\t * @param    stackKeyY  ?\r\n\t * @returns             Coordinates\r\n\t */\r\n\tpublic getPoint(dataItem: RadarSeriesDataItem, xKey: string, yKey: string, locationX?: number, locationY?: number, stackKeyX?: string, stackKeyY?: string) {\r\n\t\tif (!stackKeyX) {\r\n\t\t\tstackKeyX = \"valueX\";\r\n\t\t}\r\n\t\tif (!stackKeyY) {\r\n\t\t\tstackKeyY = \"valueY\";\r\n\t\t}\r\n\r\n\t\tlet x: number = this.yAxis.getX(dataItem, yKey, locationY, stackKeyY);\r\n\t\tlet y: number = this.yAxis.getY(dataItem, yKey, locationY, stackKeyY);\r\n\r\n\t\tlet radius: number = $math.getDistance({ x: x, y: y });\r\n\r\n\t\t// hack to be able to determine angle later\r\n\t\tif (radius == 0) {\r\n\t\t\tradius = 0.00001;\r\n\t\t}\r\n\r\n\t\tlet angle: number = this.xAxis.getAngle(dataItem, xKey, locationX, stackKeyX);\r\n\r\n\t\tlet startAngle = this.chart.startAngle;\r\n\t\tlet endAngle = this.chart.endAngle;\r\n\r\n\t\t//\t\tangle = $math.fitToRange(angle, startAngle, endAngle);\r\n\t\tif (angle < startAngle || angle > endAngle) {\r\n\t\t\treturn undefined;\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn { x: radius * $math.cos(angle), y: radius * $math.sin(angle) };\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * [addPoints description]\r\n\t *\r\n\t * @todo Description\r\n\t * @param points    [description]\r\n\t * @param dataItem  [description]\r\n\t * @param xField    [description]\r\n\t * @param yField    [description]\r\n\t * @param backwards [description]\r\n\t */\r\n\tprotected addPoints(points: IPoint[], dataItem: this[\"_dataItem\"], xField: string, yField: string, backwards?: boolean): void {\r\n\t\tlet point = this.getPoint(dataItem, xField, yField, dataItem.locations[xField], dataItem.locations[yField]);\r\n\t\tif (point) {\r\n\t\t\tpoints.push(point);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Returns an SVG path to be used as a mask for the series.\r\n\t *\r\n\t * @return SVG path\r\n\t */\r\n\tprotected getMaskPath(): string {\r\n\t\tlet renderer: AxisRendererRadial = <AxisRendererRadial>this.yAxis.renderer;\r\n\t\treturn $path.arc(renderer.startAngle, renderer.endAngle - renderer.startAngle, renderer.pixelRadius, renderer.pixelInnerRadius);\r\n\t}\r\n\r\n\t/**\r\n\t * [drawSegment description]\r\n\t *\r\n\t * @todo Description\r\n\t * @param segment      [description]\r\n\t * @param points       [description]\r\n\t * @param closePoints  [description]\r\n\t */\r\n\tprotected drawSegment(segment: LineSeriesSegment, points: IPoint[], closePoints: IPoint[]): void {\r\n\t\tlet axis: Axis = this.yAxis;\r\n\t\tlet renderer: AxisRendererRadial = <AxisRendererRadial>axis.renderer;\r\n\r\n\t\tif (this.connectEnds && Math.abs(renderer.endAngle - renderer.startAngle) == 360) {\r\n\t\t\t// adds one point to the beginning of closePoints array, if needed\r\n\t\t\tif (this.dataFields[<keyof this[\"_dataFields\"]>this._xOpenField] ||\r\n\t\t\t\tthis.dataFields[<keyof this[\"_dataFields\"]>this._yOpenField] ||\r\n\t\t\t\tthis.stacked) {\r\n\t\t\t\tpoints.push(points[0]);\r\n\t\t\t\tif (closePoints.length > 0) {\r\n\t\t\t\t\tclosePoints.unshift(closePoints[closePoints.length - 1]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tsuper.drawSegment(segment, points, closePoints);\r\n\t}\r\n\r\n\t/**\r\n\t * Should the last and and first data points be connected, forming a complete\r\n\t * closed circle?\r\n\t *\r\n\t * @default true\r\n\t * @param value  Connect?\r\n\t */\r\n\tpublic set connectEnds(value: boolean) {\r\n\t\tthis.setPropertyValue(\"connectEnds\", value, true);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Connect?\r\n\t */\r\n\tpublic get connectEnds(): boolean {\r\n\t\treturn this.getPropertyValue(\"connectEnds\");\r\n\t}\r\n\r\n\tprotected positionBulletReal(bullet:Sprite, positionX:number, positionY:number){\r\n\t\tlet xAxis = this.xAxis;\r\n\t\tlet yAxis = this.yAxis;\r\n\r\n\t\tif(positionX < xAxis.start || positionX > xAxis.end || positionY < yAxis.start || positionY > yAxis.end){\r\n\t\t\tbullet.visible = false;\r\n\t\t}\r\n\t\t\r\n\t\tbullet.moveTo(this.xAxis.renderer.positionToPoint(positionX, positionY));\t\t\r\n\t}\r\n\r\n\r\n\tprotected setXAxis(axis: Axis) {\r\n\t\tsuper.setXAxis(axis);\r\n\t\tthis.updateRendererRefs();\r\n\t}\r\n\r\n\tprotected setYAxis(axis: Axis) {\r\n\t\tsuper.setYAxis(axis);\r\n\t\tthis.updateRendererRefs();\r\n\t}\r\n\r\n\tprotected updateRendererRefs() {\r\n\t\tlet rendererX = <AxisRendererCircular>this.xAxis.renderer;\r\n\t\tlet rendererY = <AxisRendererRadial>this.yAxis.renderer;\r\n\r\n\t\trendererX.axisRendererY = rendererY;\r\n\t}\r\n}\r\n\r\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\r\nregistry.registeredClasses[\"RadarSeries\"] = RadarSeries;\r\nregistry.registeredClasses[\"RadarSeriesDataItem\"] = RadarSeriesDataItem;\r\n"]},"metadata":{},"sourceType":"module"}