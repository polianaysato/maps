{"ast":null,"code":"/**\r\n * Provides functionality used to creating and showing tooltips (balloons).\r\n */\nimport { __extends } from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\nimport { Container } from \"../Container\";\nimport { registry } from \"../../core/Registry\";\nimport { PointedRectangle } from \"./PointedRectangle\";\nimport { Label } from \"../elements/Label\";\nimport { Animation } from \"../utils/Animation\";\nimport { color } from \"../utils/Color\";\nimport { DropShadowFilter } from \"../rendering/filters/DropShadowFilter\";\nimport * as $math from \"../utils/Math\";\nimport * as $ease from \"../utils/Ease\";\nimport * as $utils from \"../utils/Utils\";\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * Tooltip displays text and/or multimedia information in a balloon over chart\r\n * area.\r\n * @see {@link ITooltipEvents} for a list of available events\r\n * @see {@link ITooltipAdapters} for a list of available Adapters\r\n */\n\nvar Tooltip =\n/** @class */\nfunction (_super) {\n  __extends(Tooltip, _super);\n  /**\r\n   * Constructor\r\n   */\n\n\n  function Tooltip() {\n    var _this = // Init\n    _super.call(this) || this;\n    /**\r\n     * Holds numeric boundary values. Calculated from the `boundingContainer`.\r\n     * @ignore\r\n     */\n\n\n    _this._boundingRect = {\n      x: -40000,\n      y: -40000,\n      width: 80000,\n      height: 80000\n    };\n    /**\r\n     * Coordinates tooltip's pointer (stem) should point to.\r\n     */\n\n    _this._pointTo = {\n      x: 0,\n      y: 0\n    };\n    /**\r\n     * If set to `true` the pointer/stem of the Tooltip will not go outside\r\n     * Tooltip's width or height depending on pointer's orientation.\r\n     *\r\n     * @default false\r\n     */\n\n    _this.fitPointerToBounds = false;\n    /**\r\n     * If `tooltipOrientation` is vertical, it can be drawn below or above point\r\n     * We need to know this when solving overlapping.\r\n     */\n\n    _this._verticalOrientation = \"up\";\n    /**\r\n     * @ignore\r\n     */\n\n    _this.fixDoc = true;\n    _this.className = \"Tooltip\";\n    _this.isMeasured = false;\n    _this.getFillFromObject = true;\n\n    _this.margin(5, 5, 5, 5);\n\n    _this.defaultState.transitionDuration = 1;\n    _this.hiddenState.transitionDuration = 1; // Create chrome/background\n\n    var background = _this.background;\n    background.interactionsEnabled = false;\n    background.fillOpacity = 0.9;\n    background.strokeWidth = 1;\n    background.strokeOpacity = 1;\n    background.stroke = color(\"#ffffff\");\n    background.cornerRadius = 3;\n    background.pointerLength = 6;\n    background.pointerBaseWidth = 10;\n    var dropShadow = new DropShadowFilter();\n    dropShadow.dy = 1;\n    dropShadow.dx = 1;\n    dropShadow.opacity = 0.5;\n    background.filters.push(dropShadow);\n    _this.autoTextColor = true; // Create text element\n\n    var label = _this.createChild(Label);\n\n    label.shouldClone = false;\n    _this.label = label;\n    label.padding(7, 12, 4, 12);\n    label.interactionsEnabled = false;\n    label.horizontalCenter = \"middle\";\n    label.fill = color(\"#ffffff\");\n\n    _this._disposers.push(label);\n\n    _this.label.events.on(\"sizechanged\", _this.drawBackground, _this);\n\n    _this.label.zIndex = 1; // @todo remove this line when bg sorting is solved\n    // Set defaults\n\n    _this.pointerOrientation = \"vertical\";\n    _this.animationDuration = 0;\n    _this.animationEasing = $ease.cubicOut;\n\n    _this.setPropertyValue(\"showInViewport\", false); // Set accessibility options\n\n\n    _this.role = \"tooltip\";\n    _this.visible = false;\n    _this.opacity = 0;\n    _this.x = 0;\n    _this.y = 0;\n\n    _this.events.on(\"visibilitychanged\", _this.handleVisibility, _this); // Apply theme\n\n\n    _this.applyTheme();\n\n    return _this;\n  }\n\n  Tooltip.prototype.handleVisibility = function () {\n    if (this.visible) {\n      this.label.invalidate();\n    }\n  };\n\n  Object.defineProperty(Tooltip.prototype, \"getStrokeFromObject\", {\n    /**\r\n     * Specifies if tooltip background should get stroke color from the sprite it is pointing to.\r\n     *\r\n     * @return {boolean}\r\n     * @default false\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"getStrokeFromObject\");\n    },\n\n    /**\r\n     * Specifies if tooltip background should get stroke color from the sprite it is pointing to.\r\n     *\r\n     * @param value boolean\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"getStrokeFromObject\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Tooltip.prototype, \"autoTextColor\", {\n    /**\r\n     * @return {boolean}\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"autoTextColor\");\n    },\n\n    /**\r\n     * Specifies if text color should be chosen automatically for a better\r\n     * readability.\r\n     *\r\n     * IMPORTANT: this feature is generally ignored, if `getFillFromObject = false`.\r\n     *\r\n     * If inheriting of `fill` color from object tooltip is displayed for is\r\n     * disabled, this feature will not work. If you are explicitly setting a\r\n     * color for tooltip background, you may set a color for its label as well\r\n     * using `tooltip.label.fill` property.\r\n     *\r\n     *\r\n     * @param value boolean\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"autoTextColor\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Tooltip.prototype, \"keepTargetHover\", {\n    /**\r\n     * @return Keep target hovered?\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"keepTargetHover\");\n    },\n\n    /**\r\n     * If this tooltip is displayed on hover on some other object, keep that\r\n     * element hovered if hovering on the tooltip.\r\n     *\r\n     * @default false\r\n     * @since 4.1.13\r\n     * @param  value  Keep target hovered?\r\n     */\n    set: function (value) {\n      var _this = this;\n\n      if (this.setPropertyValue(\"keepTargetHover\", value, true)) {\n        if (value) {\n          this.hoverable = true;\n          this.background.interactionsEnabled = true;\n\n          this._disposers.push(this.events.on(\"over\", function (ev) {\n            if (_this.targetSprite && _this.targetSprite.hoverable) {\n              _this.targetSprite.isHover = true;\n            }\n          }));\n\n          this._disposers.push(this.events.on(\"out\", function (ev) {\n            if (_this.targetSprite && _this.targetSprite.hoverable) {\n              //this.hideTooltip();\n              //this.targetSprite.handleOut();\n              _this.targetSprite.isHover = false;\n            }\n          }));\n        }\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Tooltip.prototype, \"showInViewport\", {\n    /**\r\n     * @return Force showing tooltip?\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"showInViewport\");\n    },\n\n    /**\r\n     * Normally, a tooltip will hide itself if it is pointing to a coordinate\r\n     * that is outside viewport.\r\n     *\r\n     * Setting this setting to `true` will override that and make tooltip\r\n     * appear next to the viewport edge closest to the target point.\r\n     *\r\n     * @default false\r\n     * @since 4.5.7\r\n     * @param  value  Force showing tooltip?\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"showInViewport\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Tooltip.prototype, \"getFillFromObject\", {\n    /**\r\n     * Specifies if tooltip background should get fill color from the sprite it is pointing to.\r\n     *\r\n     * @return {boolean}\r\n     * @default true\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"getFillFromObject\");\n    },\n\n    /**\r\n     * @param value boolean\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"getFillFromObject\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Creates and returns a background element.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @return Background\r\n   */\n\n  Tooltip.prototype.createBackground = function () {\n    return new PointedRectangle();\n  };\n\n  Object.defineProperty(Tooltip.prototype, \"pointerOrientation\", {\n    /**\r\n     * @return Orientation\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"pointerOrientation\");\n    },\n\n    /**\r\n     * Pointer orientation: `\"horizontal\"`, `\"vertical\"`, `\"up\"`, `\"down\"`,\r\n     * `\"right\"`, or `\"left\"`.\r\n     *\r\n     * Options`\"horizontal\"` or `\"vertical\"` are location-aware, meaning they\r\n     * will change position of the Tooltip based on the target point's position\r\n     * in relation to chart center.\r\n     *\r\n     * Options `\"up\"`, `\"down\"`, `\"right\"`, `\"left\"` are static and will point\r\n     * in the specified direction regardless of the position, even if that means\r\n     * going out of chart/screen bounds.\r\n     *\r\n     * IMPORTANT: in some situations, like having multiple tooltips stacked for\r\n     * multiple series, the `\"up\"` and `\"down\"` values might be ignored in order\r\n     * to make tooltip overlap algorithm work.\r\n     *\r\n     * @default \"vertical\"\r\n     * @param  value  Orientation\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"pointerOrientation\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Tooltip.prototype, \"animationDuration\", {\n    /**\r\n     * @return Orientation\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"animationDuration\");\n    },\n\n    /**\r\n     * Duration in milliseconds for the animation to take place when the tooltip\r\n     * is moving from one place to another.\r\n     *\r\n     * @default 0\r\n     * @param value  number\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"animationDuration\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Tooltip.prototype, \"animationEasing\", {\n    /**\r\n     * @return {Function}\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"animationEasing\");\n    },\n\n    /**\r\n     * Tooltip animation (moving from one place to another) easing function.\r\n     *\r\n     * @default $ease.cubicOut\r\n     * @param value (value: number) => number\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"animationEasing\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Tooltip.prototype, \"html\", {\n    /**\r\n     * @return HTML content\r\n     */\n    get: function () {\n      return this.label.html;\n    },\n\n    /**\r\n     * HTML content for the Tooltip.\r\n     *\r\n     * Provided value will be used as is, without applying any further\r\n     * formatting to it.\r\n     *\r\n     * @param value  HTML content\r\n     */\n    set: function (value) {\n      if (this.label.html != value) {\n        this.label.html = value;\n        this.invalidate();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Tooltip.prototype, \"text\", {\n    /**\r\n     * @return SVG text\r\n     */\n    get: function () {\n      return this.label.text;\n    },\n\n    /**\r\n     * SVG text content for the Tooltip.\r\n     *\r\n     * Text can have a number of formatting options supported by\r\n     * [[TextFormatter]].\r\n     *\r\n     * @param value  SVG text\r\n     */\n    set: function (value) {\n      if (this.label.text != value) {\n        this.label.text = value;\n        this.invalidate();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Creates the Tooltip.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n  Tooltip.prototype.draw = function () {\n    _super.prototype.draw.call(this);\n\n    var label = this.label;\n\n    if (label.invalid) {\n      label.validate();\n    }\n\n    var x = this._pointTo.x;\n    var y = this._pointTo.y;\n    var boundingRect = this._boundingRect;\n    var textW = label.measuredWidth;\n    var textH = label.measuredHeight;\n    var pointerLength = this.background.pointerLength;\n    var textX;\n    var textY;\n\n    if (this.ignoreBounds) {\n      boundingRect = undefined;\n    } // try to handle if text is wider than br\n\n\n    if (boundingRect && this.fixDoc && textW > boundingRect.width) {\n      // TODO maybe this isn't needed ?\n      $utils.spritePointToDocument({\n        x: boundingRect.x,\n        y: boundingRect.y\n      }, this.parent);\n      var p1 = $utils.spritePointToDocument({\n        x: boundingRect.x + boundingRect.width,\n        y: boundingRect.y + boundingRect.height\n      }, this.parent);\n      var documentWidth = document.body.offsetWidth; // TODO maybe this isn't needed ?\n\n      $utils.used(document.body.offsetHeight);\n\n      if (p1.x > documentWidth / 2) {\n        boundingRect.x = boundingRect.width - textW;\n      } else {\n        boundingRect.width = boundingRect.x + textW;\n      }\n    }\n\n    var pointerOrientation = this.pointerOrientation; // horizontal\n\n    if (pointerOrientation == \"horizontal\" || pointerOrientation == \"left\" || pointerOrientation == \"right\") {\n      textY = -textH / 2;\n\n      if (pointerOrientation == \"horizontal\") {\n        if (boundingRect && x > boundingRect.x + boundingRect.width / 2) {\n          textX = -textW / 2 - pointerLength;\n        } else {\n          textX = textW / 2 + pointerLength;\n        }\n      } else if (pointerOrientation == \"left\") {\n        textX = textW / 2 + pointerLength;\n      } else {\n        textX = -textW / 2 - pointerLength;\n      }\n    } // vertical pointer\n    else {\n      if (boundingRect) {\n        textX = $math.fitToRange(0, boundingRect.x - x + textW / 2, boundingRect.x - x + boundingRect.width - textW / 2);\n      }\n\n      if (pointerOrientation == \"vertical\") {\n        if (boundingRect && y > boundingRect.y + textH + pointerLength) {\n          textY = -textH - pointerLength;\n          this._verticalOrientation = \"up\";\n        } else {\n          textY = pointerLength;\n          this._verticalOrientation = \"down\";\n        }\n      } else if (pointerOrientation == \"down\") {\n        textY = -textH - pointerLength;\n        this._verticalOrientation = \"up\";\n      } else {\n        textY = pointerLength;\n        this._verticalOrientation = \"down\";\n      }\n    }\n\n    if (boundingRect) {\n      textY = $math.fitToRange(textY, boundingRect.y - y, boundingRect.y + boundingRect.height - textH - y);\n    }\n\n    label.x = textX;\n    label.y = textY;\n    this.drawBackground();\n  };\n  /**\r\n   * Overrides functionality from the superclass.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  Tooltip.prototype.updateBackground = function () {\n    this.group.addToBack(this.background.group);\n  };\n  /**\r\n   * Draws Tooltip background (chrome, background and pointer/stem).\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  Tooltip.prototype.drawBackground = function () {\n    var label = this.label;\n    var background = this.background;\n    var textWidth = label.measuredWidth;\n    var textHeight = label.measuredHeight;\n    var boundingRect = this._boundingRect;\n    var bgWidth = textWidth;\n    var bgX = label.pixelX - textWidth / 2;\n    var bgHeight = textHeight;\n    var bgY = label.pixelY;\n    var x = this._pointTo.x;\n    var y = this._pointTo.y;\n    var boundX1 = boundingRect.x - x;\n    var boundX2 = boundX1 + boundingRect.width;\n    var boundY1 = boundingRect.y - y;\n    var boundY2 = boundY1 + boundingRect.height;\n    background.x = bgX;\n    background.y = bgY;\n    background.width = bgWidth;\n    background.height = bgHeight;\n\n    if (this.fitPointerToBounds) {\n      background.pointerX = $math.fitToRange(-background.x, boundX1 - background.x, boundX2 - background.x);\n      background.pointerY = $math.fitToRange(-background.y, boundY1 - background.y, boundY2 - background.y);\n    } else {\n      background.pointerX = -background.x;\n      background.pointerY = -background.y;\n    }\n\n    background.validate();\n  };\n  /**\r\n   *\r\n   */\n\n\n  Tooltip.prototype.delayedPointTo = function (point, instantly) {\n    var _this = this;\n\n    if (this._pointToDisposer) {\n      this._pointToDisposer.dispose();\n    }\n\n    this._pointToDisposer = registry.events.once(\"exitframe\", function () {\n      _this.pointTo(point, instantly);\n    });\n    this.addDisposer(this._pointToDisposer);\n  };\n  /**\r\n   * Set nes tooltip's anchor point and moves whole tooltip.\r\n   *\r\n   * @param x  X coordinate\r\n   * @param y  Y coordinate\r\n   */\n\n\n  Tooltip.prototype.pointTo = function (point, instantly) {\n    if (this._pointTo.x != point.x || this._pointTo.y != point.y) {\n      this._pointTo = point;\n      this.invalidate(); // this helps to avoid strange animation from nowhere on initial show or when balloon was hidden already\n\n      if (!this.visible || instantly) {\n        this.moveTo(this._pointTo);\n\n        if (this._animation) {\n          this._animation.kill();\n        }\n      } else {\n        // helps to avoid flicker on top/left corner\n        if (this.pixelX == 0 && this.pixelY == 0) {\n          this.moveTo(this._pointTo);\n        } else {\n          if (this._animation) {\n            this._animation.kill();\n          }\n\n          this._animation = new Animation(this, [{\n            property: \"x\",\n            to: point.x,\n            from: this.pixelX\n          }, {\n            property: \"y\",\n            to: point.y,\n            from: this.pixelY\n          }], this.animationDuration, this.animationEasing).start();\n        }\n      }\n    }\n  };\n  /**\r\n   * Sets numeric boundaries Tooltip needs to obey (so it does not go outside\r\n   * specific area).\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param rectangle Boundary rectangle\r\n   */\n\n\n  Tooltip.prototype.setBounds = function (rectangle) {\n    var oldRect = this._boundingRect;\n\n    if (oldRect.x != rectangle.x || oldRect.y != rectangle.y || oldRect.width != rectangle.width || oldRect.height != rectangle.height) {\n      this._boundingRect = rectangle;\n      this.invalidate();\n    }\n  };\n\n  Object.defineProperty(Tooltip.prototype, \"boundingContainer\", {\n    /**\r\n     * Sets a [[Container]] instance to be used when calculating numeric\r\n     * boundaries for the Tooltip.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param container  Boundary container\r\n     */\n    set: function (container) {\n      this._boundingContainer = container; // TODO remove closures ?\n\n      container.events.on(\"sizechanged\", this.updateBounds, this);\n      container.events.on(\"positionchanged\", this.updateBounds, this);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Updates numeric boundaries for the Tooltip, based on the\r\n   * `boundingCountrainer`.\r\n   */\n\n  Tooltip.prototype.updateBounds = function () {\n    var boundingContainer = this._boundingContainer; // to global\n\n    var rect = $utils.spriteRectToSvg({\n      x: boundingContainer.pixelX,\n      y: boundingContainer.pixelY,\n      width: boundingContainer.maxWidth,\n      height: boundingContainer.maxHeight\n    }, boundingContainer);\n    this.setBounds(rect);\n  };\n\n  Object.defineProperty(Tooltip.prototype, \"ignoreBounds\", {\n    /**\r\n     * @return Ignore chart bounds?\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"ignoreBounds\");\n    },\n\n    /**\r\n     * Normally, a tooltip's position will be adjusted so it always fits into\r\n     * chart's coundaries.\r\n     *\r\n     * Setting this to `false` will disable such checks and will allow tooltip\r\n     * to \"bleed over\" the edge of the chart.\r\n     *\r\n     * @default false\r\n     * @since 4.10.8\r\n     * @param  value  Ignore chart bounds?\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"ignoreBounds\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Tooltip.prototype, \"verticalOrientation\", {\n    /**\r\n     * If tooltipOrientation is vertical, it can be drawn below or above point.\r\n     * We need to know this when solving overlapping.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @return \"up\" | \"down\"\r\n     */\n    get: function () {\n      return this._verticalOrientation;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Tooltip.prototype, \"tooltip\", {\n    /**\r\n     * To avoid stackoverflow\r\n     * @ignore\r\n     */\n    get: function () {\n      return undefined;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Copies properties and other attributes.\r\n   *\r\n   * @param source  Source\r\n   */\n\n  Tooltip.prototype.copyFrom = function (source) {\n    _super.prototype.copyFrom.call(this, source);\n\n    this.label.copyFrom(source.label);\n\n    if (source._boundingRect) {\n      this._boundingRect = source._boundingRect;\n    }\n  };\n  /**\r\n   * Adds easing functions to \"function\" fields.\r\n   *\r\n   * @param field  Field name\r\n   * @return Assign as function?\r\n   */\n\n\n  Tooltip.prototype.asFunction = function (field) {\n    return field == \"animationEasing\" || _super.prototype.asIs.call(this, field);\n  };\n\n  return Tooltip;\n}(Container);\n\nexport { Tooltip };\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\n\nregistry.registeredClasses[\"Tooltip\"] = Tooltip;","map":{"version":3,"mappings":"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","names":["Container","registry","PointedRectangle","Label","Animation","color","DropShadowFilter","$math","$ease","$utils","__extends","_super","_this","x","y","width","height","className","isMeasured","getFillFromObject","margin","defaultState","transitionDuration","hiddenState","background","interactionsEnabled","fillOpacity","strokeWidth","strokeOpacity","stroke","cornerRadius","pointerLength","pointerBaseWidth","dropShadow","dy","dx","opacity","filters","push","autoTextColor","label","createChild","shouldClone","padding","horizontalCenter","fill","_disposers","events","on","drawBackground","zIndex","pointerOrientation","animationDuration","animationEasing","cubicOut","setPropertyValue","role","visible","handleVisibility","applyTheme","Tooltip","invalidate","Object","getPropertyValue","value","hoverable","ev","targetSprite","isHover","html","text","draw","call","invalid","validate","_pointTo","boundingRect","_boundingRect","textW","measuredWidth","textH","measuredHeight","textX","textY","ignoreBounds","undefined","fixDoc","spritePointToDocument","parent","p1","documentWidth","document","body","offsetWidth","used","offsetHeight","fitToRange","_verticalOrientation","group","addToBack","textWidth","textHeight","bgWidth","bgX","pixelX","bgHeight","bgY","pixelY","boundX1","boundX2","boundY1","boundY2","fitPointerToBounds","pointerX","pointerY","point","instantly","_pointToDisposer","dispose","once","pointTo","addDisposer","moveTo","_animation","kill","property","to","from","start","rectangle","oldRect","container","_boundingContainer","updateBounds","boundingContainer","rect","spriteRectToSvg","maxWidth","maxHeight","setBounds","source","copyFrom","field","asIs","registeredClasses"],"sourceRoot":"","sources":["../../../../../src/.internal/core/elements/Tooltip.ts"],"sourcesContent":["/**\r\n * Provides functionality used to creating and showing tooltips (balloons).\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { Container, IContainerProperties, IContainerAdapters, IContainerEvents } from \"../Container\";\r\nimport { registry } from \"../../core/Registry\";\r\nimport { Sprite } from \"../../core/Sprite\";\r\nimport { PointedRectangle } from \"./PointedRectangle\";\r\nimport { IPoint } from \"../defs/IPoint\";\r\nimport { Label } from \"../elements/Label\";\r\nimport { Animation } from \"../utils/Animation\";\r\nimport { color } from \"../utils/Color\";\r\nimport { DropShadowFilter } from \"../rendering/filters/DropShadowFilter\";\r\nimport { IRectangle } from \"../defs/IRectangle\";\r\nimport * as $math from \"../utils/Math\";\r\nimport * as $ease from \"../utils/Ease\";\r\nimport * as $utils from \"../utils/Utils\";\r\nimport * as $type from \"../utils/Type\";\r\nimport { IDisposer } from \"../utils/Disposer\";\r\n\r\n/**\r\n * ============================================================================\r\n * REQUISITES\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Represents options for tooltip pointer (arrow) orientation.\r\n */\r\nexport type PointerOrientation = \"horizontal\" | \"vertical\" | \"left\" | \"right\" | \"up\" | \"down\";\r\n\r\n/**\r\n * Defines properties for [[Tooltip]].\r\n */\r\nexport interface ITooltipProperties extends IContainerProperties {\r\n\r\n\t/**\r\n\t * Pointer orientation: \"horizontal\", \"vertical\", \"left\", \"right\", \"up\", \"down\".\r\n\t *\r\n\t * @default \"vertical\"\r\n\t */\r\n\tpointerOrientation?: PointerOrientation;\r\n\r\n\t/**\r\n\t * Duration (ms) that takes for a Tooltip to move from one place to another.\r\n\t *\r\n\t * If set to a zero value, the Tooltop will jump to a new location\r\n\t * instantenously.\r\n\t *\r\n\t * If set to a non-zero value, the Tooltip will \"glide\" to a new location at\r\n\t * a speed determined by this setting.\r\n\t *\r\n\t * @see {@link https://www.amcharts.com/docs/v4/concepts/animations/} for more info about animations\r\n\t */\r\n\tanimationDuration?: number;\r\n\r\n\t/**\r\n\t * An easing function to use when animating Tooltip position.\r\n\t *\r\n\t * @see {@link https://www.amcharts.com/docs/v4/concepts/animations/} for more info about animations\r\n\t */\r\n\tanimationEasing?: (value: number) => number;\r\n\r\n\t/**\r\n\t * Specifies if tooltip background should get stroke color from the sprite\r\n\t * it is pointing to.\r\n\t */\r\n\tgetStrokeFromObject?: boolean;\r\n\r\n\t/**\r\n\t * Specifies if tooltip background should get fill color from the sprite it\r\n\t * is pointing to.\r\n\t */\r\n\tgetFillFromObject?: boolean;\r\n\r\n\t/**\r\n\t * Specifies if text color should be chosen automatically for a better\r\n\t * readability.\r\n\t */\r\n\tautoTextColor?: boolean;\r\n\r\n\t/**\r\n\t * If this tooltip is displayed on hover on some other object, keep that\r\n\t * element hovered if hovering on the tooltip.\r\n\t *\r\n\t * @since 4.1.13\r\n\t */\r\n\tkeepTargetHover?: boolean;\r\n\r\n\t/**\r\n\t * Normally, a tooltip will hide itself if it is pointing to a coordinate\r\n\t * that is outside viewport.\r\n\t *\r\n\t * Setting this setting to `true` will override that and make tooltip\r\n\t * appear next to the viewport edge closest to the target point.\r\n\t *\r\n\t * @since 4.5.7\r\n\t */\r\n\tshowInViewport?: boolean\r\n\r\n\t/**\r\n\t * Normally, a tooltip's position will be adjusted so it always fits into\r\n\t * chart's coundaries.\r\n\t *\r\n\t * Setting this to `false` will disable such checks and will allow tooltip\r\n\t * to \"bleed over\" the edge of the chart.\r\n\t *\r\n\t * @default false\r\n\t * @since 4.10.8\r\n\t */\r\n\tignoreBounds?: boolean;\r\n}\r\n\r\n/**\r\n * Defines events for [[Tooltip]].\r\n */\r\nexport interface ITooltipEvents extends IContainerEvents { }\r\n\r\n/**\r\n * Defines adapters for [[Tooltip]].\r\n *\r\n * @see {@link Adapter}\r\n */\r\nexport interface ITooltipAdapters extends IContainerAdapters, ITooltipProperties { }\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Tooltip displays text and/or multimedia information in a balloon over chart\r\n * area.\r\n * @see {@link ITooltipEvents} for a list of available events\r\n * @see {@link ITooltipAdapters} for a list of available Adapters\r\n */\r\nexport class Tooltip extends Container {\r\n\r\n\t/**\r\n\t * Defines available properties.\r\n\t */\r\n\tpublic _properties!: ITooltipProperties;\r\n\r\n\t/**\r\n\t * Defines available adapters.\r\n\t */\r\n\tpublic _adapter!: ITooltipAdapters;\r\n\r\n\t/**\r\n\t * Defines available events.\r\n\t */\r\n\tpublic _events!: ITooltipEvents;\r\n\r\n\t/**\r\n\t * A type for the background element.\r\n\t */\r\n\tpublic _background: PointedRectangle;\r\n\r\n\t/**\r\n\t * Text element that represents tooltip contents.\r\n\t */\r\n\tpublic label: Label;\r\n\r\n\t/**\r\n\t * A container that should be considered a \"boundary\" for the tooltip. A\r\n\t * bounding container is used to calculate numeric boundaries\r\n\t * (`boundingRect`). It is used to constrain the Tooltip to specific area on\r\n\t * the chart, like for example cursor tooltip in plot area.\r\n\t */\r\n\tprotected _boundingContainer: Container;\r\n\r\n\t/**\r\n\t * Holds numeric boundary values. Calculated from the `boundingContainer`.\r\n\t * @ignore\r\n\t */\r\n\tpublic _boundingRect: IRectangle = { x: -40000, y: -40000, width: 80000, height: 80000 };\r\n\r\n\t/**\r\n\t * Coordinates tooltip's pointer (stem) should point to.\r\n\t */\r\n\tprotected _pointTo: IPoint = { x: 0, y: 0 };\r\n\r\n\t/**\r\n\t * If set to `true` the pointer/stem of the Tooltip will not go outside\r\n\t * Tooltip's width or height depending on pointer's orientation.\r\n\t *\r\n\t * @default false\r\n\t */\r\n\tpublic fitPointerToBounds: boolean = false;\r\n\r\n\t/**\r\n\t * If `tooltipOrientation` is vertical, it can be drawn below or above point\r\n\t * We need to know this when solving overlapping.\r\n\t */\r\n\tprotected _verticalOrientation: \"up\" | \"down\" = \"up\";\r\n\r\n\t/**\r\n\t * Position animation of a tooltip\r\n\t */\r\n\tprotected _animation: $type.Optional<Animation>;\r\n\r\n\t/**\r\n\t * A [[Sprite]] element this tooltip is displayed for, if any.\r\n\t *\r\n\t * @since 4.1.13\r\n\t */\r\n\tpublic targetSprite: $type.Optional<Sprite>;\r\n\r\n\t/**\r\n\t * reference to a sprite which now shows this tooltip instance.\r\n\t */\r\n\tpublic currentSprite: Sprite;\r\n\r\n\tprotected _pointToDisposer: IDisposer;\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tpublic fixDoc: boolean = true;\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor() {\r\n\r\n\t\t// Init\r\n\t\tsuper();\r\n\t\tthis.className = \"Tooltip\";\r\n\t\tthis.isMeasured = false;\r\n\r\n\t\tthis.getFillFromObject = true;\r\n\t\tthis.margin(5, 5, 5, 5);\r\n\r\n\t\tthis.defaultState.transitionDuration = 1;\r\n\t\tthis.hiddenState.transitionDuration = 1;\r\n\r\n\t\t// Create chrome/background\r\n\t\tlet background = this.background;\r\n\t\tbackground.interactionsEnabled = false;\r\n\t\tbackground.fillOpacity = 0.9;\r\n\t\tbackground.strokeWidth = 1;\r\n\t\tbackground.strokeOpacity = 1;\r\n\t\tbackground.stroke = color(\"#ffffff\");\r\n\t\tbackground.cornerRadius = 3;\r\n\t\tbackground.pointerLength = 6;\r\n\t\tbackground.pointerBaseWidth = 10;\r\n\r\n\t\tlet dropShadow = new DropShadowFilter();\r\n\t\tdropShadow.dy = 1;\r\n\t\tdropShadow.dx = 1;\r\n\t\tdropShadow.opacity = 0.5;\r\n\t\tbackground.filters.push(dropShadow);\r\n\r\n\t\tthis.autoTextColor = true;\r\n\r\n\t\t// Create text element\r\n\t\tlet label = this.createChild(Label);\r\n\t\tlabel.shouldClone = false;\r\n\t\tthis.label = label;\r\n\t\tlabel.padding(7, 12, 4, 12);\r\n\t\tlabel.interactionsEnabled = false;\r\n\t\tlabel.horizontalCenter = \"middle\";\r\n\t\tlabel.fill = color(\"#ffffff\");\r\n\t\tthis._disposers.push(label);\r\n\r\n\t\tthis.label.events.on(\"sizechanged\", this.drawBackground, this);\r\n\r\n\t\tthis.label.zIndex = 1; // @todo remove this line when bg sorting is solved\r\n\r\n\t\t// Set defaults\r\n\t\tthis.pointerOrientation = \"vertical\";\r\n\r\n\t\tthis.animationDuration = 0;\r\n\t\tthis.animationEasing = $ease.cubicOut;\r\n\r\n\t\tthis.setPropertyValue(\"showInViewport\", false);\r\n\r\n\t\t// Set accessibility options\r\n\t\tthis.role = \"tooltip\";\r\n\r\n\t\tthis.visible = false;\r\n\t\tthis.opacity = 0;\r\n\r\n\t\tthis.x = 0;\r\n\t\tthis.y = 0;\r\n\r\n\t\tthis.events.on(\"visibilitychanged\", this.handleVisibility, this);\r\n\r\n\t\t// Apply theme\r\n\t\tthis.applyTheme();\r\n\t}\r\n\r\n\tprotected handleVisibility() {\r\n\t\tif (this.visible) {\r\n\t\t\tthis.label.invalidate();\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Specifies if tooltip background should get stroke color from the sprite it is pointing to.\r\n\t *\r\n\t * @return {boolean}\r\n\t * @default false\r\n\t */\r\n\tpublic get getStrokeFromObject(): boolean {\r\n\t\treturn this.getPropertyValue(\"getStrokeFromObject\");\r\n\t}\r\n\r\n\t/**\r\n\t * Specifies if tooltip background should get stroke color from the sprite it is pointing to.\r\n\t *\r\n\t * @param value boolean\r\n\t */\r\n\tpublic set getStrokeFromObject(value: boolean) {\r\n\t\tthis.setPropertyValue(\"getStrokeFromObject\", value, true);\r\n\t}\r\n\r\n\t/**\r\n\t * Specifies if text color should be chosen automatically for a better\r\n\t * readability.\r\n\t *\r\n\t * IMPORTANT: this feature is generally ignored, if `getFillFromObject = false`.\r\n\t *\r\n\t * If inheriting of `fill` color from object tooltip is displayed for is\r\n\t * disabled, this feature will not work. If you are explicitly setting a\r\n\t * color for tooltip background, you may set a color for its label as well\r\n\t * using `tooltip.label.fill` property.\r\n\t *\r\n\t *\r\n\t * @param value boolean\r\n\t */\r\n\tpublic set autoTextColor(value: boolean) {\r\n\t\tthis.setPropertyValue(\"autoTextColor\", value, true);\r\n\t}\r\n\r\n\t/**\r\n\t * @return {boolean}\r\n\t */\r\n\tpublic get autoTextColor(): boolean {\r\n\t\treturn this.getPropertyValue(\"autoTextColor\");\r\n\t}\r\n\r\n\t/**\r\n\t * If this tooltip is displayed on hover on some other object, keep that\r\n\t * element hovered if hovering on the tooltip.\r\n\t *\r\n\t * @default false\r\n\t * @since 4.1.13\r\n\t * @param  value  Keep target hovered?\r\n\t */\r\n\tpublic set keepTargetHover(value: boolean) {\r\n\t\tif (this.setPropertyValue(\"keepTargetHover\", value, true)) {\r\n\t\t\tif (value) {\r\n\t\t\t\tthis.hoverable = true;\r\n\t\t\t\tthis.background.interactionsEnabled = true;\r\n\t\t\t\tthis._disposers.push(this.events.on(\"over\", (ev) => {\r\n\t\t\t\t\tif (this.targetSprite && this.targetSprite.hoverable) {\r\n\t\t\t\t\t\tthis.targetSprite.isHover = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}));\r\n\r\n\t\t\t\tthis._disposers.push(this.events.on(\"out\", (ev) => {\r\n\t\t\t\t\tif (this.targetSprite && this.targetSprite.hoverable) {\r\n\t\t\t\t\t\t//this.hideTooltip();\r\n\t\t\t\t\t\t//this.targetSprite.handleOut();\r\n\t\t\t\t\t\tthis.targetSprite.isHover = false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}));\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Normally, a tooltip will hide itself if it is pointing to a coordinate\r\n\t * that is outside viewport.\r\n\t *\r\n\t * Setting this setting to `true` will override that and make tooltip\r\n\t * appear next to the viewport edge closest to the target point.\r\n\t *\r\n\t * @default false\r\n\t * @since 4.5.7\r\n\t * @param  value  Force showing tooltip?\r\n\t */\r\n\tpublic set showInViewport(value: boolean) {\r\n\t\tthis.setPropertyValue(\"showInViewport\", value);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Force showing tooltip?\r\n\t */\r\n\tpublic get showInViewport(): boolean {\r\n\t\treturn this.getPropertyValue(\"showInViewport\");\r\n\t}\r\n\r\n\t/**\r\n\t * @return Keep target hovered?\r\n\t */\r\n\tpublic get keepTargetHover(): boolean {\r\n\t\treturn this.getPropertyValue(\"keepTargetHover\");\r\n\t}\r\n\r\n\t/**\r\n\t * Specifies if tooltip background should get fill color from the sprite it is pointing to.\r\n\t *\r\n\t * @return {boolean}\r\n\t * @default true\r\n\t */\r\n\tpublic get getFillFromObject(): boolean {\r\n\t\treturn this.getPropertyValue(\"getFillFromObject\");\r\n\t}\r\n\r\n\t/**\r\n\t * @param value boolean\r\n\t */\r\n\tpublic set getFillFromObject(value: boolean) {\r\n\t\tthis.setPropertyValue(\"getFillFromObject\", value, true);\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Creates and returns a background element.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @return Background\r\n\t */\r\n\tpublic createBackground(): this[\"_background\"] {\r\n\t\treturn new PointedRectangle();\r\n\t}\r\n\r\n\t/**\r\n\t * Pointer orientation: `\"horizontal\"`, `\"vertical\"`, `\"up\"`, `\"down\"`,\r\n\t * `\"right\"`, or `\"left\"`.\r\n\t *\r\n\t * Options`\"horizontal\"` or `\"vertical\"` are location-aware, meaning they\r\n\t * will change position of the Tooltip based on the target point's position\r\n\t * in relation to chart center.\r\n\t *\r\n\t * Options `\"up\"`, `\"down\"`, `\"right\"`, `\"left\"` are static and will point\r\n\t * in the specified direction regardless of the position, even if that means\r\n\t * going out of chart/screen bounds.\r\n\t *\r\n\t * IMPORTANT: in some situations, like having multiple tooltips stacked for\r\n\t * multiple series, the `\"up\"` and `\"down\"` values might be ignored in order\r\n\t * to make tooltip overlap algorithm work.\r\n\t *\r\n\t * @default \"vertical\"\r\n\t * @param  value  Orientation\r\n\t */\r\n\tpublic set pointerOrientation(value: PointerOrientation) {\r\n\t\tthis.setPropertyValue(\"pointerOrientation\", value, true);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Orientation\r\n\t */\r\n\tpublic get pointerOrientation(): PointerOrientation {\r\n\t\treturn this.getPropertyValue(\"pointerOrientation\");\r\n\t}\r\n\r\n\t/**\r\n\t * Duration in milliseconds for the animation to take place when the tooltip\r\n\t * is moving from one place to another.\r\n\t *\r\n\t * @default 0\r\n\t * @param value  number\r\n\t */\r\n\tpublic set animationDuration(value: number) {\r\n\t\tthis.setPropertyValue(\"animationDuration\", value);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Orientation\r\n\t */\r\n\tpublic get animationDuration(): number {\r\n\t\treturn this.getPropertyValue(\"animationDuration\");\r\n\t}\r\n\r\n\t/**\r\n\t * Tooltip animation (moving from one place to another) easing function.\r\n\t *\r\n\t * @default $ease.cubicOut\r\n\t * @param value (value: number) => number\r\n\t */\r\n\tpublic set animationEasing(value: (value: number) => number) {\r\n\t\tthis.setPropertyValue(\"animationEasing\", value);\r\n\t}\r\n\r\n\t/**\r\n\t * @return {Function}\r\n\t */\r\n\tpublic get animationEasing(): (value: number) => number {\r\n\t\treturn this.getPropertyValue(\"animationEasing\");\r\n\t}\r\n\r\n\t/**\r\n\t * HTML content for the Tooltip.\r\n\t *\r\n\t * Provided value will be used as is, without applying any further\r\n\t * formatting to it.\r\n\t *\r\n\t * @param value  HTML content\r\n\t */\r\n\tpublic set html(value: string) {\r\n\t\tif (this.label.html != value) {\r\n\t\t\tthis.label.html = value;\r\n\t\t\tthis.invalidate();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @return HTML content\r\n\t */\r\n\tpublic get html(): string {\r\n\t\treturn this.label.html;\r\n\t}\r\n\r\n\t/**\r\n\t * SVG text content for the Tooltip.\r\n\t *\r\n\t * Text can have a number of formatting options supported by\r\n\t * [[TextFormatter]].\r\n\t *\r\n\t * @param value  SVG text\r\n\t */\r\n\tpublic set text(value: string) {\r\n\t\tif (this.label.text != value) {\r\n\t\t\tthis.label.text = value;\r\n\t\t\tthis.invalidate();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @return SVG text\r\n\t */\r\n\tpublic get text(): string {\r\n\t\treturn this.label.text;\r\n\t}\r\n\r\n\t/**\r\n\t * Creates the Tooltip.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic draw(): void {\r\n\t\tsuper.draw();\r\n\r\n\t\tlet label = this.label;\r\n\r\n\t\tif (label.invalid) {\r\n\t\t\tlabel.validate();\r\n\t\t}\r\n\r\n\t\tlet x: number = this._pointTo.x;\r\n\t\tlet y: number = this._pointTo.y;\r\n\r\n\t\tlet boundingRect: IRectangle = this._boundingRect;\r\n\r\n\t\tlet textW: number = label.measuredWidth;\r\n\t\tlet textH: number = label.measuredHeight;\r\n\r\n\t\tlet pointerLength = this.background.pointerLength;\r\n\r\n\t\tlet textX: number;\r\n\t\tlet textY: number;\r\n\r\n\t\tif (this.ignoreBounds) {\r\n\t\t\tboundingRect = undefined;\r\n\t\t}\r\n\r\n\t\t// try to handle if text is wider than br\r\n\t\tif (boundingRect && this.fixDoc && textW > boundingRect.width) {\r\n\t\t\t// TODO maybe this isn't needed ?\r\n\t\t\t$utils.spritePointToDocument({ x: boundingRect.x, y: boundingRect.y }, this.parent);\r\n\t\t\tlet p1 = $utils.spritePointToDocument({ x: boundingRect.x + boundingRect.width, y: boundingRect.y + boundingRect.height }, this.parent);\r\n\r\n\t\t\tlet documentWidth = document.body.offsetWidth;\r\n\t\t\t// TODO maybe this isn't needed ?\r\n\t\t\t$utils.used(document.body.offsetHeight);\r\n\r\n\t\t\tif (p1.x > documentWidth / 2) {\r\n\t\t\t\tboundingRect.x = boundingRect.width - textW;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tboundingRect.width = boundingRect.x + textW;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tlet pointerOrientation = this.pointerOrientation;\r\n\r\n\t\t// horizontal\r\n\t\tif (pointerOrientation == \"horizontal\" || pointerOrientation == \"left\" || pointerOrientation == \"right\") {\r\n\t\t\ttextY = - textH / 2;\r\n\t\t\tif (pointerOrientation == \"horizontal\") {\r\n\t\t\t\tif (boundingRect && x > boundingRect.x + boundingRect.width / 2) {\r\n\t\t\t\t\ttextX = - textW / 2 - pointerLength;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\ttextX = textW / 2 + pointerLength;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse if (pointerOrientation == \"left\") {\r\n\t\t\t\ttextX = textW / 2 + pointerLength;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\ttextX = -textW / 2 - pointerLength;\r\n\t\t\t}\r\n\t\t}\r\n\t\t// vertical pointer\r\n\t\telse {\r\n\t\t\tif (boundingRect) {\r\n\t\t\t\ttextX = $math.fitToRange(0, boundingRect.x - x + textW / 2, boundingRect.x - x + boundingRect.width - textW / 2);\r\n\t\t\t}\r\n\r\n\t\t\tif (pointerOrientation == \"vertical\") {\r\n\t\t\t\tif (boundingRect && y > boundingRect.y + textH + pointerLength) {\r\n\t\t\t\t\ttextY = - textH - pointerLength;\r\n\t\t\t\t\tthis._verticalOrientation = \"up\";\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\ttextY = pointerLength;\r\n\t\t\t\t\tthis._verticalOrientation = \"down\";\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse if (pointerOrientation == \"down\") {\r\n\t\t\t\ttextY = - textH - pointerLength;\r\n\t\t\t\tthis._verticalOrientation = \"up\";\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\ttextY = pointerLength;\r\n\t\t\t\tthis._verticalOrientation = \"down\";\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (boundingRect) {\r\n\t\t\ttextY = $math.fitToRange(textY, boundingRect.y - y, boundingRect.y + boundingRect.height - textH - y);\r\n\t\t}\r\n\r\n\t\tlabel.x = textX;\r\n\t\tlabel.y = textY;\r\n\r\n\t\tthis.drawBackground();\r\n\t}\r\n\r\n\t/**\r\n\t * Overrides functionality from the superclass.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic updateBackground(): void {\r\n\t\tthis.group.addToBack(this.background.group);\r\n\t}\r\n\r\n\t/**\r\n\t * Draws Tooltip background (chrome, background and pointer/stem).\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic drawBackground(): void {\r\n\t\tlet label = this.label;\r\n\t\tlet background: PointedRectangle = this.background;\r\n\r\n\t\tlet textWidth: number = label.measuredWidth;\r\n\t\tlet textHeight: number = label.measuredHeight;\r\n\r\n\t\tlet boundingRect: IRectangle = this._boundingRect;\r\n\r\n\t\tlet bgWidth: number = textWidth;\r\n\t\tlet bgX: number = label.pixelX - textWidth / 2;\r\n\r\n\t\tlet bgHeight: number = textHeight;\r\n\t\tlet bgY: number = label.pixelY;\r\n\r\n\t\tlet x: number = this._pointTo.x;\r\n\t\tlet y: number = this._pointTo.y;\r\n\r\n\t\tlet boundX1: number = boundingRect.x - x;\r\n\t\tlet boundX2: number = boundX1 + boundingRect.width;\r\n\t\tlet boundY1: number = boundingRect.y - y;\r\n\t\tlet boundY2: number = boundY1 + boundingRect.height;\r\n\r\n\t\tbackground.x = bgX;\r\n\t\tbackground.y = bgY;\r\n\r\n\t\tbackground.width = bgWidth;\r\n\t\tbackground.height = bgHeight;\r\n\r\n\t\tif (this.fitPointerToBounds) {\r\n\t\t\tbackground.pointerX = $math.fitToRange(- background.x, boundX1 - background.x, boundX2 - background.x);\r\n\t\t\tbackground.pointerY = $math.fitToRange(- background.y, boundY1 - background.y, boundY2 - background.y);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tbackground.pointerX = - background.x;\r\n\t\t\tbackground.pointerY = - background.y;\r\n\t\t}\r\n\r\n\t\tbackground.validate();\r\n\t}\r\n\r\n\t/**\r\n\t *\r\n\t */\r\n\tpublic delayedPointTo(point: IPoint, instantly?: boolean) {\r\n\t\tif (this._pointToDisposer) {\r\n\t\t\tthis._pointToDisposer.dispose();\r\n\t\t}\r\n\t\tthis._pointToDisposer = registry.events.once(\"exitframe\", () => {\r\n\t\t\tthis.pointTo(point, instantly);\r\n\t\t})\r\n\r\n\t\tthis.addDisposer(this._pointToDisposer);\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Set nes tooltip's anchor point and moves whole tooltip.\r\n\t *\r\n\t * @param x  X coordinate\r\n\t * @param y  Y coordinate\r\n\t */\r\n\tpublic pointTo(point: IPoint, instantly?: boolean): void {\r\n\t\tif (this._pointTo.x != point.x || this._pointTo.y != point.y) {\r\n\t\t\tthis._pointTo = point;\r\n\t\t\tthis.invalidate();\r\n\r\n\t\t\t// this helps to avoid strange animation from nowhere on initial show or when balloon was hidden already\r\n\t\t\tif (!this.visible || instantly) {\r\n\t\t\t\tthis.moveTo(this._pointTo);\r\n\t\t\t\tif (this._animation) {\r\n\t\t\t\t\tthis._animation.kill();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t// helps to avoid flicker on top/left corner\r\n\t\t\t\tif (this.pixelX == 0 && this.pixelY == 0) {\r\n\t\t\t\t\tthis.moveTo(this._pointTo);\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tif (this._animation) {\r\n\t\t\t\t\t\tthis._animation.kill();\r\n\t\t\t\t\t}\r\n\t\t\t\t\tthis._animation = new Animation(this, [{ property: \"x\", to: point.x, from: this.pixelX }, { property: \"y\", to: point.y, from: this.pixelY }], this.animationDuration, this.animationEasing).start();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Sets numeric boundaries Tooltip needs to obey (so it does not go outside\r\n\t * specific area).\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param rectangle Boundary rectangle\r\n\t */\r\n\tpublic setBounds(rectangle: IRectangle): void {\r\n\t\tlet oldRect = this._boundingRect;\r\n\t\tif (oldRect.x != rectangle.x || oldRect.y != rectangle.y || oldRect.width != rectangle.width || oldRect.height != rectangle.height) {\r\n\t\t\tthis._boundingRect = rectangle;\r\n\t\t\tthis.invalidate();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Sets a [[Container]] instance to be used when calculating numeric\r\n\t * boundaries for the Tooltip.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param container  Boundary container\r\n\t */\r\n\tpublic set boundingContainer(container: Container) {\r\n\t\tthis._boundingContainer = container;\r\n\t\t// TODO remove closures ?\r\n\t\tcontainer.events.on(\"sizechanged\", this.updateBounds, this);\r\n\t\tcontainer.events.on(\"positionchanged\", this.updateBounds, this);\r\n\t}\r\n\r\n\t/**\r\n\t * Updates numeric boundaries for the Tooltip, based on the\r\n\t * `boundingCountrainer`.\r\n\t */\r\n\tprotected updateBounds(): void {\r\n\t\tlet boundingContainer: Container = this._boundingContainer;\r\n\t\t// to global\r\n\t\tlet rect: IRectangle = $utils.spriteRectToSvg({\r\n\t\t\tx: boundingContainer.pixelX,\r\n\t\t\ty: boundingContainer.pixelY,\r\n\t\t\twidth: boundingContainer.maxWidth,\r\n\t\t\theight: boundingContainer.maxHeight\r\n\t\t}, boundingContainer);\r\n\t\tthis.setBounds(rect);\r\n\t}\r\n\r\n\t/**\r\n\t * Normally, a tooltip's position will be adjusted so it always fits into\r\n\t * chart's coundaries.\r\n\t *\r\n\t * Setting this to `false` will disable such checks and will allow tooltip\r\n\t * to \"bleed over\" the edge of the chart.\r\n\t *\r\n\t * @default false\r\n\t * @since 4.10.8\r\n\t * @param  value  Ignore chart bounds?\r\n\t */\r\n\tpublic set ignoreBounds(value: boolean) {\r\n\t\tthis.setPropertyValue(\"ignoreBounds\", value);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Ignore chart bounds?\r\n\t */\r\n\tpublic get ignoreBounds(): boolean {\r\n\t\treturn this.getPropertyValue(\"ignoreBounds\");\r\n\t}\r\n\r\n\t/**\r\n\t * If tooltipOrientation is vertical, it can be drawn below or above point.\r\n\t * We need to know this when solving overlapping.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @return \"up\" | \"down\"\r\n\t */\r\n\tpublic get verticalOrientation(): \"up\" | \"down\" {\r\n\t\treturn this._verticalOrientation;\r\n\t}\r\n\r\n\t/**\r\n\t * To avoid stackoverflow\r\n\t * @ignore\r\n\t */\r\n\tpublic get tooltip(): Tooltip {\r\n\t\treturn undefined;\r\n\t}\r\n\r\n\t/**\r\n\t * Copies properties and other attributes.\r\n\t *\r\n\t * @param source  Source\r\n\t */\r\n\tpublic copyFrom(source: this): void {\r\n\t\tsuper.copyFrom(source);\r\n\t\tthis.label.copyFrom(source.label);\r\n\r\n\t\tif (source._boundingRect) {\r\n\t\t\tthis._boundingRect = source._boundingRect;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Adds easing functions to \"function\" fields.\r\n\t *\r\n\t * @param field  Field name\r\n\t * @return Assign as function?\r\n\t */\r\n\tprotected asFunction(field: string): boolean {\r\n\t\treturn field == \"animationEasing\" || super.asIs(field);\r\n\t}\r\n}\r\n\r\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\r\nregistry.registeredClasses[\"Tooltip\"] = Tooltip;\r\n"]},"metadata":{},"sourceType":"module"}