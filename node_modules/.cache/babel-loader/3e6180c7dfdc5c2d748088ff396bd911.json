{"ast":null,"code":"/**\r\n * Event Dispatcher module is used for registering listeners and dispatching\r\n * events across amCharts system.\r\n */\nimport { __extends } from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\nimport { Disposer } from \"./Disposer\";\nimport * as $array from \"./Array\";\nimport * as $async from \"./AsyncPending\";\nimport * as $type from \"./Type\";\n/*export interface IEventDispatcher<T> {\r\n    isDisposed(): boolean;\r\n    dispose(): void;\r\n    hasListeners(): boolean;\r\n    enable(): void;\r\n    disable(): void;\r\n    enableType<Key extends keyof T>(type: Key): void;\r\n    disableType<Key extends keyof T>(type: Key, amount?: number): void;\r\n    isEnabled<Key extends keyof T>(type: Key): boolean;\r\n    has<C, Key extends keyof T>(type: Key, callback?: (this: C, event: T[Key]) => void, context?: C): boolean;\r\n    dispatchImmediately<Key extends keyof T>(type: Key, event: T[Key]): void;\r\n    dispatch<Key extends keyof T>(type: Key, event: T[Key]): void;\r\n    onAll<C, Key extends keyof T>(callback: (this: C, type: Key, event: T[Key]) => void, context?: C): IDisposer;\r\n    on<C, Key extends keyof T>(type: Key, callback: (this: C, event: T[Key]) => void, context?: C): IDisposer;\r\n    once<C, Key extends keyof T>(type: Key, callback: (this: C, event: T[Key]) => void, context?: C): IDisposer;\r\n    off<C, Key extends keyof T>(type: Key, callback: (this: C, event: T[Key]) => void, context?: C): void;\r\n    off<C, Key extends keyof T>(type: Key, callback: (this: C, event: T[Key]) => void, context?: C): void;\r\n    copyFrom(source: this): void;\r\n}*/\n\n/**\r\n * Universal Event Dispatcher.\r\n *\r\n * @important\r\n */\n\nvar EventDispatcher =\n/** @class */\nfunction () {\n  /**\r\n   * Constructor\r\n   */\n  function EventDispatcher() {\n    this._listeners = [];\n    this._killed = [];\n    this._disabled = {};\n    this._iterating = 0;\n    this._enabled = true;\n    this._disposed = false;\n  }\n  /**\r\n   * Returns if this object has been already disposed.\r\n   *\r\n   * @return Disposed?\r\n   */\n\n\n  EventDispatcher.prototype.isDisposed = function () {\n    return this._disposed;\n  };\n  /**\r\n   * Dispose (destroy) this object.\r\n   */\n\n\n  EventDispatcher.prototype.dispose = function () {\n    if (!this._disposed) {\n      this._disposed = true;\n      var a = this._listeners;\n      this._iterating = 1;\n      this._listeners = null;\n      this._disabled = null;\n\n      try {\n        $array.each(a, function (x) {\n          x.disposer.dispose();\n        });\n      } finally {\n        this._killed = null;\n        this._iterating = null;\n      }\n    }\n  };\n  /**\r\n   * Checks if this particular event dispatcher has any listeners set.\r\n   *\r\n   * @return Has listeners?\r\n   */\n\n\n  EventDispatcher.prototype.hasListeners = function () {\n    return this._listeners.length !== 0;\n  };\n  /**\r\n   * Checks if this particular event dispatcher has any particular listeners set.\r\n   *\r\n   * @return Has particular event listeners?\r\n   */\n\n\n  EventDispatcher.prototype.hasListenersByType = function (type) {\n    return $array.any(this._listeners, function (x) {\n      return (x.type === null || x.type === type) && !x.killed;\n    });\n  };\n  /**\r\n   * Enable dispatching of events if they were previously disabled by\r\n   * `disable()`.\r\n   */\n\n\n  EventDispatcher.prototype.enable = function () {\n    this._enabled = true;\n  };\n  /**\r\n   * Disable dispatching of events until re-enabled by `enable()`.\r\n   */\n\n\n  EventDispatcher.prototype.disable = function () {\n    this._enabled = false;\n  };\n  /**\r\n   * Enable dispatching particular event, if it was disabled before by\r\n   * `disableType()`.\r\n   *\r\n   * @param type Event type\r\n   */\n\n\n  EventDispatcher.prototype.enableType = function (type) {\n    delete this._disabled[type];\n  };\n  /**\r\n   * Disable dispatching of events for a certain event type.\r\n   *\r\n   * Optionally, can set how many dispatches to skip before automatically\r\n   * re-enabling the dispatching.\r\n   *\r\n   * @param type    Event type\r\n   * @param amount  Number of event dispatches to skip\r\n   */\n\n\n  EventDispatcher.prototype.disableType = function (type, amount) {\n    if (amount === void 0) {\n      amount = Infinity;\n    }\n\n    this._disabled[type] = amount;\n  };\n  /**\r\n   * Removes listener from dispatcher.\r\n   *\r\n   * Will throw an exception if such listener does not exists.\r\n   *\r\n   * @param listener Listener to remove\r\n   */\n\n\n  EventDispatcher.prototype._removeListener = function (listener) {\n    if (this._iterating === 0) {\n      var index = this._listeners.indexOf(listener);\n\n      if (index === -1) {\n        throw new Error(\"Invalid state: could not remove listener\");\n      }\n\n      this._listeners.splice(index, 1);\n    } else {\n      this._killed.push(listener);\n    }\n  };\n  /**\r\n   * Removes existing listener by certain parameters.\r\n   *\r\n   * @param once         Listener's once setting\r\n   * @param type         Listener's type\r\n   * @param callback     Callback function\r\n   * @param context      Callback context\r\n   */\n\n\n  EventDispatcher.prototype._removeExistingListener = function (once, type, callback, context) {\n    if (this._disposed) {\n      throw new Error(\"EventDispatcher is disposed\");\n    }\n\n    this._eachListener(function (info) {\n      if (info.once === once && // TODO is this correct ?\n      info.type === type && (callback == null || info.callback === callback) && info.context === context) {\n        info.disposer.dispose();\n      }\n    });\n  };\n  /**\r\n   * Checks if dispatching for particular event type is enabled.\r\n   *\r\n   * @param type  Event type\r\n   * @return Enabled?\r\n   */\n\n\n  EventDispatcher.prototype.isEnabled = function (type) {\n    if (this._disposed) {\n      throw new Error(\"EventDispatcher is disposed\");\n    } // TODO is this check correct ?\n\n\n    return this._enabled && this._listeners.length > 0 && this.hasListenersByType(type) && this._disabled[type] == null;\n  };\n  /**\r\n   * Checks if there's already a listener with specific parameters.\r\n   *\r\n   * @param type      Listener's type\r\n   * @param callback  Callback function\r\n   * @param context   Callback context\r\n   * @return Has listener?\r\n   */\n\n\n  EventDispatcher.prototype.has = function (type, callback, context) {\n    var index = $array.findIndex(this._listeners, function (info) {\n      return info.once !== true && // Ignoring \"once\" listeners\n      info.type === type && (callback == null || info.callback === callback) && info.context === context;\n    });\n    return index !== -1;\n  };\n  /**\r\n   * Checks whether event of the particular type should be dispatched.\r\n   *\r\n   * @param type  Event type\r\n   * @return Dispatch?\r\n   */\n\n\n  EventDispatcher.prototype._shouldDispatch = function (type) {\n    if (this._disposed) {\n      throw new Error(\"EventDispatcher is disposed\");\n    }\n\n    var count = this._disabled[type];\n\n    if (!$type.isNumber(count)) {\n      return this._enabled;\n    } else {\n      if (count <= 1) {\n        delete this._disabled[type];\n      } else {\n        --this._disabled[type];\n      }\n\n      return false;\n    }\n  };\n  /**\r\n   * [_eachListener description]\r\n   *\r\n   * All of this extra code is needed when a listener is removed while iterating\r\n   *\r\n   * @todo Description\r\n   * @param fn [description]\r\n   */\n\n\n  EventDispatcher.prototype._eachListener = function (fn) {\n    var _this = this;\n\n    ++this._iterating;\n\n    try {\n      $array.each(this._listeners, fn);\n    } finally {\n      --this._iterating; // TODO should this be inside or outside the finally ?\n\n      if (this._iterating === 0 && this._killed.length !== 0) {\n        // Remove killed listeners\n        $array.each(this._killed, function (killed) {\n          _this._removeListener(killed);\n        });\n        this._killed.length = 0;\n      }\n    }\n  };\n  /**\r\n   * Dispatches an event immediately without waiting for next cycle.\r\n   *\r\n   * @param type   Event type\r\n   * @param event  Event object\r\n   * @todo automatically add in type and target properties if they are missing\r\n   */\n\n\n  EventDispatcher.prototype.dispatchImmediately = function (type, event) {\n    if (this._shouldDispatch(type)) {\n      // TODO check if it's faster to use an object of listeners rather than a single big array\n      // TODO if the function throws, maybe it should keep going ?\n      this._eachListener(function (listener) {\n        if (!listener.killed && (listener.type === null || listener.type === type)) {\n          listener.dispatch(type, event);\n        }\n      });\n    }\n  };\n  /**\r\n   * Shelves the event to be dispatched within next update cycle.\r\n   *\r\n   * @param type   Event type\r\n   * @param event  Event object\r\n   * @todo automatically add in type and target properties if they are missing\r\n   */\n\n\n  EventDispatcher.prototype.dispatch = function (type, event) {\n    if (this._shouldDispatch(type)) {\n      this._eachListener(function (listener) {\n        // TODO check if it's faster to use an object of listeners rather than a single big array\n        if (!listener.killed && (listener.type === null || listener.type === type)) {\n          // TODO if the function throws, maybe it should keep going ?\n          // TODO dispatch during the update cycle, rather than using whenIdle\n          $async.whenIdle(function () {\n            if (!listener.killed) {\n              listener.dispatch(type, event);\n            }\n          });\n        }\n      });\n    }\n  };\n  /**\r\n   * Creates, catalogs and returns an [[EventListener]].\r\n   *\r\n   * Event listener can be disposed.\r\n   *\r\n   * @param once         Listener's once setting\r\n   * @param type         Listener's type\r\n   * @param callback     Callback function\r\n   * @param context      Callback context\r\n   * @param shouldClone  Whether the listener should be copied when the EventDispatcher is copied\r\n   * @param dispatch\r\n   * @returns An event listener\r\n   */\n\n\n  EventDispatcher.prototype._on = function (once, type, callback, context, shouldClone, dispatch) {\n    var _this = this;\n\n    if (this._disposed) {\n      throw new Error(\"EventDispatcher is disposed\");\n    }\n\n    this._removeExistingListener(once, type, callback, context);\n\n    var info = {\n      type: type,\n      callback: callback,\n      context: context,\n      shouldClone: shouldClone,\n      dispatch: dispatch,\n      killed: false,\n      once: once,\n      disposer: new Disposer(function () {\n        info.killed = true;\n\n        _this._removeListener(info);\n      })\n    };\n\n    this._listeners.push(info);\n\n    return info;\n  };\n  /**\r\n   * Creates an event listener to be invoked on **any** event.\r\n   *\r\n   * @param callback     Callback function\r\n   * @param context      Callback context\r\n   * @param shouldClone  Whether the listener should be copied when the EventDispatcher is copied\r\n   * @returns A disposable event listener\r\n   * @todo what if `listen` is called on the same function twice ?\r\n   */\n\n\n  EventDispatcher.prototype.onAll = function (callback, context, shouldClone) {\n    if (shouldClone === void 0) {\n      shouldClone = true;\n    }\n\n    return this._on(false, null, callback, context, shouldClone, function (type, event) {\n      return callback.call(context, type, event);\n    }).disposer;\n  };\n  /**\r\n   * Creates an event listener to be invoked on a specific event type.\r\n   *\r\n   * ```TypeScript\r\n   * series.events.on(\"hidden\", (ev) => {\r\n   *   console.log(\"Series hidden: \" + ev.target.name);\r\n   * }, this);\r\n   * ```\r\n   * ```JavaScript\r\n   * series.events.on(\"hidden\", function(ev) {\r\n   *   console.log(\"Series hidden: \" + ev.target.name);\r\n   * }, this);\r\n   * ```\r\n   * ```JSON\r\n   * {\r\n   *   // ...\r\n   *   \"series\": [{\r\n   *     // ...\r\n   *     \"events\": {\r\n   *     \t\"hidden\": function(ev) {\r\n   *     \t  console.log(\"Series hidden: \" + ev.target.name);\r\n   *     \t}\r\n   *     }\r\n   *   }]\r\n   * }\r\n   * ```\r\n   *\r\n   * The above will invoke our custom event handler whenever series we put\r\n   * event on is hidden.\r\n   *\r\n   * @param type         Listener's type\r\n   * @param callback     Callback function\r\n   * @param context      Callback context\r\n   * @param shouldClone  Whether the listener should be copied when the EventDispatcher is copied\r\n   * @returns A disposable event listener\r\n   * @todo what if `listen` is called on the same function twice ?\r\n   */\n\n\n  EventDispatcher.prototype.on = function (type, callback, context, shouldClone) {\n    if (shouldClone === void 0) {\n      shouldClone = true;\n    }\n\n    return this._on(false, type, callback, context, shouldClone, function (type, event) {\n      return callback.call(context, event);\n    }).disposer;\n  };\n  /**\r\n   * Creates an event listener to be invoked on a specific event type once.\r\n   *\r\n   * Once the event listener is invoked, it is automatically disposed.\r\n   *\r\n   * ```TypeScript\r\n   * series.events.on(\"hidden\", (ev) => {\r\n   *   console.log(\"Series hidden: \" + ev.target.name);\r\n   * }, this);\r\n   * ```\r\n   * ```JavaScript\r\n   * series.events.on(\"hidden\", function(ev) {\r\n   *   console.log(\"Series hidden: \" + ev.target.name);\r\n   * }, this);\r\n   * ```\r\n   * ```JSON\r\n   * {\r\n   *   // ...\r\n   *   \"series\": [{\r\n   *     // ...\r\n   *     \"events\": {\r\n   *     \t\"hidden\": function(ev) {\r\n   *     \t  console.log(\"Series hidden: \" + ev.target.name);\r\n   *     \t}\r\n   *     }\r\n   *   }]\r\n   * }\r\n   * ```\r\n   *\r\n   * The above will invoke our custom event handler the first time series we\r\n   * put event on is hidden.\r\n   *\r\n   * @param type         Listener's type\r\n   * @param callback     Callback function\r\n   * @param context      Callback context\r\n   * @param shouldClone  Whether the listener should be copied when the EventDispatcher is copied\r\n   * @returns A disposable event listener\r\n   * @todo what if `listen` is called on the same function twice ?\r\n   */\n\n\n  EventDispatcher.prototype.once = function (type, callback, context, shouldClone) {\n    if (shouldClone === void 0) {\n      shouldClone = true;\n    }\n\n    var x = this._on(true, type, callback, context, shouldClone, function (type, event) {\n      x.disposer.dispose();\n      callback.call(context, event);\n    }); // TODO maybe this should return a different Disposer ?\n\n\n    return x.disposer;\n  };\n  /**\r\n   * Removes the event listener with specific parameters.\r\n   *\r\n   * @param type         Listener's type\r\n   * @param callback     Callback function\r\n   * @param context      Callback context\r\n   */\n\n\n  EventDispatcher.prototype.off = function (type, callback, context) {\n    this._removeExistingListener(false, type, callback, context);\n  };\n  /**\r\n   * Copies all dispatcher parameters, including listeners, from another event\r\n   * dispatcher.\r\n   *\r\n   * @param source Source event dispatcher\r\n   */\n\n\n  EventDispatcher.prototype.copyFrom = function (source) {\n    var _this = this;\n\n    if (this._disposed) {\n      throw new Error(\"EventDispatcher is disposed\");\n    }\n\n    if (source === this) {\n      throw new Error(\"Cannot copyFrom the same TargetedEventDispatcher\");\n    }\n\n    $array.each(source._listeners, function (x) {\n      // TODO is this correct ?\n      if (!x.killed && x.shouldClone) {\n        if (x.type === null) {\n          _this.onAll(x.callback, x.context);\n        } else if (x.once) {\n          _this.once(x.type, x.callback, x.context);\n        } else {\n          _this.on(x.type, x.callback, x.context);\n        }\n      }\n    });\n  };\n\n  return EventDispatcher;\n}();\n\nexport { EventDispatcher };\n/**\r\n * A version of the [[EventDispatcher]] that dispatches events for a specific\r\n * target object.\r\n *\r\n * @important\r\n */\n\nvar TargetedEventDispatcher =\n/** @class */\nfunction (_super) {\n  __extends(TargetedEventDispatcher, _super);\n  /**\r\n   * Constructor\r\n   *\r\n   * @param target Event dispatcher target\r\n   */\n\n\n  function TargetedEventDispatcher(target) {\n    var _this = _super.call(this) || this;\n\n    _this.target = target;\n    return _this;\n  }\n  /**\r\n   * Copies all dispatcher parameters, including listeners, from another event\r\n   * dispatcher.\r\n   *\r\n   * @param source Source event dispatcher\r\n   */\n\n\n  TargetedEventDispatcher.prototype.copyFrom = function (source) {\n    var _this = this;\n\n    if (this._disposed) {\n      throw new Error(\"EventDispatcher is disposed\");\n    }\n\n    if (source === this) {\n      throw new Error(\"Cannot copyFrom the same TargetedEventDispatcher\");\n    }\n\n    $array.each(source._listeners, function (x) {\n      // TODO very hacky\n      if (x.context === source.target) {\n        return;\n      } // TODO is this correct ?\n\n\n      if (!x.killed && x.shouldClone) {\n        if (x.type === null) {\n          _this.onAll(x.callback, x.context);\n        } else if (x.once) {\n          _this.once(x.type, x.callback, x.context);\n        } else {\n          _this.on(x.type, x.callback, x.context);\n        }\n      }\n    });\n  };\n\n  return TargetedEventDispatcher;\n}(EventDispatcher);\n\nexport { TargetedEventDispatcher };","map":{"version":3,"mappings":"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","names":["Disposer","$array","$async","$type","_listeners","_killed","_disabled","_iterating","_enabled","_disposed","EventDispatcher","a","each","x","disposer","dispose","length","type","any","killed","amount","listener","index","indexOf","Error","splice","push","once","callback","context","_eachListener","info","hasListenersByType","findIndex","count","isNumber","fn","_this","_removeListener","event","_shouldDispatch","dispatch","whenIdle","shouldClone","_removeExistingListener","_on","call","source","onAll","on","__extends","target","_super","TargetedEventDispatcher"],"sourceRoot":"","sources":["../../../../../src/.internal/core/utils/EventDispatcher.ts"],"sourcesContent":["/**\r\n * Event Dispatcher module is used for registering listeners and dispatching\r\n * events across amCharts system.\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { Disposer, IDisposer } from \"./Disposer\";\r\nimport * as $array from \"./Array\";\r\nimport * as $async from \"./AsyncPending\";\r\nimport * as $type from \"./Type\";\r\n\r\n/**\r\n * Defines a universal type for the event object.\r\n */\r\nexport type AMEvent<Target, T> = {\r\n\t[K in keyof T]: { type: K, target: Target } & T[K];\r\n};\r\n\r\n/**\r\n * A universal interface for event listeners.\r\n */\r\nexport interface EventListener<T> {\r\n\tkilled: boolean;\r\n\tonce: boolean;\r\n\ttype: any;\r\n\tcallback: any;\r\n\tcontext: any;\r\n\tshouldClone: boolean;\r\n\tdispatch: any;\r\n\tdisposer: IDisposer;\r\n}\r\n\r\n/*export interface IEventDispatcher<T> {\r\n\tisDisposed(): boolean;\r\n\tdispose(): void;\r\n\thasListeners(): boolean;\r\n\tenable(): void;\r\n\tdisable(): void;\r\n\tenableType<Key extends keyof T>(type: Key): void;\r\n\tdisableType<Key extends keyof T>(type: Key, amount?: number): void;\r\n\tisEnabled<Key extends keyof T>(type: Key): boolean;\r\n\thas<C, Key extends keyof T>(type: Key, callback?: (this: C, event: T[Key]) => void, context?: C): boolean;\r\n\tdispatchImmediately<Key extends keyof T>(type: Key, event: T[Key]): void;\r\n\tdispatch<Key extends keyof T>(type: Key, event: T[Key]): void;\r\n\tonAll<C, Key extends keyof T>(callback: (this: C, type: Key, event: T[Key]) => void, context?: C): IDisposer;\r\n\ton<C, Key extends keyof T>(type: Key, callback: (this: C, event: T[Key]) => void, context?: C): IDisposer;\r\n\tonce<C, Key extends keyof T>(type: Key, callback: (this: C, event: T[Key]) => void, context?: C): IDisposer;\r\n\toff<C, Key extends keyof T>(type: Key, callback: (this: C, event: T[Key]) => void, context?: C): void;\r\n\toff<C, Key extends keyof T>(type: Key, callback: (this: C, event: T[Key]) => void, context?: C): void;\r\n\tcopyFrom(source: this): void;\r\n}*/\r\n\r\n/**\r\n * Universal Event Dispatcher.\r\n *\r\n * @important\r\n */\r\nexport class EventDispatcher<T> implements IDisposer {\r\n\r\n\tprotected _listeners: Array<EventListener<T>>;\r\n\tprotected _killed: Array<EventListener<T>>;\r\n\tprotected _disabled: { [key in keyof T]?: number };\r\n\tprotected _iterating: number;\r\n\tprotected _enabled: boolean;\r\n\tprotected _disposed: boolean;\r\n\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor() {\r\n\t\tthis._listeners = [];\r\n\t\tthis._killed = [];\r\n\t\tthis._disabled = {};\r\n\t\tthis._iterating = 0;\r\n\t\tthis._enabled = true;\r\n\t\tthis._disposed = false;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns if this object has been already disposed.\r\n\t *\r\n\t * @return Disposed?\r\n\t */\r\n\tpublic isDisposed(): boolean {\r\n\t\treturn this._disposed;\r\n\t}\r\n\r\n\t/**\r\n\t * Dispose (destroy) this object.\r\n\t */\r\n\tpublic dispose(): void {\r\n\t\tif (!this._disposed) {\r\n\t\t\tthis._disposed = true;\r\n\r\n\t\t\tconst a = this._listeners;\r\n\r\n\t\t\tthis._iterating = 1;\r\n\t\t\tthis._listeners = <any>null;\r\n\t\t\tthis._disabled = <any>null;\r\n\r\n\t\t\ttry {\r\n\t\t\t\t$array.each(a, (x) => {\r\n\t\t\t\t\tx.disposer.dispose();\r\n\t\t\t\t});\r\n\r\n\t\t\t} finally {\r\n\t\t\t\tthis._killed = <any>null;\r\n\t\t\t\tthis._iterating = <any>null;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if this particular event dispatcher has any listeners set.\r\n\t *\r\n\t * @return Has listeners?\r\n\t */\r\n\tpublic hasListeners(): boolean {\r\n\t\treturn this._listeners.length !== 0;\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if this particular event dispatcher has any particular listeners set.\r\n\t *\r\n\t * @return Has particular event listeners?\r\n\t */\r\n\tpublic hasListenersByType<Key extends keyof T>(type: Key): boolean {\r\n\t\treturn $array.any(this._listeners, (x) => (x.type === null || x.type === type) && !x.killed);\r\n\t}\r\n\r\n\t/**\r\n\t * Enable dispatching of events if they were previously disabled by\r\n\t * `disable()`.\r\n\t */\r\n\tpublic enable(): void {\r\n\t\tthis._enabled = true;\r\n\t}\r\n\r\n\t/**\r\n\t * Disable dispatching of events until re-enabled by `enable()`.\r\n\t */\r\n\tpublic disable(): void {\r\n\t\tthis._enabled = false;\r\n\t}\r\n\r\n\t/**\r\n\t * Enable dispatching particular event, if it was disabled before by\r\n\t * `disableType()`.\r\n\t *\r\n\t * @param type Event type\r\n\t */\r\n\tpublic enableType<Key extends keyof T>(type: Key): void {\r\n\t\tdelete this._disabled[type];\r\n\t}\r\n\r\n\t/**\r\n\t * Disable dispatching of events for a certain event type.\r\n\t *\r\n\t * Optionally, can set how many dispatches to skip before automatically\r\n\t * re-enabling the dispatching.\r\n\t *\r\n\t * @param type    Event type\r\n\t * @param amount  Number of event dispatches to skip\r\n\t */\r\n\tpublic disableType<Key extends keyof T>(type: Key, amount: number = Infinity): void {\r\n\t\tthis._disabled[type] = amount;\r\n\t}\r\n\r\n\t/**\r\n\t * Removes listener from dispatcher.\r\n\t *\r\n\t * Will throw an exception if such listener does not exists.\r\n\t *\r\n\t * @param listener Listener to remove\r\n\t */\r\n\tprotected _removeListener(listener: EventListener<T>): void {\r\n\t\tif (this._iterating === 0) {\r\n\t\t\tconst index = this._listeners.indexOf(listener);\r\n\r\n\t\t\tif (index === -1) {\r\n\t\t\t\tthrow new Error(\"Invalid state: could not remove listener\");\r\n\t\t\t}\r\n\r\n\t\t\tthis._listeners.splice(index, 1);\r\n\r\n\t\t} else {\r\n\t\t\tthis._killed.push(listener);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Removes existing listener by certain parameters.\r\n\t *\r\n\t * @param once         Listener's once setting\r\n\t * @param type         Listener's type\r\n\t * @param callback     Callback function\r\n\t * @param context      Callback context\r\n\t */\r\n\tprotected _removeExistingListener<A, B, Key extends keyof T>(once: boolean, type: Key | null, callback?: A, context?: B): void {\r\n\t\tif (this._disposed) {\r\n\t\t\tthrow new Error(\"EventDispatcher is disposed\");\r\n\t\t}\r\n\r\n\t\tthis._eachListener((info) => {\r\n\t\t\tif (info.once === once && // TODO is this correct ?\r\n\t\t\t\tinfo.type === type &&\r\n\t\t\t\t(callback == null || info.callback === callback) &&\r\n\t\t\t\tinfo.context === context) {\r\n\t\t\t\tinfo.disposer.dispose();\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if dispatching for particular event type is enabled.\r\n\t *\r\n\t * @param type  Event type\r\n\t * @return Enabled?\r\n\t */\r\n\tpublic isEnabled<Key extends keyof T>(type: Key): boolean {\r\n\t\tif (this._disposed) {\r\n\t\t\tthrow new Error(\"EventDispatcher is disposed\");\r\n\t\t}\r\n\r\n\t\t// TODO is this check correct ?\r\n\t\treturn this._enabled && this._listeners.length > 0 && this.hasListenersByType(type) && this._disabled[type] == null;\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if there's already a listener with specific parameters.\r\n\t *\r\n\t * @param type      Listener's type\r\n\t * @param callback  Callback function\r\n\t * @param context   Callback context\r\n\t * @return Has listener?\r\n\t */\r\n\tpublic has<C, Key extends keyof T>(type: Key, callback?: (this: C, event: T[Key]) => void, context?: C): boolean {\r\n\t\tconst index = $array.findIndex(this._listeners, (info) => {\r\n\t\t\treturn info.once !== true && // Ignoring \"once\" listeners\r\n\t\t\t\tinfo.type === type &&\r\n\t\t\t\t(callback == null || info.callback === callback) &&\r\n\t\t\t\tinfo.context === context;\r\n\t\t});\r\n\r\n\t\treturn index !== -1;\r\n\t}\r\n\r\n\t/**\r\n\t * Checks whether event of the particular type should be dispatched.\r\n\t *\r\n\t * @param type  Event type\r\n\t * @return Dispatch?\r\n\t */\r\n\tprotected _shouldDispatch<Key extends keyof T>(type: Key): boolean {\r\n\t\tif (this._disposed) {\r\n\t\t\tthrow new Error(\"EventDispatcher is disposed\");\r\n\t\t}\r\n\r\n\t\tconst count = this._disabled[type];\r\n\r\n\t\tif (!$type.isNumber(count)) {\r\n\t\t\treturn this._enabled;\r\n\r\n\t\t} else {\r\n\t\t\tif (count <= 1) {\r\n\t\t\t\tdelete this._disabled[type];\r\n\r\n\t\t\t} else {\r\n\t\t\t\t--this._disabled[type];\r\n\t\t\t}\r\n\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * [_eachListener description]\r\n\t *\r\n\t * All of this extra code is needed when a listener is removed while iterating\r\n\t *\r\n\t * @todo Description\r\n\t * @param fn [description]\r\n\t */\r\n\tprotected _eachListener(fn: (listener: EventListener<T>) => void): void {\r\n\t\t++this._iterating;\r\n\r\n\t\ttry {\r\n\t\t\t$array.each(this._listeners, fn);\r\n\r\n\t\t} finally {\r\n\t\t\t--this._iterating;\r\n\r\n\t\t\t// TODO should this be inside or outside the finally ?\r\n\t\t\tif (this._iterating === 0 && this._killed.length !== 0) {\r\n\t\t\t\t// Remove killed listeners\r\n\t\t\t\t$array.each(this._killed, (killed) => {\r\n\t\t\t\t\tthis._removeListener(killed);\r\n\t\t\t\t});\r\n\r\n\t\t\t\tthis._killed.length = 0;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Dispatches an event immediately without waiting for next cycle.\r\n\t *\r\n\t * @param type   Event type\r\n\t * @param event  Event object\r\n\t * @todo automatically add in type and target properties if they are missing\r\n\t */\r\n\tpublic dispatchImmediately<Key extends keyof T>(type: Key, event: T[Key]): void {\r\n\t\tif (this._shouldDispatch(type)) {\r\n\t\t\t// TODO check if it's faster to use an object of listeners rather than a single big array\r\n\t\t\t// TODO if the function throws, maybe it should keep going ?\r\n\t\t\tthis._eachListener((listener) => {\r\n\t\t\t\tif (!listener.killed && (listener.type === null || listener.type === type)) {\r\n\t\t\t\t\tlistener.dispatch(type, event);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Shelves the event to be dispatched within next update cycle.\r\n\t *\r\n\t * @param type   Event type\r\n\t * @param event  Event object\r\n\t * @todo automatically add in type and target properties if they are missing\r\n\t */\r\n\tpublic dispatch<Key extends keyof T>(type: Key, event: T[Key]): void {\r\n\t\tif (this._shouldDispatch(type)) {\r\n\t\t\tthis._eachListener((listener) => {\r\n\t\t\t\t// TODO check if it's faster to use an object of listeners rather than a single big array\r\n\t\t\t\tif (!listener.killed && (listener.type === null || listener.type === type)) {\r\n\t\t\t\t\t// TODO if the function throws, maybe it should keep going ?\r\n\t\t\t\t\t// TODO dispatch during the update cycle, rather than using whenIdle\r\n\t\t\t\t\t$async.whenIdle(() => {\r\n\t\t\t\t\t\tif (!listener.killed) {\r\n\t\t\t\t\t\t\tlistener.dispatch(type, event);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Creates, catalogs and returns an [[EventListener]].\r\n\t *\r\n\t * Event listener can be disposed.\r\n\t *\r\n\t * @param once         Listener's once setting\r\n\t * @param type         Listener's type\r\n\t * @param callback     Callback function\r\n\t * @param context      Callback context\r\n\t * @param shouldClone  Whether the listener should be copied when the EventDispatcher is copied\r\n\t * @param dispatch\r\n\t * @returns An event listener\r\n\t */\r\n\tprotected _on<A, B, Key extends keyof T>(once: boolean, type: Key | null, callback: A, context: B, shouldClone: boolean, dispatch: (type: Key, event: T[Key]) => void): EventListener<T> {\r\n\t\tif (this._disposed) {\r\n\t\t\tthrow new Error(\"EventDispatcher is disposed\");\r\n\t\t}\r\n\r\n\t\tthis._removeExistingListener(once, type, callback, context);\r\n\r\n\t\tconst info: EventListener<T> = {\r\n\t\t\ttype: type,\r\n\t\t\tcallback: callback,\r\n\t\t\tcontext: context,\r\n\t\t\tshouldClone: shouldClone,\r\n\t\t\tdispatch: <any>dispatch,\r\n\t\t\tkilled: false,\r\n\t\t\tonce: once,\r\n\t\t\tdisposer: new Disposer(() => {\r\n\t\t\t\tinfo.killed = true;\r\n\t\t\t\tthis._removeListener(info);\r\n\t\t\t})\r\n\t\t};\r\n\r\n\t\tthis._listeners.push(info);\r\n\r\n\t\treturn info;\r\n\t}\r\n\r\n\t/**\r\n\t * Creates an event listener to be invoked on **any** event.\r\n\t *\r\n\t * @param callback     Callback function\r\n\t * @param context      Callback context\r\n\t * @param shouldClone  Whether the listener should be copied when the EventDispatcher is copied\r\n\t * @returns A disposable event listener\r\n\t * @todo what if `listen` is called on the same function twice ?\r\n\t */\r\n\tpublic onAll<C, Key extends keyof T>(callback: (this: C, type: Key, event: T[Key]) => void, context?: C, shouldClone: boolean = true): IDisposer {\r\n\t\treturn this._on(false, null, callback, context, shouldClone, (type, event) => callback.call(context, type, event)).disposer;\r\n\t}\r\n\r\n\t/**\r\n\t * Creates an event listener to be invoked on a specific event type.\r\n\t *\r\n\t * ```TypeScript\r\n\t * series.events.on(\"hidden\", (ev) => {\r\n\t *   console.log(\"Series hidden: \" + ev.target.name);\r\n\t * }, this);\r\n\t * ```\r\n\t * ```JavaScript\r\n\t * series.events.on(\"hidden\", function(ev) {\r\n\t *   console.log(\"Series hidden: \" + ev.target.name);\r\n\t * }, this);\r\n\t * ```\r\n\t * ```JSON\r\n\t * {\r\n\t *   // ...\r\n\t *   \"series\": [{\r\n\t *     // ...\r\n\t *     \"events\": {\r\n\t *     \t\"hidden\": function(ev) {\r\n\t *     \t  console.log(\"Series hidden: \" + ev.target.name);\r\n\t *     \t}\r\n\t *     }\r\n\t *   }]\r\n\t * }\r\n\t * ```\r\n\t *\r\n\t * The above will invoke our custom event handler whenever series we put\r\n\t * event on is hidden.\r\n\t *\r\n\t * @param type         Listener's type\r\n\t * @param callback     Callback function\r\n\t * @param context      Callback context\r\n\t * @param shouldClone  Whether the listener should be copied when the EventDispatcher is copied\r\n\t * @returns A disposable event listener\r\n\t * @todo what if `listen` is called on the same function twice ?\r\n\t */\r\n\tpublic on<C, Key extends keyof T>(type: Key, callback: (this: C, event: T[Key]) => void, context?: C, shouldClone: boolean = true): IDisposer {\r\n\t\treturn this._on(false, type, callback, context, shouldClone, (type, event) => callback.call(context, event)).disposer;\r\n\t}\r\n\r\n\t/**\r\n\t * Creates an event listener to be invoked on a specific event type once.\r\n\t *\r\n\t * Once the event listener is invoked, it is automatically disposed.\r\n\t *\r\n\t * ```TypeScript\r\n\t * series.events.on(\"hidden\", (ev) => {\r\n\t *   console.log(\"Series hidden: \" + ev.target.name);\r\n\t * }, this);\r\n\t * ```\r\n\t * ```JavaScript\r\n\t * series.events.on(\"hidden\", function(ev) {\r\n\t *   console.log(\"Series hidden: \" + ev.target.name);\r\n\t * }, this);\r\n\t * ```\r\n\t * ```JSON\r\n\t * {\r\n\t *   // ...\r\n\t *   \"series\": [{\r\n\t *     // ...\r\n\t *     \"events\": {\r\n\t *     \t\"hidden\": function(ev) {\r\n\t *     \t  console.log(\"Series hidden: \" + ev.target.name);\r\n\t *     \t}\r\n\t *     }\r\n\t *   }]\r\n\t * }\r\n\t * ```\r\n\t *\r\n\t * The above will invoke our custom event handler the first time series we\r\n\t * put event on is hidden.\r\n\t *\r\n\t * @param type         Listener's type\r\n\t * @param callback     Callback function\r\n\t * @param context      Callback context\r\n\t * @param shouldClone  Whether the listener should be copied when the EventDispatcher is copied\r\n\t * @returns A disposable event listener\r\n\t * @todo what if `listen` is called on the same function twice ?\r\n\t */\r\n\tpublic once<C, Key extends keyof T>(type: Key, callback: (this: C, event: T[Key]) => void, context?: C, shouldClone: boolean = true): IDisposer {\r\n\t\tconst x = this._on(true, type, callback, context, shouldClone, (type, event) => {\r\n\t\t\tx.disposer.dispose();\r\n\t\t\tcallback.call(context, event)\r\n\t\t});\r\n\r\n\t\t// TODO maybe this should return a different Disposer ?\r\n\t\treturn x.disposer;\r\n\t}\r\n\r\n\t/**\r\n\t * Removes the event listener with specific parameters.\r\n\t *\r\n\t * @param type         Listener's type\r\n\t * @param callback     Callback function\r\n\t * @param context      Callback context\r\n\t */\r\n\tpublic off<C, Key extends keyof T>(type: Key, callback?: (this: C, event: T[Key]) => void, context?: C): void {\r\n\t\tthis._removeExistingListener(false, type, callback, context);\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Copies all dispatcher parameters, including listeners, from another event\r\n\t * dispatcher.\r\n\t *\r\n\t * @param source Source event dispatcher\r\n\t */\r\n\tpublic copyFrom(source: this): void {\r\n\t\tif (this._disposed) {\r\n\t\t\tthrow new Error(\"EventDispatcher is disposed\");\r\n\t\t}\r\n\r\n\t\tif (source === this) {\r\n\t\t\tthrow new Error(\"Cannot copyFrom the same TargetedEventDispatcher\");\r\n\t\t}\r\n\r\n\t\t$array.each(source._listeners, (x) => {\r\n\t\t\t// TODO is this correct ?\r\n\t\t\tif (!x.killed && x.shouldClone) {\r\n\t\t\t\tif (x.type === null) {\r\n\t\t\t\t\tthis.onAll(x.callback, x.context);\r\n\r\n\t\t\t\t} else if (x.once) {\r\n\t\t\t\t\tthis.once(x.type, x.callback, x.context);\r\n\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthis.on(x.type, x.callback, x.context);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * A version of the [[EventDispatcher]] that dispatches events for a specific\r\n * target object.\r\n *\r\n * @important\r\n */\r\nexport class TargetedEventDispatcher<Target, T> extends EventDispatcher<T> {\r\n\r\n\t/**\r\n\t * A target object which is originating events using this dispatcher.\r\n\t */\r\n\tpublic target: Target;\r\n\r\n\t/**\r\n\t * Constructor\r\n\t *\r\n\t * @param target Event dispatcher target\r\n\t */\r\n\tconstructor(target: Target) {\r\n\t\tsuper();\r\n\t\tthis.target = target;\r\n\t}\r\n\r\n\t/**\r\n\t * Copies all dispatcher parameters, including listeners, from another event\r\n\t * dispatcher.\r\n\t *\r\n\t * @param source Source event dispatcher\r\n\t */\r\n\tpublic copyFrom(source: this): void {\r\n\t\tif (this._disposed) {\r\n\t\t\tthrow new Error(\"EventDispatcher is disposed\");\r\n\t\t}\r\n\r\n\t\tif (source === this) {\r\n\t\t\tthrow new Error(\"Cannot copyFrom the same TargetedEventDispatcher\");\r\n\t\t}\r\n\r\n\t\t$array.each(source._listeners, (x) => {\r\n\t\t\t// TODO very hacky\r\n\t\t\tif (x.context === source.target) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\t// TODO is this correct ?\r\n\t\t\tif (!x.killed && x.shouldClone) {\r\n\t\t\t\tif (x.type === null) {\r\n\t\t\t\t\tthis.onAll(x.callback, x.context);\r\n\r\n\t\t\t\t} else if (x.once) {\r\n\t\t\t\t\tthis.once(x.type, x.callback, x.context);\r\n\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthis.on(x.type, x.callback, x.context);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n}\r\n"]},"metadata":{},"sourceType":"module"}